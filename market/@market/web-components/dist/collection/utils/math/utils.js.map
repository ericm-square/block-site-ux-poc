{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../src/utils/math/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vec2 } from './types';\n\ntype CompressOptions = { threshold?: number; linearRatio?: number; quadraticRatio?: number; invert?: boolean };\nconst compressDefaults: CompressOptions = { threshold: 0, linearRatio: 1, quadraticRatio: 1, invert: false };\n\n/**\n * Compress a given input value as it exceeds a given threshhold.\n * Both quadratic and linear compression is supported.\n * the output grows by an increasingly diminishing amount.\n * @param {number} input - The value to be compressed.\n * @param {CompressOptions} options - Override defaults for the compression.\n * @param {number} options.threshhold - The value where compression starts. Input values that exceed the threshhold will be compressed. Default of 0.\n * @param {number} options.linearRatio - (0-1) The ratio to which the input exceeding the threshhold will be reduced. 0.33 creates a ~3-to-1 compression. Default of 1 (no compression).\n * @param {number} options.quadraticRatio - (0-1) The ratio of quadratic compression to which the input exceeding the threshhold will be reduced. 0.33 creates a ~cube-root compression. Default of 1 (no compression).\n * @param {boolean} options.invert - If true, the compression instead comrpesses values below the threshhold.\n */\nexport function compress(input: number, options: CompressOptions = {}) {\n  const { quadraticRatio, linearRatio, threshold, invert } = Object.assign({}, compressDefaults, options);\n  const inverter = invert ? -1 : 1;\n  if (input * inverter < threshold * inverter) {\n    return input;\n  }\n  const inputDelta = (input - threshold) * inverter;\n  // note we offset by 1 to avoid values 0-1 being adjusted in the opposite direction when exponentialized.\n  // this means that a provided quadratic ration of 0.5 does not result in a perfect square root.\n  let outputDelta = (inputDelta + 1) ** quadraticRatio - 1;\n  outputDelta = outputDelta * linearRatio;\n  return threshold + outputDelta * inverter;\n}\n\ntype LimitOptions = { threshold?: number; maximum?: number; invert?: boolean };\nconst limitDefaults: LimitOptions = { threshold: 0, maximum: 1, invert: false };\n\n/**\n * Limit a given input value as it exceeds a threshhold to stay below given maximum.\n * @param {number} input - The value to be limited.\n */\nexport function limit(input: number, options: LimitOptions = {}) {\n  const { threshold, maximum, invert } = Object.assign({}, limitDefaults, options);\n  const inverter = invert ? -1 : 1;\n  if (input * inverter < threshold * inverter) {\n    return input;\n  }\n  const inputDelta = (input - threshold) * inverter;\n  const maxDelta = (maximum - threshold) * inverter;\n  const outputDelta = (inputDelta * maxDelta) / (inputDelta + maxDelta);\n  return threshold + outputDelta * inverter;\n}\n\nexport function lerp(a: number, b: number, alpha: number) {\n  return a + alpha * (b - a);\n}\n\nexport function lerp2(a: Vec2, b: Vec2, alpha: number) {\n  return {\n    x: lerp(a.x, b.x, alpha),\n    y: lerp(a.y, b.y, alpha),\n  };\n}\n\nexport function getDelta(startCoords: Vec2, endCoords: Vec2): Vec2 {\n  return {\n    x: endCoords.x - startCoords.x,\n    y: endCoords.y - startCoords.y,\n  };\n}\n\nexport function magnitude(delta: Vec2) {\n  return (delta.x ** 2 + delta.y ** 2) ** 0.5;\n}\n"]}