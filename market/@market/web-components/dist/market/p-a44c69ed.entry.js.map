{"version":3,"names":["marketButtonGroupCss","MarketButtonGroupStyle0","MAX_VISIBLE_BUTTONS","DROPDOWN_MENU_BUTTON_WIDTH","RESIZE_DEBOUNCE_DURATION","MarketButtonGroup","this","_buttonEls","_observers","throttledHandleResize","throttle","handleResize","bind","overflow","visible","getComputedWidth","el","Number","parseFloat","window","getComputedStyle","width","findButtonCutoffIndex","alignment","length","buttonGroupWidth","tempEl","document","createElement","style","position","visibility","shadowRoot","appendChild","index","buttonWidths","buttonEl","dropdownMenuButtonWidth","BUTTON_GROUP_SPACING","clonedButtonEl","cloneNode","display","asyncRequestAnimationFrame","buttonElWidth","removeChild","potentialWidth","remove","sortVisibleAndOverflowButtons","_sortedButtonEls","slice","_buttonCutoffIndex","forEach","getAttribute","removeAttribute","setAttribute","isButtonCutoffUpdated","registerSlottedButtons","MarketButtonTagName","getNamespacedTagFor","querySelectorAll","observeContent","content","ResizeObserver","observe","connectedCallback","host","componentWillLoad","disconnectedCallback","Object","entries","key","observer","disconnect","undefined","render","MarketButtonDropdownTagName","MarketIconTagName","h","Host","class","ref","onSlotchange","popoverStrategy","slot","name","BUTTON_GROUP_OVERFLOW_BUTTON_ICON_ASSET"],"sources":["src/components/market-button-group/market-button-group.css?tag=market-button-group&encapsulation=shadow","src/components/market-button-group/market-button-group.tsx"],"sourcesContent":["@import \"../../styles/mixins/component-base.css\";\n\n:host {\n  display: flex;\n\n  /* ensure button group fills available space when used inside a flex container */\n  flex-grow: 1;\n}\n\n.content {\n  display: flex;\n  flex: 1;\n  flex-flow: row nowrap;\n  gap: var(--button-group-spacing);\n}\n\n:host([alignment=\"right\"]) .content {\n  flex-direction: row-reverse;\n}\n\n:host([alignment=\"left\"]) .content {\n  justify-content: flex-start;\n}\n\n:host([alignment=\"split\"]) .content {\n  flex-direction: row-reverse;\n  justify-content: flex-end;\n\n  ::slotted(.market-button:first-of-type) {\n    margin-left: auto;\n  }\n}\n\n:host([alignment=\"fill\"]) .content {\n  flex-direction: row-reverse;\n\n  ::slotted(.market-button) {\n    flex: 1;\n  }\n}\n\n:host([alignment=\"stack\"]) .content {\n  flex-direction: column;\n}\n\n/* overflow content */\n\n[slot=\"content\"] {\n  display: flex;\n  flex-direction: column;\n  gap: var(--button-group-spacing);\n}\n\n::slotted([slot=\"overflow-buttons\"]) {\n  width: 100%;\n}\n","import { Component, Host, h, State, Element, Prop } from '@stencil/core';\nimport { getNamespacedTagFor } from '../../utils/namespace';\nimport { BUTTON_GROUP_OVERFLOW_BUTTON_ICON_ASSET, BUTTON_GROUP_SPACING } from '@market/market-theme/js/cjs/index.js';\nimport type { PositioningStrategy } from '@popperjs/core';\nimport { throttle } from 'lodash-es';\nimport { asyncRequestAnimationFrame } from '../../utils/raf';\n\nconst MAX_VISIBLE_BUTTONS = 2;\nconst DROPDOWN_MENU_BUTTON_WIDTH = 48;\nconst RESIZE_DEBOUNCE_DURATION = 16; // 60fps\n\n/**\n * @slot - Intended to slot any number of `<market-button>` components here.\n * @slot overflow-buttons - Not intended for external consumers. Used by\n * `<market-button-group>` when programmatically arranging visible vs overflow\n * buttons based on available space.\n */\n@Component({\n  tag: 'market-button-group',\n  styleUrl: 'market-button-group.css',\n  shadow: true,\n})\nexport class MarketButtonGroup {\n  @Element() el: HTMLMarketButtonGroupElement;\n\n  /**\n   * A string specifying the alignment for the button group.\n   * This will change button size and distribution across the group.\n   */\n  @Prop({ reflect: true }) readonly alignment: 'left' | 'right' | 'split' | 'fill' | 'stack' = 'right';\n\n  /**\n   * Configuration option for Popper.js (used to position `<market-popover>`).\n   * Describes the positioning strategy to use. By default, it is absolute. If\n   * your reference element is in a fixed container, use the fixed strategy.\n   * https://popper.js.org/docs/v2/constructors//#strategy\n   */\n  @Prop() readonly popoverStrategy: PositioningStrategy = 'absolute';\n\n  /**\n   * Sorted overflow and visible buttons\n   */\n  @State() private _sortedButtonEls: {\n    overflow: Array<HTMLMarketButtonElement>;\n    visible: Array<HTMLMarketButtonElement>;\n  } = {\n    overflow: [],\n    visible: [],\n  };\n\n  /**\n   * References to the button elements\n   */\n  private _buttonEls: Array<HTMLMarketButtonElement> = [];\n\n  /**\n   * Used to set the index cutoff for overflowing buttons\n   */\n  private _buttonCutoffIndex: number;\n\n  /**\n   * Observers\n   */\n  private _observers: {\n    content?: ResizeObserver;\n    host?: ResizeObserver;\n  } = {};\n\n  private getComputedWidth(el: HTMLElement) {\n    return Number.parseFloat(window.getComputedStyle(el).width);\n  }\n\n  /**\n   * Find out where the cutoff will happen.\n   * Main chunk of the overflow logic happens here\n   */\n  private async findButtonCutoffIndex(): Promise<number> {\n    if (this.alignment === 'stack') {\n      // buttons are full width so no overflow necessary\n      return this._buttonEls.length;\n    }\n\n    const buttonGroupWidth = this.getComputedWidth(this.el);\n\n    /**\n     * Temporary container where we can measure button widths\n     * https://dev.to/sstraatemans/calculate-html-element-width-before-render-4ii7\n     */\n    const tempEl = document.createElement('div');\n    tempEl.style.width = 'auto';\n    tempEl.style.position = 'absolute';\n    tempEl.style.visibility = 'hidden';\n    this.el.shadowRoot.appendChild(tempEl);\n\n    let index = 0;\n    let buttonWidths = 0;\n    for (const buttonEl of this._buttonEls) {\n      if (index === MAX_VISIBLE_BUTTONS) {\n        break;\n      }\n\n      /**\n       * Presuming that all the remaining buttons (**excluding** the current one, i.e. `buttonEl`)\n       * will be overflowed, calculate the potential dropdown menu button width.\n       * If this is the last button, it will not be followed by a `market-button-dropdown-menu`.\n       */\n      const dropdownMenuButtonWidth =\n        index + 1 === this._buttonEls.length // is this the last one?\n          ? 0\n          : BUTTON_GROUP_SPACING + DROPDOWN_MENU_BUTTON_WIDTH;\n\n      // measure the button's width in the temporary container\n      const clonedButtonEl = buttonEl.cloneNode(true) as HTMLMarketButtonElement;\n      clonedButtonEl.style.display = 'block';\n      tempEl.appendChild(clonedButtonEl);\n\n      // let the shadow DOM render within the temp container first before measuring its width\n      await asyncRequestAnimationFrame();\n      const buttonElWidth = this.getComputedWidth(tempEl);\n      tempEl.removeChild(clonedButtonEl);\n\n      // width of all the buttons so far; gap is only added for buttons after the first\n      buttonWidths += (index > 0 ? BUTTON_GROUP_SPACING : 0) + buttonElWidth;\n\n      // check if button can fit\n      const potentialWidth = buttonWidths + dropdownMenuButtonWidth;\n      if (potentialWidth >= buttonGroupWidth) {\n        // it won't fit; breaking the loop sets the cutoff\n        break;\n      }\n      ++index;\n    }\n\n    // cleanup\n    this.el.shadowRoot.removeChild(tempEl);\n    tempEl.remove();\n\n    return index;\n  }\n\n  /**\n   * Sort buttons:\n   * - split by `this._buttonCutoffIndex`\n   * - visible buttons: remove attr `[slot=\"overflow-buttons\"]`; remove `display: none;`\n   * - overflow buttons: set attr `[slot=\"overflow-buttons\"]`; add `display: none;`\n   */\n  private sortVisibleAndOverflowButtons() {\n    this._sortedButtonEls = {\n      visible: this._buttonEls.slice(0, this._buttonCutoffIndex),\n      overflow: this._buttonEls.slice(this._buttonCutoffIndex),\n    };\n    this._sortedButtonEls.visible.forEach((buttonEl) => {\n      // if (buttonEl.style.display) {\n      //   buttonEl.style.removeProperty('display');\n      // }\n      if (buttonEl.getAttribute('slot') === 'overflow-buttons') {\n        buttonEl.removeAttribute('slot');\n      }\n    });\n    this._sortedButtonEls.overflow.forEach((buttonEl) => {\n      // if (buttonEl.style.display !== 'none') {\n      //   buttonEl.style.display = 'none';\n      // }\n      if (buttonEl.getAttribute('slot') !== 'overflow-buttons') {\n        buttonEl.setAttribute('slot', 'overflow-buttons');\n      }\n    });\n  }\n\n  /**\n   * Handle screen / component resize\n   */\n  private async handleResize() {\n    if (!this.getComputedWidth(this.el)) {\n      // element isn't fully rendered yet\n      return;\n    }\n\n    const index = await this.findButtonCutoffIndex();\n    const isButtonCutoffUpdated = index !== this._buttonCutoffIndex;\n    if (isButtonCutoffUpdated) {\n      this._buttonCutoffIndex = index;\n      await asyncRequestAnimationFrame();\n      this.sortVisibleAndOverflowButtons();\n    }\n\n    this.el.style.visibility = '';\n  }\n\n  private registerSlottedButtons() {\n    const MarketButtonTagName = getNamespacedTagFor('market-button');\n    this._buttonEls = [...this.el.querySelectorAll(MarketButtonTagName)];\n  }\n\n  private throttledHandleResize = throttle(this.handleResize.bind(this), RESIZE_DEBOUNCE_DURATION);\n\n  private observeContent(el: HTMLDivElement) {\n    if (!this._observers.content) {\n      this._observers.content = new ResizeObserver(this.throttledHandleResize);\n      this._observers.content.observe(el);\n    }\n  }\n\n  connectedCallback() {\n    if (!this._observers.host) {\n      this._observers.host = new ResizeObserver(this.throttledHandleResize);\n      this._observers.host.observe(this.el);\n    }\n  }\n\n  componentWillLoad() {\n    // hide component until handleResize()\n    this.el.style.visibility = 'hidden';\n    this.registerSlottedButtons();\n    this.handleResize();\n  }\n\n  disconnectedCallback() {\n    Object.entries(this._observers).forEach(([key, observer]) => {\n      if (observer) {\n        observer.disconnect();\n        this._observers[key] = undefined;\n      }\n    });\n  }\n\n  render() {\n    const MarketButtonDropdownTagName = getNamespacedTagFor('market-button-dropdown');\n    const MarketButtonTagName = getNamespacedTagFor('market-button');\n    const MarketIconTagName = getNamespacedTagFor('market-icon');\n    return (\n      <Host class=\"market-button-group\">\n        <div class=\"content\" ref={(el) => this.observeContent(el)}>\n          <slot onSlotchange={() => this.registerSlottedButtons()}></slot>\n          {this._sortedButtonEls.overflow.length > 0 && (\n            <MarketButtonDropdownTagName no-caret popover-strategy={this.popoverStrategy}>\n              <MarketButtonTagName slot=\"trigger\">\n                <MarketIconTagName slot=\"icon\" name={BUTTON_GROUP_OVERFLOW_BUTTON_ICON_ASSET}></MarketIconTagName>\n              </MarketButtonTagName>\n              <div slot=\"content\">\n                <slot name=\"overflow-buttons\" slot=\"overflow-buttons\"></slot>\n              </div>\n            </MarketButtonDropdownTagName>\n          )}\n        </div>\n      </Host>\n    );\n  }\n}\n"],"mappings":"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"}