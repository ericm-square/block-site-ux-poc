{"version":3,"names":["async","transitionToPromise","el","styles","computedStyle","getComputedStyle","transitionProperty","properties","split","Promise","all","Object","keys","map","property","value","resolve","style","includes","transitionEnded","e","propertyName","removeEventListener","addEventListener","isMarketTableV2Row","tagName","toLowerCase","Boolean","getNamespacedTagFor","isMarketTableV2Group","isDraggable","dragEnabled","undefined","SCROLL_DELAY","Math","min","SCROLL_STEP_MAX","MarketTableV2GroupTag","Draggable","constructor","opts","this","anchor","start","coords","canceled","x","y","startCoords","previousCoords","referenceElement","querySelector","top","startTop","right","startRight","left","startLeft","width","startWidth","height","startHeight","measureElement","source","parentElement","target","document","elementsFromPoint","clone","cloneNode","classList","add","defaultPrevented","dispatchEvent","CustomEvent","bubbles","cancelable","detail","assign","scrollParent","getScrollParent","position","opacity","body","append","asyncRequestAnimationFrame","finalWidth","finalHeight","window","innerWidth","zIndex","getMaxZIndex","setProperty","then","remove","move","newTarget","find","contains","deltaX","deltaY","transform","scroll","end","scrollInterval","clearInterval","collapsedTableGroup","farthest","draggedIntoCollapsedGroup","finalTop","finalRight","finalLeft","pointerEvents","removeProperty","bottom","cloneBottom","cloneTop","cloneRight","cloneLeft","scrollParentBottom","scrollParentTop","scrollParentRight","scrollParentLeft","getScrollParentRect","deltaBottom","deltaTop","max","deltaRight","deltaLeft","setInterval","scrollBy","destroy","element","parent","documentElement","overflowY","overflowX","scrollableY","test","scrollHeight","offsetHeight","scrollableX","scrollWidth","offsetWidth","innerHeight","selector","pointer","nextClosest","closest","rect","getBoundingClientRect","round"],"sources":["src/utils/transition-to-promise.ts","src/components/tables-v2/market-table-v2-row/types.ts","src/components/tables-v2/market-table-v2-group/types.ts","src/utils/draggable.ts"],"sourcesContent":["// This function sets CSS styles on an element and returns a promise.\n// The promise is resolved after any CSS transitions complete on the changed styles.\n// It's smart enough to resolve immediately if there is no transition on the style.\n// However, this is intended to be used with transitions that are set in CSS files.\n//\n// Example usage:\n// await transitionToPromise(element, {\n//   top: '100px',\n//   height: '100px',\n//   transform: 'scale(2)',\n// });\n//\n// adapted from https://gist.github.com/davej/44e3bbec414ed4665220\nexport async function transitionToPromise(el: HTMLElement, styles: object) {\n  const computedStyle = getComputedStyle(el);\n  const { transitionProperty } = computedStyle;\n  const properties = transitionProperty.split(', ');\n\n  return Promise.all(\n    Object.keys(styles).map((property) => {\n      const value = styles[property];\n      return new Promise<void>((resolve) => {\n        // if no value to set, resolve\n        if (!value) resolve();\n\n        // if same value, resolve\n        if (value === el.style[property]) resolve();\n\n        // if no transition on this property, set it and resolve\n        if (!properties.includes(property)) {\n          el.style[property] = value;\n          resolve();\n        }\n\n        // otherwise, set up a listener for transitionend\n        const transitionEnded = (e: TransitionEvent) => {\n          if (e.propertyName !== property) return;\n          el.removeEventListener('transitionend', transitionEnded);\n          resolve();\n        };\n        el.addEventListener('transitionend', transitionEnded);\n        el.style[property] = value;\n      });\n    }),\n  );\n}\n","import { getNamespacedTagFor } from '../../../utils/namespace';\n\nexport function isMarketTableV2Row(value: unknown): value is HTMLMarketTableV2RowElement {\n  const tagName = (value as HTMLElement)?.tagName.toLowerCase();\n  return Boolean(value && tagName === getNamespacedTagFor('market-table-v2-row'));\n}\n","import { getNamespacedTagFor } from '../../../utils/namespace';\n\nexport function isMarketTableV2Group(value: unknown): value is HTMLMarketTableV2GroupElement {\n  const tagName = (value as HTMLElement)?.tagName.toLowerCase();\n  return Boolean(value && tagName === getNamespacedTagFor('market-table-v2-group'));\n}\n","import { TMarketDragCoords } from './gesture/types';\nimport { getMaxZIndex } from './max-z-index';\nimport { asyncRequestAnimationFrame } from './raf';\nimport { getNamespacedTagFor } from './namespace';\nimport { transitionToPromise } from './transition-to-promise';\nimport { isMarketTableV2Row } from '../components/tables-v2/market-table-v2-row/types';\nimport { isMarketTableV2Group } from '../components/tables-v2/market-table-v2-group/types';\n\nexport interface MarketDraggableElement extends HTMLElement {\n  dragEnabled: boolean;\n}\n\nexport function isDraggable(value: unknown): value is MarketDraggableElement {\n  return Boolean(value && (value as MarketDraggableElement).dragEnabled !== undefined);\n}\n\nexport type TMarketDragEventDetail = {\n  x: number;\n  y: number;\n  el: MarketDraggableElement;\n  clone: MarketDraggableElement;\n  source: HTMLElement;\n  target: HTMLElement;\n};\n\nexport type TMarketDragAnchor = 'none' | 'left' | 'right';\n\nexport const SCROLL_DELAY = Math.min(1000 / 60); // shoot for ~60 fps\nexport const SCROLL_STEP_MAX = 24; // max scroll 24px at a time\n\nconst MarketTableV2GroupTag = getNamespacedTagFor('market-table-v2-group');\n\n/*\n  This util class abstracts & encapsulates drag & drop functionality for a component.\n\n  When wired up to a component, it does the following:\n  - adds a .market-drag-placeholder class to the original dragged element\n  - clones the dragged element with a class of .market-drag-clone\n  - visually tracks the drag move with the cloned element via CSS transform\n  - fires custom events on the dragged element:\n    - marketDragStart: fires on drag start\n    - marketDragEnd: fires on drag end\n    - marketDragComplete: fires when the dragged element's transition completes\n  - fires custom events on the drag target:\n    - marketDragEnter: fires when the dragged element enters a new target\n    - marketDragMove: fires when the dragged element moves over a target\n    - marketDragLeave: fires when the dragged element leaves a target\n    - marketDragDrop: fires when the dragged element is dropped on a target\n  - adds a .market-drag-released class to transition the clone back to the placeholder\n\n  Intended to be wired up via events fired by <market-drag-handle> like so:\n\n  ```html\n  <Host\n    onMarketDragHandleDragStart={(e: CustomEvent<TMarketDragCoords>) => this.onDragStart(e)}\n    onMarketDragHandleDragMove={(e: CustomEvent<TMarketDragCoords>) => this.onDragMove(e)}\n    onMarketDragHandleDragEnd={(e: CustomEvent<TMarketDragCoords> => this.onDragEnd(e)}\n  >\n    <market-drag-handle></market-drag-handle>\n  </Host>\n  ```\n\n  ```js\n  async onDragStart(e: CustomEvent<TMarketDragCoords>) {\n    const coords: TMarketDragCoords = e.detail;\n    this.drag = new Draggable(this.el, { anchor: 'right' });\n    await this.drag.start(coords);\n  }\n  onDragMove(e: CustomEvent<TMarketDragCoords>) {\n    const coords: TMarketDragCoords = e.detail;\n    this.drag.move(coords);\n  }\n  async onDragEnd(e: CustomEvent<TMarketDragCoords>) {\n    const coords: TMarketDragCoords = e.detail;\n    await this.drag.end(coords);\n    this.drag.destroy();\n  }\n  ```\n\n  ```css \n  // the original element stays in place and gets this class.\n  // use it to add placeholder styles, e.g. a grayed out row, etc.\n  :host(.market-drag-placeholder) {\n    color: gray;\n    background: gray;\n  }\n\n  // the cloned element follows the drag via CSS transform and gets this class.\n  // to add styles for the dragged element, do it here. for example:\n  // - you want to size the dragged element with a width and/or height\n  // - you want to transition from the starting size & position\n  // - you want to transition in a drop-shadow (see below)\n  :host(.market-drag-clone) {\n    min-width: 200px;\n    transition-timing-function: ease;\n    transition-duration: 200ms;\n    transition-property: top, width, height;\n\n    // pro tip: transitioning the opacity of a pseudo with a\n    // box-shadow is hardware accelerated and more performant\n    // than transitioning the box-shadow property directly\n    &::after {\n      box-shadow: 0 4px 32px 0 rgba(0, 0, 0, 0.1);\n      opacity: var(--market-drag-clone-shadow-opacity, 0); // set by draggable\n      transition: 200ns opacity ease;\n    }\n  }\n\n  // the cloned element gets this class when released.\n  // use it to transition clone back to the placeholder.\n  :host(.market-drag-released) {\n    transition-timing-function: ease;\n    transition-duration: 200ms;\n    transition-property: top, width, height, transform;\n  }\n  ```\n*/\n\nexport class Draggable {\n  el: MarketDraggableElement;\n  clone: MarketDraggableElement;\n  source: HTMLElement;\n  target: HTMLElement;\n  startCoords: TMarketDragCoords;\n  previousCoords: TMarketDragCoords;\n  canceled: boolean;\n  scrollParent: HTMLElement;\n  scrollInterval: ReturnType<typeof setInterval>;\n  anchor: TMarketDragAnchor;\n\n  // Init the class with the element to be dragged\n  constructor(el: MarketDraggableElement, opts?: { anchor?: TMarketDragAnchor }) {\n    this.el = el;\n    this.anchor = opts?.anchor || 'none';\n  }\n\n  // Start a drag movement on the element:\n  // - adds a .market-drag-placeholder class to the dragged element\n  // - clones the dragged element with a class of .market-drag-clone\n  // - fires marketDragStart custom event on the dragged element\n  async start(coords: TMarketDragCoords) {\n    this.canceled = false;\n    const { x, y } = coords;\n    this.startCoords = this.previousCoords = coords;\n    const { el, anchor } = this;\n\n    // find and measure a reference element\n    // special case: if el is a table group, reference its parent row\n    const referenceElement: HTMLElement = isMarketTableV2Group(el) ? el.querySelector('[slot=\"parent\"]') : el;\n    const {\n      top: startTop,\n      right: startRight,\n      left: startLeft,\n      width: startWidth,\n      height: startHeight,\n    } = measureElement(referenceElement);\n\n    // get the drag source\n    const source = el.parentElement;\n\n    // get the drag target\n    const target = document.elementsFromPoint(x, y)[0] as HTMLElement;\n\n    // clone the reference element to visually track the drag movement\n    const clone = referenceElement.cloneNode(true) as MarketDraggableElement;\n    clone.classList.add('market-drag-clone', 'market-drag-transitioning');\n\n    // save references\n    this.source = source;\n    this.target = target;\n    this.clone = clone;\n\n    // fire start event\n    const defaultPrevented = !el.dispatchEvent(\n      new CustomEvent<TMarketDragEventDetail>('marketDragStart', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          ...coords,\n          el,\n          source,\n          target,\n          clone,\n        },\n      }),\n    );\n    if (defaultPrevented) {\n      this.canceled = true;\n      return;\n    }\n\n    // get nearest scrollable parent\n    this.scrollParent = getScrollParent(el);\n\n    // the original element becomes a placeholder when it's dragged\n    el.classList.add('market-drag-placeholder');\n\n    // append and measure the clone's final size\n    // - if desired, dragged dimensions should be specified in CSS\n    Object.assign(clone.style, {\n      position: 'fixed',\n      opacity: 0, // hidden while we measure it\n      transitionProperty: 'none', // turn transitions off\n    });\n    document.body.append(clone);\n    await asyncRequestAnimationFrame();\n    const { width: finalWidth, height: finalHeight } = measureElement(clone);\n\n    // set the clone's initial position to match the reference element\n    Object.assign(clone.style, {\n      opacity: '', // visible now that we've measured it\n      width: `${startWidth}px`,\n      height: `${startHeight}px`,\n      top: `${startTop}px`,\n      left: anchor !== 'right' ? `${startLeft}px` : 'auto',\n      right: anchor !== 'left' ? `${window.innerWidth - startRight}px` : 'auto',\n      zIndex: `${getMaxZIndex(document.body) + 1}`,\n    });\n    await asyncRequestAnimationFrame();\n    // eslint-disable-next-line require-atomic-updates\n    clone.style.transitionProperty = ''; // turn transitions back on\n\n    // special case: if clone is a table row, add class to style the first cell\n    if (isMarketTableV2Row(clone)) {\n      clone.querySelector('market-table-v2-cell').classList.add('market-drag-clone-first-cell');\n    }\n\n    // add optional drop shadow opacity (custom CSS property)\n    clone.style.setProperty('--market-drag-clone-shadow-opacity', '1');\n\n    // transition clone to dragged size and position\n    transitionToPromise(clone, {\n      top: `${startTop + (startHeight - finalHeight) / 2}px`,\n      height: `${finalHeight}px`,\n      width: anchor === 'none' ? `${startWidth}px` : `${finalWidth}px`,\n    }).then(() => {\n      clone.classList.remove('market-drag-transitioning');\n    });\n  }\n\n  // Continues a drag movement on the element:\n  // - visually tracks the drag move with the cloned element via CSS transform\n  // - fires marketDragEnter, marketDragMove, & marketDragLeave custom events on drag targets\n  move(coords: TMarketDragCoords) {\n    const { el, clone, source, target, startCoords, previousCoords, canceled } = this;\n    const { x, y } = coords;\n\n    // if the drag has already been canceled, return early\n    if (canceled) return;\n\n    // if for some reason we have no clone, return early\n    if (!clone) return;\n\n    // if the drag coords haven't changed, return early\n    if (x === previousCoords.x && y === previousCoords.y) return;\n\n    // save the current coords\n    this.previousCoords = coords;\n\n    // get the first drag target that is not the clone or its descendants\n    const newTarget = [...document.elementsFromPoint(x, y)].find((target) => {\n      return !clone.contains(target);\n    }) as HTMLElement;\n\n    // if drag target is new\n    if (newTarget !== target) {\n      // fire leave on current target\n      target?.dispatchEvent(\n        new CustomEvent<TMarketDragEventDetail>('marketDragLeave', {\n          bubbles: true,\n          detail: {\n            x,\n            y,\n            el,\n            source,\n            target,\n            clone,\n          },\n        }),\n      );\n\n      // fire enter on new target\n      newTarget?.dispatchEvent(\n        new CustomEvent<TMarketDragEventDetail>('marketDragEnter', {\n          bubbles: true,\n          detail: {\n            x,\n            y,\n            el,\n            source,\n            target: newTarget,\n            clone,\n          },\n        }),\n      );\n\n      // update current drag target\n      this.target = newTarget;\n    }\n\n    // fire drag move on new target\n    newTarget?.dispatchEvent(\n      new CustomEvent<TMarketDragEventDetail>('marketDragMove', {\n        bubbles: true,\n        detail: {\n          x,\n          y,\n          el,\n          source,\n          target: newTarget,\n          clone,\n        },\n      }),\n    );\n\n    // move the clone with the drag move\n    const deltaX = x - startCoords.x;\n    const deltaY = y - startCoords.y;\n    Object.assign(clone.style, {\n      transform: `translate(${deltaX}px, ${deltaY}px)`,\n    });\n\n    // scroll the scrollParent if need be\n    this.scroll();\n  }\n\n  // Ends a drag movement on the element:\n  // - fires marketDragEnd custom event on the dragged element\n  // - fires marketDragDrop custom event on drag target\n  // - removes the cloned element after transitioning it back to the placeholder\n  // - removes the .market-drag-placeholder class from the dragged element\n  async end(coords: TMarketDragCoords) {\n    if (this.canceled) return;\n\n    const { el, source, clone, anchor, scrollInterval } = this;\n    const { x, y } = coords;\n\n    // stop any current scrolling\n    clearInterval(scrollInterval);\n\n    // if for some reason we have no clone, return early\n    if (!clone) return;\n\n    // get the first drag target that is not the clone or its descendants\n    const target = [...document.elementsFromPoint(x, y)].find((target) => {\n      return !clone.contains(target);\n    }) as HTMLElement;\n\n    // fire end event on dragged element\n    const defaultPrevented = !el.dispatchEvent(\n      new CustomEvent<TMarketDragEventDetail>('marketDragEnd', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          x,\n          y,\n          el,\n          source,\n          target,\n          clone,\n        },\n      }),\n    );\n\n    // fire drop event on target\n    if (!defaultPrevented) {\n      target?.dispatchEvent(\n        new CustomEvent<TMarketDragEventDetail>('marketDragDrop', {\n          bubbles: true,\n          cancelable: false,\n          detail: {\n            x,\n            y,\n            el,\n            source,\n            target,\n            clone,\n          },\n        }),\n      );\n    }\n\n    // find the reference element, w/ some special logic for table groups\n    const collapsedTableGroup = farthest(el, `${MarketTableV2GroupTag}[collapsed]`);\n    const draggedIntoCollapsedGroup = collapsedTableGroup && collapsedTableGroup !== el;\n    const referenceElement: HTMLElement = draggedIntoCollapsedGroup\n      ? collapsedTableGroup.querySelector('[slot=\"parent\"]')\n      : isMarketTableV2Group(el)\n      ? el.querySelector('[slot=\"parent\"]')\n      : el;\n\n    // measure the elements\n    await asyncRequestAnimationFrame();\n    const {\n      top: finalTop,\n      right: finalRight,\n      left: finalLeft,\n      width: finalWidth,\n      height: finalHeight,\n    } = measureElement(referenceElement);\n    const {\n      top: startTop,\n      right: startRight,\n      left: startLeft,\n      width: startWidth,\n      height: startHeight,\n    } = measureElement(clone);\n    const deltaX = anchor === 'left' ? startLeft - finalLeft : startRight - finalRight;\n    const deltaY = startTop - finalTop;\n\n    // update the clone position so that its top & left origin\n    // is the same as the dragged element (which may have been moved!)\n    // delta transform will result in the clone appearing in the same spot\n    Object.assign(clone.style, {\n      pointerEvents: 'none', // disable mouse events\n      transitionProperty: 'none', // turn transitions off\n      top: `${finalTop}px`,\n      left: anchor !== 'right' ? `${finalLeft}px` : 'auto',\n      right: anchor !== 'left' ? `${window.innerWidth - finalRight}px` : 'auto',\n      width: `${startWidth}px`,\n      height: `${startHeight}px`,\n      transform: `translate(${deltaX}px, ${deltaY}px)`,\n    });\n    await asyncRequestAnimationFrame();\n    // eslint-disable-next-line require-atomic-updates\n    clone.style.transitionProperty = ''; // turn transitions back on\n\n    // special case: if clone is a table row, remove styling from the first cell\n    if (isMarketTableV2Row(clone) && isMarketTableV2Row(referenceElement)) {\n      clone.querySelector('market-table-v2-cell').classList.remove('market-drag-clone-first-cell');\n    }\n\n    // remove the transform to transition clone back to the placeholder.\n    clone.classList.add('market-drag-released', 'market-drag-transitioning');\n    if (draggedIntoCollapsedGroup) clone.classList.add('market-drag-into-collapsed-group');\n    clone.style.removeProperty('--market-drag-clone-shadow-opacity');\n    await asyncRequestAnimationFrame();\n    await transitionToPromise(clone, {\n      width: `${finalWidth}px`,\n      height: `${finalHeight}px`,\n      transform: deltaX || deltaY ? 'translate(0, 0)' : null,\n    });\n\n    // cleanup\n    el.classList.remove('market-drag-placeholder');\n    clone.remove();\n\n    // fire event on dragged element when its transition completes\n    el?.dispatchEvent(\n      new CustomEvent<TMarketDragEventDetail>('marketDragComplete', {\n        bubbles: true,\n        cancelable: false,\n        detail: {\n          x,\n          y,\n          el,\n          source,\n          target,\n          clone,\n        },\n      }),\n    );\n  }\n\n  private scroll() {\n    const { clone, scrollParent, scrollInterval } = this;\n\n    // stop any current scrolling\n    clearInterval(scrollInterval);\n\n    // measure the clone position\n    const { bottom: cloneBottom, top: cloneTop, right: cloneRight, left: cloneLeft } = measureElement(clone);\n\n    // measure the scroll parent position\n    const {\n      bottom: scrollParentBottom,\n      top: scrollParentTop,\n      right: scrollParentRight,\n      left: scrollParentLeft,\n    } = getScrollParentRect(scrollParent);\n\n    // scroll vertically if clone is over a vertical edge\n    const deltaBottom = cloneBottom - scrollParentBottom;\n    const deltaTop = cloneTop - scrollParentTop;\n    const top =\n      deltaBottom > 0\n        ? Math.min(deltaBottom / 4, SCROLL_STEP_MAX)\n        : deltaTop < 0\n        ? Math.max(deltaTop / 4, -SCROLL_STEP_MAX)\n        : 0;\n\n    // scroll horizontally if clone is over a horizontal edge\n    const deltaRight = cloneRight - scrollParentRight;\n    const deltaLeft = cloneLeft - scrollParentLeft;\n    const left =\n      deltaRight > 0\n        ? Math.min(deltaRight / 4, SCROLL_STEP_MAX)\n        : deltaLeft < 0\n        ? Math.max(deltaLeft / 4, -SCROLL_STEP_MAX)\n        : 0;\n\n    if (top !== 0 || left !== 0) {\n      this.scrollInterval = setInterval(() => {\n        scrollParent.scrollBy({ top, left });\n      }, SCROLL_DELAY);\n    }\n  }\n\n  // clean up var refs\n  destroy() {\n    this.el = null;\n    this.clone = null;\n    this.source = null;\n    this.target = null;\n    this.startCoords = null;\n    this.canceled = null;\n    this.scrollParent = null;\n    this.scrollInterval = null;\n    this.anchor = null;\n  }\n}\n\n// Finds the nearest scrollable ancestor element.\n// Looks for scrolling in both X and Y directions. Returns the document if no element is found.\n// Works for now for our purposes, but may eventually need to take into account other display/position types.\nfunction getScrollParent(element: HTMLElement): HTMLElement {\n  let parent = element.parentElement;\n  while (parent !== document.documentElement) {\n    const { overflowY, overflowX } = getComputedStyle(parent);\n    const scrollableY = /(auto|scroll)/.test(overflowY) && parent.scrollHeight > parent.offsetHeight;\n    const scrollableX = /(auto|scroll)/.test(overflowX) && parent.scrollWidth > parent.offsetWidth;\n    if (scrollableY || scrollableX) return parent;\n    parent = parent.parentElement;\n  }\n  return document.documentElement;\n}\n\n// Basically getBoundingClientRect() but handles an edge case\n// where the scrollable parent could be the document itself\nfunction getScrollParentRect(element: HTMLElement): Pick<DOMRect, 'top' | 'bottom' | 'left' | 'right'> {\n  const { top, right, bottom, left } = measureElement(element);\n  if (element === document.documentElement) {\n    // we actually want the window size in this case\n    const top = 0;\n    const right = window.innerWidth;\n    const bottom = window.innerHeight;\n    const left = 0;\n    return { top, right, bottom, left };\n  }\n  return { top, right, bottom, left };\n}\n\n// This does the opposite of element.closest(selector).\n// That is, it finds the outermost ancestor element that matches the selector.\nfunction farthest(el: HTMLElement, selector: string) {\n  let farthest: HTMLElement;\n  let pointer: HTMLElement = el;\n  while (pointer !== document.body) {\n    const nextClosest = pointer.closest(selector) as HTMLElement;\n    if (nextClosest) farthest = nextClosest;\n    pointer = pointer.parentElement;\n  }\n  return farthest;\n}\n\n// Basically getBoundingClientRect() but rounded\nfunction measureElement(el: HTMLElement): Pick<DOMRect, 'top' | 'right' | 'bottom' | 'left' | 'width' | 'height'> {\n  const rect = el.getBoundingClientRect();\n  return {\n    top: Math.round(rect.top),\n    right: Math.round(rect.right),\n    bottom: Math.round(rect.bottom),\n    left: Math.round(rect.left),\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n  };\n}\n"],"mappings":"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"}