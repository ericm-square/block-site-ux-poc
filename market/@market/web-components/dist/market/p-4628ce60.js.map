{"version":3,"names":["isReorderable","value","Boolean","includes","reorderable","TABLE_GROUP_EXPAND_TIMEOUT_DURATION","Reorderable","createCursor","cursor","document","createElement","classList","add","constructor","el","accepts","event","mode","this","isValidDrag","dragged","source","target","reorderableSource","closest","reorderableTarget","isDraggable","join","bothExternal","closestReorderable","getCommonAncestor","dragMove","e","tableGroupExpandTimeout","y","detail","_a","clearTimeout","_b","parentElement","remove","append","targetSibling","isMarketTableV2Group","parent","children","find","isMarketTableV2Row","slot","top","height","getBoundingClientRect","collapsible","collapsed","oneThird","Math","round","twoThirds","before","after","filter","length","setTimeout","async","setCollapsed","asyncRequestAnimationFrame","halfway","_c","dragLeave","dragEnd","stopImmediatePropagation","items","getReorderableItems","oldIndex","indexOf","newIndex","defaultPrevented","emit","item","preventDefault","dragDrop","previousElementSibling","nextElementSibling","itemsWithoutDraggedEl","splice","originalPosition","replaceWith","Promise","resolve","addEventListener","once","destroy","scopedSelectors","map","selector","querySelectorAll","forEach","push","node1","node2","node","contains"],"sources":["src/utils/reorderable.ts"],"sourcesContent":["import { EventEmitter } from '@stencil/core';\nimport { isDraggable, TMarketDragEventDetail, MarketDraggableElement } from './draggable';\nimport { isMarketTableV2Row } from '../components/tables-v2/market-table-v2-row/types';\nimport { isMarketTableV2Group } from '../components/tables-v2/market-table-v2-group/types';\nimport { asyncRequestAnimationFrame } from './raf';\n\nexport type TMarketReorderableOptions = 'off' | 'internal' | 'external';\n\nexport interface MarketReorderableElement extends HTMLElement {\n  reorderable: TMarketReorderableOptions;\n}\n\nexport function isReorderable(value: unknown): value is MarketReorderableElement {\n  return Boolean(value && ['internal', 'external'].includes((value as MarketReorderableElement).reorderable));\n}\n\nexport type TMarketReorderEventDetail = {\n  item: MarketDraggableElement;\n  oldIndex: number;\n  newIndex: number;\n};\n\nexport const TABLE_GROUP_EXPAND_TIMEOUT_DURATION = 300;\n\n/*\n  This util class abstracts & encapsulates reorderable functionality for a component.\n\n  In the constructor:\n  - `el` is the component element to apply reordering functionality to\n  - `accepts` is an array of CSS selectors that are valid draggable elements\n  - `event` is the stencil EventEmitter to fire when a reorder event occurs\n\n  Intended to be wired up via drag events fired by a dragged object like so:\n  \n  ```html\n  <Host\n    onMarketDragMove={(e: CustomEvent<TMarketDragEventDetail>) => this.onDragMove(e)}\n    onMarketDragLeave={() => this.onDragLeave()}\n    onMarketDragEnd={(e: CustomEvent<TMarketDragEventDetail>) => this.onDragEnd(e)}\n    onMarketDragDrop={(e: CustomEvent<TMarketDragEventDetail>) => this.onDragDrop(e)}\n  >\n    ...\n  </Host>\n  ```\n\n  ```js\n  this.reorder = new Reorderable({\n    el: this.el,\n    accepts: ['market-row'],\n    event: marketListItemsReordered,\n  });\n  onDragMove(e: CustomEvent<TMarketDragEventDetail>) {\n    this.reorder.dragMove(e);\n  }\n  onDragLeave() {\n    this.reorder.dragLeave();\n  }\n  onDragEnd(e: CustomEvent<TMarketDragEventDetail>) {\n    this.reorder.dragEnd(e);\n  }\n  onDragDrop(e: CustomEvent<TMarketDragEventDetail>) {\n    this.reorder.dragDrop(e);\n  }\n  ```\n\n  ```css \n  // the drag cursor inserted to show current drop location\n  ::slotted(.market-drag-cursor) { ... }\n  ```\n*/\n\nexport class Reorderable {\n  el: MarketReorderableElement;\n  accepts: Array<string>;\n  event: EventEmitter<TMarketReorderEventDetail>;\n  mode: 'default' | 'framework';\n  tableGroupExpandTimeout: ReturnType<typeof setTimeout>;\n\n  // static instance var means only one cursor shared across all Reorderable instances\n  static cursor = this.createCursor();\n  static createCursor() {\n    const cursor = document.createElement('div');\n    cursor.classList.add('market-drag-cursor');\n    return cursor;\n  }\n\n  constructor({\n    el,\n    accepts,\n    event,\n    mode,\n  }: {\n    el: MarketReorderableElement;\n    accepts: Array<string>;\n    event: EventEmitter;\n    mode: 'default' | 'framework';\n  }) {\n    this.el = el;\n    this.accepts = accepts;\n    this.event = event;\n    this.mode = mode;\n  }\n\n  private isValidDrag(dragged: HTMLElement, source: HTMLElement, target: HTMLElement) {\n    const { el, accepts } = this;\n    const reorderableSource = source?.closest('[reorderable=\"internal\"], [reorderable=\"external\"]');\n    const reorderableTarget = target?.closest('[reorderable=\"internal\"], [reorderable=\"external\"]');\n\n    // begin with type checks...\n    if (!isDraggable(dragged)) return false;\n    if (!isReorderable(reorderableSource)) return false;\n    if (!isReorderable(reorderableTarget)) return false;\n\n    // is this an accepted draggable item?\n    if (dragged.closest(accepts.join(',')) !== dragged) return false;\n\n    // is this element either the source or destination?\n    if (el !== reorderableSource && el !== reorderableTarget) return false;\n\n    // if source & destination elements are different...\n    if (reorderableSource !== reorderableTarget) {\n      // are they both reorderable externally?\n      const bothExternal = reorderableSource.reorderable === 'external' && reorderableTarget.reorderable === 'external';\n      // or do they have a common reorderable ancestor?\n      const closestReorderable = getCommonAncestor(reorderableSource, reorderableTarget).closest(\n        '[reorderable=\"internal\"], [reorderable=\"external\"]',\n      );\n      if (!bothExternal && !closestReorderable) return false;\n    }\n\n    // looks like we're good!\n    return true;\n  }\n\n  /**\n   * Fired on a target element when an item is dragged over the target.\n   */\n  dragMove(e: CustomEvent<TMarketDragEventDetail>) {\n    const { el, accepts, tableGroupExpandTimeout } = this;\n    const { y, el: dragged, source, target } = e.detail;\n    const { cursor } = Reorderable;\n\n    // check drag validity\n    if (!this.isValidDrag(dragged, source, target)) return;\n\n    // clear the table group timeout\n    clearTimeout(tableGroupExpandTimeout);\n\n    // remove cursor parent class\n    cursor.parentElement?.classList.remove('market-drag-cursor-parent');\n\n    // if this element is the drag target itself (not another child)\n    if (target === el) {\n      el.append(cursor);\n      el.classList.add('market-drag-cursor-parent');\n      return;\n    }\n\n    // otherwise, find the nearest child item target\n    const targetSibling = target.closest(accepts.join(',')) as HTMLElement;\n\n    // do nothing if no target sibling\n    if (!targetSibling) return;\n\n    // do nothing if the target sibling is the placeholder\n    if (targetSibling === dragged) return;\n\n    // determine where to insert cursor based on mouse position\n    if (isMarketTableV2Group(targetSibling)) {\n      // special case for table groups; look at the parent row\n      const parent = [...targetSibling.children].find((el) => isMarketTableV2Row(el) && el.slot === 'parent');\n\n      const { top, height } = parent.getBoundingClientRect();\n      if (targetSibling.collapsible && targetSibling.collapsed) {\n        const oneThird = Math.round(top + height / 3);\n        const twoThirds = Math.round(top + (height * 2) / 3);\n        if (y < oneThird) {\n          // insert cursor before the group\n          targetSibling.before(cursor);\n        } else if (y > twoThirds) {\n          // insert cursor after the group\n          targetSibling.after(cursor);\n        } else {\n          // insert cursor inside the group after the parent\n          parent.after(cursor);\n          const children = [...targetSibling.children].filter(\n            (el) => (isMarketTableV2Row(el) || isMarketTableV2Group(el)) && !el.slot,\n          );\n          // set a timeout to expand the group if hovered\n          if (children.length > 0) {\n            this.tableGroupExpandTimeout = setTimeout(async () => {\n              await targetSibling.setCollapsed(false);\n              await asyncRequestAnimationFrame();\n              parent.after(cursor);\n            }, TABLE_GROUP_EXPAND_TIMEOUT_DURATION);\n          }\n        }\n      } else {\n        const halfway = Math.round(top + height / 2);\n        if (y < halfway) {\n          // insert cursor before the group\n          targetSibling.before(cursor);\n        } else {\n          // insert cursor inside the group after the parent\n          parent.after(cursor);\n        }\n      }\n    } else {\n      const { top, height } = targetSibling.getBoundingClientRect();\n      const halfway = Math.round(top + height / 2);\n      if (y < halfway) {\n        targetSibling.before(cursor);\n      } else {\n        targetSibling.after(cursor);\n      }\n    }\n\n    // mark the cursor's parent\n    cursor.parentElement?.classList.add('market-drag-cursor-parent');\n  }\n\n  /**\n   * Fired on a target element when a dragged item leaves the target\n   */\n  dragLeave() {\n    const { tableGroupExpandTimeout } = this;\n    const { cursor } = Reorderable;\n\n    // remove the cursor and parent class\n    cursor.parentElement?.classList.remove('market-drag-cursor-parent');\n    cursor.remove();\n\n    // clear the table group timeout\n    clearTimeout(tableGroupExpandTimeout);\n  }\n\n  /**\n   * Fired on a dragged item when it is released.\n   * Useful to determine if an item was dropped externally.\n   */\n  dragEnd(e: CustomEvent<TMarketDragEventDetail>) {\n    const { el, accepts, event, tableGroupExpandTimeout } = this;\n    const { el: dragged, source } = e.detail;\n    const { cursor } = Reorderable;\n\n    // clear the table group timeout\n    clearTimeout(tableGroupExpandTimeout);\n\n    // instead of using target from the event detail, use cursor's parent\n    const target = cursor.parentElement as MarketReorderableElement;\n\n    // check for drag validity\n    if (!this.isValidDrag(dragged, source, target)) return;\n\n    // do nothing if the source and target are the same reorderable\n    const reorderableSource = source?.closest('[reorderable=\"internal\"], [reorderable=\"external\"]');\n    const reorderableTarget = target?.closest('[reorderable=\"internal\"], [reorderable=\"external\"]');\n    if (reorderableSource === reorderableTarget) return;\n\n    // we now know the element is being dragged out of its reorderable parent,\n    // so we stop propagation on original event so reorder event isn't duped.\n    e.stopImmediatePropagation();\n\n    // note: dragging externally means new index = -1\n    const items = getReorderableItems(el, accepts);\n    const oldIndex = items.indexOf(dragged);\n    const newIndex = -1;\n\n    // emit the reorder event and check for prevent default\n    const { defaultPrevented } = event.emit({\n      item: dragged,\n      oldIndex,\n      newIndex,\n    });\n\n    // if reorder event was prevented, prevent the drop event\n    if (defaultPrevented) {\n      e.preventDefault();\n      cursor.remove();\n    }\n  }\n\n  /**\n   * Fired on a target element when a dragged item is released over the target.\n   */\n  async dragDrop(e: CustomEvent<TMarketDragEventDetail>) {\n    const { el, accepts, event, mode, tableGroupExpandTimeout } = this;\n    const { el: dragged, source } = e.detail;\n    const { cursor } = Reorderable;\n\n    // clear the table group timeout\n    clearTimeout(tableGroupExpandTimeout);\n\n    // if this is not the cursor's parent, do nothing and let the event bubble up\n    const reorderableTarget = cursor.parentElement as MarketReorderableElement;\n    if (el !== reorderableTarget) return;\n\n    // check for drag validity\n    if (!this.isValidDrag(dragged, source, reorderableTarget)) return;\n\n    // prevent the event from further bubbling up\n    e.stopImmediatePropagation();\n\n    // remove cursor parent class\n    reorderableTarget?.classList.remove('market-drag-cursor-parent');\n\n    // if the cursor is a sibling of the dragged element, do nothing\n    if ([cursor.previousElementSibling, cursor.nextElementSibling].includes(dragged)) {\n      cursor.remove();\n      return;\n    }\n\n    // note: if item is external, then old index is -1\n    const items = getReorderableItems(reorderableTarget, accepts);\n    const oldIndex = items.indexOf(dragged);\n\n    // find new index\n    const itemsWithoutDraggedEl = [...items];\n    if (oldIndex >= 0) {\n      itemsWithoutDraggedEl.splice(oldIndex, 1);\n    }\n    const newIndex = itemsWithoutDraggedEl.indexOf(cursor.previousElementSibling as MarketDraggableElement) + 1;\n\n    // same index means no reorder event\n    if (newIndex === oldIndex) {\n      cursor.remove();\n      return;\n    }\n\n    // create a temp div to hold the element's original position\n    const originalPosition = document.createElement('div');\n\n    // insert the dragged element at the cursor's position\n    dragged.replaceWith(originalPosition);\n    cursor.replaceWith(dragged);\n\n    // await the drop completion event\n    await new Promise((resolve) => dragged.addEventListener('marketDragComplete', resolve, { once: true }));\n\n    // in framework mode, restore the original position before firing event\n    if (mode === 'framework') originalPosition.replaceWith(dragged);\n\n    // fire the reorder event and check for prevent default\n    const { defaultPrevented } = event.emit({\n      item: dragged,\n      oldIndex,\n      newIndex,\n    });\n\n    // in default mode, restore the original position if event was prevented\n    if (defaultPrevented && mode === 'default') originalPosition.replaceWith(dragged);\n\n    // cleanup: remove the original position if still in DOM\n    originalPosition.remove();\n  }\n\n  // clean up var refs\n  destroy() {\n    Reorderable.cursor.remove();\n\n    clearTimeout(this.tableGroupExpandTimeout);\n\n    this.el = null;\n    this.accepts = null;\n    this.event = null;\n    this.mode = null;\n    this.tableGroupExpandTimeout = null;\n  }\n}\n\nfunction getReorderableItems(el: MarketReorderableElement, accepts: Array<string>): MarketDraggableElement[] {\n  const items = [];\n  const scopedSelectors = accepts.map((selector) => `:scope > ${selector}`);\n  el.querySelectorAll(scopedSelectors.join(',')).forEach((item) => {\n    if (isDraggable(item)) items.push(item);\n  });\n  return items;\n}\n\nfunction getCommonAncestor(node1: HTMLElement, node2: HTMLElement): HTMLElement {\n  let node: HTMLElement = node1;\n  while (node) {\n    if (node.contains(node2)) {\n      return node;\n    }\n    node = node.parentElement;\n  }\n  return null;\n}\n"],"mappings":"qGAYgBA,EAAcC,GAC5B,OAAOC,QAAQD,GAAS,CAAC,WAAY,YAAYE,SAAUF,EAAmCG,aAChG,CAQO,MAAMC,EAAsC,I,MAiDtCC,EASX,mBAAOC,GACL,MAAMC,EAASC,SAASC,cAAc,OACtCF,EAAOG,UAAUC,IAAI,sBACrB,OAAOJ,C,CAGT,WAAAK,EAAYC,GACVA,EAAEC,QACFA,EAAOC,MACPA,EAAKC,KACLA,IAOAC,KAAKJ,GAAKA,EACVI,KAAKH,QAAUA,EACfG,KAAKF,MAAQA,EACbE,KAAKD,KAAOA,C,CAGN,WAAAE,CAAYC,EAAsBC,EAAqBC,GAC7D,MAAMR,GAAEA,EAAEC,QAAEA,GAAYG,KACxB,MAAMK,EAAoBF,IAAM,MAANA,SAAM,SAANA,EAAQG,QAAQ,sDAC1C,MAAMC,EAAoBH,IAAM,MAANA,SAAM,SAANA,EAAQE,QAAQ,sDAG1C,IAAKE,EAAYN,GAAU,OAAO,MAClC,IAAKpB,EAAcuB,GAAoB,OAAO,MAC9C,IAAKvB,EAAcyB,GAAoB,OAAO,MAG9C,GAAIL,EAAQI,QAAQT,EAAQY,KAAK,QAAUP,EAAS,OAAO,MAG3D,GAAIN,IAAOS,GAAqBT,IAAOW,EAAmB,OAAO,MAGjE,GAAIF,IAAsBE,EAAmB,CAE3C,MAAMG,EAAeL,EAAkBnB,cAAgB,YAAcqB,EAAkBrB,cAAgB,WAEvG,MAAMyB,EAAqBC,EAAkBP,EAAmBE,GAAmBD,QACjF,sDAEF,IAAKI,IAAiBC,EAAoB,OAAO,K,CAInD,OAAO,I,CAMT,QAAAE,CAASC,G,QACP,MAAMlB,GAAEA,EAAEC,QAAEA,EAAOkB,wBAAEA,GAA4Bf,KACjD,MAAMgB,EAAEA,EAAGpB,GAAIM,EAAOC,OAAEA,EAAMC,OAAEA,GAAWU,EAAEG,OAC7C,MAAM3B,OAAEA,GAAW4B,EAGnB,IAAKlB,KAAKC,YAAYC,EAASC,EAAQC,GAAS,OAGhDe,aAAaJ,IAGbK,EAAA9B,EAAO+B,iBAAa,MAAAD,SAAA,SAAAA,EAAE3B,UAAU6B,OAAO,6BAGvC,GAAIlB,IAAWR,EAAI,CACjBA,EAAG2B,OAAOjC,GACVM,EAAGH,UAAUC,IAAI,6BACjB,M,CAIF,MAAM8B,EAAgBpB,EAAOE,QAAQT,EAAQY,KAAK,MAGlD,IAAKe,EAAe,OAGpB,GAAIA,IAAkBtB,EAAS,OAG/B,GAAIuB,EAAqBD,GAAgB,CAEvC,MAAME,EAAS,IAAIF,EAAcG,UAAUC,MAAMhC,GAAOiC,EAAmBjC,IAAOA,EAAGkC,OAAS,WAE9F,MAAMC,IAAEA,EAAGC,OAAEA,GAAWN,EAAOO,wBAC/B,GAAIT,EAAcU,aAAeV,EAAcW,UAAW,CACxD,MAAMC,EAAWC,KAAKC,MAAMP,EAAMC,EAAS,GAC3C,MAAMO,EAAYF,KAAKC,MAAMP,EAAOC,EAAS,EAAK,GAClD,GAAIhB,EAAIoB,EAAU,CAEhBZ,EAAcgB,OAAOlD,E,MAChB,GAAI0B,EAAIuB,EAAW,CAExBf,EAAciB,MAAMnD,E,KACf,CAELoC,EAAOe,MAAMnD,GACb,MAAMqC,EAAW,IAAIH,EAAcG,UAAUe,QAC1C9C,IAAQiC,EAAmBjC,IAAO6B,EAAqB7B,MAASA,EAAGkC,OAGtE,GAAIH,EAASgB,OAAS,EAAG,CACvB3C,KAAKe,wBAA0B6B,YAAWC,gBAClCrB,EAAcsB,aAAa,aAC3BC,IACNrB,EAAOe,MAAMnD,EAAO,GACnBH,E,OAGF,CACL,MAAM6D,EAAUX,KAAKC,MAAMP,EAAMC,EAAS,GAC1C,GAAIhB,EAAIgC,EAAS,CAEfxB,EAAcgB,OAAOlD,E,KAChB,CAELoC,EAAOe,MAAMnD,E,OAGZ,CACL,MAAMyC,IAAEA,EAAGC,OAAEA,GAAWR,EAAcS,wBACtC,MAAMe,EAAUX,KAAKC,MAAMP,EAAMC,EAAS,GAC1C,GAAIhB,EAAIgC,EAAS,CACfxB,EAAcgB,OAAOlD,E,KAChB,CACLkC,EAAciB,MAAMnD,E,GAKxB2D,EAAA3D,EAAO+B,iBAAa,MAAA4B,SAAA,SAAAA,EAAExD,UAAUC,IAAI,4B,CAMtC,SAAAwD,G,MACE,MAAMnC,wBAAEA,GAA4Bf,KACpC,MAAMV,OAAEA,GAAW4B,GAGnBE,EAAA9B,EAAO+B,iBAAa,MAAAD,SAAA,SAAAA,EAAE3B,UAAU6B,OAAO,6BACvChC,EAAOgC,SAGPH,aAAaJ,E,CAOf,OAAAoC,CAAQrC,GACN,MAAMlB,GAAEA,EAAEC,QAAEA,EAAOC,MAAEA,EAAKiB,wBAAEA,GAA4Bf,KACxD,MAAQJ,GAAIM,EAAOC,OAAEA,GAAWW,EAAEG,OAClC,MAAM3B,OAAEA,GAAW4B,EAGnBC,aAAaJ,GAGb,MAAMX,EAASd,EAAO+B,cAGtB,IAAKrB,KAAKC,YAAYC,EAASC,EAAQC,GAAS,OAGhD,MAAMC,EAAoBF,IAAM,MAANA,SAAM,SAANA,EAAQG,QAAQ,sDAC1C,MAAMC,EAAoBH,IAAM,MAANA,SAAM,SAANA,EAAQE,QAAQ,sDAC1C,GAAID,IAAsBE,EAAmB,OAI7CO,EAAEsC,2BAGF,MAAMC,EAAQC,EAAoB1D,EAAIC,GACtC,MAAM0D,EAAWF,EAAMG,QAAQtD,GAC/B,MAAMuD,GAAY,EAGlB,MAAMC,iBAAEA,GAAqB5D,EAAM6D,KAAK,CACtCC,KAAM1D,EACNqD,WACAE,aAIF,GAAIC,EAAkB,CACpB5C,EAAE+C,iBACFvE,EAAOgC,Q,EAOX,cAAMwC,CAAShD,GACb,MAAMlB,GAAEA,EAAEC,QAAEA,EAAOC,MAAEA,EAAKC,KAAEA,EAAIgB,wBAAEA,GAA4Bf,KAC9D,MAAQJ,GAAIM,EAAOC,OAAEA,GAAWW,EAAEG,OAClC,MAAM3B,OAAEA,GAAW4B,EAGnBC,aAAaJ,GAGb,MAAMR,EAAoBjB,EAAO+B,cACjC,GAAIzB,IAAOW,EAAmB,OAG9B,IAAKP,KAAKC,YAAYC,EAASC,EAAQI,GAAoB,OAG3DO,EAAEsC,2BAGF7C,IAAiB,MAAjBA,SAAiB,SAAjBA,EAAmBd,UAAU6B,OAAO,6BAGpC,GAAI,CAAChC,EAAOyE,uBAAwBzE,EAAO0E,oBAAoB/E,SAASiB,GAAU,CAChFZ,EAAOgC,SACP,M,CAIF,MAAM+B,EAAQC,EAAoB/C,EAAmBV,GACrD,MAAM0D,EAAWF,EAAMG,QAAQtD,GAG/B,MAAM+D,EAAwB,IAAIZ,GAClC,GAAIE,GAAY,EAAG,CACjBU,EAAsBC,OAAOX,EAAU,E,CAEzC,MAAME,EAAWQ,EAAsBT,QAAQlE,EAAOyE,wBAAoD,EAG1G,GAAIN,IAAaF,EAAU,CACzBjE,EAAOgC,SACP,M,CAIF,MAAM6C,EAAmB5E,SAASC,cAAc,OAGhDU,EAAQkE,YAAYD,GACpB7E,EAAO8E,YAAYlE,SAGb,IAAImE,SAASC,GAAYpE,EAAQqE,iBAAiB,qBAAsBD,EAAS,CAAEE,KAAM,SAG/F,GAAIzE,IAAS,YAAaoE,EAAiBC,YAAYlE,GAGvD,MAAMwD,iBAAEA,GAAqB5D,EAAM6D,KAAK,CACtCC,KAAM1D,EACNqD,WACAE,aAIF,GAAIC,GAAoB3D,IAAS,UAAWoE,EAAiBC,YAAYlE,GAGzEiE,EAAiB7C,Q,CAInB,OAAAmD,GACEvD,EAAY5B,OAAOgC,SAEnBH,aAAanB,KAAKe,yBAElBf,KAAKJ,GAAK,KACVI,KAAKH,QAAU,KACfG,KAAKF,MAAQ,KACbE,KAAKD,KAAO,KACZC,KAAKe,wBAA0B,I,MA/R1B3B,EAAAE,OAAS4B,EAAK7B,eAmSvB,SAASiE,EAAoB1D,EAA8BC,GACzD,MAAMwD,EAAQ,GACd,MAAMqB,EAAkB7E,EAAQ8E,KAAKC,GAAa,YAAYA,MAC9DhF,EAAGiF,iBAAiBH,EAAgBjE,KAAK,MAAMqE,SAASlB,IACtD,GAAIpD,EAAYoD,GAAOP,EAAM0B,KAAKnB,EAAK,IAEzC,OAAOP,CACT,CAEA,SAASzC,EAAkBoE,EAAoBC,GAC7C,IAAIC,EAAoBF,EACxB,MAAOE,EAAM,CACX,GAAIA,EAAKC,SAASF,GAAQ,CACxB,OAAOC,C,CAETA,EAAOA,EAAK7D,a,CAEd,OAAO,IACT,Q"}