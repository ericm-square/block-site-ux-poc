{"version":3,"names":["getAriaAttributes","el","getAttributeNames","filter","attr","startsWith","reduce","acc","value","getAttribute","observeAriaAttributes","onMutationObserved","mutationObserver","MutationObserver","ariaAttributes","observe","attributes","getTextInputAriaLabel","inputEl","slottedLabel","querySelector","_a","getRootNode","host","innerHTML","undefined","getControlInputAriaLabel","controlEl","attrIsValid","trim","controlAriaLabel","ariaLabelledBy","labelledByText","document","getElementById","textContent","ariaLabel","applyExpandableAriaControls","expanded","popoverId","setAttribute"],"sources":["src/utils/aria.ts"],"sourcesContent":["export type AriaAttributes = { [key: string]: string };\n\nconst getAriaAttributes = (el: HTMLElement): AriaAttributes => {\n  // create an object with all aria-* attributes on host element\n  return el\n    .getAttributeNames()\n    .filter((attr) => attr.startsWith('aria-'))\n    .reduce((acc, attr) => {\n      const value = el.getAttribute(attr);\n      if (value !== null) acc[attr] = value;\n      return acc;\n    }, {});\n};\n\n/**\n * Watch for aria attribute changes on host element.\n */\nexport const observeAriaAttributes = (\n  el: HTMLElement,\n  onMutationObserved: (ariaAttributes: AriaAttributes) => void,\n): MutationObserver => {\n  const mutationObserver = new MutationObserver(() => {\n    const ariaAttributes = getAriaAttributes(el);\n    return onMutationObserved(ariaAttributes);\n  });\n\n  mutationObserver.observe(el, { attributes: true });\n\n  return mutationObserver;\n};\n\n/**\n * ARIA LABELS\n *\n * It's currently not possible to make label/input associations across the\n * shadow DOM boundary. These helpers are intended to act as a lightweight a11y\n * solution by allowing our input and control components to set their own\n * aria-label attributes based on what is being used to label them.\n *\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n * https://nolanlawson.com/2022/11/28/shadow-dom-and-accessibility-the-trouble-with-aria\n * https://github.com/whatwg/html/issues/3219\n */\n\n/**\n * Returns the the aria-label attribute to set on text input components:\n *   <market-input-text>\n *   <market-select>\n *   <market-textarea>\n *   <market-input-password> (via its internal market-input-text)\n *\n * These components expect a <label> element in the default slot to use as the\n * floating input label. Falls back to the component's `name` attribute if no\n * label can be found.\n *\n * @param inputEl The input element that needs an aria-label\n */\nexport const getTextInputAriaLabel = (inputEl: HTMLElement): string => {\n  const slottedLabel =\n    // label slotted directly into input component\n    inputEl.querySelector('label:not([slot])') ||\n    // label slotted into a higher-level component (market-input-password)\n    (inputEl.getRootNode() as ShadowRoot).host?.querySelector('label:not([slot])');\n  return slottedLabel?.innerHTML || inputEl.getAttribute('name') || undefined;\n};\n\n/**\n * Returns the aria-label attribute to set on control components:\n *   <market-checkbox>\n *   <market-radio>\n *   <market-toggle>\n *\n * When used as a slotted control in <market-row>, the row handles setting the\n * aria-label of the control to match its own slotted label element. Otherwise,\n * if a consumer sets the aria-labelledby or aria-label attribute on the Market\n * component, the correct label text will be reflected in the shadow DOM.\n *\n * Adapted from Ionic Framework's getAriaLabel() helper:\n * https://github.com/ionic-team/ionic-framework/blob/main/core/src/utils/helpers.ts#L275-L332\n *\n * @param controlEl The control element that needs an aria-label\n */\n\nexport const getControlInputAriaLabel = (controlEl: HTMLElement): string => {\n  const attrIsValid = (attr: string) => attr !== null && attr.trim() !== '';\n  let controlAriaLabel: string;\n\n  // aria-labelledby takes precedence\n  const ariaLabelledBy = controlEl.getAttribute('aria-labelledby');\n  if (attrIsValid(ariaLabelledBy)) {\n    const labelledByText = document.getElementById(ariaLabelledBy)?.textContent;\n    controlAriaLabel = controlAriaLabel || labelledByText;\n  }\n\n  // aria-label\n  const ariaLabel = controlEl.getAttribute('aria-label');\n  if (attrIsValid(ariaLabel)) {\n    controlAriaLabel = controlAriaLabel || ariaLabel;\n  }\n\n  return controlAriaLabel || controlEl.getAttribute('name') || undefined;\n};\n\nexport const applyExpandableAriaControls = (\n  controlEl: HTMLElement,\n  { expanded, popoverId }: { expanded: string; popoverId: string },\n): void => {\n  // Screen reader announces the expanded state of the control on focus\n  controlEl.setAttribute('aria-expanded', expanded);\n  // Connect control to the popover content\n  controlEl.setAttribute('aria-controls', popoverId);\n};\n"],"mappings":"AAEA,MAAMA,EAAqBC,GAElBA,EACJC,oBACAC,QAAQC,GAASA,EAAKC,WAAW,WACjCC,QAAO,CAACC,EAAKH,KACZ,MAAMI,EAAQP,EAAGQ,aAAaL,GAC9B,GAAII,IAAU,KAAMD,EAAIH,GAAQI,EAChC,OAAOD,CAAG,GACT,I,MAMMG,EAAwB,CACnCT,EACAU,KAEA,MAAMC,EAAmB,IAAIC,kBAAiB,KAC5C,MAAMC,EAAiBd,EAAkBC,GACzC,OAAOU,EAAmBG,EAAe,IAG3CF,EAAiBG,QAAQd,EAAI,CAAEe,WAAY,OAE3C,OAAOJ,CAAgB,E,MA6BZK,EAAyBC,I,MACpC,MAAMC,EAEJD,EAAQE,cAAc,wBAEtBC,EAACH,EAAQI,cAA6BC,QAAI,MAAAF,SAAA,SAAAA,EAAED,cAAc,sBAC5D,OAAOD,IAAY,MAAZA,SAAY,SAAZA,EAAcK,YAAaN,EAAQT,aAAa,SAAWgB,SAAS,E,MAoBhEC,EAA4BC,I,MACvC,MAAMC,EAAexB,GAAiBA,IAAS,MAAQA,EAAKyB,SAAW,GACvE,IAAIC,EAGJ,MAAMC,EAAiBJ,EAAUlB,aAAa,mBAC9C,GAAImB,EAAYG,GAAiB,CAC/B,MAAMC,GAAiBX,EAAAY,SAASC,eAAeH,MAAe,MAAAV,SAAA,SAAAA,EAAEc,YAChEL,EAAmBA,GAAoBE,C,CAIzC,MAAMI,EAAYT,EAAUlB,aAAa,cACzC,GAAImB,EAAYQ,GAAY,CAC1BN,EAAmBA,GAAoBM,C,CAGzC,OAAON,GAAoBH,EAAUlB,aAAa,SAAWgB,SAAS,E,MAG3DY,EAA8B,CACzCV,GACEW,WAAUC,gBAGZZ,EAAUa,aAAa,gBAAiBF,GAExCX,EAAUa,aAAa,gBAAiBD,EAAU,S"}