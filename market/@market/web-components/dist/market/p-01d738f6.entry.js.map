{"version":3,"names":["marketTextareaCss","MarketTextareaStyle0","MarketTextarea","this","onMutationObserved","ariaAttributes","TEXTAREA_MAXIMUM_HEIGHT","handleMarketDialogLoaded","autofocus","setFocus","registerSlottedTextarea","slottedTextarea","el","querySelector","_a","getRootNode","host","addEventListener","e","textareaValueDidChange","focused","Promise","resolve","syncSharedPropsToSlottedTextarea","prevSharedProps","modifiedPropKeys","Set","Object","keys","sharedProps","forEach","key","removeAttribute","attributeValue","setAttribute","updateSharedPropsAndSyncSlottedTextarea","assign","name","placeholder","maxlength","undefined","Number","parseInt","value","readonly","disabled","inputmode","getTextInputAriaLabel","componentWillLoad","mutationObserver","observeAriaAttributes","componentDidLoad","maxHeight","style","componentWillUpdate","target","marketTextareaValueChange","emit","originalEvent","shouldSetElementFocus","focus","_e","_d","_c","_b","shadowRoot","call","render","h","Host","class","onBlur","onClick","onFocus","part","onSlotchange","id","onInput","disconnectedCallback","disconnect"],"sources":["src/components/market-textarea/market-textarea.css?tag=market-textarea&encapsulation=shadow","src/components/market-textarea/market-textarea.tsx"],"sourcesContent":["@import \"../../styles/mixins/component-base.css\";\n@import \"../../styles/mixins/field.css\";\n@import \"../../styles/mixins/field-states.css\";\n@import \"../../styles/mixins/floating-input.css\";\n\n:host {\n  --textarea-height: 120px;\n  --textarea-minimum-height: 120px;\n  --textarea-label-bottom-padding: 16px;\n\n  @extend %field;\n  @extend %field-states;\n  @extend %floating-input;\n\n  flex-direction: column;\n  overflow: hidden;\n  min-height: var(--textarea-minimum-height);\n  max-height: var(--textarea-maximum-height);\n  resize: vertical;\n\n  .label-input-container,\n  &([value='']:not([focused]):not([autofilled])) .label-input-container {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    padding-bottom: var(--textarea-label-bottom-padding);\n    font-weight: var(--textarea-font-weight);\n    font-size: var(--textarea-font-size);\n    line-height: var(--textarea-font-leading);\n    letter-spacing: var(--textarea-font-tracking);\n  }\n\n  /* Override `:host([disabled]) *` style in component-base mixin */\n  &([disabled]) textarea,\n  &([disabled]) ::slotted(textarea) {\n    pointer-events: auto !important; /* stylelint-disable-line declaration-no-important */\n  }\n}\n\ntextarea,\n::slotted(textarea) {\n  flex-grow: 1;\n  resize: none;\n}\n","import { TEXTAREA_MAXIMUM_HEIGHT } from '@market/market-theme/js/cjs/index.js';\nimport { Component, Host, h, Element, Prop, Event, EventEmitter, Listen, State, Method } from '@stencil/core';\n\nimport { getTextInputAriaLabel, observeAriaAttributes, AriaAttributes } from '../../utils/aria';\n\n/**\n * @slot - The main label for the textarea.\n * @slot textarea - Can be used to slot your own custom textarea element.\n * @part container - The containing div for the textarea and label.\n */\n@Component({\n  tag: 'market-textarea',\n  styleUrl: 'market-textarea.css',\n  shadow: true,\n})\nexport class MarketTextarea {\n  private slottedTextarea?: HTMLTextAreaElement;\n\n  @Element() el: HTMLMarketTextareaElement;\n\n  /**\n   * A string specifying the placeholder of the textarea.\n   * This is shown before a user attempts to add a value, given no value is already provided.\n   */\n  @Prop() readonly placeholder: string;\n\n  /**\n   * A string specifying a name for the textarea.\n   */\n  @Prop() readonly name: string;\n\n  /**\n   * A string specifying a value for the textarea. This will be visually shown on the textarea and can be edited by the user.\n   */\n  @Prop({ mutable: true, reflect: true }) value: string = '';\n\n  /**\n   * A string specifying the maximum length of characters for the input value.\n   */\n  @Prop() readonly maxlength: string;\n\n  /**\n   * A boolean representing whether the textarea is readonly or not.\n   */\n  @Prop({ reflect: true }) readonly readonly: boolean = false;\n\n  /**\n   * A boolean representing whether the textarea is disabled or not.\n   * This visually and functionally will disable the textarea.\n   */\n  @Prop({ reflect: true }) readonly disabled: boolean = false;\n\n  /**\n   * A boolean representing whether the textarea is focused or not.\n   */\n  @Prop({ mutable: true, reflect: true }) focused: boolean = false;\n\n  /**\n   * A boolean representing whether the textarea is invalid or not.\n   * This represents error states.\n   */\n  @Prop({ reflect: true }) readonly invalid: boolean = false;\n\n  /**\n   * A string specifying the maximum height in pixels for the textarea. Vertical resizing will be limited to this height. Example value: '200px'.\n   *\n   * **DEPRECATED**: set `max-height` via CSS\n   *\n   * @default '320px'\n   */\n  @Prop() readonly maxHeight: string = `${TEXTAREA_MAXIMUM_HEIGHT}px`;\n\n  /**\n   * A boolean representing whether the input should focus on page load.\n   * If multiple elements with `autofocus` are present, it is not guaranteed which one\n   * will ultimately receive the focus. It is advised that only one at most is present.\n   */\n  @Prop() readonly autofocus: boolean = false;\n\n  /**\n   * Allows a browser to display an appropriate virtual keyboard.\n   * [Accepted values](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inputmode).\n   */\n  @Prop() readonly inputmode: string;\n\n  /**\n   * Fired whenever the value of the textarea changes.\n   */\n  @Event() marketTextareaValueChange: EventEmitter<{ value: string; originalEvent: KeyboardEvent }>;\n\n  @State() ariaAttributes: AriaAttributes;\n\n  mutationObserver: MutationObserver;\n\n  sharedProps: {};\n\n  @Listen('marketDialogLoaded', { target: 'window' })\n  handleMarketDialogLoaded() {\n    if (this.autofocus) {\n      this.setFocus();\n    }\n  }\n\n  /**\n   * Allows passing an alternative light DOM textarea.\n   * Sets the this.slottedTextarea value to undefined if there is no slotted element.\n   */\n  @Method()\n  registerSlottedTextarea(slottedTextarea?: HTMLTextAreaElement) {\n    this.slottedTextarea =\n      slottedTextarea ||\n      // textarea slotted into market-textarea\n      this.el.querySelector('textarea[slot=textarea]') ||\n      // textarea slotted into a higher-level component that uses market-textarea\n      (this.el.getRootNode() as ShadowRoot).host?.querySelector('textarea[slot=textarea]');\n    if (this.slottedTextarea) {\n      this.slottedTextarea.addEventListener('input', (e) => this.textareaValueDidChange(e));\n      this.slottedTextarea.addEventListener('focus', () => this.setFocus());\n      this.slottedTextarea.addEventListener('blur', () => (this.focused = false));\n    }\n\n    return Promise.resolve();\n  }\n\n  syncSharedPropsToSlottedTextarea(prevSharedProps) {\n    // sync component props to slotted input, if one exists\n    if (this.slottedTextarea) {\n      const modifiedPropKeys = [...new Set([...Object.keys(prevSharedProps), ...Object.keys(this.sharedProps)])];\n      modifiedPropKeys.forEach((key) => {\n        if (!(key in this.sharedProps)) {\n          // remove properties that have been unset\n          this.slottedTextarea.removeAttribute(key);\n        } else {\n          // boolean attributes can be set using empty strings\n          // https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#javascript\n          const attributeValue = this.sharedProps[key] !== true ? this.sharedProps[key] : '';\n          this.slottedTextarea.setAttribute(key, attributeValue);\n        }\n      });\n    }\n  }\n\n  updateSharedPropsAndSyncSlottedTextarea() {\n    const prevSharedProps = { ...this.sharedProps };\n\n    // used by the default shadow DOM native input and to copy component properties to slotted inputs\n    // conditionally adding key/value pairs based on whether we want to set them on the <input>\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#individual_attributes\n    this.sharedProps = {\n      ...(this.name && { name: this.name }),\n      ...(this.placeholder && { placeholder: this.placeholder }),\n      ...(this.maxlength !== undefined && Number.parseInt(this.maxlength, 10) >= 0 && { maxlength: this.maxlength }),\n      ...(this.value !== undefined && { value: this.value }),\n      ...(this.readonly && { readonly: this.readonly }),\n      ...(this.disabled && { disabled: this.disabled }),\n      ...(this.autofocus && { autofocus: this.autofocus }),\n      ...(this.inputmode && { inputmode: this.inputmode }),\n      ...this.ariaAttributes,\n      'aria-label': getTextInputAriaLabel(this.el),\n    };\n\n    this.syncSharedPropsToSlottedTextarea(prevSharedProps);\n  }\n\n  onMutationObserved = (ariaAttributes: AriaAttributes) => {\n    this.ariaAttributes = ariaAttributes;\n  };\n\n  componentWillLoad() {\n    this.mutationObserver = observeAriaAttributes(this.el, this.onMutationObserved);\n    this.registerSlottedTextarea();\n    this.updateSharedPropsAndSyncSlottedTextarea();\n  }\n\n  componentDidLoad() {\n    if (this.maxHeight) {\n      // Set the passed max height on the input container, since that's where\n      // the drag handle will actually be visible.\n      // This will be removed until `maxHeight` prop is fully deprecated.\n      this.el.style.maxHeight = this.maxHeight;\n    }\n  }\n\n  componentWillUpdate() {\n    this.updateSharedPropsAndSyncSlottedTextarea();\n  }\n\n  textareaValueDidChange(e) {\n    // Need to update value for the label, which floats if this value exists.\n    this.value = e.target.value;\n\n    this.marketTextareaValueChange.emit({\n      value: e.target.value,\n      originalEvent: e,\n    });\n  }\n\n  setFocus(value: boolean = true) {\n    if (this.readonly || this.disabled) {\n      return;\n    }\n\n    const shouldSetElementFocus = value && !this.focused;\n\n    this.focused = value;\n\n    // Set focus on element if not already focused\n    if (shouldSetElementFocus) {\n      this.slottedTextarea ? this.slottedTextarea.focus() : this.el?.shadowRoot?.querySelector?.('textarea')?.focus?.();\n    }\n  }\n\n  render() {\n    return (\n      <Host\n        class=\"market-textarea\"\n        onBlur={() => {\n          this.focused = false;\n        }}\n        onClick={() => {\n          this.setFocus();\n        }}\n        onFocus={() => {\n          this.setFocus();\n        }}\n      >\n        <div class=\"label-input-container\" part=\"container\">\n          <slot></slot>\n          <slot name=\"textarea\" onSlotchange={() => this.registerSlottedTextarea()}>\n            {!this.slottedTextarea && (\n              <textarea\n                {...this.ariaAttributes}\n                id={this.name}\n                onInput={(e) => this.textareaValueDidChange(e)}\n                {...this.sharedProps}\n              ></textarea>\n            )}\n          </slot>\n        </div>\n      </Host>\n    );\n  }\n\n  disconnectedCallback() {\n    this.mutationObserver?.disconnect();\n  }\n}\n"],"mappings":"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"}