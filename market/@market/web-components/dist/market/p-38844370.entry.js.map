{"version":3,"names":["baseRest","func","start","setToString","overRest","identity","FUNC_ERROR_TEXT","baseDelay","wait","args","TypeError","setTimeout","apply","undefined","delay","toNumber","delay$1","compressDefaults","threshold","linearRatio","quadraticRatio","invert","compress","input","options","Object","assign","inverter","inputDelta","outputDelta","lerp","a","b","alpha","getDelta","startCoords","endCoords","x","y","magnitude","delta","marketSheetCss","MarketSheetStyle0","TOP_GAP","MODAL_SHEET_HANDLE_HEIGHT","MODAL_SHEET_HANDLE_PADDING_BOTTOM_SIZE","MODAL_SHEET_HANDLE_PADDING_TOP_SIZE","SWIPE_DISTANCE","SWIPE_WINDOW","TAP_DISABLE_DISTANCE","MIN_DRAG_COMPRESSION_RATIO","MAX_DRAG_COMPRESSION_RATIO","RESIZE_DEBOUNCE_DURATION","MarketSheet","this","type","boundOnDragMove","onDragMove","bind","boundOnDragEnd","onDragEnd","boundOnScrollDrag","onScrollDrag","CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION","CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION","activateFocusTrap","activateOptions","focusTrap","activate","disableFocus","createAndActivateFocusTrap","el","initialFocus","focusTrapActivateOptions","deactivateFocusTrap","deactivateOptions","deactivate","dismiss","defaultPrevented","marketDialogDismissed","emit","dialog","origin","hidden","Promise","resolve","marketDialogDidDismiss","setState","state","targetState","openMode","setAttribute","resetTopByState","calculateTopBoundary","getAttribute","clientHeight","style","removeProperty","window","innerHeight","top","visualViewport","offsetTop","paddingBottom","topBoundary","compressionRatio","setTop","newTop","onDragStart","e","isTouchEvent","button","target","document","activeElement","blur","click","getBoundingClientRect","dragStartTop","eventCoords","getCoordsFromEvent","dragEventStack","timeStamp","touchStartCoords","dragDelta","addEventListener","hasAttribute","push","pruneStack","finalTop","naturalTop","halfwayBreakpoint","bottomDropBreakpoint","topDropBreakpoint","minSwipeDistance","gestureDelta","getGestureDelta","cleanupDragging","onScrollStart","scrollStart","mainContent","scrollTop","passive","maxScroll","scrollHeight","dragCoords","scrollDelta","scrollTarget","stopImmediatePropagation","removeEventListener","length","shift","currentTop","pop","previousTop","updateDelta","Math","abs","removeAttribute","onKeyDown","key","preventDefault","connectedCallback","marketDialogLoaded","hiddenHandler","componentDidLoad","heightObserver","ResizeObserver","throttle","observe","prevOffsetTop","_a","relatedTarget","currOffsetTop","_b","scrollIntoView","behavior","block","inline","disconnectedCallback","disconnect","render","h","Host","role","onMouseDown","onTouchStart","closeHandleAriaLabel","class","onClick","name","ref"],"sources":["../../node_modules/lodash-es/_baseRest.js","../../node_modules/lodash-es/_baseDelay.js","../../node_modules/lodash-es/delay.js","src/utils/math/utils.ts","src/components/market-sheet/market-sheet.css?tag=market-sheet&encapsulation=shadow","src/components/market-sheet/market-sheet.tsx"],"sourcesContent":["import identity from './identity.js';\nimport overRest from './_overRest.js';\nimport setToString from './_setToString.js';\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nexport default baseRest;\n","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * The base implementation of `_.delay` and `_.defer` which accepts `args`\n * to provide to `func`.\n *\n * @private\n * @param {Function} func The function to delay.\n * @param {number} wait The number of milliseconds to delay invocation.\n * @param {Array} args The arguments to provide to `func`.\n * @returns {number|Object} Returns the timer id or timeout object.\n */\nfunction baseDelay(func, wait, args) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return setTimeout(function() { func.apply(undefined, args); }, wait);\n}\n\nexport default baseDelay;\n","import baseDelay from './_baseDelay.js';\nimport baseRest from './_baseRest.js';\nimport toNumber from './toNumber.js';\n\n/**\n * Invokes `func` after `wait` milliseconds. Any additional arguments are\n * provided to `func` when it's invoked.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to delay.\n * @param {number} wait The number of milliseconds to delay invocation.\n * @param {...*} [args] The arguments to invoke `func` with.\n * @returns {number} Returns the timer id.\n * @example\n *\n * _.delay(function(text) {\n *   console.log(text);\n * }, 1000, 'later');\n * // => Logs 'later' after one second.\n */\nvar delay = baseRest(function(func, wait, args) {\n  return baseDelay(func, toNumber(wait) || 0, args);\n});\n\nexport default delay;\n","import { Vec2 } from './types';\n\ntype CompressOptions = { threshold?: number; linearRatio?: number; quadraticRatio?: number; invert?: boolean };\nconst compressDefaults: CompressOptions = { threshold: 0, linearRatio: 1, quadraticRatio: 1, invert: false };\n\n/**\n * Compress a given input value as it exceeds a given threshhold.\n * Both quadratic and linear compression is supported.\n * the output grows by an increasingly diminishing amount.\n * @param {number} input - The value to be compressed.\n * @param {CompressOptions} options - Override defaults for the compression.\n * @param {number} options.threshhold - The value where compression starts. Input values that exceed the threshhold will be compressed. Default of 0.\n * @param {number} options.linearRatio - (0-1) The ratio to which the input exceeding the threshhold will be reduced. 0.33 creates a ~3-to-1 compression. Default of 1 (no compression).\n * @param {number} options.quadraticRatio - (0-1) The ratio of quadratic compression to which the input exceeding the threshhold will be reduced. 0.33 creates a ~cube-root compression. Default of 1 (no compression).\n * @param {boolean} options.invert - If true, the compression instead comrpesses values below the threshhold.\n */\nexport function compress(input: number, options: CompressOptions = {}) {\n  const { quadraticRatio, linearRatio, threshold, invert } = Object.assign({}, compressDefaults, options);\n  const inverter = invert ? -1 : 1;\n  if (input * inverter < threshold * inverter) {\n    return input;\n  }\n  const inputDelta = (input - threshold) * inverter;\n  // note we offset by 1 to avoid values 0-1 being adjusted in the opposite direction when exponentialized.\n  // this means that a provided quadratic ration of 0.5 does not result in a perfect square root.\n  let outputDelta = (inputDelta + 1) ** quadraticRatio - 1;\n  outputDelta = outputDelta * linearRatio;\n  return threshold + outputDelta * inverter;\n}\n\ntype LimitOptions = { threshold?: number; maximum?: number; invert?: boolean };\nconst limitDefaults: LimitOptions = { threshold: 0, maximum: 1, invert: false };\n\n/**\n * Limit a given input value as it exceeds a threshhold to stay below given maximum.\n * @param {number} input - The value to be limited.\n */\nexport function limit(input: number, options: LimitOptions = {}) {\n  const { threshold, maximum, invert } = Object.assign({}, limitDefaults, options);\n  const inverter = invert ? -1 : 1;\n  if (input * inverter < threshold * inverter) {\n    return input;\n  }\n  const inputDelta = (input - threshold) * inverter;\n  const maxDelta = (maximum - threshold) * inverter;\n  const outputDelta = (inputDelta * maxDelta) / (inputDelta + maxDelta);\n  return threshold + outputDelta * inverter;\n}\n\nexport function lerp(a: number, b: number, alpha: number) {\n  return a + alpha * (b - a);\n}\n\nexport function lerp2(a: Vec2, b: Vec2, alpha: number) {\n  return {\n    x: lerp(a.x, b.x, alpha),\n    y: lerp(a.y, b.y, alpha),\n  };\n}\n\nexport function getDelta(startCoords: Vec2, endCoords: Vec2): Vec2 {\n  return {\n    x: endCoords.x - startCoords.x,\n    y: endCoords.y - startCoords.y,\n  };\n}\n\nexport function magnitude(delta: Vec2) {\n  return (delta.x ** 2 + delta.y ** 2) ** 0.5;\n}\n","@import \"../../styles/mixins/modals.css\";\n\n:host {\n  --handle-whitespace: calc(var(--modal-sheet-handle-padding-top-size) + var(--modal-sheet-handle-padding-bottom-size));\n  --handle-area-height: calc(var(--handle-whitespace) + var(--modal-sheet-handle-height));\n  --max-width-padding: var(--modal-sheet-regular-horizontal-size-class-horizontal-padding);\n  --min-width-padding: var(--modal-sheet-compact-horizontal-size-class-horizontal-padding);\n\n  /* todo: replace 200px half-width with design token */\n  --padding-width: clamp(var(--min-width-padding), calc(50% - 200px), var(--max-width-padding));\n  --padding-height: var(--modal-sheet-regular-vertical-size-class-vertical-padding);\n\n  @extend %modal;\n\n  position: fixed;\n\n  /* start just off screen when added to the dom */\n  top: calc(100vh + var(--handle-area-height));\n  bottom: auto;\n  left: 50%;\n  overflow: visible;\n  box-sizing: border-box;\n  width: 100%;\n\n  /* todo: replace 400px width with design token */\n  max-width: calc(400px + calc(var(--max-width-padding) + var(--max-width-padding)));\n  max-height: calc(100% - var(--handle-area-height));\n  padding-top: var(--padding-height);\n  border-radius: var(--modal-sheet-border-radius) var(--modal-sheet-border-radius) 0 0;\n  background-color: var(--modal-sheet-background-color);\n  opacity: 0%;\n  user-select: none;\n  transition:\n    top var(--core-animation-enter-transition-moderate-speed-duration),\n    opacity var(--core-animation-enter-transition-moderate-speed-duration);\n  transform: translate(-50%, 0);\n\n  &([state=\"closed\"]) {\n    top: calc(100vh + var(--handle-area-height));\n    opacity: 0%;\n    transition:\n      top var(--core-animation-exit-transition-moderate-speed-duration),\n      opacity var(--core-animation-exit-transition-moderate-speed-duration);\n  }\n\n  &([state=\"partial-open\"]) {\n    opacity: 100%;\n  }\n\n  &([state=\"full-open\"]) {\n    opacity: 100%;\n  }\n\n  &([dragging]) {\n    transition: opacity var(--core-animation-enter-transition-moderate-speed-duration);\n  }\n\n  &([tapdisabled]) {\n    pointer-events: none;\n  }\n\n  ::slotted([slot=\"header\"]) {\n    padding-right: var(--padding-width);\n    padding-left: var(--padding-width);\n  }\n\n  /*\n    this visually extends the sheet below the screen to avoid a gap\n    when the sheet is dragged upwards.\n  */\n  &::after {\n    content: \"\";\n    position: absolute;\n    top: 100%;\n    display: block;\n    width: inherit;\n    max-width: inherit;\n    height: 100vh;\n    background-color: inherit;\n  }\n}\n\n.handle {\n  position: fixed;\n  bottom: calc(100% + var(--modal-sheet-handle-padding-bottom-size));\n  left: 50%;\n  display: block;\n  width: var(--modal-sheet-handle-width);\n  height: var(--modal-sheet-handle-height);\n  border: none;\n  border-radius: var(--modal-sheet-border-radius);\n  background-color: var(--modal-sheet-handle-background-color);\n  user-select: none;\n  transform: translate(-50%, 0);\n\n  &::before {\n    content: \"\";\n    position: absolute;\n    inset: calc(var(--modal-sheet-handle-padding-bottom-size) * -1);\n  }\n\n  &:focus {\n    outline: var(--button-focus-ring-border-size) solid var(--button-focus-ring-color);\n  }\n}\n\n.main {\n  overflow-x: hidden;\n  overflow-y: auto;\n  padding-right: var(--padding-width);\n  padding-bottom: var(--padding-height);\n  padding-left: var(--padding-width);\n  overscroll-behavior: contain;\n}\n\n.main[dragging] {\n  overflow-y: hidden;\n}\n","import {\n  CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION,\n  CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION,\n  MODAL_SHEET_HANDLE_HEIGHT,\n  MODAL_SHEET_HANDLE_PADDING_BOTTOM_SIZE,\n  MODAL_SHEET_HANDLE_PADDING_TOP_SIZE,\n} from '@market/market-theme/js/cjs/index.js';\nimport { Component, Element, Event, EventEmitter, Host, Method, Prop, Watch, h } from '@stencil/core';\nimport { delay, throttle } from 'lodash-es';\n\nimport { TMarketDragCoords, TMouseOrTouchEvent } from '../../utils/gesture/types';\nimport { getCoordsFromEvent, isTouchEvent } from '../../utils/gesture/utils';\nimport { compress, getDelta, lerp, magnitude } from '../../utils/math/utils';\nimport { DialogDismissedEvent, DialogLoadedEvent, DialogType } from '../../utils/dialog';\nimport {\n  FocusTrap,\n  FocusTrapActivateOptions,\n  FocusTrapDeactivateOptions,\n  FocusTrapOptions,\n  createAndActivateFocusTrap,\n} from '../../utils/focus-trap';\n\nconst TOP_GAP =\n  MODAL_SHEET_HANDLE_HEIGHT + MODAL_SHEET_HANDLE_PADDING_BOTTOM_SIZE + MODAL_SHEET_HANDLE_PADDING_TOP_SIZE;\nconst SWIPE_DISTANCE = 0.12; // ratio of screen height before drag registers as a gesture\nconst SWIPE_WINDOW = 250; // time in milliseconds to consider for gesture recognition\nconst TAP_DISABLE_DISTANCE = 0.01; // ratio of screen height before drag disables tapping child elements\nconst MIN_DRAG_COMPRESSION_RATIO = 0.8; // (0-1) how much the sheet allows itself to be dragged past its natural boundaries\nconst MAX_DRAG_COMPRESSION_RATIO = 0.55; // (0-1) how much the sheet allows itself to be dragged past its natural boundaries\n\nconst RESIZE_DEBOUNCE_DURATION = 16; // 60fps\n\ntype SheetState = 'closed' | 'partial-open' | 'full-open';\n\n@Component({\n  tag: 'market-sheet',\n  styleUrl: 'market-sheet.css',\n  shadow: true,\n})\nexport class MarketSheet {\n  @Element() el: HTMLMarketSheetElement;\n  mainContent: HTMLElement;\n  type: DialogType = 'sheet';\n  focusTrap: FocusTrap;\n  focusTrapActivateOptions: FocusTrapActivateOptions; // remember options when we reactivate later\n  topBoundary: number;\n  compressionRatio: number;\n\n  dragEventStack: [number, number][];\n  touchStartCoords: TMarketDragCoords;\n  dragDelta: TMarketDragCoords;\n  dragStartTop: number;\n  scrollStart: number;\n  heightObserver: ResizeObserver;\n\n  // These bound func refs are so we can remove them later\n  boundOnDragMove = this.onDragMove.bind(this);\n  boundOnDragEnd = this.onDragEnd.bind(this);\n  boundOnScrollDrag = this.onScrollDrag.bind(this);\n\n  /**\n   * @internal\n   *\n   * Used in CSS to trigger start and stop animations\n   */\n  @Prop({ mutable: true, reflect: true }) hidden: boolean = false;\n\n  /**\n   * @internal\n   *\n   * Used by the context manager to identify a specific dialog/modal\n   */\n  @Prop({ reflect: true, attribute: 'data-dialog-id' }) readonly dialogID: string;\n\n  /**\n   * Default state sheet opens to when opened from close\n   */\n  @Prop({ mutable: true }) openMode: 'full' | 'dynamic' | 'partial' = 'partial';\n\n  /**\n   * The duration for the modal enter animation, set from design tokens\n   */\n  @Prop() readonly animationEnterDuration: number = CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION;\n\n  /**\n   * The duration for the modal exit animation, set from design tokens\n   */\n  @Prop() readonly animationExitDuration: number = CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION;\n\n  /**\n   * Disable focus trapping on the modal\n   */\n  @Prop({ mutable: true }) disableFocus: boolean = false;\n\n  /**\n   * Translated string to label Close handle\n   */\n  @Prop() readonly closeHandleAriaLabel: string = 'Close';\n\n  /**\n   * Triggered when the sheet finishes loading\n   */\n  @Event() marketDialogLoaded: EventEmitter<DialogLoadedEvent>;\n\n  /**\n   * Triggered when the sheet is dismissed, handled by context manager\n   */\n  @Event() marketDialogDismissed: EventEmitter<DialogDismissedEvent>;\n\n  /**\n   * Triggered when the dialog is fully dismissed\n   */\n  @Event() marketDialogDidDismiss: EventEmitter<DialogDismissedEvent>;\n\n  /* eslint-disable @typescript-eslint/require-await */\n\n  /**\n   * Activates the focus trap\n   * @param {Object} [options] [focus-trap `.createFocusTrap` options](https://github.com/focus-trap/focus-trap#createoptions)\n   * @param {Object} [activateOptions] [focus-trap `.activate` options](https://github.com/focus-trap/focus-trap#trapactivate)\n   */\n  @Method()\n  async activateFocusTrap(options?: FocusTrapOptions, activateOptions?: FocusTrapActivateOptions) {\n    if (this.focusTrap) {\n      this.focusTrap.activate(activateOptions);\n      if (this.disableFocus) {\n        this.disableFocus = false;\n      }\n    } else {\n      this.focusTrap = createAndActivateFocusTrap({\n        activateOptions,\n        el: this.el,\n        options: { ...options, initialFocus: false },\n      });\n    }\n    this.focusTrapActivateOptions = activateOptions;\n  }\n\n  /**\n   * Deactivates the focus trap\n   * @param {Object} [deactivateOptions] [focus-trap `.deactivate` options](https://github.com/focus-trap/focus-trap#trapdeactivate)\n   */\n  @Method()\n  async deactivateFocusTrap(deactivateOptions?: FocusTrapDeactivateOptions) {\n    if (this.focusTrap) {\n      this.focusTrap.deactivate(deactivateOptions);\n      this.focusTrap = undefined;\n    }\n  }\n\n  /**\n   * Emits the dismiss event\n   * The parent context will handle actually removing elements from the DOM,\n   * All the sheet needs to do it emit an event so actually closing it can be\n   * some other elements problem\n   */\n  @Method()\n  async dismiss(options?) {\n    const { defaultPrevented } = this.marketDialogDismissed.emit({\n      dialog: this.el,\n      type: this.type,\n      origin: options?.origin || this.el,\n    });\n\n    if (!defaultPrevented) {\n      this.hidden = true;\n\n      await new Promise((resolve) => setTimeout(resolve, CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION));\n      this.marketDialogDidDismiss.emit({\n        dialog: this.el,\n        type: this.type,\n        origin: this.el,\n      });\n    }\n  }\n\n  /* eslint-enable @typescript-eslint/require-await */\n\n  // Given a desired state, we update our actual state according to the open mode.\n  // e.g. \"fully opening\" a sheet in partial open mode will result in a partial-open state.\n  setState(state: SheetState) {\n    let targetState = state;\n    if (targetState !== 'closed' && this.openMode !== 'dynamic') {\n      // override open state according to open mode\n      targetState = `${this.openMode}-open`;\n    }\n    this.el.setAttribute('state', targetState);\n    this.resetTopByState();\n  }\n\n  // Calculate the `top` value for the sheet according to the state.\n  resetTopByState() {\n    this.calculateTopBoundary();\n\n    const state = this.el.getAttribute('state');\n    // For some incredibly arcane reason, if you do not read the clientHeight property\n    // then the second time a context manager opens the sheet it will not animate open correctly.\n    // So we set this variable to ensure that the clientHeight gets read regardless of state.\n    const clientHeight = this.el.clientHeight;\n\n    if (state === 'closed') {\n      this.el.style.removeProperty('top');\n    } else if (clientHeight + TOP_GAP >= window.innerHeight || state === 'full-open') {\n      // Stick to the top of the screen even if the window resizes.\n      this.el.style.top = `${TOP_GAP + window.visualViewport.offsetTop}px`;\n    } else {\n      // partial-open\n      // We essentially recreate `top: auto` here. This is necessary\n      // because `top: auto` breaks css transitions.\n      // It's important to use % rather than vh here so that the\n      // address bar is accounted for.\n      this.el.style.top = `calc(100% - ${clientHeight}px)`;\n    }\n\n    // when virtual keyboard is open, add padding to bottom of sheet to allow space for content to scroll\n    this.el.style.paddingBottom = window.visualViewport.offsetTop ? `${window.visualViewport.offsetTop}px` : '0';\n  }\n\n  // Calculate the highest top value allowed by the open mode.\n  // Dragging past this boundary will experience resitance.\n  // The closer the top boundary is to the top of the screen, the more resistance.\n  calculateTopBoundary() {\n    this.topBoundary = this.openMode === 'partial' ? window.innerHeight - this.el.clientHeight : TOP_GAP;\n    this.compressionRatio = lerp(\n      MAX_DRAG_COMPRESSION_RATIO,\n      MIN_DRAG_COMPRESSION_RATIO,\n      this.topBoundary / window.innerHeight,\n    );\n  }\n\n  setTop(top: number) {\n    // Add some 'springiness' that resists sheet being dragged past its topBoundary\n    // by compressing movement past that threshhold.\n    const newTop = compress(top, { threshold: this.topBoundary, quadraticRatio: this.compressionRatio, invert: true });\n\n    this.el.style.top = `${newTop}px`;\n    return newTop;\n  }\n\n  onDragStart(e: TMouseOrTouchEvent) {\n    // only start drag on touch events or left mouse clicks\n    if (!isTouchEvent(e) && e.button !== 0) {\n      return;\n    }\n\n    // special cases if virtual keyboard is open\n    if (window.visualViewport.offsetTop) {\n      // if clicking an already-focused element, do nothing\n      if (e.target === document.activeElement) {\n        return;\n      }\n      // blur currently-focused element (dismisses virtual keyboard)\n      (document.activeElement as HTMLElement).blur();\n      // click event target (element will get focus if focusable)\n      (e.target as HTMLElement).click();\n      return;\n    }\n\n    const { top } = this.el.getBoundingClientRect();\n    this.dragStartTop = top;\n\n    this.el.setAttribute('dragging', '');\n    this.calculateTopBoundary();\n    const newTop = this.setTop(top);\n\n    const eventCoords = getCoordsFromEvent(e);\n    this.dragEventStack = [[e.timeStamp, newTop]];\n    this.touchStartCoords = eventCoords;\n    this.dragDelta = { x: 0, y: 0 };\n\n    const { boundOnDragMove, boundOnDragEnd } = this;\n\n    document.addEventListener('mousemove', boundOnDragMove);\n    document.addEventListener('mouseup', boundOnDragEnd);\n    document.addEventListener('touchmove', boundOnDragMove);\n    document.addEventListener('touchend', boundOnDragEnd);\n  }\n\n  onDragMove(e: TMouseOrTouchEvent) {\n    const eventCoords = getCoordsFromEvent(e);\n\n    this.dragDelta = getDelta(this.touchStartCoords, eventCoords);\n    if (!this.el.hasAttribute('tapdisabled') && magnitude(this.dragDelta) / window.innerHeight > TAP_DISABLE_DISTANCE) {\n      this.el.setAttribute('tapdisabled', '');\n    }\n\n    const newTop = this.setTop(this.dragStartTop + this.dragDelta.y);\n    this.dragEventStack.push([e.timeStamp, newTop]);\n    this.pruneStack(e.timeStamp);\n  }\n\n  // When we end drag we need to calculate what gesture was performed and update the state accordingly.\n  // There are two categories of gesture: 'swipe' and 'drop'. If the gesture ends with movement that exceeds\n  // the SWIPE_DISTANCE within the SWIPE_WINDOW, then the gesture is a 'swipe', otherwise it is a 'drop.'\n  // A 'swipe' up always sets the sheet to its maximally open mode, while a swipe down closes it.\n  // A 'drop' sets the state according to where on the page the sheet was released (e.g) releasing the sheet\n  // near the bottom of the screen will close it.\n  onDragEnd(e: TMouseOrTouchEvent) {\n    const eventCoords = getCoordsFromEvent(e);\n\n    this.dragDelta = getDelta(this.touchStartCoords, eventCoords);\n\n    const finalTop = this.dragStartTop + this.dragDelta.y;\n    const newTop = this.setTop(finalTop);\n\n    // this differs from the 'topBoundary' for sheets in dynamic mode\n    const naturalTop = this.openMode === 'full' ? TOP_GAP : window.innerHeight - this.el.clientHeight;\n    const halfwayBreakpoint = window.innerHeight / 2;\n    const bottomDropBreakpoint = lerp(window.innerHeight, naturalTop, 0.6);\n    const topDropBreakpoint = lerp(TOP_GAP, naturalTop, 0.6);\n\n    const minSwipeDistance = SWIPE_DISTANCE * window.innerHeight;\n    this.dragEventStack.push([e.timeStamp, newTop]);\n    const gestureDelta = this.getGestureDelta(e, minSwipeDistance);\n\n    if (gestureDelta > minSwipeDistance) {\n      // we have finished the drag by swiping downward,\n      // so dismiss regardless of final position\n      this.dismiss();\n    } else if (gestureDelta < -minSwipeDistance) {\n      // we have finished the drag by swiping upward,\n      // so open the sheet regardless of final position\n      this.setState('full-open');\n    } else if (finalTop > halfwayBreakpoint && finalTop > bottomDropBreakpoint) {\n      // we have dragged down to within the bottom drop distance\n      this.dismiss();\n    } else if (finalTop < topDropBreakpoint) {\n      // we have dragged up to within the top drop distance\n      this.setState('full-open');\n    } else {\n      // we have dragged to a middle position\n      this.setState('partial-open');\n    }\n\n    this.cleanupDragging();\n  }\n\n  // When we start a touch within the scrollable part of the sheet we set up a listener\n  // to track this move.\n  onScrollStart() {\n    this.scrollStart = this.mainContent.scrollTop;\n\n    document.addEventListener('touchmove', this.boundOnScrollDrag, { passive: true });\n  }\n\n  // When we get our first touch move event (after touching within the scrollable area)\n  // we calculate whether this move will result in scrolling within the sheet. If so we disable\n  // the drag event handling for the rest of the touch move and let the browser handle scrolling.\n  // If the move won't result in scrolling (i.e. we've alreadry reached the end of the scrollable area)\n  // then instead we disable scrolling until the touch move completes, allowing the drag event\n  // handlers to operate as normal.\n  onScrollDrag(e: TouchEvent) {\n    const maxScroll = this.mainContent.scrollHeight - this.mainContent.clientHeight;\n    const dragCoords = getCoordsFromEvent(e);\n    const scrollDelta = getDelta(this.touchStartCoords, dragCoords);\n    const scrollTarget = this.scrollStart - scrollDelta.y;\n\n    const { boundOnScrollDrag, mainContent } = this;\n\n    // If the calculated scroll is within the scrollable area, scroll instead of dragging the sheet.\n    if (scrollTarget >= 0 && scrollTarget <= maxScroll) {\n      // We are scrolling, so we stop all of our drag handling and let the browser handle things from here\n      e.stopImmediatePropagation();\n      this.cleanupDragging();\n    } else {\n      // this disables scrolling on the scrollable area while the drag is in progress.\n      mainContent.setAttribute('dragging', '');\n    }\n\n    document.removeEventListener('touchmove', boundOnScrollDrag);\n  }\n\n  // Remove expired events from the gesutre tracking stack.\n  pruneStack(timeStamp: number) {\n    while (this.dragEventStack.length > 0 && this.dragEventStack[0][0] < timeStamp - SWIPE_WINDOW) {\n      this.dragEventStack.shift();\n    }\n  }\n\n  // 'Replay' events from our gesture tracking stack until we reach total movement\n  // that exceeds the minSwipeDistance threshhold (indicating a 'swipe' rather than a 'drop').\n  // This means the most recent movement will be considered first, and so if the gesture ends in a\n  // swipe this will be detected regardless of the total delta of the gesture.\n  // (e.g. the sheet is dragged downward before ending with a swipe up will register as a swipe up\n  // even if the released position of the sheet is below its starting position.\n  getGestureDelta(e: TMouseOrTouchEvent, minSwipeDistance: number) {\n    let gestureDelta = 0;\n    let currentTop = this.dragEventStack.pop()[1];\n\n    this.pruneStack(e.timeStamp);\n\n    while (this.dragEventStack.length > 0) {\n      const previousTop = this.dragEventStack.pop()[1];\n      const updateDelta = currentTop - previousTop;\n      gestureDelta += updateDelta;\n      currentTop = previousTop;\n      if (Math.abs(gestureDelta) > minSwipeDistance) break;\n    }\n    return gestureDelta;\n  }\n\n  cleanupDragging() {\n    const { boundOnDragMove, boundOnDragEnd, el, mainContent } = this;\n\n    el.removeAttribute('dragging');\n    mainContent.removeAttribute('dragging');\n    el.removeAttribute('tapdisabled');\n\n    document.removeEventListener('mousemove', boundOnDragMove);\n    document.removeEventListener('mouseup', boundOnDragEnd);\n    document.removeEventListener('touchmove', boundOnDragMove);\n    document.removeEventListener('touchend', boundOnDragEnd);\n  }\n\n  onKeyDown(e: KeyboardEvent) {\n    switch (e.key) {\n      case 'Enter':\n        this.dismiss();\n        break;\n      case ' ':\n        this.dismiss(e);\n        e.preventDefault(); // spacebar should not scroll page\n        break;\n      default:\n        break;\n    }\n  }\n\n  connectedCallback() {\n    /**\n     * Emit a dialogLoaded event when the component connects. Need this so\n     * the context manager isn't rummaging around it's DOM to try and find the\n     * dialog that was just appended\n     */\n    setTimeout(\n      () => {\n        this.marketDialogLoaded.emit({\n          dialog: this.el,\n          type: this.type,\n        });\n\n        if (!this.disableFocus) {\n          this.activateFocusTrap();\n        }\n      },\n      this.hidden ? 0 : CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION,\n    );\n  }\n\n  @Watch('hidden')\n  hiddenHandler() {\n    this.setState(this.hidden ? 'closed' : 'partial-open');\n  }\n\n  componentDidLoad() {\n    this.hiddenHandler();\n\n    // when element is resized\n    this.heightObserver = new ResizeObserver(\n      throttle(() => {\n        this.resetTopByState();\n      }, RESIZE_DEBOUNCE_DURATION),\n    );\n    this.heightObserver.observe(this.el);\n\n    // when visual viewport is resized (aka when virtual keyboard is opened or closed)\n    window.visualViewport.addEventListener(\n      'resize',\n      throttle(() => {\n        this.resetTopByState();\n      }, RESIZE_DEBOUNCE_DURATION),\n    );\n\n    // when child elements get focus (via click/touch event, keyboard, or browser form assistant)\n    this.mainContent.addEventListener('focusin', (e) => {\n      this.resetTopByState();\n\n      // wait for any related resetTopByState style changes to settle\n      delay(() => {\n        // if virtual keyboard is open (mobile only), programmatically scroll to focused input\n        if (window.visualViewport.offsetTop) {\n          const prevOffsetTop = (e.relatedTarget as HTMLElement)?.offsetTop;\n          const currOffsetTop = (document.activeElement as HTMLElement)?.offsetTop;\n\n          // scrollIntoView needs to use different block (vertical alignment) behavior depending on\n          // how the focus was set, otherwise mobile Safari Form Assistant can't reliably move\n          // between all inputs (clicking an input or moving to the previous input uses \"center\",\n          // moving to the next input uses \"start\")\n          document.activeElement.scrollIntoView({\n            behavior: 'smooth',\n            block: prevOffsetTop < currOffsetTop ? 'start' : 'center',\n            inline: 'start',\n          });\n        }\n      }, 250);\n    });\n  }\n\n  disconnectedCallback() {\n    this.heightObserver?.disconnect();\n  }\n\n  render() {\n    return (\n      <Host\n        role=\"dialog\"\n        onMouseDown={(e: MouseEvent) => this.onDragStart(e)}\n        onTouchStart={(e: TouchEvent) => this.onDragStart(e)}\n      >\n        <button\n          aria-label={this.closeHandleAriaLabel}\n          class=\"handle\"\n          onClick={this.dismiss.bind(this)}\n          onKeyDown={this.onKeyDown.bind(this)}\n        />\n        <slot name=\"header\" />\n        <div class=\"main\" ref={(el) => (this.mainContent = el)} onTouchStart={() => this.onScrollStart()}>\n          <slot />\n        </div>\n      </Host>\n    );\n  }\n}\n"],"mappings":"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"}