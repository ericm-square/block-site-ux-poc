{"version":3,"names":["marketColorPickerGradientCss","MarketColorPickerGradientStyle0","RESIZE_DEBOUNCE_DURATION","PRIMARY_ID","SECONDARY_ID","PRIMARY_COORDINATES","SECONDARY_COORDINATES","MarketColorPickerGradient","this","secondaryPointerCoordinates","boundOnDragMove","onDragMove","bind","boundOnDragEnd","onDragEnd","throttledUpdatePointerOnDrag","throttle","updatePointerOnDrag","onDragStart","e","pointer","preventDefault","stopPropagation","isTouchEvent","button","coords","getCoordsFromEvent","x","y","draggablePointer","document","addEventListener","passive","removeEventListener","posX","posY","elem","parentElement","rect","getBoundingClientRect","elemOffsetX","left","elemOffsetY","top","maxWidth","width","maxHeight","height","updatedX","updatedY","Math","max","min","setPointerCoordinates","options","emitEvent","colorType","pointerOffset","offsetWidth","style","id","setPrimaryGradientColor","setSecondaryGradientColor","primaryHue","primaryPointer","background","updateSecondaryGradient","saturation","value","colorValue","colorString","hsvToRgb","hsvToHex","join","secondaryPointer","marketColorPickerGradientValueChange","emit","gradient","el","shadowRoot","querySelector","updateGradientsByValue","convertedColor","parseToHSVA","values","h","s","v","primaryX","secondaryX","secondaryY","primaryOptions","secondaryOptions","setInitialPointers","pointers","pointerCoordinates","forEach","i","pointerOptions","componentDidLoad","success","render","Host","key","class","role","onMouseDown","onTouchStart"],"sources":["src/components/market-color-picker/subcomponents/market-color-picker-gradient/market-color-picker-gradient.css?tag=market-color-picker-gradient&encapsulation=shadow","src/components/market-color-picker/subcomponents/market-color-picker-gradient/market-color-picker-gradient.tsx"],"sourcesContent":["/* TODO: add design tokens to file */\n\n:host {\n  --primary-gradient-height: var(--color-picker-adjustments-hue-min-height);\n  --gradient-border-radius: var(--color-picker-adjustments-hue-radius);\n  --gradient-margin: var(--color-picker-vertical-spacing);\n  --secondary-gradient-height: calc(var(--color-picker-adjustments-saturation-brightness-min-height) * 1px);\n  --gradient-pointer-width: 12px;\n  --gradient-pointer-height: 12px;\n  --gradient-pointer-border: 2px white solid;\n  --gradient-pointer-border-radius: 50%;\n\n  display: block;\n}\n\n.primary-gradient {\n  position: relative;\n  width: 100%;\n  height: var(--primary-gradient-height);\n  border-radius: var(--gradient-border-radius);\n\n  /* Standardized gradient for selecting hues */\n  background:\n    linear-gradient(\n      to right,\n      hsl(0deg 100% 50%),\n      hsl(60deg 100% 50%),\n      hsl(120deg 100% 50%),\n      hsl(180deg 100% 50%),\n      hsl(240deg 100% 50%),\n      hsl(300deg 100% 50%),\n      hsl(0deg 100% 50%)\n    );\n}\n\n.secondary-gradient {\n  position: relative;\n  width: 100%;\n  height: var(--secondary-gradient-height);\n  margin-top: var(--gradient-margin);\n  border-radius: var(--gradient-border-radius);\n}\n\n.pointer {\n  position: absolute;\n  z-index: 2;\n  width: var(--gradient-pointer-width);\n  height: var(--gradient-pointer-height);\n  border: var(--gradient-pointer-border);\n  border-radius: var(--gradient-pointer-border-radius);\n  box-shadow: var(--elevation-20-shadow);\n}\n\n#primary-pointer {\n  top: calc(50% - 8px);\n}\n","import { Component, Host, h, Element, Event, EventEmitter, Prop, Watch } from '@stencil/core';\nimport { throttle } from 'lodash-es';\n\nimport { TMouseOrTouchEvent } from '../../../../utils/gesture/types';\nimport { isTouchEvent, getCoordsFromEvent } from '../../../../utils/gesture/utils';\n\nimport { hsvToRgb, parseToHSVA, hsvToHex } from '../../../../utils/color';\n\nconst RESIZE_DEBOUNCE_DURATION = 16; // 60fps\n\n/**\n * String values for pointer ids.\n */\nconst PRIMARY_ID = 'primary-pointer';\nconst SECONDARY_ID = 'secondary-pointer';\n\n/**\n * Default constants as percentages. Looks different at different viewport sizes, so no obvious coordinates available.\n */\nconst PRIMARY_COORDINATES = [50, 50] as [number, number];\nconst SECONDARY_COORDINATES = [95, 10] as [number, number];\n\n@Component({\n  tag: 'market-color-picker-gradient',\n  styleUrl: 'market-color-picker-gradient.css',\n  shadow: true,\n})\nexport class MarketColorPickerGradient {\n  @Element() el: HTMLMarketColorPickerGradientElement;\n\n  /**\n   * Value representing the selected color of the secondary gradient picker.\n   * This is a string that can represent a [CSS color value](https://developer.mozilla.org/en-US/docs/Web/CSS/color).\n   * This is the value the color picker will use.\n   * Supported color types are rgb/a, hsl/a, and hex colors.\n   */\n  @Prop() readonly value: string;\n\n  /**\n   * Fired whenever the picker selection state changes.\n   */\n  @Event({ cancelable: true }) marketColorPickerGradientValueChange: EventEmitter<{ value: string }>;\n\n  /**\n   * Current hue set on primary gradient.\n   */\n  primaryHue: number;\n\n  primaryPointer: HTMLElement;\n  secondaryPointer: HTMLElement;\n\n  /**\n   * Secondary pointer location. Used to determine secondary pointer color when secondary gradient changes.\n   */\n  secondaryPointerCoordinates: [number, number] = SECONDARY_COORDINATES;\n\n  /**\n   * Element of currently dragged pointer.\n   */\n  draggablePointer: HTMLElement | null;\n\n  /**\n   * Drag and drop logic for pointers.\n   */\n  boundOnDragMove = this.onDragMove.bind(this);\n  boundOnDragEnd = this.onDragEnd.bind(this);\n\n  private throttledUpdatePointerOnDrag = throttle(this.updatePointerOnDrag.bind(this), RESIZE_DEBOUNCE_DURATION);\n\n  onDragStart(e: TMouseOrTouchEvent, pointer: HTMLElement) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // only start drag on touch events or left mouse clicks\n    if (!isTouchEvent(e) && e.button !== 0) return;\n\n    const coords = getCoordsFromEvent(e);\n\n    this.updatePointerOnDrag(coords.x, coords.y, pointer);\n    this.draggablePointer = pointer;\n\n    document.addEventListener('mousemove', this.boundOnDragMove);\n    document.addEventListener('mouseup', this.boundOnDragEnd);\n\n    // don't use passive touch event listeners so we can call preventDefault()\n    document.addEventListener('touchmove', this.boundOnDragMove, { passive: false });\n    document.addEventListener('touchend', this.boundOnDragEnd, { passive: false });\n  }\n\n  onDragMove(e: TMouseOrTouchEvent) {\n    e.preventDefault();\n    const coords = getCoordsFromEvent(e);\n\n    this.throttledUpdatePointerOnDrag(coords.x, coords.y, this.draggablePointer);\n  }\n\n  onDragEnd(e: TMouseOrTouchEvent) {\n    e.preventDefault();\n\n    this.draggablePointer = null;\n    document.removeEventListener('mousemove', this.boundOnDragMove);\n    document.removeEventListener('mouseup', this.boundOnDragEnd);\n    document.removeEventListener('touchmove', this.boundOnDragMove);\n    document.removeEventListener('touchend', this.boundOnDragEnd);\n  }\n\n  /**\n   * Drag logic function to determine coordinates as a percentage.\n   * @param posX\n   * @param posY\n   * @param pointer\n   */\n  updatePointerOnDrag(posX: number, posY: number, pointer: HTMLElement) {\n    const elem = pointer.parentElement;\n    if (!elem) {\n      return;\n    }\n\n    const rect = elem.getBoundingClientRect();\n    const elemOffsetX = rect.left;\n    const elemOffsetY = rect.top;\n    const maxWidth = rect.width;\n    const maxHeight = rect.height;\n\n    // Set x and y as percentages of the gradient\n    let updatedX = (posX - elemOffsetX) / maxWidth;\n    let updatedY = (posY - elemOffsetY) / maxHeight;\n\n    // Ensure pointer does not leave gradient bounds\n    updatedX = Math.max(Math.min(updatedX, 1), 0);\n    updatedY = Math.max(Math.min(updatedY, 1), 0);\n\n    // utilize the %'s given for S & V (H decided by primary gradient)\n    // S = x increasing\n    // V = y decreasing\n    // H = color (0-360) by %\n    this.setPointerCoordinates({\n      pointer,\n      x: updatedX * 100,\n      y: updatedY * 100,\n    });\n  }\n\n  /**\n   * Function handling updating pointer location based on provided coordinates.\n   * The x and y values are percentages, from 0-100.\n   * It then also updates the colors of the pointers.\n   * @param {HTMLElement} options.pointer\n   * @param {number} options.x\n   * @param {number} options.y\n   * @param {boolean} options.emitEvent\n   * @param {string} options.colorType\n   */\n  setPointerCoordinates(options: {\n    pointer: HTMLElement;\n    x: number;\n    y?: number;\n    emitEvent?: boolean;\n    colorType?: string;\n  }) {\n    const { pointer, x, y = 50, emitEvent = true, colorType = '' } = options;\n\n    const pointerOffset = pointer.offsetWidth / 2;\n\n    pointer.style.left = `calc(${x}% - ${pointerOffset}px)`;\n\n    // Updates the selected color of the targeted gradient\n    if (pointer.id === PRIMARY_ID) {\n      this.setPrimaryGradientColor(x / 100, emitEvent);\n    } else if (pointer.id === SECONDARY_ID) {\n      // only update this on secondary gradient\n      pointer.style.top = `calc(${y}% - ${pointerOffset}px)`;\n\n      this.setSecondaryGradientColor(x / 100, y / 100, emitEvent, colorType);\n    }\n  }\n\n  /**\n   * Sets primary pointer color.\n   * Secondary gradient is updated to reflect new primary color.\n   * @param x\n   * @param emitEvent\n   */\n  setPrimaryGradientColor(x: number, emitEvent: boolean = true) {\n    this.primaryHue = x * 360;\n    this.primaryPointer.style.background = `hsl(${this.primaryHue}, 100%, 50%)`;\n    this.updateSecondaryGradient(emitEvent);\n  }\n\n  /**\n   * Sets secondary pointer color. If rgba is used, show that, otherwise default to hex values.\n   * The value emitted from the gradient here, if emitEvent is true.\n   * @param x\n   * @param y\n   * @param emitEvent\n   * @param colorType\n   */\n  setSecondaryGradientColor(x: number, y: number, emitEvent: boolean = true, colorType: string = '') {\n    const saturation = x * 100;\n    const value = 100 - y * 100;\n\n    let colorValue;\n    let colorString;\n\n    if (colorType === 'rgba') {\n      colorValue = hsvToRgb(this.primaryHue, saturation, value);\n      colorString = `rgb(${colorValue[0]}, ${colorValue[1]}, ${colorValue[2]})`;\n    } else {\n      // Defaults to hex value shown\n      colorValue = hsvToHex(this.primaryHue, saturation, value);\n      colorString = `#${colorValue.join('')}`;\n    }\n\n    this.secondaryPointer.style.background = colorString;\n\n    this.secondaryPointerCoordinates = [x, y];\n\n    if (emitEvent) {\n      this.marketColorPickerGradientValueChange.emit({ value: colorString });\n    }\n  }\n\n  /**\n   * Updates the secondary gradient picker background, then updates secondary pointer.\n   * @param emitEvent\n   */\n  updateSecondaryGradient(emitEvent: boolean = true) {\n    const gradient = this.el.shadowRoot.querySelector('.secondary-gradient') as HTMLElement;\n    gradient.style.background = `\n      linear-gradient(to top, rgb(0, 0, 0), transparent),\n      linear-gradient(to left, hsl(${this.primaryHue}, 100%, 50%), rgb(255, 255, 255))\n    `;\n\n    this.setSecondaryGradientColor(...this.secondaryPointerCoordinates, emitEvent);\n  }\n\n  /**\n   * This value watcher attempts to convert the value into a valid color and updates the gradient pickers.\n   * It returns a boolean based on whether this succeeded or not.\n   * @returns boolean\n   */\n  @Watch('value')\n  updateGradientsByValue() {\n    // Determine if color formatted as: hex, rgb, hsl\n    // Convert it to hsv and update position based on hsv\n\n    // Attempt to convert value\n    const convertedColor = parseToHSVA(this.value);\n\n    // If it converts successfully, values will exist. We also need the pointers to be initialized for this to work.\n    if (convertedColor.values && this.primaryPointer && this.secondaryPointer) {\n      const h = convertedColor.values[0];\n      const s = convertedColor.values[1];\n      const v = convertedColor.values[2];\n\n      // Deconstruct to HSV values. h = primary, s = secondary x, v = secondary y (decreasing)\n      const primaryX = (100 * h) / 360;\n      const secondaryX = s;\n      const secondaryY = 100 - v;\n\n      const primaryOptions = {\n        pointer: this.primaryPointer,\n        x: primaryX,\n        emitEvent: false,\n      };\n\n      const secondaryOptions = {\n        pointer: this.secondaryPointer,\n        x: secondaryX,\n        y: secondaryY,\n        colorType: convertedColor.colorType,\n        emitEvent: false,\n      };\n\n      this.setPointerCoordinates(primaryOptions);\n      this.setPointerCoordinates(secondaryOptions);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets necessary values for pointers to work if no valid value has been preset on load\n   */\n  setInitialPointers() {\n    const pointers = [this.primaryPointer, this.secondaryPointer];\n    const pointerCoordinates = [PRIMARY_COORDINATES, SECONDARY_COORDINATES];\n\n    pointers.forEach((pointer, i) => {\n      const pointerOptions = {\n        pointer,\n        x: pointerCoordinates[i][0],\n        y: pointerCoordinates[i][1],\n        emitEvent: false,\n      };\n      this.setPointerCoordinates(pointerOptions);\n    });\n  }\n\n  componentDidLoad() {\n    this.primaryPointer = this.el.shadowRoot.querySelector(`#${PRIMARY_ID}`);\n    this.secondaryPointer = this.el.shadowRoot.querySelector(`#${SECONDARY_ID}`);\n    const success = this.updateGradientsByValue();\n    if (!success) {\n      this.setInitialPointers();\n    }\n  }\n\n  /* eslint-disable jsx-a11y/aria-role */\n  render() {\n    return (\n      <Host class=\"market-color-picker-gradient\">\n        <slot></slot>\n        <div\n          class=\"primary-gradient\"\n          role=\"input\"\n          onMouseDown={(e: MouseEvent) => this.onDragStart(e, this.primaryPointer)}\n          onTouchStart={(e: TouchEvent) => this.onDragStart(e, this.primaryPointer)}\n        >\n          <div id={PRIMARY_ID} class=\"pointer\"></div>\n        </div>\n        <div\n          class=\"secondary-gradient\"\n          role=\"input\"\n          onMouseDown={(e: MouseEvent) => this.onDragStart(e, this.secondaryPointer)}\n          onTouchStart={(e: TouchEvent) => this.onDragStart(e, this.secondaryPointer)}\n        >\n          <div id={SECONDARY_ID} class=\"pointer\"></div>\n        </div>\n      </Host>\n    );\n  }\n  /* eslint-enable jsx-a11y/aria-role */\n}\n"],"mappings":"4OAAA,MAAMA,EAA+B,qwCACrC,MAAAC,EAAeD,ECOf,MAAME,EAA2B,GAKjC,MAAMC,EAAa,kBACnB,MAAMC,EAAe,oBAKrB,MAAMC,EAAsB,CAAC,GAAI,IACjC,MAAMC,EAAwB,CAAC,GAAI,I,MAOtBC,EAAyB,M,oHA2BpCC,KAAAC,4BAAgDH,EAUhDE,KAAAE,gBAAkBF,KAAKG,WAAWC,KAAKJ,MACvCA,KAAAK,eAAiBL,KAAKM,UAAUF,KAAKJ,MAE7BA,KAAAO,6BAA+BC,EAASR,KAAKS,oBAAoBL,KAAKJ,MAAON,G,qBAErF,WAAAgB,CAAYC,EAAuBC,GACjCD,EAAEE,iBACFF,EAAEG,kBAGF,IAAKC,EAAaJ,IAAMA,EAAEK,SAAW,EAAG,OAExC,MAAMC,EAASC,EAAmBP,GAElCX,KAAKS,oBAAoBQ,EAAOE,EAAGF,EAAOG,EAAGR,GAC7CZ,KAAKqB,iBAAmBT,EAExBU,SAASC,iBAAiB,YAAavB,KAAKE,iBAC5CoB,SAASC,iBAAiB,UAAWvB,KAAKK,gBAG1CiB,SAASC,iBAAiB,YAAavB,KAAKE,gBAAiB,CAAEsB,QAAS,QACxEF,SAASC,iBAAiB,WAAYvB,KAAKK,eAAgB,CAAEmB,QAAS,O,CAGxE,UAAArB,CAAWQ,GACTA,EAAEE,iBACF,MAAMI,EAASC,EAAmBP,GAElCX,KAAKO,6BAA6BU,EAAOE,EAAGF,EAAOG,EAAGpB,KAAKqB,iB,CAG7D,SAAAf,CAAUK,GACRA,EAAEE,iBAEFb,KAAKqB,iBAAmB,KACxBC,SAASG,oBAAoB,YAAazB,KAAKE,iBAC/CoB,SAASG,oBAAoB,UAAWzB,KAAKK,gBAC7CiB,SAASG,oBAAoB,YAAazB,KAAKE,iBAC/CoB,SAASG,oBAAoB,WAAYzB,KAAKK,e,CAShD,mBAAAI,CAAoBiB,EAAcC,EAAcf,GAC9C,MAAMgB,EAAOhB,EAAQiB,cACrB,IAAKD,EAAM,CACT,M,CAGF,MAAME,EAAOF,EAAKG,wBAClB,MAAMC,EAAcF,EAAKG,KACzB,MAAMC,EAAcJ,EAAKK,IACzB,MAAMC,EAAWN,EAAKO,MACtB,MAAMC,EAAYR,EAAKS,OAGvB,IAAIC,GAAYd,EAAOM,GAAeI,EACtC,IAAIK,GAAYd,EAAOO,GAAeI,EAGtCE,EAAWE,KAAKC,IAAID,KAAKE,IAAIJ,EAAU,GAAI,GAC3CC,EAAWC,KAAKC,IAAID,KAAKE,IAAIH,EAAU,GAAI,GAM3CzC,KAAK6C,sBAAsB,CACzBjC,UACAO,EAAGqB,EAAW,IACdpB,EAAGqB,EAAW,K,CAclB,qBAAAI,CAAsBC,GAOpB,MAAMlC,QAAEA,EAAOO,EAAEA,EAACC,EAAEA,EAAI,GAAE2B,UAAEA,EAAY,KAAIC,UAAEA,EAAY,IAAOF,EAEjE,MAAMG,EAAgBrC,EAAQsC,YAAc,EAE5CtC,EAAQuC,MAAMlB,KAAO,QAAQd,QAAQ8B,OAGrC,GAAIrC,EAAQwC,KAAOzD,EAAY,CAC7BK,KAAKqD,wBAAwBlC,EAAI,IAAK4B,E,MACjC,GAAInC,EAAQwC,KAAOxD,EAAc,CAEtCgB,EAAQuC,MAAMhB,IAAM,QAAQf,QAAQ6B,OAEpCjD,KAAKsD,0BAA0BnC,EAAI,IAAKC,EAAI,IAAK2B,EAAWC,E,EAUhE,uBAAAK,CAAwBlC,EAAW4B,EAAqB,MACtD/C,KAAKuD,WAAapC,EAAI,IACtBnB,KAAKwD,eAAeL,MAAMM,WAAa,OAAOzD,KAAKuD,yBACnDvD,KAAK0D,wBAAwBX,E,CAW/B,yBAAAO,CAA0BnC,EAAWC,EAAW2B,EAAqB,KAAMC,EAAoB,IAC7F,MAAMW,EAAaxC,EAAI,IACvB,MAAMyC,EAAQ,IAAMxC,EAAI,IAExB,IAAIyC,EACJ,IAAIC,EAEJ,GAAId,IAAc,OAAQ,CACxBa,EAAaE,EAAS/D,KAAKuD,WAAYI,EAAYC,GACnDE,EAAc,OAAOD,EAAW,OAAOA,EAAW,OAAOA,EAAW,K,KAC/D,CAELA,EAAaG,EAAShE,KAAKuD,WAAYI,EAAYC,GACnDE,EAAc,IAAID,EAAWI,KAAK,K,CAGpCjE,KAAKkE,iBAAiBf,MAAMM,WAAaK,EAEzC9D,KAAKC,4BAA8B,CAACkB,EAAGC,GAEvC,GAAI2B,EAAW,CACb/C,KAAKmE,qCAAqCC,KAAK,CAAER,MAAOE,G,EAQ5D,uBAAAJ,CAAwBX,EAAqB,MAC3C,MAAMsB,EAAWrE,KAAKsE,GAAGC,WAAWC,cAAc,uBAClDH,EAASlB,MAAMM,WAAa,mGAEKzD,KAAKuD,oDAGtCvD,KAAKsD,6BAA6BtD,KAAKC,4BAA6B8C,E,CAStE,sBAAA0B,GAKE,MAAMC,EAAiBC,EAAY3E,KAAK4D,OAGxC,GAAIc,EAAeE,QAAU5E,KAAKwD,gBAAkBxD,KAAKkE,iBAAkB,CACzE,MAAMW,EAAIH,EAAeE,OAAO,GAChC,MAAME,EAAIJ,EAAeE,OAAO,GAChC,MAAMG,EAAIL,EAAeE,OAAO,GAGhC,MAAMI,EAAY,IAAMH,EAAK,IAC7B,MAAMI,EAAaH,EACnB,MAAMI,EAAa,IAAMH,EAEzB,MAAMI,EAAiB,CACrBvE,QAASZ,KAAKwD,eACdrC,EAAG6D,EACHjC,UAAW,OAGb,MAAMqC,EAAmB,CACvBxE,QAASZ,KAAKkE,iBACd/C,EAAG8D,EACH7D,EAAG8D,EACHlC,UAAW0B,EAAe1B,UAC1BD,UAAW,OAGb/C,KAAK6C,sBAAsBsC,GAC3BnF,KAAK6C,sBAAsBuC,GAC3B,OAAO,I,CAGT,OAAO,K,CAMT,kBAAAC,GACE,MAAMC,EAAW,CAACtF,KAAKwD,eAAgBxD,KAAKkE,kBAC5C,MAAMqB,EAAqB,CAAC1F,EAAqBC,GAEjDwF,EAASE,SAAQ,CAAC5E,EAAS6E,KACzB,MAAMC,EAAiB,CACrB9E,UACAO,EAAGoE,EAAmBE,GAAG,GACzBrE,EAAGmE,EAAmBE,GAAG,GACzB1C,UAAW,OAEb/C,KAAK6C,sBAAsB6C,EAAe,G,CAI9C,gBAAAC,GACE3F,KAAKwD,eAAiBxD,KAAKsE,GAAGC,WAAWC,cAAc,IAAI7E,KAC3DK,KAAKkE,iBAAmBlE,KAAKsE,GAAGC,WAAWC,cAAc,IAAI5E,KAC7D,MAAMgG,EAAU5F,KAAKyE,yBACrB,IAAKmB,EAAS,CACZ5F,KAAKqF,oB,EAKT,MAAAQ,GACE,OACEhB,EAACiB,EAAI,CAAAC,IAAA,2CAACC,MAAM,gCACVnB,EAAA,QAAAkB,IAAA,6CACAlB,EAAA,OAAAkB,IAAA,2CACEC,MAAM,mBACNC,KAAK,QACLC,YAAcvF,GAAkBX,KAAKU,YAAYC,EAAGX,KAAKwD,gBACzD2C,aAAexF,GAAkBX,KAAKU,YAAYC,EAAGX,KAAKwD,iBAE1DqB,EAAA,OAAAkB,IAAA,2CAAK3C,GAAIzD,EAAYqG,MAAM,aAE7BnB,EAAA,OAAAkB,IAAA,2CACEC,MAAM,qBACNC,KAAK,QACLC,YAAcvF,GAAkBX,KAAKU,YAAYC,EAAGX,KAAKkE,kBACzDiC,aAAexF,GAAkBX,KAAKU,YAAYC,EAAGX,KAAKkE,mBAE1DW,EAAA,OAAAkB,IAAA,2CAAK3C,GAAIxD,EAAcoG,MAAM,a"}