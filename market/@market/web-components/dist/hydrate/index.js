'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function hydrateFactory($stencilWindow, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve) {
  var globalThis = $stencilWindow;
  var self = $stencilWindow;
  var top = $stencilWindow;
  var parent = $stencilWindow;

  var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
  var alert = $stencilWindow.alert.bind($stencilWindow);
  var blur = $stencilWindow.blur.bind($stencilWindow);
  var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
  var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
  var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
  var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
  var close = () => {};
  var confirm = $stencilWindow.confirm.bind($stencilWindow);
  var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
  var focus = $stencilWindow.focus.bind($stencilWindow);
  var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
  var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
  var open = $stencilWindow.open.bind($stencilWindow);
  var prompt = $stencilWindow.prompt.bind($stencilWindow);
  var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
  var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
  var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
  var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
  var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

  var CharacterData = $stencilWindow.CharacterData;
  var CSS = $stencilWindow.CSS;
  var CustomEvent = $stencilWindow.CustomEvent;
  var Document = $stencilWindow.Document;
  var DocumentFragment = $stencilWindow.DocumentFragment;
  var DocumentType = $stencilWindow.DocumentType;
  var DOMTokenList = $stencilWindow.DOMTokenList;
  var Element = $stencilWindow.Element;
  var Event = $stencilWindow.Event;
  var HTMLAnchorElement = $stencilWindow.HTMLAnchorElement;
  var HTMLBaseElement = $stencilWindow.HTMLBaseElement;
  var HTMLButtonElement = $stencilWindow.HTMLButtonElement;
  var HTMLCanvasElement = $stencilWindow.HTMLCanvasElement;
  var HTMLElement = $stencilWindow.HTMLElement;
  var HTMLFormElement = $stencilWindow.HTMLFormElement;
  var HTMLImageElement = $stencilWindow.HTMLImageElement;
  var HTMLInputElement = $stencilWindow.HTMLInputElement;
  var HTMLLinkElement = $stencilWindow.HTMLLinkElement;
  var HTMLMetaElement = $stencilWindow.HTMLMetaElement;
  var HTMLScriptElement = $stencilWindow.HTMLScriptElement;
  var HTMLStyleElement = $stencilWindow.HTMLStyleElement;
  var HTMLTemplateElement = $stencilWindow.HTMLTemplateElement;
  var HTMLTitleElement = $stencilWindow.HTMLTitleElement;
  var IntersectionObserver = $stencilWindow.IntersectionObserver;
  var KeyboardEvent = $stencilWindow.KeyboardEvent;
  var MouseEvent = $stencilWindow.MouseEvent;
  var Node = $stencilWindow.Node;
  var NodeList = $stencilWindow.NodeList;
  var URL = $stencilWindow.URL;

  var console = $stencilWindow.console;
  var customElements = $stencilWindow.customElements;
  var history = $stencilWindow.history;
  var localStorage = $stencilWindow.localStorage;
  var location = $stencilWindow.location;
  var navigator = $stencilWindow.navigator;
  var performance = $stencilWindow.performance;
  var sessionStorage = $stencilWindow.sessionStorage;

  var devicePixelRatio = $stencilWindow.devicePixelRatio;
  var innerHeight = $stencilWindow.innerHeight;
  var innerWidth = $stencilWindow.innerWidth;
  var origin = $stencilWindow.origin;
  var pageXOffset = $stencilWindow.pageXOffset;
  var pageYOffset = $stencilWindow.pageYOffset;
  var screen = $stencilWindow.screen;
  var screenLeft = $stencilWindow.screenLeft;
  var screenTop = $stencilWindow.screenTop;
  var screenX = $stencilWindow.screenX;
  var screenY = $stencilWindow.screenY;
  var scrollX = $stencilWindow.scrollX;
  var scrollY = $stencilWindow.scrollY;
  var exports = {};

  var fetch, FetchError, Headers, Request, Response;

  if (typeof $stencilWindow.fetch === 'function') {
    fetch = $stencilWindow.fetch;
  } else {
    fetch = $stencilWindow.fetch = function() { throw new Error('fetch() is not implemented'); };
  }

  if (typeof $stencilWindow.FetchError === 'function') {
    FetchError = $stencilWindow.FetchError;
  } else {
    FetchError = $stencilWindow.FetchError = class FetchError { constructor() { throw new Error('FetchError is not implemented'); } };
  }

  if (typeof $stencilWindow.Headers === 'function') {
    Headers = $stencilWindow.Headers;
  } else {
    Headers = $stencilWindow.Headers = class Headers { constructor() { throw new Error('Headers is not implemented'); } };
  }

  if (typeof $stencilWindow.Request === 'function') {
    Request = $stencilWindow.Request;
  } else {
    Request = $stencilWindow.Request = class Request { constructor() { throw new Error('Request is not implemented'); } };
  }

  if (typeof $stencilWindow.Response === 'function') {
    Response = $stencilWindow.Response;
  } else {
    Response = $stencilWindow.Response = class Response { constructor() { throw new Error('Response is not implemented'); } };
  }

  function hydrateAppClosure($stencilWindow) {
    const window = $stencilWindow;
    const document = $stencilWindow.document;
    /*hydrateAppClosure start*/


const NAMESPACE = 'market';
const BUILD = /* market */ { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: true, cmpShouldUpdate: false, cmpWillLoad: true, cmpWillRender: true, cmpWillUpdate: true, connectedCallback: true, constructableCSS: false, cssAnnotations: true, devTools: false, disconnectedCallback: true, element: false, event: true, experimentalScopedSlotChanges: false, experimentalSlotFixes: false, formAssociated: true, hasRenderFn: true, hostListener: true, hostListenerTarget: true, hostListenerTargetBody: false, hostListenerTargetDocument: false, hostListenerTargetParent: false, hostListenerTargetWindow: true, hotModuleReplacement: false, hydrateClientSide: true, hydrateServerSide: true, hydratedAttribute: false, hydratedClass: true, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: true, scoped: false, scriptDataOpts: false, shadowDelegatesFocus: true, shadowDom: true, shadowDomShim: true, slot: true, slotChildNodesFix: false, slotRelocation: true, state: true, style: true, svg: true, taskQueue: true, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: true, vdomKey: true, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: true, vdomText: true, vdomXlink: true, watchCallback: true };

/*
 Stencil Hydrate Platform v4.18.0 | MIT Licensed | https://stenciljs.com
 */
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/utils/constants.ts
var EMPTY_OBJ = {};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";

// src/utils/helpers.ts
var isDef = (v) => v != null;
var isComplexType = (o) => {
  o = typeof o;
  return o === "object" || o === "function";
};
var isPromise = (v) => !!v && (typeof v === "object" || typeof v === "function") && typeof v.then === "function";

// src/utils/query-nonce-meta-tag-content.ts
function queryNonceMetaTagContent(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
}

// src/utils/result.ts
var result_exports = {};
__export(result_exports, {
  err: () => err,
  map: () => map,
  ok: () => ok,
  unwrap: () => unwrap,
  unwrapErr: () => unwrapErr
});
var ok = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map(result, fn) {
  if (result.isOk) {
    const val = fn(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
var unwrap = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};
var createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
var uniqueTime = (key, measureText) => {
  {
    return () => {
      return;
    };
  }
};

// src/runtime/runtime-constants.ts
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var HYDRATE_ID = "s-id";
var HYDRATED_STYLE_ID = "sty-id";
var HYDRATE_CHILD_ID = "c-id";
var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS = [
  "formAssociatedCallback",
  "formResetCallback",
  "formDisabledCallback",
  "formStateRestoreCallback"
];
var h = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c) => {
    for (let i2 = 0; i2 < c.length; i2++) {
      child = c[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(
      vnodeData === null ? {} : vnodeData,
      vNodeChildren,
      vdomFnUtils
    );
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host = {};
var isHost = (node) => node && node.$tag$ === Host;
var vdomFnUtils = {
  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
var convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = { ...node.vattrs };
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};

// src/runtime/client-hydrate.ts
var initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
  const endHydrate = createTime("hydrateClient", tagName);
  const shadowRoot = hostElm.shadowRoot;
  const childRenderNodes = [];
  const slotNodes = [];
  const shadowRootNodes = shadowRoot ? [] : null;
  const vnode = hostRef.$vnode$ = newVNode(tagName, null);
  if (!plt.$orgLocNodes$) {
    initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
  }
  hostElm[HYDRATE_ID] = hostId;
  hostElm.removeAttribute(HYDRATE_ID);
  clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
  childRenderNodes.map((c) => {
    const orgLocationId = c.$hostId$ + "." + c.$nodeId$;
    const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
    const node = c.$elm$;
    if (orgLocationNode && supportsShadow && orgLocationNode["s-en"] === "") {
      orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
    }
    if (!shadowRoot) {
      node["s-hn"] = tagName;
      if (orgLocationNode) {
        node["s-ol"] = orgLocationNode;
        node["s-ol"]["s-nr"] = node;
      }
    }
    plt.$orgLocNodes$.delete(orgLocationId);
  });
  if (shadowRoot) {
    shadowRootNodes.map((shadowRootNode) => {
      if (shadowRootNode) {
        shadowRoot.appendChild(shadowRootNode);
      }
    });
  }
  endHydrate();
};
var clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {
  let childNodeType;
  let childIdSplt;
  let childVNode;
  let i2;
  if (node.nodeType === 1 /* ElementNode */) {
    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
    if (childNodeType) {
      childIdSplt = childNodeType.split(".");
      if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
        childVNode = {
          $flags$: 0,
          $hostId$: childIdSplt[0],
          $nodeId$: childIdSplt[1],
          $depth$: childIdSplt[2],
          $index$: childIdSplt[3],
          $tag$: node.tagName.toLowerCase(),
          $elm$: node,
          $attrs$: null,
          $children$: null,
          $key$: null,
          $name$: null,
          $text$: null
        };
        childRenderNodes.push(childVNode);
        node.removeAttribute(HYDRATE_CHILD_ID);
        if (!parentVNode.$children$) {
          parentVNode.$children$ = [];
        }
        parentVNode.$children$[childVNode.$index$] = childVNode;
        parentVNode = childVNode;
        if (shadowRootNodes && childVNode.$depth$ === "0") {
          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
        }
      }
    }
    for (i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
      clientHydrate(
        parentVNode,
        childRenderNodes,
        slotNodes,
        shadowRootNodes,
        hostElm,
        node.childNodes[i2],
        hostId
      );
    }
    if (node.shadowRoot) {
      for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {
        clientHydrate(
          parentVNode,
          childRenderNodes,
          slotNodes,
          shadowRootNodes,
          hostElm,
          node.shadowRoot.childNodes[i2],
          hostId
        );
      }
    }
  } else if (node.nodeType === 8 /* CommentNode */) {
    childIdSplt = node.nodeValue.split(".");
    if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
      childNodeType = childIdSplt[0];
      childVNode = {
        $flags$: 0,
        $hostId$: childIdSplt[1],
        $nodeId$: childIdSplt[2],
        $depth$: childIdSplt[3],
        $index$: childIdSplt[4],
        $elm$: node,
        $attrs$: null,
        $children$: null,
        $key$: null,
        $name$: null,
        $tag$: null,
        $text$: null
      };
      if (childNodeType === TEXT_NODE_ID) {
        childVNode.$elm$ = node.nextSibling;
        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {
          childVNode.$text$ = childVNode.$elm$.textContent;
          childRenderNodes.push(childVNode);
          node.remove();
          if (!parentVNode.$children$) {
            parentVNode.$children$ = [];
          }
          parentVNode.$children$[childVNode.$index$] = childVNode;
          if (shadowRootNodes && childVNode.$depth$ === "0") {
            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
          }
        }
      } else if (childVNode.$hostId$ === hostId) {
        if (childNodeType === SLOT_NODE_ID) {
          childVNode.$tag$ = "slot";
          if (childIdSplt[5]) {
            node["s-sn"] = childVNode.$name$ = childIdSplt[5];
          } else {
            node["s-sn"] = "";
          }
          node["s-sr"] = true;
          if (shadowRootNodes) {
            childVNode.$elm$ = doc.createElement(childVNode.$tag$);
            if (childVNode.$name$) {
              childVNode.$elm$.setAttribute("name", childVNode.$name$);
            }
            node.parentNode.insertBefore(childVNode.$elm$, node);
            node.remove();
            if (childVNode.$depth$ === "0") {
              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
            }
          }
          slotNodes.push(childVNode);
          if (!parentVNode.$children$) {
            parentVNode.$children$ = [];
          }
          parentVNode.$children$[childVNode.$index$] = childVNode;
        } else if (childNodeType === CONTENT_REF_ID) {
          if (shadowRootNodes) {
            node.remove();
          } else {
            hostElm["s-cr"] = node;
            node["s-cn"] = true;
          }
        }
      }
    }
  } else if (parentVNode && parentVNode.$tag$ === "style") {
    const vnode = newVNode(null, node.textContent);
    vnode.$elm$ = node;
    vnode.$index$ = "0";
    parentVNode.$children$ = [vnode];
  }
};
var initializeDocumentHydrate = (node, orgLocNodes) => {
  if (node.nodeType === 1 /* ElementNode */) {
    let i2 = 0;
    for (; i2 < node.childNodes.length; i2++) {
      initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);
    }
    if (node.shadowRoot) {
      for (i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++) {
        initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
      }
    }
  } else if (node.nodeType === 8 /* CommentNode */) {
    const childIdSplt = node.nodeValue.split(".");
    if (childIdSplt[0] === ORG_LOCATION_ID) {
      orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
      node.nodeValue = "";
      node["s-en"] = childIdSplt[3];
    }
  }
};
var parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4 /* Boolean */) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2 /* Number */) {
      return parseFloat(propValue);
    }
    if (propType & 1 /* String */) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var getElement = (ref) => getHostRef(ref).$hostElement$ ;

// src/runtime/event-emitter.ts
var createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4 /* Bubbles */),
        composed: !!(flags & 2 /* Composed */),
        cancelable: !!(flags & 1 /* Cancellable */),
        detail
      });
    }
  };
};
var emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId(cmpMeta);
  const style = styles.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        if (styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
          styleElm.innerHTML = style;
        } else {
          styleElm = doc.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          {
            styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    }
  }
  return scopeId2;
};
var attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(
    elm.getRootNode(),
    cmpMeta);
  if (flags & 10 /* needsScopedEncapsulation */) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
  }
  endAttachStyles();
};
var getScopeId = (cmp, mode) => "sc-" + (cmp.$tagName$);
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
    } else if (memberName === "style") {
      {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            {
              elm.style[prop] = "";
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (memberName === "key") ; else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if ((!isProp ) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln)) {
        memberName = ln.slice(2);
      } else {
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue || newValue) {
        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
        memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
        if (oldValue) {
          plt.rel(elm, memberName, oldValue, capture);
        }
        if (newValue) {
          plt.ael(elm, memberName, newValue, capture);
        }
      }
    } else {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n) {
              elm[memberName] = n;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e) {
        }
      }
      let xlink = false;
      {
        if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
          memberName = ln;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
var parseClassListRegex = /\s/;
var parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
var CAPTURE_EVENT_SUFFIX = "Capture";
var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");

// src/runtime/vdom/update-element.ts
var updateElement = (oldVnode, newVnode, isSvgMode2) => {
  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  {
    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
function sortedAttrNames(attrNames) {
  return attrNames.includes("ref") ? (
    // we need to sort these to ensure that `'ref'` is the last attr
    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
  ) : (
    // no need to sort, return the original array
    attrNames
  );
}

// src/runtime/vdom/vdom-render.ts
var scopeId;
var contentRef;
var hostTagName;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  var _d;
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        // still create an element that "mocks" the slot element
        2 /* isSlotFallback */
      ) : (
        // slot element does not have fallback content
        // create an html comment we'll use to always reference
        // where actual slot content should sit next to
        1 /* isSlotReference */
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1 /* isSlotReference */) {
    elm = newVNode2.$elm$ = slotReferenceDebugNode(newVNode2) ;
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc.createElementNS(
      isSvgMode ? SVG_NS : HTML_NS,
      newVNode2.$flags$ & 2 /* isSlotFallback */ ? "slot-fb" : newVNode2.$tag$
    ) ;
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm(oldParentVNode, newVNode2, i2, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  elm["s-hn"] = hostTagName;
  {
    if (newVNode2.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      elm["s-rf"] = (_d = newVNode2.$attrs$) == null ? void 0 : _d.ref;
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1 /* isTmpDisconnected */;
  const oldSlotChildNodes = Array.from(parentElm.childNodes);
  if (parentElm["s-sr"] && BUILD.experimentalSlotFixes) {
    let node = parentElm;
    while (node = node.nextSibling) {
      if (node && node["s-sn"] === parentElm["s-sn"] && node["s-sh"] === hostTagName) {
        oldSlotChildNodes.push(node);
      }
    }
  }
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1 /* isTmpDisconnected */;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, referenceNode(before) );
      }
    }
  }
};
var removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      if ((oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      if ((oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode, isInitialRender);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(
      parentElm,
      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
      newVNode2,
      newCh,
      newStartIdx,
      newEndIdx
    );
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    if (!isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    return true;
  }
  return false;
};
var referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
var parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      if (tag === "slot" && !useNativeShadowDom) ; else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (oldChildren !== null) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if ((defaultHolder = elm["s-cr"])) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var updateFallbackSlotVisibility = (elm) => {
  const childNodes = elm.childNodes;
  for (const childNode of childNodes) {
    if (childNode.nodeType === 1 /* ElementNode */) {
      if (childNode["s-sr"]) {
        const slotName = childNode["s-sn"];
        childNode.hidden = false;
        for (const siblingNode of childNodes) {
          if (siblingNode !== childNode) {
            if (siblingNode["s-hn"] !== childNode["s-hn"] || slotName !== "") {
              if (siblingNode.nodeType === 1 /* ElementNode */ && (slotName === siblingNode.getAttribute("slot") || slotName === siblingNode["s-sn"]) || siblingNode.nodeType === 3 /* TextNode */ && slotName === siblingNode["s-sn"]) {
                childNode.hidden = true;
                break;
              }
            } else {
              if (siblingNode.nodeType === 1 /* ElementNode */ || siblingNode.nodeType === 3 /* TextNode */ && siblingNode.textContent.trim() !== "") {
                childNode.hidden = true;
                break;
              }
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
var relocateNodes = [];
var markSlotContentForRelocation = (elm) => {
  let node;
  let hostContentNodes;
  let j;
  for (const childNode of elm.childNodes) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && (!BUILD.experimentalSlotFixes  )) {
          if (isNodeLocatedInSlot(node, slotName)) {
            let relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1 /* ElementNode */) {
      markSlotContentForRelocation(childNode);
    }
  }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
var nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(
      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]
    );
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4 /* isHost */;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm ;
  {
    scopeId = hostElm["s-sc"];
  }
  useNativeShadowDom = supportsShadow ;
  {
    contentRef = hostElm["s-cr"];
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode, isInitialLoad);
  {
    plt.$flags$ |= 1 /* isTmpDisconnected */;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          const orgLocationNode = originalLocationDebugNode(nodeToRelocate) ;
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) == null ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) != null ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;
                while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode["s-sr"])) {
                  refNode = refNode == null ? void 0 : refNode.nextSibling;
                }
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) != null ? _c : false;
              }
            }
          }
          nodeToRelocate && typeof slotRefNode["s-rf"] === "function" && slotRefNode["s-rf"](nodeToRelocate);
        } else {
          if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) != null ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1 /* isTmpDisconnected */;
    relocateNodes.length = 0;
  }
  contentRef = void 0;
};
var slotReferenceDebugNode = (slotVNode) => doc.createComment(
  `<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`
);
var originalLocationDebugNode = (nodeToRelocate) => doc.createComment(
  `org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate["s-hn"]})` : `[${nodeToRelocate.textContent}]`)
);

// src/runtime/update-component.ts
var attachToAncestor = (hostRef, ancestorComponent) => {
  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
    ancestorComponent["s-p"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));
  }
};
var scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
  }
  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {
    hostRef.$flags$ |= 512 /* needsRerender */;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return writeTask(dispatch) ;
};
var dispatchHooks = (hostRef, isInitialLoad) => {
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = hostRef.$lazyInstance$ ;
  let maybePromise;
  if (isInitialLoad) {
    {
      hostRef.$flags$ |= 256 /* isListenReady */;
      if (hostRef.$queuedListeners$) {
        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
        hostRef.$queuedListeners$ = void 0;
      }
    }
    {
      maybePromise = safeCall(instance, "componentWillLoad");
    }
  } else {
    {
      maybePromise = safeCall(instance, "componentWillUpdate");
    }
  }
  {
    maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender"));
  }
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
};
var enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
var isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
var updateComponent = async (hostRef, instance, isInitialLoad) => {
  var _a;
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  const rc = elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    await callRender(hostRef, instance, elm, isInitialLoad);
  }
  {
    try {
      serverSideConnected(elm);
      if (isInitialLoad) {
        if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {
          elm["s-en"] = "";
        } else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {
          elm["s-en"] = "c";
        }
      }
    } catch (e) {
      consoleError(e, elm);
    }
  }
  if (rc) {
    rc.map((cb) => cb());
    elm["s-rc"] = void 0;
  }
  endRender();
  endUpdate();
  {
    const childrenPromises = (_a = elm["s-p"]) != null ? _a : [];
    const postUpdate = () => postUpdateComponent(hostRef);
    if (childrenPromises.length === 0) {
      postUpdate();
    } else {
      Promise.all(childrenPromises).then(postUpdate);
      hostRef.$flags$ |= 4 /* isWaitingForChildren */;
      childrenPromises.length = 0;
    }
  }
};
var callRender = (hostRef, instance, elm, isInitialLoad) => {
  try {
    instance = instance.render() ;
    {
      hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;
    }
    {
      hostRef.$flags$ |= 2 /* hasRendered */;
    }
    {
      {
        {
          return Promise.resolve(instance).then((value) => renderVdom(hostRef, value, isInitialLoad));
        }
      }
    }
  } catch (e) {
    consoleError(e, hostRef.$hostElement$);
  }
  return null;
};
var postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = hostRef.$lazyInstance$ ;
  const ancestorComponent = hostRef.$ancestorComponent$;
  {
    safeCall(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {
    hostRef.$flags$ |= 64 /* hasLoadedComponent */;
    {
      addHydratedFlag(elm);
    }
    {
      safeCall(instance, "componentDidLoad");
    }
    endPostUpdate();
    {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad();
      }
    }
  } else {
    {
      safeCall(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
  {
    hostRef.$onInstanceResolve$(elm);
  }
  {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = void 0;
    }
    if (hostRef.$flags$ & 512 /* needsRerender */) {
      nextTick(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);
  }
};
var appDidLoad = (who) => {
  {
    addHydratedFlag(doc.documentElement);
  }
  nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
};
var safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e) {
      consoleError(e);
    }
  }
  return void 0;
};
var addHydratedFlag = (elm) => elm.classList.add("hydrated") ;
var serverSideConnected = (elm) => {
  const children = elm.children;
  if (children != null) {
    for (let i2 = 0, ii = children.length; i2 < ii; i2++) {
      const childElm = children[i2];
      if (typeof childElm.connectedCallback === "function") {
        childElm.connectedCallback();
      }
      serverSideConnected(childElm);
    }
  }
};

// src/runtime/set-value.ts
var getValue$1 = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  const elm = hostRef.$hostElement$ ;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = hostRef.$lazyInstance$ ;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if ((!(flags & 8 /* isConstructingInstance */) || oldVal === void 0) && didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    if (instance) {
      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e) {
              consoleError(e, elm);
            }
          });
        }
      }
      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
        scheduleUpdate(hostRef, false);
      }
    }
  }
};

// src/runtime/proxy-component.ts
var proxyComponent = (Cstr, cmpMeta, flags) => {
  var _a;
  const prototype = Cstr.prototype;
  if (cmpMeta.$flags$ & 64 /* formAssociated */ && flags & 1 /* isElementConstructor */) {
    FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS.forEach(
      (cbName) => Object.defineProperty(prototype, cbName, {
        value(...args) {
          const hostRef = getHostRef(this);
          const instance = hostRef.$lazyInstance$ ;
          if (!instance) {
            hostRef.$onReadyPromise$.then((instance2) => {
              const cb = instance2[cbName];
              typeof cb === "function" && cb.call(instance2, ...args);
            });
          } else {
            const cb = instance[cbName];
            typeof cb === "function" && cb.call(instance, ...args);
          }
        }
      })
    );
  }
  if (cmpMeta.$members$) {
    if (Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    members.map(([memberName, [memberFlags]]) => {
      if ((memberFlags & 31 /* Prop */ || (flags & 2 /* proxyState */) && memberFlags & 32 /* State */)) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue$1(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      } else if (flags & 1 /* isElementConstructor */ && memberFlags & 64 /* Method */) {
        Object.defineProperty(prototype, memberName, {
          value(...args) {
            var _a2;
            const ref = getHostRef(this);
            return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null ? void 0 : _a2.then(() => {
              var _a3;
              return (_a3 = ref.$lazyInstance$) == null ? void 0 : _a3[memberName](...args);
            });
          }
        });
      }
    });
    if ((flags & 1 /* isElementConstructor */)) {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef(this);
            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;
            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {
              const instance = hostRef.$lazyInstance$ ;
              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
              entry == null ? void 0 : entry.forEach((callbackName) => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = Array.from(
        /* @__PURE__ */ new Set([
          ...Object.keys((_a = cmpMeta.$watchers$) != null ? _a : {}),
          ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {
            var _a2;
            const attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            if (m[0] & 512 /* ReflectAttr */) {
              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
            }
            return attrName;
          })
        ])
      );
    }
  }
  return Cstr;
};

// src/runtime/initialize-component.ts
var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {
    hostRef.$flags$ |= 32 /* hasInitializedComponent */;
    const bundleId = cmpMeta.$lazyBundleId$;
    if (bundleId) {
      Cstr = loadModule(cmpMeta);
      if (Cstr.then) {
        const endLoad = uniqueTime();
        Cstr = await Cstr;
        endLoad();
      }
      if (!Cstr.isProxied) {
        {
          cmpMeta.$watchers$ = Cstr.watchers;
        }
        proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);
        Cstr.isProxied = true;
      }
      const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
      {
        hostRef.$flags$ |= 8 /* isConstructingInstance */;
      }
      try {
        new Cstr(hostRef);
      } catch (e) {
        consoleError(e);
      }
      {
        hostRef.$flags$ &= ~8 /* isConstructingInstance */;
      }
      {
        hostRef.$flags$ |= 128 /* isWatchReady */;
      }
      endNewInstance();
      fireConnectedCallback(hostRef.$lazyInstance$);
    } else {
      Cstr = elm.constructor;
      customElements.whenDefined(cmpMeta.$tagName$).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);
    }
    if (Cstr.style) {
      let style = Cstr.style;
      const scopeId2 = getScopeId(cmpMeta);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style);
        endRegisterStyles();
      }
    }
  }
  const ancestorComponent = hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  if (ancestorComponent && ancestorComponent["s-rc"]) {
    ancestorComponent["s-rc"].push(schedule);
  } else {
    schedule();
  }
};
var fireConnectedCallback = (instance) => {
  {
    safeCall(instance, "connectedCallback");
  }
};

// src/runtime/connected-callback.ts
var connectedCallback = (elm) => {
  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {
      hostRef.$flags$ |= 1 /* hasConnected */;
      let hostId;
      {
        hostId = elm.getAttribute(HYDRATE_ID);
        if (hostId) {
          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
        }
      }
      if (!hostId) {
        {
          setContentReference(elm);
        }
      }
      {
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          if (ancestorComponent.nodeType === 1 /* ElementNode */ && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback(hostRef.$lazyInstance$);
      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
      }
    }
    endConnected();
  }
};
var setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc.createComment(
    ""
  );
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};

// src/runtime/fragment.ts
var Fragment = (_, children) => children;
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners) {
    listeners.map(([flags, name, method]) => {
      const target = getHostListenerTarget(elm, flags) ;
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
var hostListenerProxy = (hostRef, methodName) => (ev) => {
  try {
    {
      if (hostRef.$flags$ & 256 /* isListenReady */) {
        hostRef.$lazyInstance$[methodName](ev);
      } else {
        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
      }
    }
  } catch (e) {
    consoleError(e);
  }
};
var getHostListenerTarget = (elm, flags) => {
  if (flags & 8 /* TargetWindow */)
    return win;
  return elm;
};
var hostListenerOpts = (flags) => (flags & 2 /* Capture */) !== 0;

// src/runtime/vdom/vdom-annotations.ts
var insertVdomAnnotations = (doc2, staticComponents) => {
  if (doc2 != null) {
    const docData = {
      hostIds: 0,
      rootLevelIds: 0,
      staticComponents: new Set(staticComponents)
    };
    const orgLocationNodes = [];
    parseVNodeAnnotations(doc2, doc2.body, docData, orgLocationNodes);
    orgLocationNodes.forEach((orgLocationNode) => {
      var _a, _b;
      if (orgLocationNode != null && orgLocationNode["s-nr"]) {
        const nodeRef = orgLocationNode["s-nr"];
        let hostId = nodeRef["s-host-id"];
        let nodeId = nodeRef["s-node-id"];
        let childId = `${hostId}.${nodeId}`;
        if (hostId == null) {
          hostId = 0;
          docData.rootLevelIds++;
          nodeId = docData.rootLevelIds;
          childId = `${hostId}.${nodeId}`;
          if (nodeRef.nodeType === 1 /* ElementNode */) {
            nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);
          } else if (nodeRef.nodeType === 3 /* TextNode */) {
            if (hostId === 0) {
              const textContent = (_a = nodeRef.nodeValue) == null ? void 0 : _a.trim();
              if (textContent === "") {
                orgLocationNode.remove();
                return;
              }
            }
            const commentBeforeTextNode = doc2.createComment(childId);
            commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;
            (_b = nodeRef.parentNode) == null ? void 0 : _b.insertBefore(commentBeforeTextNode, nodeRef);
          }
        }
        let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;
        const orgLocationParentNode = orgLocationNode.parentElement;
        if (orgLocationParentNode) {
          if (orgLocationParentNode["s-en"] === "") {
            orgLocationNodeId += `.`;
          } else if (orgLocationParentNode["s-en"] === "c") {
            orgLocationNodeId += `.c`;
          }
        }
        orgLocationNode.nodeValue = orgLocationNodeId;
      }
    });
  }
};
var parseVNodeAnnotations = (doc2, node, docData, orgLocationNodes) => {
  if (node == null) {
    return;
  }
  if (node["s-nr"] != null) {
    orgLocationNodes.push(node);
  }
  if (node.nodeType === 1 /* ElementNode */) {
    node.childNodes.forEach((childNode) => {
      const hostRef = getHostRef(childNode);
      if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {
        const cmpData = {
          nodeIds: 0
        };
        insertVNodeAnnotations(doc2, childNode, hostRef.$vnode$, docData, cmpData);
      }
      parseVNodeAnnotations(doc2, childNode, docData, orgLocationNodes);
    });
  }
};
var insertVNodeAnnotations = (doc2, hostElm, vnode, docData, cmpData) => {
  if (vnode != null) {
    const hostId = ++docData.hostIds;
    hostElm.setAttribute(HYDRATE_ID, hostId);
    if (hostElm["s-cr"] != null) {
      hostElm["s-cr"].nodeValue = `${CONTENT_REF_ID}.${hostId}`;
    }
    if (vnode.$children$ != null) {
      const depth = 0;
      vnode.$children$.forEach((vnodeChild, index) => {
        insertChildVNodeAnnotations(doc2, vnodeChild, cmpData, hostId, depth, index);
      });
    }
    if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(HYDRATE_CHILD_ID)) {
      const parent = hostElm.parentElement;
      if (parent && parent.childNodes) {
        const parentChildNodes = Array.from(parent.childNodes);
        const comment = parentChildNodes.find(
          (node) => node.nodeType === 8 /* CommentNode */ && node["s-sr"]
        );
        if (comment) {
          const index = parentChildNodes.indexOf(hostElm) - 1;
          vnode.$elm$.setAttribute(
            HYDRATE_CHILD_ID,
            `${comment["s-host-id"]}.${comment["s-node-id"]}.0.${index}`
          );
        }
      }
    }
  }
};
var insertChildVNodeAnnotations = (doc2, vnodeChild, cmpData, hostId, depth, index) => {
  const childElm = vnodeChild.$elm$;
  if (childElm == null) {
    return;
  }
  const nodeId = cmpData.nodeIds++;
  const childId = `${hostId}.${nodeId}.${depth}.${index}`;
  childElm["s-host-id"] = hostId;
  childElm["s-node-id"] = nodeId;
  if (childElm.nodeType === 1 /* ElementNode */) {
    childElm.setAttribute(HYDRATE_CHILD_ID, childId);
  } else if (childElm.nodeType === 3 /* TextNode */) {
    const parentNode = childElm.parentNode;
    const nodeName = parentNode == null ? void 0 : parentNode.nodeName;
    if (nodeName !== "STYLE" && nodeName !== "SCRIPT") {
      const textNodeId = `${TEXT_NODE_ID}.${childId}`;
      const commentBeforeTextNode = doc2.createComment(textNodeId);
      parentNode == null ? void 0 : parentNode.insertBefore(commentBeforeTextNode, childElm);
    }
  } else if (childElm.nodeType === 8 /* CommentNode */) {
    if (childElm["s-sr"]) {
      const slotName = childElm["s-sn"] || "";
      const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;
      childElm.nodeValue = slotNodeId;
    }
  }
  if (vnodeChild.$children$ != null) {
    const childDepth = depth + 1;
    vnodeChild.$children$.forEach((vnode, index2) => {
      insertChildVNodeAnnotations(doc2, vnode, cmpData, hostId, childDepth, index2);
    });
  }
};

// src/hydrate/platform/h-async.ts
var hAsync = (nodeName, vnodeData, ...children) => {
  if (Array.isArray(children) && children.length > 0) {
    const flatChildren = children.flat(Infinity);
    if (flatChildren.some(isPromise)) {
      return Promise.all(flatChildren).then((resolvedChildren) => {
        return h(nodeName, vnodeData, ...resolvedChildren);
      }).catch((err2) => {
        return h(nodeName, vnodeData);
      });
    }
    return h(nodeName, vnodeData, ...children);
  }
  return h(nodeName, vnodeData);
};

// src/hydrate/platform/proxy-host-element.ts
function proxyHostElement(elm, cmpMeta) {
  if (typeof elm.componentOnReady !== "function") {
    elm.componentOnReady = componentOnReady;
  }
  if (typeof elm.forceUpdate !== "function") {
    elm.forceUpdate = forceUpdate2;
  }
  if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
    elm.shadowRoot = elm;
  }
  if (cmpMeta.$members$ != null) {
    const hostRef = getHostRef(elm);
    const members = Object.entries(cmpMeta.$members$);
    members.forEach(([memberName, m]) => {
      const memberFlags = m[0];
      if (memberFlags & 31 /* Prop */) {
        const attributeName = m[1] || memberName;
        const attrValue = elm.getAttribute(attributeName);
        if (attrValue != null) {
          const parsedAttrValue = parsePropertyValue(attrValue, memberFlags);
          hostRef.$instanceValues$.set(memberName, parsedAttrValue);
        }
        const ownValue = elm[memberName];
        if (ownValue !== void 0) {
          hostRef.$instanceValues$.set(memberName, ownValue);
          delete elm[memberName];
        }
        Object.defineProperty(elm, memberName, {
          get() {
            return getValue$1(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      } else if (memberFlags & 64 /* Method */) {
        Object.defineProperty(elm, memberName, {
          value(...args) {
            const ref = getHostRef(this);
            return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args)).catch(consoleError);
          }
        });
      }
    });
  }
}
function componentOnReady() {
  return getHostRef(this).$onReadyPromise$;
}
function forceUpdate2() {
}

// src/hydrate/platform/hydrate-app.ts
function hydrateApp(win2, opts, results, afterHydrate, resolve) {
  const connectedElements = /* @__PURE__ */ new Set();
  const createdElements = /* @__PURE__ */ new Set();
  const waitingElements = /* @__PURE__ */ new Set();
  const orgDocumentCreateElement = win2.document.createElement;
  const orgDocumentCreateElementNS = win2.document.createElementNS;
  const resolved2 = Promise.resolve();
  let tmrId;
  let ranCompleted = false;
  function hydratedComplete() {
    global.clearTimeout(tmrId);
    createdElements.clear();
    connectedElements.clear();
    if (!ranCompleted) {
      ranCompleted = true;
      try {
        if (opts.clientHydrateAnnotations) {
          insertVdomAnnotations(win2.document, opts.staticComponents);
        }
        win2.dispatchEvent(new win2.Event("DOMContentLoaded"));
        win2.document.createElement = orgDocumentCreateElement;
        win2.document.createElementNS = orgDocumentCreateElementNS;
      } catch (e) {
        renderCatchError(opts, results, e);
      }
    }
    afterHydrate(win2, opts, results, resolve);
  }
  function hydratedError(err2) {
    renderCatchError(opts, results, err2);
    hydratedComplete();
  }
  function timeoutExceeded() {
    hydratedError(`Hydrate exceeded timeout${waitingOnElementsMsg(waitingElements)}`);
  }
  try {
    let patchedConnectedCallback2 = function() {
      return connectElement2(this);
    }, patchElement2 = function(elm) {
      if (isValidComponent(elm, opts)) {
        const hostRef = getHostRef(elm);
        if (!hostRef) {
          const Cstr = loadModule(
            {
              $tagName$: elm.nodeName.toLowerCase(),
              $flags$: null
            });
          if (Cstr != null && Cstr.cmpMeta != null) {
            createdElements.add(elm);
            elm.connectedCallback = patchedConnectedCallback2;
            registerHost(elm, Cstr.cmpMeta);
            proxyHostElement(elm, Cstr.cmpMeta);
          }
        }
      }
    }, patchChild2 = function(elm) {
      if (elm != null && elm.nodeType === 1) {
        patchElement2(elm);
        const children = elm.children;
        for (let i2 = 0, ii = children.length; i2 < ii; i2++) {
          patchChild2(children[i2]);
        }
      }
    }, connectElement2 = function(elm) {
      createdElements.delete(elm);
      if (isValidComponent(elm, opts) && results.hydratedCount < opts.maxHydrateCount) {
        if (!connectedElements.has(elm) && shouldHydrate(elm)) {
          connectedElements.add(elm);
          return hydrateComponent(win2, results, elm.nodeName, elm, waitingElements);
        }
      }
      return resolved2;
    }, waitLoop2 = function() {
      const toConnect = Array.from(createdElements).filter((elm) => elm.parentElement);
      if (toConnect.length > 0) {
        return Promise.all(toConnect.map(connectElement2)).then(waitLoop2);
      }
      return resolved2;
    };
    win2.document.createElement = function patchedCreateElement(tagName) {
      const elm = orgDocumentCreateElement.call(win2.document, tagName);
      patchElement2(elm);
      return elm;
    };
    win2.document.createElementNS = function patchedCreateElement(namespaceURI, tagName) {
      const elm = orgDocumentCreateElementNS.call(win2.document, namespaceURI, tagName);
      patchElement2(elm);
      return elm;
    };
    tmrId = global.setTimeout(timeoutExceeded, opts.timeout);
    plt.$resourcesUrl$ = new URL(opts.resourcesUrl || "./", doc.baseURI).href;
    patchChild2(win2.document.body);
    waitLoop2().then(hydratedComplete).catch(hydratedError);
  } catch (e) {
    hydratedError(e);
  }
}
async function hydrateComponent(win2, results, tagName, elm, waitingElements) {
  tagName = tagName.toLowerCase();
  const Cstr = loadModule(
    {
      $tagName$: tagName,
      $flags$: null
    });
  if (Cstr != null) {
    const cmpMeta = Cstr.cmpMeta;
    if (cmpMeta != null) {
      waitingElements.add(elm);
      try {
        connectedCallback(elm);
        await elm.componentOnReady();
        results.hydratedCount++;
        const ref = getHostRef(elm);
        const modeName = !ref.$modeName$ ? "$" : ref.$modeName$;
        if (!results.components.some((c) => c.tag === tagName && c.mode === modeName)) {
          results.components.push({
            tag: tagName,
            mode: modeName,
            count: 0,
            depth: -1
          });
        }
      } catch (e) {
        win2.console.error(e);
      }
      waitingElements.delete(elm);
    }
  }
}
function isValidComponent(elm, opts) {
  if (elm != null && elm.nodeType === 1) {
    const tagName = elm.nodeName;
    if (typeof tagName === "string" && tagName.includes("-")) {
      if (opts.excludeComponents.includes(tagName.toLowerCase())) {
        return false;
      }
      return true;
    }
  }
  return false;
}
function shouldHydrate(elm) {
  if (elm.nodeType === 9) {
    return true;
  }
  if (NO_HYDRATE_TAGS.has(elm.nodeName)) {
    return false;
  }
  if (elm.hasAttribute("no-prerender")) {
    return false;
  }
  const parentNode = elm.parentNode;
  if (parentNode == null) {
    return true;
  }
  return shouldHydrate(parentNode);
}
var NO_HYDRATE_TAGS = /* @__PURE__ */ new Set([
  "CODE",
  "HEAD",
  "IFRAME",
  "INPUT",
  "OBJECT",
  "OUTPUT",
  "NOSCRIPT",
  "PRE",
  "SCRIPT",
  "SELECT",
  "STYLE",
  "TEMPLATE",
  "TEXTAREA"
]);
function renderCatchError(opts, results, err2) {
  const diagnostic = {
    level: "error",
    type: "build",
    header: "Hydrate Error",
    messageText: "",
    relFilePath: void 0,
    absFilePath: void 0,
    lines: []
  };
  if (opts.url) {
    try {
      const u = new URL(opts.url);
      if (u.pathname !== "/") {
        diagnostic.header += ": " + u.pathname;
      }
    } catch (e) {
    }
  }
  if (err2 != null) {
    if (err2.stack != null) {
      diagnostic.messageText = err2.stack.toString();
    } else if (err2.message != null) {
      diagnostic.messageText = err2.message.toString();
    } else {
      diagnostic.messageText = err2.toString();
    }
  }
  results.diagnostics.push(diagnostic);
}
function printTag(elm) {
  let tag = `<${elm.nodeName.toLowerCase()}`;
  if (Array.isArray(elm.attributes)) {
    for (let i2 = 0; i2 < elm.attributes.length; i2++) {
      const attr = elm.attributes[i2];
      tag += ` ${attr.name}`;
      if (attr.value !== "") {
        tag += `="${attr.value}"`;
      }
    }
  }
  tag += `>`;
  return tag;
}
function waitingOnElementMsg(waitingElement) {
  let msg = "";
  if (waitingElement) {
    const lines = [];
    msg = " - waiting on:";
    let elm = waitingElement;
    while (elm && elm.nodeType !== 9 && elm.nodeName !== "BODY") {
      lines.unshift(printTag(elm));
      elm = elm.parentElement;
    }
    let indent = "";
    for (const ln of lines) {
      indent += "  ";
      msg += `
${indent}${ln}`;
    }
  }
  return msg;
}
function waitingOnElementsMsg(waitingElements) {
  return Array.from(waitingElements).map(waitingOnElementMsg);
}
var cmpModules = /* @__PURE__ */ new Map();
var getModule = (tagName) => {
  if (typeof tagName === "string") {
    tagName = tagName.toLowerCase();
    const cmpModule = cmpModules.get(tagName);
    if (cmpModule != null) {
      return cmpModule[tagName];
    }
  }
  return null;
};
var loadModule = (cmpMeta, _hostRef, _hmrVersionId) => {
  return getModule(cmpMeta.$tagName$);
};
var isMemberInElement = (elm, memberName) => {
  if (elm != null) {
    if (memberName in elm) {
      return true;
    }
    const cstr = getModule(elm.nodeName);
    if (cstr != null) {
      const hostRef = cstr;
      if (hostRef != null && hostRef.cmpMeta != null && hostRef.cmpMeta.$members$ != null) {
        return memberName in hostRef.cmpMeta.$members$;
      }
    }
  }
  return false;
};
var registerComponents = (Cstrs) => {
  for (const Cstr of Cstrs) {
    const exportName = Cstr.cmpMeta.$tagName$;
    cmpModules.set(exportName, {
      [exportName]: Cstr
    });
  }
};
var win = window;
var doc = win.document;
var writeTask = (cb) => {
  process.nextTick(() => {
    try {
      cb();
    } catch (e) {
      consoleError(e);
    }
  });
};
var resolved = /* @__PURE__ */ Promise.resolve();
var nextTick = (cb) => resolved.then(cb);
var defaultConsoleError = (e) => {
  if (e != null) {
    console.error(e.stack || e.message || e);
  }
};
var consoleError = (e, el) => (defaultConsoleError)(e, el);
var plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new win.CustomEvent(eventName, opts)
};
var supportsShadow = false;
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref) => hostRefs.get(ref);
var registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
var registerHost = (elm, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $cmpMeta$: cmpMeta,
    $hostElement$: elm,
    $instanceValues$: /* @__PURE__ */ new Map(),
    $renderCount$: 0
  };
  hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);
  hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
  elm["s-p"] = [];
  elm["s-rc"] = [];
  addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
  return hostRefs.set(elm, hostRef);
};
var styles = /* @__PURE__ */ new Map();

/**
 * We need to account for several possible values for autocomplete.
 * many people make the assumption that autocomplete is a boolean value,
 * but it is actually a string, so we're going to account for people's
 * incorrect assumptions and accept a boolean as well as accepting the
 * spec values
 * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete
 */
var AUTOCOMPLETE;
(function (AUTOCOMPLETE) {
    AUTOCOMPLETE["TRUE"] = "true";
    AUTOCOMPLETE["FALSE"] = "false";
    AUTOCOMPLETE["ON"] = "on";
    AUTOCOMPLETE["OFF"] = "off";
})(AUTOCOMPLETE || (AUTOCOMPLETE = {}));
function autocompleteWatcher(newValue) {
    switch (newValue) {
        case '':
        case true:
        case AUTOCOMPLETE.ON:
        case AUTOCOMPLETE.TRUE:
            /**
             * First, we check for known "truthy" values which will just set
             * the autocomplete attribute to "on" and tell the browser, yes please
             * autocomplete this field, but you have to fend for yourself to figure
             * out what to fill it with.
             */
            return AUTOCOMPLETE.ON;
        case false: // gotta check for exact bc empty strings are falsey, _ thanks javascript
        case AUTOCOMPLETE.OFF:
        case AUTOCOMPLETE.FALSE:
            return AUTOCOMPLETE.OFF;
        default:
            /**
             * Otherwise we can assume that a non-empty string is passed
             * that doesn't map to a specific enum value. Despite assumptions
             * otherwise, the autocomplete attribute is not a boolean. You can
             * pass strings to it and browsers will use that to infer what kind
             * of data should be autofilled to this field (address, name)
             * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete
             */
            return newValue;
    }
}

/**
 * Utility for joining class names
 *
 * This function accepts any number of arguments which can be a string or an object.
 * With object parameters, class names that have a truthy value are applied.
 *
 * Based on https://github.com/JedWatson/classnames
 *
 * @param {TClassNamesArgs} args class names
 */
function classNames(...args) {
    return args
        .reduce((result, arg) => {
        if (typeof arg === 'string') {
            result.push(arg);
        }
        else if (typeof arg === 'object') {
            for (const cn of Object.keys(arg)) {
                if (arg[cn]) {
                    result.push(cn);
                }
            }
        }
        return result;
    }, [])
        .join(' ');
}

// Allows access to the transformTagName function at runtime to transform nested children.
// Stencil does not currently expose this.
function getNamespacedTagFor(tagName) {
    return new Proxy((tag) => tag, {
        apply(target, thisArg, args) {
            return Reflect.apply(target, thisArg, args);
        },
    })(tagName);
}
function isElementWithTagName(el, tagName) {
    var _a, _b;
    return ((_b = (_a = el === null || el === void 0 ? void 0 : el.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a)) === getNamespacedTagFor(tagName);
}

function submitFormImplicitly(trigger) {
    const form = trigger.closest('form');
    if (form) {
        const submitButton = form.querySelector('[type="submit"]:not(disabled)');
        if (submitButton) {
            submitButton.click();
        }
    }
}

const marketInputSearchCss = "/*!@:host, ::slotted(*), **/.sc-market-input-search-h,.sc-market-input-search-s>*,*.sc-market-input-search{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-input-search-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-input-search-h *.sc-market-input-search,.sc-market-input-search-h[disabled].sc-market-input-search-s>*,.sc-market-input-search-h[disabled] .sc-market-input-search-s>*{cursor:not-allowed !important;pointer-events:none !important}@keyframes market-popup{from{opacity:0%;transform:scale(0.9, 0.9)}to{opacity:100%;transform:scale(1, 1)}}@keyframes market-popdown{from{opacity:100%;transform:scale(1, 1)}to{opacity:0%;transform:scale(0.9, 0.9)}}@keyframes market-slideup{from{opacity:0%;transform:translateY(80vh)}to{opacity:100%;transform:translateY(0)}}@keyframes market-slidedown{from{opacity:100%;transform:translateY(0)}to{opacity:0%;transform:translateY(80vh)}}@keyframes market-slide-left-enter{from{transform:translateX(100%)}to{transform:translateX(0)}}@keyframes market-slide-left-exit{from{transform:translateX(0)}to{transform:translateX(100%)}}@keyframes market-fade-in{from{opacity:0%}to{opacity:100%}}@keyframes market-fade-out{from{opacity:100%}to{opacity:0%}}@keyframes market-input-autofill-start{from{}to{}}@keyframes market-input-autofill-cancel{from{}to{}}@keyframes market-input-search-compact-enter{from{}to{}}@keyframes market-input-search-compact-exit{from{}to{}}/*!@:host*/.sc-market-input-search-h{--input-search-accessory-height:48px;--input-search-accessory-width:48px;--input-search-animation-enter-transition-duration:var(--core-animation-enter-transition-moderate-speed-duration);--input-search-animation-enter-transition-easing:var(--core-animation-enter-transition-easing);--input-search-animation-exit-transition-duration:var(--core-animation-exit-transition-fast-speed-duration);--input-search-animation-exit-transition-easing:var(--core-animation-exit-transition-easing);--input-search-background-color:var(--core-surface-5-color);--input-search-border-radius:6px;--input-search-border-size:1px;--input-search-clear-button-fill:var(--core-text-20-color);--input-search-clear-button-hover-state-fill:var(--core-fill-10-color);--input-search-compact-state-hover-state-background-color:var(--core-fill-40-color);--input-search-compact-state-hover-state-border-color:var(--core-fill-30-color);--input-search-compact-state-max-width:40px;--input-search-disabled-state-border-color:var(--core-fill-40-color);--input-search-disabled-state-text-color:var(--core-text-20-color);--input-search-focused-state-border-color:var(--core-fill-10-color);--input-search-height:48px;--input-search-hover-state-border-color:var(--core-fill-20-color);--input-search-icon-color:var(--core-text-10-color);--input-search-normal-state-border-color:var(--core-fill-30-color);--input-search-secondary-button-disabled-state-color:var(--core-text-30-color);--input-search-small-size-accessory-height:40px;--input-search-small-size-accessory-width:40px;--input-search-small-size-compact-state-max-width:40px;--input-search-small-size-height:40px;--input-search-small-size-text-size:14px;--input-search-text-color:var(--core-text-10-color);--input-search-text-font-family:var(--square-sans-text);--input-search-text-leading:24px;--input-search-text-placeholder-color:var(--core-text-30-color);--input-search-text-size:16px;--input-search-text-weight:var(--core-type-regular-weight);display:flex;flex:1;flex-direction:row;align-items:center;border:var(--input-search-border-size) solid var(--input-search-normal-state-border-color);border-radius:var(--input-search-border-radius);background-color:var(--input-search-background-color);color:var(--input-search-text-color);font-weight:var(--input-search-text-weight);font-family:var(--input-search-text-font-family);line-height:var(--input-search-text-leading);cursor:text;transition:flex\n    var(--input-search-animation-enter-transition-duration)\n    var(--input-search-animation-enter-transition-easing)}/*!@:host(.preload)*/.preload.sc-market-input-search-h{transition:none !important}/*!@:host(:hover)*/.sc-market-input-search-h:hover{border-color:var(--input-search-hover-state-border-color)}/*!@:host([focused])*/[focused].sc-market-input-search-h{border-color:var(--input-search-focused-state-border-color)}/*!@:host([disabled])*/[disabled].sc-market-input-search-h{border-color:var(--input-search-disabled-state-border-color);color:var(--input-search-disabled-state-text-color);cursor:not-allowed}/*!@:host([disabled]) svg*/[disabled].sc-market-input-search-h svg.sc-market-input-search{fill:var(--input-search-secondary-button-disabled-state-color)}/*!@:host([variant=\"medium\" i]), :host([size=\"medium\" i])*/[variant=\"medium\" i].sc-market-input-search-h,[size=\"medium\" i].sc-market-input-search-h{height:var(--input-search-height);font-size:var(--input-search-text-size)}/*!@:host([variant=\"medium\" i]) .leading-accessory, :host([variant=\"medium\" i]) .leading-accessory .market-accessory, :host([variant=\"medium\" i]) ::slotted([slot=\"trailing-accessory\"]), :host([variant=\"medium\" i]) .clear-button, :host([size=\"medium\" i]) .leading-accessory, :host([size=\"medium\" i]) .leading-accessory .market-accessory, :host([size=\"medium\" i]) ::slotted([slot=\"trailing-accessory\"]), :host([size=\"medium\" i]) .clear-button*/[variant=\"medium\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search,[variant=\"medium\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search .market-accessory.sc-market-input-search,.sc-market-input-search-h[variant=\"medium\" i].sc-market-input-search-s>[slot=\"trailing-accessory\"],.sc-market-input-search-h[variant=\"medium\" i] .sc-market-input-search-s>[slot=\"trailing-accessory\"],[variant=\"medium\" i].sc-market-input-search-h .clear-button.sc-market-input-search,[size=\"medium\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search,[size=\"medium\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search .market-accessory.sc-market-input-search,.sc-market-input-search-h[size=\"medium\" i].sc-market-input-search-s>[slot=\"trailing-accessory\"],.sc-market-input-search-h[size=\"medium\" i] .sc-market-input-search-s>[slot=\"trailing-accessory\"],[size=\"medium\" i].sc-market-input-search-h .clear-button.sc-market-input-search{width:calc(var(--input-search-accessory-width) - var(--input-search-border-size) * 2);height:calc(var(--input-search-accessory-height) - var(--input-search-border-size) * 2)}/*!@:host([variant=\"medium\" i][compact]:not([focused])), :host([size=\"medium\" i][compact]:not([focused]))*/[variant=\"medium\" i][compact].sc-market-input-search-h:not([focused]),[size=\"medium\" i][compact].sc-market-input-search-h:not([focused]){flex-basis:var(--input-search-compact-state-max-width)}/*!@:host([variant=\"small\" i]), :host([size=\"small\" i])*/[variant=\"small\" i].sc-market-input-search-h,[size=\"small\" i].sc-market-input-search-h{height:var(--input-search-small-size-height);font-size:var(--input-search-small-size-text-size)}/*!@:host([variant=\"small\" i]) .leading-accessory, :host([variant=\"small\" i]) .leading-accessory .market-accessory, :host([variant=\"small\" i]) ::slotted([slot=\"trailing-accessory\"]), :host([variant=\"small\" i]) .clear-button, :host([size=\"small\" i]) .leading-accessory, :host([size=\"small\" i]) .leading-accessory .market-accessory, :host([size=\"small\" i]) ::slotted([slot=\"trailing-accessory\"]), :host([size=\"small\" i]) .clear-button*/[variant=\"small\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search,[variant=\"small\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search .market-accessory.sc-market-input-search,.sc-market-input-search-h[variant=\"small\" i].sc-market-input-search-s>[slot=\"trailing-accessory\"],.sc-market-input-search-h[variant=\"small\" i] .sc-market-input-search-s>[slot=\"trailing-accessory\"],[variant=\"small\" i].sc-market-input-search-h .clear-button.sc-market-input-search,[size=\"small\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search,[size=\"small\" i].sc-market-input-search-h .leading-accessory.sc-market-input-search .market-accessory.sc-market-input-search,.sc-market-input-search-h[size=\"small\" i].sc-market-input-search-s>[slot=\"trailing-accessory\"],.sc-market-input-search-h[size=\"small\" i] .sc-market-input-search-s>[slot=\"trailing-accessory\"],[size=\"small\" i].sc-market-input-search-h .clear-button.sc-market-input-search{width:calc(var(--input-search-small-size-accessory-width) - var(--input-search-border-size) * 2);height:calc(var(--input-search-small-size-accessory-height) - var(--input-search-border-size) * 2)}/*!@:host([variant=\"small\" i][compact]:not([focused])), :host([size=\"small\" i][compact]:not([focused]))*/[variant=\"small\" i][compact].sc-market-input-search-h:not([focused]),[size=\"small\" i][compact].sc-market-input-search-h:not([focused]){flex-basis:var(--input-search-small-size-compact-state-max-width)}/*!@:host([compact]:not([focused]))*/[compact].sc-market-input-search-h:not([focused]){flex:0;cursor:pointer;transition:flex\n    var(--input-search-animation-exit-transition-duration)\n    var(--input-search-animation-exit-transition-easing);animation-name:market-input-search-compact-exit;animation-duration:var(--input-search-animation-exit-transition-duration)}/*!@:host([compact]:not([focused])) .leading-accessory*/[compact].sc-market-input-search-h:not([focused]) .leading-accessory.sc-market-input-search{margin-right:0;pointer-events:none}/*!@:host([compact]:not([focused])) ::slotted([slot=\"trailing-accessory\"]), :host([compact]:not([focused])) .clear-button*/.sc-market-input-search-h[compact]:not([focused]) .sc-market-input-search-s>[slot=\"trailing-accessory\"],[compact].sc-market-input-search-h:not([focused]) .clear-button.sc-market-input-search{display:none}/*!@:host([compact]:not([focused]):hover)*/[compact].sc-market-input-search-h:not([focused]):hover{border-color:var(--input-search-compact-state-hover-state-border-color);background-color:var(--input-search-compact-state-hover-state-background-color)}/*!@:host([compact][focused])*/[compact][focused].sc-market-input-search-h{animation-name:market-input-search-compact-enter;animation-duration:var(--input-search-animation-enter-transition-duration)}/*!@input::-moz-placeholder, ::slotted(input::-moz-placeholder)*/input.sc-market-input-search::-moz-placeholder,.sc-market-input-search-s>input::-moz-placeholder{color:var(--input-search-text-placeholder-color)}/*!@input::placeholder, ::slotted(input::placeholder), :host([value=\"\"]) input, :host([value=\"\"]) ::slotted(input)*/input.sc-market-input-search::placeholder,.sc-market-input-search-s>input::placeholder,[value=\"\"].sc-market-input-search-h input.sc-market-input-search,.sc-market-input-search-h[value=\"\"].sc-market-input-search-s>input,.sc-market-input-search-h[value=\"\"] .sc-market-input-search-s>input{color:var(--input-search-text-placeholder-color)}/*!@.leading-accessory, ::slotted([slot=\"trailing-accessory\"]), .clear-button*/.leading-accessory.sc-market-input-search,.sc-market-input-search-s>[slot=\"trailing-accessory\"],.clear-button.sc-market-input-search{display:flex;justify-content:center;align-items:center;padding:0;border:0;background:transparent}/*!@.leading-accessory.is-back-icon, .clear-button*/.leading-accessory.is-back-icon.sc-market-input-search,.clear-button.sc-market-input-search{cursor:pointer}/*!@.clear-button svg*/.clear-button.sc-market-input-search svg.sc-market-input-search{fill:var(--input-search-clear-button-fill)}/*!@.clear-button:hover svg*/.clear-button.sc-market-input-search:hover svg.sc-market-input-search{fill:var(--input-search-clear-button-hover-state-fill)}/*!@.clear-button.hidden*/.clear-button.hidden.sc-market-input-search{display:none}/*!@svg*/svg.sc-market-input-search{fill:var(--input-search-icon-color)}/*!@.input-container*/.input-container.sc-market-input-search{flex:1}/*!@input, ::slotted(input)*/input.sc-market-input-search,.sc-market-input-search-s>input{width:100%;height:var(--input-search-text-leading);padding:0;border:none;background-color:transparent;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit}/*!@input:focus, ::slotted(input:focus)*/input.sc-market-input-search:focus,.sc-market-input-search-s>input:focus{outline:none}/*!@input[disabled], ::slotted(input[disabled])*/input[disabled].sc-market-input-search,.sc-market-input-search-s>input[disabled]{color:var(--input-search-disabled-state-text-color)}/*!@:host(:not([value=\"\"])) ::slotted([slot=\"trailing-accessory\"])*/.sc-market-input-search-h:not([value=\"\"]) .sc-market-input-search-s>[slot=\"trailing-accessory\"]{display:none}/*!@input:-webkit-autofill, ::slotted(input:-webkit-autofill)*/input.sc-market-input-search:-webkit-autofill,.sc-market-input-search-s>input:-webkit-autofill{box-shadow:0 0 0 var(--input-search-text-leading) var(--input-search-background-color) inset !important;-webkit-text-fill-color:var(--input-search-text-color) !important;caret-color:var(--input-search-text-color)}/*!@:host input:-webkit-autofill, :host ::slotted(input:-webkit-autofill)*/.sc-market-input-search-h input.sc-market-input-search:-webkit-autofill,.sc-market-input-search-h.sc-market-input-search-s>input:-webkit-autofill,.sc-market-input-search-h .sc-market-input-search-s>input:-webkit-autofill{animation-name:market-input-autofill-start}/*!@:host input:not(:-webkit-autofill), :host ::slotted(input:not(:-webkit-autofill))*/.sc-market-input-search-h input.sc-market-input-search:not(:-webkit-autofill),.sc-market-input-search-h.sc-market-input-search-s>input:not(:-webkit-autofill),.sc-market-input-search-h .sc-market-input-search-s>input:not(:-webkit-autofill){animation-name:market-input-autofill-cancel}";
var MarketInputSearchStyle0 = marketInputSearchCss;

/**
 * @slot input - Can be used to slot your own HTML input, if needed (ex. if supporting browser
 * autofill)
 * @part native-input - The default inner HTML input.
 */
class InputText$1 {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketInputSearchCleared = createEvent(this, "marketInputSearchCleared", 7);
        this.marketInputSearchValueChange = createEvent(this, "marketInputSearchValueChange", 7);
        this.marketInputSearchFocus = createEvent(this, "marketInputSearchFocus", 7);
        this.marketInternalInputSearchCompactAnimation = createEvent(this, "marketInternalInputSearchCompactAnimation", 7);
        this.marketInputSearchDidLoad = createEvent(this, "marketInputSearchDidLoad", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.value = '';
        this.placeholder = '';
        this.maxlength = undefined;
        this.size = 'medium';
        this.variant = 'medium';
        this.disabled = false;
        this.focused = false;
        this.autofocus = false;
        this.autocomplete = true;
        this.name = undefined;
        this.inputAriaLabel = 'Search';
        this.clearButtonAriaLabel = 'Clear';
        this.searchIconButtonAriaLabel = 'Search icon';
        this.compact = false;
    }
    /**
     * This toggles focus on the inner `<input>`.
     * When input is about to receive focus, force a `tabindex="-1"` on the `<Host>`.
     * Since the focus is already on the inner `<input>`, tabbing into `<Host>` is redundant.
     * When the input loses is focus, the previous `tabindex` value,
     * presumably assigned by the consumer, is assigned back.
     */
    focusedWatcher(newValue, oldValue) {
        if (newValue === oldValue) {
            return;
        }
        if (newValue) {
            this.nativeInputEl.focus();
        }
    }
    disabledWatcher(newValue) {
        // if this component is disabled but focused, make sure to remove focus
        if (newValue && this.focused) {
            this.setFocus(false);
        }
    }
    autocompleteWatcher(newValue) {
        this._autocomplete = autocompleteWatcher(newValue);
    }
    /**
     * Sets focus styling on `<market-input-search>`;
     * toggles focus on the native `<input>` depending on the value passed
     * @param value new `focused` value
     */
    setFocus(value = true) {
        // don't do anything when: disabled; or it's already focused/blurred
        if ((this.disabled && value) || this.focused === value) {
            return Promise.resolve();
        }
        const { defaultPrevented } = this.marketInputSearchFocus.emit(value);
        if (!defaultPrevented) {
            this.focused = value; // this will cause the `focusedChangeHandler` to be triggered
            if (!value && this.nativeInputEl) {
                this.nativeInputEl.blur();
            }
        }
        return Promise.resolve();
    }
    /**
     * Clears the current input value.
     */
    clearInput() {
        const clearedEvent = this.marketInputSearchCleared.emit();
        if (clearedEvent.defaultPrevented || this.value === '') {
            // if the value is already '', no need to emit the value change event below
            return Promise.resolve();
        }
        const valueChangeEvent = this.marketInputSearchValueChange.emit({
            current: '',
            prevValue: this.value,
            originalEvent: null,
            value: '',
        });
        if (!valueChangeEvent.defaultPrevented) {
            this.value = '';
        }
        return Promise.resolve();
    }
    /**
     * When the clear (X) button is clicked
     */
    async handleClearButtonClicked() {
        await this.clearInput();
        this.clearButtonClicked = true;
    }
    /**
     * Handle value change from an <input> event
     */
    handleValueChange(e) {
        const target = e.target;
        if (!target) {
            return;
        }
        const { defaultPrevented } = this.marketInputSearchValueChange.emit({
            current: target.value,
            prevValue: this.value,
            originalEvent: e,
            value: target.value,
        });
        if (defaultPrevented) {
            e.preventDefault();
            return;
        }
        this.updateElementInternals();
        this.value = target.value;
    }
    /**
     * Handles `.input-container` animation changes
     */
    handleAnimation(e) {
        if (!this.compact) {
            return;
        }
        if (e.animationName === 'market-input-search-compact-enter' && e.type === 'animationstart' && this.focused) {
            this.marketInternalInputSearchCompactAnimation.emit(e.type);
            // re-focus because `this.focused` prop change happens first before this animation even trigger
            window.requestAnimationFrame(() => {
                var _a;
                (_a = this.nativeInputEl) === null || _a === void 0 ? void 0 : _a.focus();
            });
        }
        else if (e.animationName === 'market-input-search-compact-exit' && e.type === 'animationend') {
            this.marketInternalInputSearchCompactAnimation.emit(e.type);
        }
    }
    handleAccessoryClicked(e, isBackIcon) {
        if (isBackIcon) {
            e.stopPropagation();
            // back button should be displayed, so unfocus
            this.setFocus(false);
        }
    }
    handleKeyDown(e) {
        if (e.key === 'Enter') {
            submitFormImplicitly(this.el);
        }
    }
    /**
     * Allows passing an alternative light DOM input.
     */
    registerSlottedInput(slottedInput) {
        var _a;
        this.slottedInputEl =
            slottedInput ||
                // input slotted into market-input-search
                this.el.querySelector('input[slot=input]') ||
                (
                // input slotted into a higher-level component that uses market-input-search
                // (e.g. market-input-password)
                (_a = this.el.getRootNode().host) === null || _a === void 0 ? void 0 : _a.querySelector('input[slot=input]'));
        if (this.slottedInputEl) {
            this.slottedInputEl.addEventListener('input', (e) => this.handleValueChange(e));
            this.slottedInputEl.addEventListener('focus', () => this.setFocus());
            this.slottedInputEl.addEventListener('blur', () => this.setFocus(false));
            this.slottedInputEl.addEventListener('keydown', (e) => this.handleKeyDown(e));
            this.nativeInputEl = this.slottedInputEl;
        }
    }
    /**
     * TODO: This should be a common util. -antonn
     */
    updateSharedInputProps() {
        const prevSharedProps = Object.assign({}, this.sharedProps);
        // used by the default shadow DOM native input and to copy component properties to slotted inputs
        // conditionally adding key/value pairs based on whether we want to set them on the <input>
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#individual_attributes
        this.sharedProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (this._autocomplete && { autocomplete: this._autocomplete })), (this.autofocus && { autofocus: this.autofocus })), (this.disabled && { disabled: this.disabled })), (this.maxlength >= 0 && { maxlength: this.maxlength })), (this.name && { name: this.name })), (this.placeholder && { placeholder: this.placeholder })), (this.value !== undefined && { value: this.value }));
        // sync component props to slotted input, if one exists
        if (this.slottedInputEl) {
            const modifiedPropKeys = [...new Set([...Object.keys(prevSharedProps), ...Object.keys(this.sharedProps)])];
            modifiedPropKeys.forEach((key) => {
                if (!(key in this.sharedProps)) {
                    // remove properties that have been unset
                    this.slottedInputEl.removeAttribute(key);
                }
                else {
                    /**
                     * Boolean attributes can be set using empty strings
                     * https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#javascript
                     *
                     * But for setting properties like `value` (currently the only known one), directly modify the value instead
                     * https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#gecko_notes
                     */
                    const attributeValue = this.sharedProps[key] !== true ? this.sharedProps[key] : '';
                    if (key === 'value') {
                        this.slottedInputEl.value = attributeValue;
                    }
                    else if (attributeValue === false) {
                        this.slottedInputEl.removeAttribute(key);
                    }
                    else {
                        this.slottedInputEl.setAttribute(key, attributeValue);
                    }
                }
            });
        }
    }
    /**
     * Updates the internal state of this element bound to the surrounding form.
     */
    updateElementInternals() {
        var _a, _b, _c, _d;
        if (!this.internals) {
            return;
        }
        (_b = (_a = this.internals).setFormValue) === null || _b === void 0 ? void 0 : _b.call(_a, this.value);
        if (this.nativeInputEl) {
            (_d = (_c = this.internals).setValidity) === null || _d === void 0 ? void 0 : _d.call(_c, this.nativeInputEl.validity, this.nativeInputEl.validationMessage);
        }
    }
    componentWillLoad() {
        this.el.classList.add('preload'); // disables transitions on page load
        this.autocompleteWatcher(this.autocomplete);
        this.registerSlottedInput();
        this.updateSharedInputProps();
        this.updateElementInternals();
    }
    componentWillUpdate() {
        this.updateSharedInputProps();
        this.updateElementInternals();
    }
    componentDidLoad() {
        this.el.classList.remove('preload');
        this.marketInputSearchDidLoad.emit();
    }
    render() {
        const isBackIcon = this.compact && this.focused;
        // remove tabindex from host if inner <input> is already focused
        const tabindex = this.el.querySelector('input:focus') ? -1 : undefined;
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        return (hAsync(Host, { key: '133164a3dff4cdf3c6eb2794c8c5314b21bc581a', class: "market-input-search", onAnimationEnd: (e) => this.handleAnimation(e), onAnimationStart: (e) => this.handleAnimation(e), onBlur: () => {
                var _a;
                if (this.clearButtonClicked) {
                    (_a = this.nativeInputEl) === null || _a === void 0 ? void 0 : _a.focus();
                    this.clearButtonClicked = false;
                }
                else {
                    this.setFocus(false);
                }
            }, onClick: (e) => {
                e.stopPropagation();
                this.setFocus();
            }, onFocus: () => this.setFocus(), tabindex: tabindex }, hAsync("button", { key: '65f27022216df4507d9e33f3be45c6cba519cd76', class: classNames('leading-accessory', {
                'is-back-icon': isBackIcon,
            }), "aria-label": this.searchIconButtonAriaLabel, onClick: (e) => this.handleAccessoryClicked(e, isBackIcon), "aria-hidden": isBackIcon ? 'false' : 'true', tabindex: isBackIcon ? '0' : '-1' }, hAsync("slot", { key: 'cf48f6cef7804a9a729a011844bd5bbe86d7b902', name: "leading-accessory" }, hAsync(MarketAccessoryTagName, { key: 'e1b65cddebbd31f71dce043619a582e7dfb60fe9', size: "icon", tabindex: "-1", "aria-hidden": "true" }, isBackIcon ? (
        // back icon
        hAsync("svg", { width: "15", height: "16", viewBox: "0 0 15 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.292894 7.29285C-0.0976308 7.68337 -0.0976307 8.31654 0.292894 8.70706L7.29289 15.7071L8.70711 14.2928L3.41421 8.99995L15 8.99995L15 6.99995L3.41421 6.99995L8.70711 1.70706L7.29289 0.292846L0.292894 7.29285Z" }))) : (
        // search icon
        hAsync("svg", { width: "18", height: "18", viewBox: "0 0 18 18", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { d: "M7.49999 14.4998C9.06999 14.4998 10.52 13.9698 11.68 13.0998L15.79 17.2098L17.2 15.7998L13.09 11.6898C13.97 10.5198 14.49 9.07983 14.49 7.50983C14.49 3.64983 11.35 0.509827 7.48999 0.509827C3.62999 0.509827 0.48999 3.64983 0.48999 7.50983C0.48999 11.3698 3.63999 14.4998 7.49999 14.4998ZM7.49999 2.49983C10.26 2.49983 12.5 4.73983 12.5 7.49983C12.5 10.2598 10.26 12.4998 7.49999 12.4998C4.73999 12.4998 2.49999 10.2598 2.49999 7.49983C2.49999 4.73983 4.73999 2.49983 7.49999 2.49983Z" })))))), hAsync("div", { key: '616a4221ceecb87592b3f084a760fd4900ed58c0', class: "input-container" }, hAsync("slot", { key: '71088c117ef927aed382b3a53fc1fbb9d7bf6fba', name: "input", onSlotchange: () => this.registerSlottedInput() }, !this.slottedInputEl && (hAsync("input", Object.assign({ key: 'ffba176eaf116ee61fe69b3b234fb1f0ebc5edfa', "aria-label": this.inputAriaLabel, onInput: (e) => this.handleValueChange(e), onKeyDown: (e) => {
                this.handleKeyDown(e);
            }, part: "native-input", ref: (input) => (this.nativeInputEl = input), type: "text" }, this.sharedProps))))), hAsync("slot", { key: 'f259048200346a8163766b86d6c65b204e328471', name: "trailing-accessory" }), hAsync("button", { key: 'e4ecd8d3fecf4155c929c0676351ea26a00aae82', "aria-label": this.clearButtonAriaLabel, class: classNames('clear-button', { hidden: !this.value || this.disabled }), onClick: this.handleClearButtonClicked.bind(this), tabindex: "0" }, hAsync("svg", { key: '625050a3a003ee3e1ae18da5f0dd9857e3f9f17a', width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '2a3e4a6396d02a59054f108a04881bacd671dd7c', d: "M1.71004 13.71L7.00004 8.41004L12.29 13.71L13.71 12.29L8.41004 7.00004L13.71 1.71004L12.29 0.290039L7.00004 5.59004L1.71004 0.290039L0.290039 1.71004L5.59004 7.00004L0.290039 12.29L1.71004 13.71Z" })))));
    }
    static get formAssociated() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focused": ["focusedWatcher"],
        "disabled": ["disabledWatcher"],
        "autocomplete": ["autocompleteWatcher"]
    }; }
    static get style() { return MarketInputSearchStyle0; }
    static get cmpMeta() { return {
        "$flags$": 73,
        "$tagName$": "market-input-search",
        "$members$": {
            "value": [1537],
            "placeholder": [1],
            "maxlength": [2],
            "size": [513],
            "variant": [513],
            "disabled": [516],
            "focused": [1540],
            "autofocus": [4],
            "autocomplete": [8],
            "name": [1],
            "inputAriaLabel": [1, "input-aria-label"],
            "clearButtonAriaLabel": [1, "clear-button-aria-label"],
            "searchIconButtonAriaLabel": [1, "search-icon-button-aria-label"],
            "compact": [4],
            "setFocus": [64],
            "clearInput": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["size", "size"], ["variant", "variant"], ["disabled", "disabled"], ["focused", "focused"]]
    }; }
}

const getAriaAttributes = (el) => {
    // create an object with all aria-* attributes on host element
    return el
        .getAttributeNames()
        .filter((attr) => attr.startsWith('aria-'))
        .reduce((acc, attr) => {
        const value = el.getAttribute(attr);
        if (value !== null)
            acc[attr] = value;
        return acc;
    }, {});
};
/**
 * Watch for aria attribute changes on host element.
 */
const observeAriaAttributes = (el, onMutationObserved) => {
    const mutationObserver = new MutationObserver(() => {
        const ariaAttributes = getAriaAttributes(el);
        return onMutationObserved(ariaAttributes);
    });
    mutationObserver.observe(el, { attributes: true });
    return mutationObserver;
};
/**
 * ARIA LABELS
 *
 * It's currently not possible to make label/input associations across the
 * shadow DOM boundary. These helpers are intended to act as a lightweight a11y
 * solution by allowing our input and control components to set their own
 * aria-label attributes based on what is being used to label them.
 *
 * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html
 * https://nolanlawson.com/2022/11/28/shadow-dom-and-accessibility-the-trouble-with-aria
 * https://github.com/whatwg/html/issues/3219
 */
/**
 * Returns the the aria-label attribute to set on text input components:
 *   <market-input-text>
 *   <market-select>
 *   <market-textarea>
 *   <market-input-password> (via its internal market-input-text)
 *
 * These components expect a <label> element in the default slot to use as the
 * floating input label. Falls back to the component's `name` attribute if no
 * label can be found.
 *
 * @param inputEl The input element that needs an aria-label
 */
const getTextInputAriaLabel = (inputEl) => {
    var _a;
    const slottedLabel = 
    // label slotted directly into input component
    inputEl.querySelector('label:not([slot])') ||
        (
        // label slotted into a higher-level component (market-input-password)
        (_a = inputEl.getRootNode().host) === null || _a === void 0 ? void 0 : _a.querySelector('label:not([slot])'));
    return (slottedLabel === null || slottedLabel === void 0 ? void 0 : slottedLabel.innerHTML) || inputEl.getAttribute('name') || undefined;
};
/**
 * Returns the aria-label attribute to set on control components:
 *   <market-checkbox>
 *   <market-radio>
 *   <market-toggle>
 *
 * When used as a slotted control in <market-row>, the row handles setting the
 * aria-label of the control to match its own slotted label element. Otherwise,
 * if a consumer sets the aria-labelledby or aria-label attribute on the Market
 * component, the correct label text will be reflected in the shadow DOM.
 *
 * Adapted from Ionic Framework's getAriaLabel() helper:
 * https://github.com/ionic-team/ionic-framework/blob/main/core/src/utils/helpers.ts#L275-L332
 *
 * @param controlEl The control element that needs an aria-label
 */
const getControlInputAriaLabel = (controlEl) => {
    var _a;
    const attrIsValid = (attr) => attr !== null && attr.trim() !== '';
    let controlAriaLabel;
    // aria-labelledby takes precedence
    const ariaLabelledBy = controlEl.getAttribute('aria-labelledby');
    if (attrIsValid(ariaLabelledBy)) {
        const labelledByText = (_a = document.getElementById(ariaLabelledBy)) === null || _a === void 0 ? void 0 : _a.textContent;
        controlAriaLabel = controlAriaLabel || labelledByText;
    }
    // aria-label
    const ariaLabel = controlEl.getAttribute('aria-label');
    if (attrIsValid(ariaLabel)) {
        controlAriaLabel = controlAriaLabel || ariaLabel;
    }
    return controlAriaLabel || controlEl.getAttribute('name') || undefined;
};
const applyExpandableAriaControls = (controlEl, { expanded, popoverId }) => {
    // Screen reader announces the expanded state of the control on focus
    controlEl.setAttribute('aria-expanded', expanded);
    // Connect control to the popover content
    controlEl.setAttribute('aria-controls', popoverId);
};

const marketInputTextCss = "/*!@:host, ::slotted(*), **/.sc-market-input-text-h,.sc-market-input-text-s>*,*.sc-market-input-text{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-input-text-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-input-text-h *.sc-market-input-text,.sc-market-input-text-h[disabled].sc-market-input-text-s>*,.sc-market-input-text-h[disabled] .sc-market-input-text-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-input-text-h{position:relative;outline:none;font-weight:var(--field-input-weight);font-size:var(--field-input-size);line-height:var(--field-input-leading);cursor:text}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-input-text-h input.sc-market-input-text,.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h .sc-market-input-text-s>input,.sc-market-input-text-h textarea.sc-market-input-text,.sc-market-input-text-h.sc-market-input-text-s>textarea,.sc-market-input-text-h .sc-market-input-text-s>textarea{width:100%;margin:0;padding:0;border:none;background-color:transparent;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;cursor:inherit}/*!@:host ::slotted(label)*/.sc-market-input-text-h .sc-market-input-text-s>label{cursor:inherit}/*!@:host input:focus, :host ::slotted(input:focus), :host textarea:focus, :host ::slotted(textarea:focus)*/.sc-market-input-text-h input.sc-market-input-text:focus,.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h.sc-market-input-text-s>input:focus,.sc-market-input-text-h .sc-market-input-text-s>input:focus,.sc-market-input-text-h textarea.sc-market-input-text:focus,.sc-market-input-text-h.sc-market-input-text-s>textarea,.sc-market-input-text-h.sc-market-input-text-s>textarea:focus,.sc-market-input-text-h .sc-market-input-text-s>textarea:focus{outline:none}/*!@:host input::-moz-placeholder, :host textarea::-moz-placeholder*/.sc-market-input-text-h input.sc-market-input-text::-moz-placeholder,.sc-market-input-text-h textarea.sc-market-input-text::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host input::placeholder, :host textarea::placeholder*/.sc-market-input-text-h input.sc-market-input-text::placeholder,.sc-market-input-text-h textarea.sc-market-input-text::placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::-moz-placeholder, :host ::slotted(textarea)::-moz-placeholder*/.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h .sc-market-input-text-s>input::-moz-placeholder,.sc-market-input-text-h.sc-market-input-text-s>textarea,.sc-market-input-text-h.sc-market-input-text-s>textarea::-moz-placeholder,.sc-market-input-text-h .sc-market-input-text-s>textarea::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::placeholder, :host ::slotted(textarea)::placeholder*/.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h .sc-market-input-text-s>input::placeholder,.sc-market-input-text-h.sc-market-input-text-s>textarea,.sc-market-input-text-h.sc-market-input-text-s>textarea::placeholder,.sc-market-input-text-h .sc-market-input-text-s>textarea::placeholder{color:var(--field-placeholder-text-color)}/*!@:host([size='small'])*/[size='small'].sc-market-input-text-h{font-size:var(--core-type-paragraph-20-size);line-height:var(--core-type-paragraph-20-leading)}/*!@:host*/.sc-market-input-text-h{border-radius:var(--field-border-radius);background-color:var(--field-normal-state-background-color);color:var(--field-normal-state-input-color)}/*!@:host::after*/.sc-market-input-text-h::after{content:\"\";position:absolute;inset:0;border-radius:var(--field-border-radius);box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color);pointer-events:none}/*!@:host([invalid])::after*/[invalid].sc-market-input-text-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-invalid-validity-border-color)}/*!@:host(:hover)*/.sc-market-input-text-h:hover{background-color:var(--field-hover-state-background-color);color:var(--field-hover-state-input-color)}/*!@:host(:hover)::after*/.sc-market-input-text-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-normal-validity-border-color)}/*!@:host([invalid]:hover)::after*/[invalid].sc-market-input-text-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-invalid-validity-border-color)}/*!@:host([focused])*/[focused].sc-market-input-text-h{color:var(--field-focus-state-input-color)}/*!@:host([focused])::after*/[focused].sc-market-input-text-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size)\n        var(--field-focus-state-normal-validity-border-color)}/*!@:host([focused][invalid])::after*/[focused][invalid].sc-market-input-text-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size) var(--field-focus-state-invalid-validity-border-color)}/*!@:host([readonly]:hover)::after*/[readonly].sc-market-input-text-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color)}/*!@:host([disabled])*/[disabled].sc-market-input-text-h{background-color:var(--field-disabled-state-background-color) !important;color:var(--field-disabled-state-input-color) !important;cursor:not-allowed !important}/*!@:host([disabled])::after*/[disabled].sc-market-input-text-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-disabled-state-border-color) !important}/*!@:host([disabled]) ::slotted(.market-accessory), :host([disabled]) ::slotted(img[slot*=\"accessory\"]), :host([disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([disabled]) ::slotted(div[slot*=\"accessory\"])*/.sc-market-input-text-h[disabled] .sc-market-input-text-s>.market-accessory,.sc-market-input-text-h[disabled].sc-market-input-text-s>img[slot*=\"accessory\"],.sc-market-input-text-h[disabled] .sc-market-input-text-s>img[slot*=\"accessory\"],.sc-market-input-text-h[disabled].sc-market-input-text-s>svg[slot*=\"accessory\"],.sc-market-input-text-h[disabled] .sc-market-input-text-s>svg[slot*=\"accessory\"],.sc-market-input-text-h[disabled].sc-market-input-text-s>div[slot*=\"accessory\"],.sc-market-input-text-h[disabled] .sc-market-input-text-s>div[slot*=\"accessory\"]{--field-disabled-state-accessory-opacity:var(--row-disabled-state-leading-accessory-opacity);opacity:var(--field-disabled-state-accessory-opacity)}/*!@:host([value=\"\"]) ::slotted(label)*/.sc-market-input-text-h[value=\"\"] .sc-market-input-text-s>label{color:var(--field-normal-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"][autofilled]) ::slotted(label)*/.sc-market-input-text-h:not([value=\"\"]) .sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"][autofilled].sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"][autofilled] .sc-market-input-text-s>label{color:var(--field-normal-state-float-phase-label-color)}/*!@:host(:hover) ::slotted(label)*/.sc-market-input-text-h:hover .sc-market-input-text-s>label{color:var(--field-hover-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"]):hover) ::slotted(label), :host([value=\"\"][autofilled]:hover) ::slotted(label)*/.sc-market-input-text-h:not([value=\"\"]):hover .sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"][autofilled]:hover.sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"][autofilled]:hover .sc-market-input-text-s>label{color:var(--field-hover-state-float-phase-label-color)}/*!@:host([focused]) ::slotted(label)*/.sc-market-input-text-h[focused].sc-market-input-text-s>label,.sc-market-input-text-h[focused] .sc-market-input-text-s>label{color:var(--field-focus-state-float-phase-label-color)}/*!@:host([value=\"\"][disabled]) ::slotted(label)*/.sc-market-input-text-h[value=\"\"][disabled] .sc-market-input-text-s>label{color:var(--field-disabled-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])[disabled]) ::slotted(label), :host([value=\"\"][autofilled][disabled]) ::slotted(label)*/.sc-market-input-text-h:not([value=\"\"])[disabled] .sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"][autofilled][disabled].sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"][autofilled][disabled] .sc-market-input-text-s>label{color:var(--field-disabled-state-float-phase-label-color)}/*!@:host*/.sc-market-input-text-h{--field-accessory-horizontal-spacing-size:16px;--field-size-small-accessory-horizontal-spacing-size:12px;--field-size-large-image-accessory-outer-spacing-size:12px;--field-size-medium-image-accessory-outer-spacing-size:4px;--field-size-large-button-accessory-outer-spacing-size:12px;--field-size-medium-button-accessory-outer-spacing-size:4px;--field-size-large-tooltip-accessory-horizontal-spacing-size:5px;--field-size-large-tooltip-accessory-vertical-spacing-size:-1px;--field-size-small-tooltip-accessory-horizontal-spacing-size:1px}/*!@:host ::slotted([slot=\"leading-accessory\"])*/.sc-market-input-text-h .sc-market-input-text-s>[slot=\"leading-accessory\"]{flex-shrink:0;margin-right:var(--field-accessory-horizontal-spacing-size);margin-left:var(--field-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-accessory[slot=\"leading-accessory\"][size=\"image\"])*/.sc-market-input-text-h .sc-market-input-text-s>.market-accessory[slot=\"leading-accessory\"][size=\"image\"]{margin-left:var(--field-size-large-image-accessory-outer-spacing-size)}/*!@:host ::slotted(.market-tooltip[slot=\"leading-accessory\"])*/.sc-market-input-text-h .sc-market-input-text-s>.market-tooltip[slot=\"leading-accessory\"]{margin:var(--field-size-large-tooltip-accessory-vertical-spacing-size)\n      var(--field-size-large-tooltip-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-button[slot=\"leading-accessory\"][size=\"small\"])*/.sc-market-input-text-h .sc-market-input-text-s>.market-button[slot=\"leading-accessory\"][size=\"small\"]{margin-left:var(--field-size-large-button-accessory-outer-spacing-size)}/*!@:host ::slotted([slot=\"trailing-accessory\"])*/.sc-market-input-text-h .sc-market-input-text-s>[slot=\"trailing-accessory\"]{flex-shrink:0;margin-right:var(--field-accessory-horizontal-spacing-size);margin-left:var(--field-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-accessory[slot=\"trailing-accessory\"][size=\"image\"])*/.sc-market-input-text-h .sc-market-input-text-s>.market-accessory[slot=\"trailing-accessory\"][size=\"image\"]{margin-right:var(--field-size-large-image-accessory-outer-spacing-size)}/*!@:host ::slotted(.market-tooltip[slot=\"trailing-accessory\"])*/.sc-market-input-text-h .sc-market-input-text-s>.market-tooltip[slot=\"trailing-accessory\"]{margin:var(--field-size-large-tooltip-accessory-vertical-spacing-size)\n      var(--field-size-large-tooltip-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-button[slot=\"trailing-accessory\"][size=\"small\"])*/.sc-market-input-text-h .sc-market-input-text-s>.market-button[slot=\"trailing-accessory\"][size=\"small\"]{margin-right:var(--field-size-large-button-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-accessory[slot=\"leading-accessory\"][size=\"image\"])*/.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>.market-accessory[slot=\"leading-accessory\"][size=\"image\"]{margin-left:var(--field-size-medium-image-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-button[slot=\"leading-accessory\"][size=\"small\"])*/.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>.market-button[slot=\"leading-accessory\"][size=\"small\"]{margin-left:var(--field-size-medium-button-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-accessory[slot=\"trailing-accessory\"][size=\"image\"])*/.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>.market-accessory[slot=\"trailing-accessory\"][size=\"image\"]{margin-right:var(--field-size-medium-image-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-button[slot=\"trailing-accessory\"][size=\"small\"])*/.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>.market-button[slot=\"trailing-accessory\"][size=\"small\"]{margin-right:var(--field-size-medium-button-accessory-outer-spacing-size)}/*!@:host([size='small']) ::slotted([slot=\"leading-accessory\"]), :host([size='small']) ::slotted([slot=\"trailing-accessory\"])*/.sc-market-input-text-h[size='small'] .sc-market-input-text-s>[slot=\"leading-accessory\"],.sc-market-input-text-h[size='small'].sc-market-input-text-s>[slot=\"trailing-accessory\"],.sc-market-input-text-h[size='small'] .sc-market-input-text-s>[slot=\"trailing-accessory\"]{margin-right:var(--field-size-small-accessory-horizontal-spacing-size);margin-left:var(--field-size-small-accessory-horizontal-spacing-size)}/*!@:host([size='small']) ::slotted(.market-tooltip[slot=\"leading-accessory\"]), :host([size='small']) ::slotted(.market-tooltip[slot=\"trailing-accessory\"])*/.sc-market-input-text-h[size='small'] .sc-market-input-text-s>.market-tooltip[slot=\"leading-accessory\"],.sc-market-input-text-h[size='small'].sc-market-input-text-s>.market-tooltip[slot=\"trailing-accessory\"],.sc-market-input-text-h[size='small'] .sc-market-input-text-s>.market-tooltip[slot=\"trailing-accessory\"]{margin-right:var(--field-size-small-tooltip-accessory-horizontal-spacing-size);margin-left:var(--field-size-small-tooltip-accessory-horizontal-spacing-size)}/*!@:host .label-input-container.has-leading-accessory*/.sc-market-input-text-h .label-input-container.has-leading-accessory.sc-market-input-text{padding-left:0 !important}/*!@:host .label-input-container.has-trailing-accessory*/.sc-market-input-text-h .label-input-container.has-trailing-accessory.sc-market-input-text{padding-right:0 !important}/*!@:host*/.sc-market-input-text-h{--field-input-animation-speed:0.2s;--field-input-label-translate:12px;--field-empty-phase-label-text-size-unitless:16;--field-float-phase-label-text-size-unitless:14;--field-size-medium-float-phase-vertical-padding-size:12px;--field-size-medium-float-phase-horizontal-padding-size:16px;--field-size-small-float-phase-vertical-padding-size:9px;--field-size-small-float-phase-horizontal-padding-size:12px;display:flex;align-items:center}/*!@:host .label-input-container, :host([value='']:not([focused]):not([autofilled])) .label-input-container*/.sc-market-input-text-h .label-input-container.sc-market-input-text,[value=''].sc-market-input-text-h:not([focused]):not([autofilled]) .label-input-container.sc-market-input-text{flex-grow:1;padding:var(--field-float-phase-vertical-padding-size) var(--field-float-phase-horizontal-padding-size)}/*!@:host([size='medium']) .label-input-container, :host([size='medium'][value='']:not([focused]):not([autofilled])) .label-input-container*/[size='medium'].sc-market-input-text-h .label-input-container.sc-market-input-text,[size='medium'][value=''].sc-market-input-text-h:not([focused]):not([autofilled]) .label-input-container.sc-market-input-text{padding:var(--field-size-medium-float-phase-vertical-padding-size)\n      var(--field-size-medium-float-phase-horizontal-padding-size)}/*!@:host([size='small']) .label-input-container, :host([size='small'][value='']:not([focused]):not([autofilled])) .label-input-container*/[size='small'].sc-market-input-text-h .label-input-container.sc-market-input-text,[size='small'][value=''].sc-market-input-text-h:not([focused]):not([autofilled]) .label-input-container.sc-market-input-text{padding:var(--field-size-small-float-phase-vertical-padding-size)\n      var(--field-size-small-float-phase-horizontal-padding-size)}/*!@:host ::slotted(label)*/.sc-market-input-text-h .sc-market-input-text-s>label{display:block;min-height:var(--field-empty-phase-label-text-leading);font-weight:var(--field-empty-phase-label-text-weight);font-size:var(--field-empty-phase-label-text-size);line-height:var(--field-empty-phase-label-text-leading);letter-spacing:var(--field-empty-phase-label-text-tracking);transition:all var(--field-input-animation-speed);transform:translateY(var(--field-input-label-translate));transform-origin:0 0}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"]:not([focused])[autofilled]) ::slotted(label), :host([focused]) ::slotted(label)*/.sc-market-input-text-h:not([value=\"\"]) .sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"]:not([focused])[autofilled].sc-market-input-text-s>label,.sc-market-input-text-h[value=\"\"]:not([focused])[autofilled] .sc-market-input-text-s>label,.sc-market-input-text-h[focused].sc-market-input-text-s>label,.sc-market-input-text-h[focused] .sc-market-input-text-s>label{font-weight:var(--field-float-phase-label-text-weight);transform:scale(\n        calc(var(--field-float-phase-label-text-size-unitless) / var(--field-empty-phase-label-text-size-unitless))\n      )}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-input-text-h input.sc-market-input-text,.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h .sc-market-input-text-s>input,.sc-market-input-text-h textarea.sc-market-input-text,.sc-market-input-text-h.sc-market-input-text-s>textarea,.sc-market-input-text-h .sc-market-input-text-s>textarea{opacity:0%}/*!@:host([focused]) input, :host([focused]) ::slotted(input), :host([focused]) textarea, :host([focused]) ::slotted(textarea), :host(:not([value=''])) input, :host(:not([value=''])) ::slotted(input), :host(:not([value=''])) textarea, :host(:not([value=''])) ::slotted(textarea)*/[focused].sc-market-input-text-h input.sc-market-input-text,.sc-market-input-text-h[focused].sc-market-input-text-s>input,.sc-market-input-text-h[focused] .sc-market-input-text-s>input,[focused].sc-market-input-text-h textarea.sc-market-input-text,.sc-market-input-text-h[focused].sc-market-input-text-s>textarea,.sc-market-input-text-h[focused] .sc-market-input-text-s>textarea,.sc-market-input-text-h:not([value='']) input.sc-market-input-text,.sc-market-input-text-h:not([value='']).sc-market-input-text-s>input,.sc-market-input-text-h:not([value='']) .sc-market-input-text-s>input,.sc-market-input-text-h:not([value='']) textarea.sc-market-input-text,.sc-market-input-text-h:not([value='']).sc-market-input-text-s>textarea,.sc-market-input-text-h:not([value='']) .sc-market-input-text-s>textarea{opacity:100%}/*!@:host([size='small']) ::slotted(label), :host([size='medium']) ::slotted(label)*/.sc-market-input-text-h[size='small'] .sc-market-input-text-s>label,.sc-market-input-text-h[size='medium'].sc-market-input-text-s>label,.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>label{position:absolute;overflow:hidden;clip:rect(0 0 0 0);width:1px;height:1px;white-space:nowrap;-webkit-clip-path:inset(50%);clip-path:inset(50%)}/*!@:host([size='small']) input, :host([size='small']) ::slotted(input), :host([size='small']) textarea, :host([size='small']) ::slotted(textarea), :host([size='medium']) input, :host([size='medium']) ::slotted(input), :host([size='medium']) textarea, :host([size='medium']) ::slotted(textarea)*/[size='small'].sc-market-input-text-h input.sc-market-input-text,.sc-market-input-text-h[size='small'].sc-market-input-text-s>input,.sc-market-input-text-h[size='small'] .sc-market-input-text-s>input,[size='small'].sc-market-input-text-h textarea.sc-market-input-text,.sc-market-input-text-h[size='small'].sc-market-input-text-s>textarea,.sc-market-input-text-h[size='small'] .sc-market-input-text-s>textarea,[size='medium'].sc-market-input-text-h input.sc-market-input-text,.sc-market-input-text-h[size='medium'].sc-market-input-text-s>input,.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>input,[size='medium'].sc-market-input-text-h textarea.sc-market-input-text,.sc-market-input-text-h[size='medium'].sc-market-input-text-s>textarea,.sc-market-input-text-h[size='medium'] .sc-market-input-text-s>textarea{opacity:100%}/*!@:host input::-webkit-outer-spin-button, :host input::-webkit-inner-spin-button*/.sc-market-input-text-h input.sc-market-input-text::-webkit-outer-spin-button,.sc-market-input-text-h input.sc-market-input-text::-webkit-inner-spin-button{margin:0;-webkit-appearance:none;appearance:none}/*!@:host input[type=\"number\"]*/.sc-market-input-text-h input[type=\"number\"].sc-market-input-text{-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield}/*!@input[type=\"time\"]::-webkit-inner-spin-button, input[type=\"time\"]::-webkit-outer-spin-button, input[type=\"time\"]::-webkit-clear-button, input[type=\"time\"]::-webkit-calendar-picker-indicator*/input[type=\"time\"].sc-market-input-text::-webkit-inner-spin-button,input[type=\"time\"].sc-market-input-text::-webkit-outer-spin-button,input[type=\"time\"].sc-market-input-text::-webkit-clear-button,input[type=\"time\"].sc-market-input-text::-webkit-calendar-picker-indicator{display:none}/*!@input[type=\"date\"]::-webkit-calendar-picker-indicator, input[type=\"time\"]::-webkit-calendar-picker-indicator*/input[type=\"date\"].sc-market-input-text::-webkit-calendar-picker-indicator,input[type=\"time\"].sc-market-input-text::-webkit-calendar-picker-indicator{display:none}/*!@input[type=\"date\"]::-webkit-inner-spin-button, input[type=\"time\"]::-webkit-inner-spin-button, input[type=\"date\"]::-webkit-clear-button, input[type=\"time\"]::-webkit-clear-button*/input[type=\"date\"].sc-market-input-text::-webkit-inner-spin-button,input[type=\"time\"].sc-market-input-text::-webkit-inner-spin-button,input[type=\"date\"].sc-market-input-text::-webkit-clear-button,input[type=\"time\"].sc-market-input-text::-webkit-clear-button{display:none;margin:0;-webkit-appearance:none;appearance:none}/*!@:host([value=\"\"]) input, :host([value=\"\"]) ::slotted(input)*/[value=\"\"].sc-market-input-text-h input.sc-market-input-text,.sc-market-input-text-h[value=\"\"].sc-market-input-text-s>input,.sc-market-input-text-h[value=\"\"] .sc-market-input-text-s>input{color:var(--field-placeholder-text-color)}/*!@:host input:-webkit-autofill, :host ::slotted(input:-webkit-autofill)*/.sc-market-input-text-h input.sc-market-input-text:-webkit-autofill,.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h.sc-market-input-text-s>input:-webkit-autofill,.sc-market-input-text-h .sc-market-input-text-s>input:-webkit-autofill{animation-name:market-input-autofill-start;animation-duration:0.1ms}/*!@:host input:not(:-webkit-autofill), :host ::slotted(input:not(:-webkit-autofill))*/.sc-market-input-text-h input.sc-market-input-text:not(:-webkit-autofill),.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h.sc-market-input-text-s>input:not(:-webkit-autofill),.sc-market-input-text-h .sc-market-input-text-s>input:not(:-webkit-autofill){animation-name:market-input-autofill-cancel;animation-duration:0.1ms}/*!@:host input::-webkit-date-and-time-value*/.sc-market-input-text-h input.sc-market-input-text::-webkit-date-and-time-value{text-align:left}/*!@:host ::slotted(input::-webkit-date-and-time-value)*/.sc-market-input-text-h.sc-market-input-text-s>input,.sc-market-input-text-h .sc-market-input-text-s>input::-webkit-date-and-time-value{text-align:left}";
var MarketInputTextStyle0 = marketInputTextCss;

/**
 * @slot - The main label for the input.
 * @slot leading-accessory - An icon set on the left side of the input.
 * @slot trailing-accessory - An icon set on the right side of the input.
 *
 * @slot input - Can be used to slot your own HTML input, if needed (ex. if supporting browser
 * autofill)
 * @part native-input - The default inner HTML input.
 */
class InputText {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketInputValueChange = createEvent(this, "marketInputValueChange", 7);
        this.marketInputDidLoad = createEvent(this, "marketInputDidLoad", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.hasLeadingAccessory = false;
        this.hasTrailingAccessory = false;
        this.type = 'text';
        this.inputId = undefined;
        this.name = undefined;
        this.value = '';
        this.placeholder = undefined;
        this.maxlength = undefined;
        this.minlength = undefined;
        this.size = 'large';
        this.step = undefined;
        this.min = undefined;
        this.max = undefined;
        this.pattern = undefined;
        this.required = undefined;
        this.readonly = false;
        this.disabled = false;
        this.focused = false;
        this.invalid = false;
        this.inputmode = undefined;
        this.autofocus = false;
        this.autocomplete = true;
        this.autovalidate = false;
        this.autofilled = false;
        this.ariaAttributes = undefined;
    }
    focusedChangeHandler(newValue) {
        if (!this.nativeInput) {
            return;
        }
        if (newValue) {
            this.nativeInput.focus();
        }
    }
    autocompleteWatcher(newValue) {
        this._autocomplete = autocompleteWatcher(newValue);
    }
    handleMarketDialogLoaded() {
        if (this.autofocus) {
            this.setFocus();
        }
    }
    valueDidChange(e) {
        const result = this.marketInputValueChange.emit({
            value: e.target.value,
            originalEvent: e,
        });
        if (result.defaultPrevented) {
            e.target.value = this.value;
            e.preventDefault();
        }
        else {
            this.value = e.target.value;
            this.updateElementInternals();
            if (this.autovalidate || this.validatingThroughSubmission) {
                this.invalid = !this.nativeInput.checkValidity();
            }
        }
        // Once the merchant has entered text, the content is no longer populated
        // via autofill, and should be styled as usual.
        this.autofilled = false;
    }
    handleAutofill(e) {
        // This a hack to detect browser autofill, since there's no event emitted for it.
        // See here for details: https://stackoverflow.com/a/41530164
        if (e.animationName === 'market-input-autofill-start') {
            this.autofilled = true;
        }
        else if (e.animationName === 'market-input-autofill-cancel' && !this.value) {
            this.autofilled = false;
        }
    }
    handleKeyDown(e) {
        if (e.key === 'Enter') {
            // There are cases where the input acts as a trigger for a dropdown for example a dropdown that renders
            // the market-date-picker. In those cases, we want to prevent the form from submitting when the user clicks
            // enter
            if (this.el.slot === 'trigger') {
                e.preventDefault();
            }
            else {
                submitFormImplicitly(this.el);
            }
        }
    }
    /**
     * Handles the invalid submission event of this component.
     * This can happen when the component has been externally
     * checked for validity and does not satisfy the constraints.
     */
    handleSubmissionInvalid(event) {
        event.preventDefault(); // Prevent the default auto focus behavior as this will error out.
        this.validatingThroughSubmission = true;
        this.invalid = !this.nativeInput.checkValidity();
    }
    /**
     * Sets focus styling on `<market-input-text>`. Toggles focus on the inner `<input>` if true, and blurs focus if false.
     */
    setFocus(value = true) {
        if (this.readonly || this.disabled) {
            return Promise.resolve();
        }
        this.focused = value; // this will cause the `focusedChangeHandler` to be triggered
        if (!value && this.nativeInput) {
            this.nativeInput.blur();
        }
        return Promise.resolve();
    }
    /**
     * Returns the native `<input>` element used under the hood.
     */
    getInputElement() {
        return Promise.resolve(this.nativeInput);
    }
    /**
     * Allows passing an alternative light DOM input.
     */
    registerSlottedInput(slottedInput) {
        var _a;
        this.slottedInput =
            slottedInput ||
                // input slotted into market-input-text
                this.el.querySelector('input[slot=input]') ||
                (
                // input slotted into a higher-level component that uses market-input-text
                // (e.g. market-input-password)
                (_a = this.el.getRootNode().host) === null || _a === void 0 ? void 0 : _a.querySelector('input[slot=input]'));
        if (this.slottedInput) {
            this.slottedInput.addEventListener('input', (e) => this.valueDidChange(e));
            this.slottedInput.addEventListener('focus', () => this.setFocus());
            this.slottedInput.addEventListener('blur', () => (this.focused = false));
            this.slottedInput.addEventListener('animationstart', (e) => this.handleAutofill(e));
            this.nativeInput = this.slottedInput;
        }
        return Promise.resolve();
    }
    updateSharedInputProps() {
        const prevSharedProps = Object.assign({}, this.sharedProps);
        // used by the default shadow DOM native input and to copy component properties to slotted inputs
        // conditionally adding key/value pairs based on whether we want to set them on the <input>
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#individual_attributes
        this.sharedProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (this.inputId && { id: this.inputId })), (this.name && { name: this.name })), (this.type && { type: this.type })), (this.placeholder && { placeholder: this.placeholder })), (this.maxlength >= 0 && { maxlength: this.maxlength })), (this.minlength >= 0 && { minlength: this.minlength })), (this.step && { step: this.step })), (this.min && { min: this.min })), (this.max && { max: this.max })), (this.pattern && { pattern: this.pattern })), (this.value !== undefined && { value: this.value })), (this.readonly && { readonly: this.readonly })), (this.required && { required: this.required })), (this.disabled && { disabled: this.disabled })), (this.autofocus && { autofocus: this.autofocus })), (this.inputmode && { inputmode: this.inputmode })), (this._autocomplete && { autocomplete: this._autocomplete })), this.ariaAttributes), { 'aria-label': getTextInputAriaLabel(this.el) });
        // sync component props to slotted input, if one exists
        if (this.slottedInput) {
            const modifiedPropKeys = [...new Set([...Object.keys(prevSharedProps), ...Object.keys(this.sharedProps)])];
            modifiedPropKeys.forEach((key) => {
                if (!(key in this.sharedProps)) {
                    // remove properties that have been unset
                    this.slottedInput.removeAttribute(key);
                }
                else {
                    // boolean attributes can be set using empty strings
                    // https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#javascript
                    const attributeValue = this.sharedProps[key] !== true ? this.sharedProps[key] : '';
                    this.slottedInput.setAttribute(key, attributeValue);
                }
            });
        }
    }
    /**
     * Updates the internal state of this element bound to the surrounding form.
     */
    updateElementInternals() {
        var _a, _b, _c, _d;
        if (!this.internals) {
            return;
        }
        (_b = (_a = this.internals).setFormValue) === null || _b === void 0 ? void 0 : _b.call(_a, this.value);
        if (this.nativeInput) {
            (_d = (_c = this.internals).setValidity) === null || _d === void 0 ? void 0 : _d.call(_c, this.nativeInput.validity, this.nativeInput.validationMessage);
        }
    }
    componentWillLoad() {
        this.hasLeadingAccessory = Boolean([...this.el.children].some((el) => el.slot === 'leading-accessory'));
        this.hasTrailingAccessory = Boolean([...this.el.children].some((el) => el.slot === 'trailing-accessory'));
        // In testing environments like vitest, formAssociated stencil classes aren't fully supported at the moment.
        // This leads to issues like missing functions on the this context of the class. In order to address this
        // we've defined the onMutationObserved callback inline.
        this.mutationObserver = observeAriaAttributes(this.el, (ariaAttributes) => {
            this.ariaAttributes = ariaAttributes;
        });
        this.registerSlottedInput();
        this.autocompleteWatcher(this.autocomplete);
        this.updateSharedInputProps();
        this.updateElementInternals();
    }
    componentDidLoad() {
        this.marketInputDidLoad.emit({ input: this.nativeInput });
    }
    componentWillUpdate() {
        this.updateSharedInputProps();
        this.updateElementInternals();
    }
    disconnectedCallback() {
        var _a;
        (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    render() {
        return (hAsync(Host, { key: '2b00628499d159769decf60369dacf70e7f25e76', class: "market-input-text", onBlur: () => {
                this.focused = false;
            }, onClick: () => {
                this.setFocus();
            }, onFocus: () => {
                this.setFocus();
            }, onKeyDown: (e) => {
                this.handleKeyDown(e);
            }, onInvalid: (e) => {
                this.handleSubmissionInvalid(e);
            } }, hAsync("slot", { key: '4e44ddfc5331ad822c1c23daddbcab7236e2e41f', name: "leading-accessory" }), hAsync("div", { key: '04efd6df745a8d1d72b1dc06d0fbd9127a32a604', class: classNames('label-input-container', {
                'has-leading-accessory': this.hasLeadingAccessory,
                'has-trailing-accessory': this.hasTrailingAccessory,
            }) }, hAsync("slot", { key: 'e03b88c83f61893431f963b2a38796b4687d5cde' }), hAsync("slot", { key: '5d92ec605564a2a9f2b45510a5b1e68f0ede8ebc', name: "input", onSlotchange: () => this.registerSlottedInput() }, !this.slottedInput && (hAsync("input", Object.assign({ key: 'a51c7a88872af608513d780e7798990d7f76d38c', part: "native-input", ref: (input) => (this.nativeInput = input), onInput: (e) => this.valueDidChange(e), onAnimationStart: (e) => this.handleAutofill(e) }, this.sharedProps))))), hAsync("slot", { key: 'fe4dc406e24264c849b098ee7b439b84124717ff', name: "trailing-accessory" })));
    }
    static get formAssociated() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focused": ["focusedChangeHandler"],
        "autocomplete": ["autocompleteWatcher"]
    }; }
    static get style() { return MarketInputTextStyle0; }
    static get cmpMeta() { return {
        "$flags$": 73,
        "$tagName$": "market-input-text",
        "$members$": {
            "type": [513],
            "inputId": [1, "input-id"],
            "name": [1],
            "value": [1537],
            "placeholder": [1],
            "maxlength": [2],
            "minlength": [2],
            "size": [513],
            "step": [1],
            "min": [1],
            "max": [1],
            "pattern": [1],
            "required": [4],
            "readonly": [516],
            "disabled": [516],
            "focused": [1540],
            "invalid": [1540],
            "inputmode": [1],
            "autofocus": [4],
            "autocomplete": [8],
            "autovalidate": [4],
            "autofilled": [1540],
            "ariaAttributes": [32],
            "setFocus": [64],
            "getInputElement": [64],
            "registerSlottedInput": [64]
        },
        "$listeners$": [[8, "marketDialogLoaded", "handleMarketDialogLoaded"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["type", "type"], ["value", "value"], ["size", "size"], ["readonly", "readonly"], ["disabled", "disabled"], ["focused", "focused"], ["invalid", "invalid"], ["autofilled", "autofilled"]]
    }; }
}

const marketAccessoryCss = "/*!@:host, ::slotted(*), **/.sc-market-accessory-h,.sc-market-accessory-s>*,*.sc-market-accessory{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-accessory-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-accessory-h *.sc-market-accessory,.sc-market-accessory-h[disabled].sc-market-accessory-s>*,.sc-market-accessory-h[disabled] .sc-market-accessory-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-accessory-h{display:flex;justify-content:center;align-items:center}/*!@:host([size=\"icon\"])*/[size=\"icon\"].sc-market-accessory-h{width:var(--accessory-icon-variant-medium-size-width);height:var(--accessory-icon-variant-medium-size-height)}/*!@:host([size=\"image\"])*/[size=\"image\"].sc-market-accessory-h{width:var(--accessory-medium-size-width);height:var(--accessory-medium-size-height)}/*!@:host ::slotted(.market-icon)*//*!@:host ::slotted(img)*/.sc-market-accessory-h .sc-market-accessory-s>img{-o-object-fit:cover;object-fit:cover;width:100%;height:100%}/*!@:host([size=\"icon\"]) ::slotted(img)*/.sc-market-accessory-h[size=\"icon\"] .sc-market-accessory-s>img{border-radius:var(--accessory-background-radius)}/*!@:host([size=\"image\"]) ::slotted(img)*/.sc-market-accessory-h[size=\"image\"] .sc-market-accessory-s>img{border-radius:var(--accessory-background-radius)}";
var MarketAccessoryStyle0 = marketAccessoryCss;

/**
 * @slot - Intended for a slotted image or icon.
 */
class MarketAccessory {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.size = undefined;
    }
    /* TODO: add optional height/width props for custom sizing of slotted image */
    render() {
        return (hAsync(Host, { key: 'ce321a0739c785b655c6483c94ace4248f7adcbb', class: "market-accessory", size: this.size }, hAsync("slot", { key: '4190735a507d572868ad9f54da6a6039a66794e5' })));
    }
    static get style() { return MarketAccessoryStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-accessory",
        "$members$": {
            "size": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

// This file is automatically generated. Do not edit.

var cjs = {
  "ACCESSORY_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCESSORY_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ACCESSORY_BACKGROUND_RADIUS": 6,
  "ACCESSORY_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCESSORY_MEDIUM_SIZE_HEIGHT": 40,
  "ACCESSORY_MEDIUM_SIZE_WIDTH": 40,
  "ACCESSORY_LARGE_SIZE_HEIGHT": 64,
  "ACCESSORY_LARGE_SIZE_WIDTH": 64,
  "ACCESSORY_ICON_VARIANT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACCESSORY_ICON_VARIANT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ACCESSORY_ICON_VARIANT_MEDIUM_SIZE_HEIGHT": 24,
  "ACCESSORY_ICON_VARIANT_MEDIUM_SIZE_WIDTH": 24,
  "ACCESSORY_ICON_VARIANT_LARGE_SIZE_HEIGHT": 40,
  "ACCESSORY_ICON_VARIANT_LARGE_SIZE_WIDTH": 40,
  "ACCESSORY_ICON_VARIANT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACCESSORY_INITIALS_VARIANT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCESSORY_INITIALS_VARIANT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_SIZE": 16,
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_LEADING": 24,
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_TRACKING": 0,
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_WEIGHT": 600,
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_CASE": "regular",
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_NUMBER_SPACING": "default",
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_SCALE": "paragraph-30",
  "ACCESSORY_INITIALS_VARIANT_MEDIUM_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_SIZE": 28,
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_LEADING": 40,
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_TRACKING": 0,
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_WEIGHT": 500,
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_CASE": "regular",
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_NUMBER_SPACING": "default",
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_SCALE": "heading-30",
  "ACCESSORY_INITIALS_VARIANT_LARGE_SIZE_TEXT_FONT_FAMILY": "Square Sans Display",
  "ACCESSORY_INITIALS_VARIANT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_DISABLED_STATE_CONTENT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ACCORDION_DISABLED_STATE_CONTENT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ACCORDION_DISABLED_STATE_CONTENT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ACCORDION_DISABLED_STATE_ACCESSORY_OPACITY": 0.5,
  "ACCORDION_DISABLED_STATE_SIDE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ACCORDION_DISABLED_STATE_SIDE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ACCORDION_DISABLED_STATE_SIDE_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ACCORDION_FOCUS_STATE_CONTENT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ACCORDION_FOCUS_STATE_CONTENT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ACCORDION_FOCUS_STATE_CONTENT_COLOR": "rgb(0, 90, 217)",
  "ACCORDION_FOCUS_STATE_ACCESSORY_OPACITY": 1,
  "ACCORDION_FOCUS_STATE_SIDE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_FOCUS_STATE_SIDE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ACCORDION_FOCUS_STATE_SIDE_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_HOVER_STATE_CONTENT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ACCORDION_HOVER_STATE_CONTENT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ACCORDION_HOVER_STATE_CONTENT_COLOR": "rgb(0, 90, 217)",
  "ACCORDION_HOVER_STATE_ACCESSORY_OPACITY": 1,
  "ACCORDION_HOVER_STATE_SIDE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_HOVER_STATE_SIDE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ACCORDION_HOVER_STATE_SIDE_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_NORMAL_STATE_CONTENT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACCORDION_NORMAL_STATE_CONTENT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ACCORDION_NORMAL_STATE_CONTENT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACCORDION_NORMAL_STATE_ACCESSORY_OPACITY": 1,
  "ACCORDION_NORMAL_STATE_SIDE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_NORMAL_STATE_SIDE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ACCORDION_NORMAL_STATE_SIDE_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_PRESSED_STATE_CONTENT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ACCORDION_PRESSED_STATE_CONTENT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ACCORDION_PRESSED_STATE_CONTENT_COLOR": "rgb(0, 90, 217)",
  "ACCORDION_PRESSED_STATE_ACCESSORY_OPACITY": 1,
  "ACCORDION_PRESSED_STATE_SIDE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_PRESSED_STATE_SIDE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ACCORDION_PRESSED_STATE_SIDE_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ACCORDION_HEADING_10_VARIANT_CONTENT_SPACING": 16,
  "ACCORDION_HEADING_10_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCORDION_HEADING_10_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ACCORDION_HEADING_10_VARIANT_SEPARATOR_SIZE": 1,
  "ACCORDION_HEADING_10_VARIANT_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCORDION_HEADING_10_VARIANT_HORIZONTAL_PADDING": 0,
  "ACCORDION_HEADING_10_VARIANT_TEXT_SIZE": 14,
  "ACCORDION_HEADING_10_VARIANT_TEXT_LEADING": 22,
  "ACCORDION_HEADING_10_VARIANT_TEXT_TRACKING": 0,
  "ACCORDION_HEADING_10_VARIANT_TEXT_WEIGHT": 700,
  "ACCORDION_HEADING_10_VARIANT_TEXT_CASE": "regular",
  "ACCORDION_HEADING_10_VARIANT_TEXT_NUMBER_SPACING": "default",
  "ACCORDION_HEADING_10_VARIANT_TEXT_SCALE": "heading-10",
  "ACCORDION_HEADING_10_VARIANT_TEXT_FONT_FAMILY": "Square Sans Text",
  "ACCORDION_HEADING_10_VARIANT_TEXT_IS_HEADER": true,
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_SIZE": 12,
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_LEADING": 18,
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_TRACKING": 0,
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_WEIGHT": 400,
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_CASE": "regular",
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_NUMBER_SPACING": "default",
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_SCALE": "paragraph-10",
  "ACCORDION_HEADING_10_VARIANT_SIDE_TEXT_FONT_FAMILY": "Square Sans Text",
  "ACCORDION_HEADING_10_VARIANT_VERTICAL_PADDING": 13,
  "ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_ICON_ASSET": "chevron-down",
  "ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_ICON_WIDTH": 16,
  "ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_ICON_HEIGHT": 16,
  "ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_ICON_TINTABLE": true,
  "ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_ICON_SEMANTIC_NAME": "expand",
  "ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_SPACING": 8,
  "ACCORDION_HEADING_10_VARIANT_COLLAPSED_PHASE_ICON_ASSET": "chevron-up",
  "ACCORDION_HEADING_10_VARIANT_COLLAPSED_PHASE_ICON_WIDTH": 16,
  "ACCORDION_HEADING_10_VARIANT_COLLAPSED_PHASE_ICON_HEIGHT": 16,
  "ACCORDION_HEADING_10_VARIANT_COLLAPSED_PHASE_ICON_TINTABLE": true,
  "ACCORDION_HEADING_10_VARIANT_COLLAPSED_PHASE_ICON_SEMANTIC_NAME": "collapse",
  "ACCORDION_HEADING_20_VARIANT_CONTENT_SPACING": 16,
  "ACCORDION_HEADING_20_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCORDION_HEADING_20_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ACCORDION_HEADING_20_VARIANT_SEPARATOR_SIZE": 1,
  "ACCORDION_HEADING_20_VARIANT_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCORDION_HEADING_20_VARIANT_HORIZONTAL_PADDING": 0,
  "ACCORDION_HEADING_20_VARIANT_TEXT_SIZE": 19,
  "ACCORDION_HEADING_20_VARIANT_TEXT_LEADING": 26,
  "ACCORDION_HEADING_20_VARIANT_TEXT_TRACKING": 0,
  "ACCORDION_HEADING_20_VARIANT_TEXT_WEIGHT": 700,
  "ACCORDION_HEADING_20_VARIANT_TEXT_CASE": "regular",
  "ACCORDION_HEADING_20_VARIANT_TEXT_NUMBER_SPACING": "default",
  "ACCORDION_HEADING_20_VARIANT_TEXT_SCALE": "heading-20",
  "ACCORDION_HEADING_20_VARIANT_TEXT_FONT_FAMILY": "Square Sans Display",
  "ACCORDION_HEADING_20_VARIANT_TEXT_IS_HEADER": true,
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_SIZE": 14,
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_LEADING": 22,
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_TRACKING": 0,
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_WEIGHT": 400,
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_CASE": "regular",
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_NUMBER_SPACING": "default",
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_SCALE": "paragraph-20",
  "ACCORDION_HEADING_20_VARIANT_SIDE_TEXT_FONT_FAMILY": "Square Sans Text",
  "ACCORDION_HEADING_20_VARIANT_VERTICAL_PADDING": 19,
  "ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_ICON_ASSET": "chevron-down",
  "ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_ICON_WIDTH": 16,
  "ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_ICON_HEIGHT": 16,
  "ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_ICON_TINTABLE": true,
  "ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_ICON_SEMANTIC_NAME": "expand",
  "ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_SPACING": 8,
  "ACCORDION_HEADING_20_VARIANT_COLLAPSED_PHASE_ICON_ASSET": "chevron-up",
  "ACCORDION_HEADING_20_VARIANT_COLLAPSED_PHASE_ICON_WIDTH": 16,
  "ACCORDION_HEADING_20_VARIANT_COLLAPSED_PHASE_ICON_HEIGHT": 16,
  "ACCORDION_HEADING_20_VARIANT_COLLAPSED_PHASE_ICON_TINTABLE": true,
  "ACCORDION_HEADING_20_VARIANT_COLLAPSED_PHASE_ICON_SEMANTIC_NAME": "collapse",
  "ACCORDION_HEADING_30_VARIANT_CONTENT_SPACING": 16,
  "ACCORDION_HEADING_30_VARIANT_HORIZONTAL_PADDING": 0,
  "ACCORDION_HEADING_30_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCORDION_HEADING_30_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ACCORDION_HEADING_30_VARIANT_SEPARATOR_SIZE": 1,
  "ACCORDION_HEADING_30_VARIANT_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ACCORDION_HEADING_30_VARIANT_TEXT_SIZE": 25,
  "ACCORDION_HEADING_30_VARIANT_TEXT_LEADING": 32,
  "ACCORDION_HEADING_30_VARIANT_TEXT_TRACKING": 0,
  "ACCORDION_HEADING_30_VARIANT_TEXT_WEIGHT": 700,
  "ACCORDION_HEADING_30_VARIANT_TEXT_CASE": "regular",
  "ACCORDION_HEADING_30_VARIANT_TEXT_NUMBER_SPACING": "default",
  "ACCORDION_HEADING_30_VARIANT_TEXT_SCALE": "heading-30",
  "ACCORDION_HEADING_30_VARIANT_TEXT_FONT_FAMILY": "Square Sans Display",
  "ACCORDION_HEADING_30_VARIANT_TEXT_IS_HEADER": true,
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_SIZE": 16,
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_LEADING": 24,
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_TRACKING": 0,
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_WEIGHT": 400,
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_CASE": "regular",
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_NUMBER_SPACING": "default",
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_SCALE": "paragraph-30",
  "ACCORDION_HEADING_30_VARIANT_SIDE_TEXT_FONT_FAMILY": "Square Sans Text",
  "ACCORDION_HEADING_30_VARIANT_VERTICAL_PADDING": 24,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_16_FIDELITY_ASSET": "chevron-down",
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_16_FIDELITY_WIDTH": 16,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_16_FIDELITY_HEIGHT": 16,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_16_FIDELITY_TINTABLE": true,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_16_FIDELITY_SEMANTIC_NAME": "expand",
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_ASSET": "chevron-down",
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_WIDTH": 16,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_HEIGHT": 16,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_TINTABLE": true,
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_SEMANTIC_NAME": "expand",
  "ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_SPACING": 8,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_16_FIDELITY_ASSET": "chevron-up",
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_16_FIDELITY_WIDTH": 16,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_16_FIDELITY_HEIGHT": 16,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_16_FIDELITY_TINTABLE": true,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_16_FIDELITY_SEMANTIC_NAME": "collapse",
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_ASSET": "chevron-up",
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_WIDTH": 16,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_HEIGHT": 16,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_TINTABLE": true,
  "ACCORDION_HEADING_30_VARIANT_COLLAPSED_PHASE_ICON_SEMANTIC_NAME": "collapse",
  "ACTION_CARD_BORDER_RADIUS": 6,
  "ACTION_CARD_BORDER_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACTION_CARD_BORDER_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ACTION_CARD_BORDER_HOVER_STATE_WIDTH": 1,
  "ACTION_CARD_BORDER_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACTION_CARD_BORDER_SELECTED_STATE_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_BORDER_SELECTED_STATE_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_BORDER_SELECTED_STATE_WIDTH": 2,
  "ACTION_CARD_BORDER_SELECTED_STATE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_BORDER_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ACTION_CARD_BORDER_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "ACTION_CARD_BORDER_DISABLED_STATE_WIDTH": 1,
  "ACTION_CARD_BORDER_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ACTION_CARD_NORMAL_STATE_CONTENT_OPACITY": 1,
  "ACTION_CARD_NORMAL_STATE_UNSELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ACTION_CARD_NORMAL_STATE_UNSELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "ACTION_CARD_NORMAL_STATE_UNSELECTED_VALUE_BORDER_WIDTH": 1,
  "ACTION_CARD_NORMAL_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "ACTION_CARD_NORMAL_STATE_SELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_NORMAL_STATE_SELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_NORMAL_STATE_SELECTED_VALUE_BORDER_WIDTH": 2,
  "ACTION_CARD_NORMAL_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_HOVER_STATE_CONTENT_OPACITY": 1,
  "ACTION_CARD_HOVER_STATE_UNSELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACTION_CARD_HOVER_STATE_UNSELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ACTION_CARD_HOVER_STATE_UNSELECTED_VALUE_BORDER_WIDTH": 1,
  "ACTION_CARD_HOVER_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACTION_CARD_HOVER_STATE_SELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_HOVER_STATE_SELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_HOVER_STATE_SELECTED_VALUE_BORDER_WIDTH": 2,
  "ACTION_CARD_HOVER_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_ACTIVE_STATE_CONTENT_OPACITY": 1,
  "ACTION_CARD_ACTIVE_STATE_UNSELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_ACTIVE_STATE_UNSELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_ACTIVE_STATE_UNSELECTED_VALUE_BORDER_WIDTH": 1,
  "ACTION_CARD_ACTIVE_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_ACTIVE_STATE_SELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACTION_CARD_ACTIVE_STATE_SELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ACTION_CARD_ACTIVE_STATE_SELECTED_VALUE_BORDER_WIDTH": 2,
  "ACTION_CARD_ACTIVE_STATE_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.9)",
  "ACTION_CARD_DISABLED_STATE_CONTENT_OPACITY": 0.4,
  "ACTION_CARD_DISABLED_STATE_UNSELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ACTION_CARD_DISABLED_STATE_UNSELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "ACTION_CARD_DISABLED_STATE_UNSELECTED_VALUE_BORDER_WIDTH": 1,
  "ACTION_CARD_DISABLED_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "ACTION_CARD_DISABLED_STATE_SELECTED_VALUE_BORDER_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_DISABLED_STATE_SELECTED_VALUE_BORDER_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_DISABLED_STATE_SELECTED_VALUE_BORDER_WIDTH": 2,
  "ACTION_CARD_DISABLED_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "ACTION_CARD_BACKGROUND_DARK_MODE_COLOR": "rgb(20, 20, 20)",
  "ACTION_CARD_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "ACTION_CARD_PADDING_HORIZONTAL_SIZE": 16,
  "ACTION_CARD_PADDING_VERTICAL_SIZE": 16,
  "ACTION_CARD_SPACING": 16,
  "ACTION_CARD_FOCUS_RING_BUFFER_SIZE": 2,
  "ACTION_CARD_FOCUS_RING_BORDER_SIZE": 2,
  "ACTION_CARD_FOCUS_RING_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_FOCUS_RING_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "ACTION_CARD_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ACTIVITY_INDICATOR_BAR_WIDTH": 120,
  "ACTIVITY_INDICATOR_BAR_HEIGHT": 4,
  "ACTIVITY_INDICATOR_BAR_RADIUS": 2,
  "ACTIVITY_INDICATOR_RADIAL_SMALL_SIZE_DIAMETER_SIZE": 20,
  "ACTIVITY_INDICATOR_RADIAL_SMALL_SIZE_STROKE_SIZE": 2,
  "ACTIVITY_INDICATOR_RADIAL_MEDIUM_SIZE_DIAMETER_SIZE": 36,
  "ACTIVITY_INDICATOR_RADIAL_MEDIUM_SIZE_STROKE_SIZE": 4,
  "ACTIVITY_INDICATOR_RADIAL_LARGE_SIZE_DIAMETER_SIZE": 60,
  "ACTIVITY_INDICATOR_RADIAL_LARGE_SIZE_STROKE_SIZE": 6,
  "ACTIVITY_INDICATOR_RADIAL_XLARGE_SIZE_DIAMETER_SIZE": 120,
  "ACTIVITY_INDICATOR_RADIAL_XLARGE_SIZE_STROKE_SIZE": 10,
  "BANNER_BORDER_RADIUS": 6,
  "BANNER_BORDER_WIDTH": 1,
  "BANNER_DISMISS_BUTTON_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_DISMISS_BUTTON_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_DISMISS_BUTTON_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_DISMISS_BUTTON_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "BANNER_DISMISS_BUTTON_PRESSED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "BANNER_DISMISS_BUTTON_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0.55)",
  "BANNER_DISMISS_BUTTON_ICON_ASSET": "x",
  "BANNER_DISMISS_BUTTON_ICON_WIDTH": 24,
  "BANNER_DISMISS_BUTTON_ICON_HEIGHT": 24,
  "BANNER_DISMISS_BUTTON_ICON_TINTABLE": true,
  "BANNER_DISMISS_BUTTON_ICON_SEMANTIC_NAME": "close",
  "BANNER_BUTTON_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_BUTTON_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_BUTTON_SEPARATOR_HEIGHT": 8,
  "BANNER_BUTTON_SEPARATOR_OPACITY": 0.3,
  "BANNER_BUTTON_SEPARATOR_WIDTH": 1,
  "BANNER_BUTTON_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_BUTTON_SPACING": 12,
  "BANNER_BUTTON_TEXT_SIZE": 16,
  "BANNER_BUTTON_TEXT_LEADING": 24,
  "BANNER_BUTTON_TEXT_TRACKING": 0,
  "BANNER_BUTTON_TEXT_WEIGHT": 600,
  "BANNER_BUTTON_TEXT_CASE": "regular",
  "BANNER_BUTTON_TEXT_NUMBER_SPACING": "default",
  "BANNER_BUTTON_TEXT_SCALE": "paragraph-30",
  "BANNER_BUTTON_TEXT_FONT_FAMILY": "Square Sans Text",
  "BANNER_CONTENT_SPACING": 12,
  "BANNER_HORIZONTAL_PADDING": 16,
  "BANNER_ICON_SPACING": 12,
  "BANNER_MULTILINE_SPACING": 12,
  "BANNER_VERTICAL_PADDING": 16,
  "BANNER_TITLE_SIZE": 16,
  "BANNER_TITLE_LEADING": 24,
  "BANNER_TITLE_TRACKING": 0,
  "BANNER_TITLE_WEIGHT": 600,
  "BANNER_TITLE_CASE": "regular",
  "BANNER_TITLE_NUMBER_SPACING": "default",
  "BANNER_TITLE_SCALE": "paragraph-30",
  "BANNER_TITLE_FONT_FAMILY": "Square Sans Text",
  "BANNER_TEXT_SIZE": 16,
  "BANNER_TEXT_LEADING": 24,
  "BANNER_TEXT_TRACKING": 0,
  "BANNER_TEXT_WEIGHT": 400,
  "BANNER_TEXT_CASE": "regular",
  "BANNER_TEXT_NUMBER_SPACING": "default",
  "BANNER_TEXT_SCALE": "paragraph-30",
  "BANNER_TEXT_FONT_FAMILY": "Square Sans Text",
  "BANNER_INFO_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "BANNER_INFO_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "BANNER_INFO_VARIANT_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BANNER_INFO_VARIANT_BORDER_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "BANNER_INFO_VARIANT_BORDER_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "BANNER_INFO_VARIANT_BORDER_COLOR": "rgb(204, 225, 255)",
  "BANNER_INFO_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "BANNER_INFO_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "BANNER_INFO_VARIANT_ICON_ASSET": "i-circle",
  "BANNER_INFO_VARIANT_ICON_COLOR": "rgb(0, 106, 255)",
  "BANNER_INFO_VARIANT_ICON_WIDTH": 24,
  "BANNER_INFO_VARIANT_ICON_HEIGHT": 24,
  "BANNER_INFO_VARIANT_ICON_TINTABLE": true,
  "BANNER_INFO_VARIANT_ICON_SEMANTIC_NAME": "info",
  "BANNER_INFO_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_INFO_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_INFO_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_INFO_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "BANNER_INFO_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "BANNER_INFO_VARIANT_BUTTON_TEXT_COLOR": "rgb(0, 90, 217)",
  "BANNER_INFO_VARIANT_TEXT_LINK_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "BANNER_INFO_VARIANT_TEXT_LINK_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "BANNER_INFO_VARIANT_TEXT_LINK_TEXT_COLOR": "rgb(0, 90, 217)",
  "BANNER_SUCCESS_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(229, 255, 238)",
  "BANNER_SUCCESS_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 51, 17)",
  "BANNER_SUCCESS_VARIANT_BACKGROUND_COLOR": "rgb(229, 255, 238)",
  "BANNER_SUCCESS_VARIANT_BORDER_LIGHT_MODE_COLOR": "rgb(204, 255, 221)",
  "BANNER_SUCCESS_VARIANT_BORDER_DARK_MODE_COLOR": "rgb(0, 89, 30)",
  "BANNER_SUCCESS_VARIANT_BORDER_COLOR": "rgb(204, 255, 221)",
  "BANNER_SUCCESS_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "BANNER_SUCCESS_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "BANNER_SUCCESS_VARIANT_ICON_ASSET": "checkmark-circle",
  "BANNER_SUCCESS_VARIANT_ICON_COLOR": "rgb(0, 178, 59)",
  "BANNER_SUCCESS_VARIANT_ICON_WIDTH": 24,
  "BANNER_SUCCESS_VARIANT_ICON_HEIGHT": 24,
  "BANNER_SUCCESS_VARIANT_ICON_TINTABLE": true,
  "BANNER_SUCCESS_VARIANT_ICON_SEMANTIC_NAME": "success",
  "BANNER_SUCCESS_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_SUCCESS_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_SUCCESS_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_SUCCESS_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "BANNER_SUCCESS_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "BANNER_SUCCESS_VARIANT_BUTTON_TEXT_COLOR": "rgb(0, 125, 42)",
  "BANNER_SUCCESS_VARIANT_TEXT_LINK_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "BANNER_SUCCESS_VARIANT_TEXT_LINK_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "BANNER_SUCCESS_VARIANT_TEXT_LINK_TEXT_COLOR": "rgb(0, 125, 42)",
  "BANNER_WARNING_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "BANNER_WARNING_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 26, 0)",
  "BANNER_WARNING_VARIANT_BACKGROUND_COLOR": "rgb(255, 242, 230)",
  "BANNER_WARNING_VARIANT_BORDER_LIGHT_MODE_COLOR": "rgb(255, 230, 204)",
  "BANNER_WARNING_VARIANT_BORDER_DARK_MODE_COLOR": "rgb(89, 45, 0)",
  "BANNER_WARNING_VARIANT_BORDER_COLOR": "rgb(255, 230, 204)",
  "BANNER_WARNING_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "BANNER_WARNING_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "BANNER_WARNING_VARIANT_ICON_ASSET": "exclamation-circle",
  "BANNER_WARNING_VARIANT_ICON_COLOR": "rgb(255, 159, 64)",
  "BANNER_WARNING_VARIANT_ICON_WIDTH": 24,
  "BANNER_WARNING_VARIANT_ICON_HEIGHT": 24,
  "BANNER_WARNING_VARIANT_ICON_TINTABLE": true,
  "BANNER_WARNING_VARIANT_ICON_SEMANTIC_NAME": "warning",
  "BANNER_WARNING_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_WARNING_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_WARNING_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_WARNING_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "BANNER_WARNING_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "BANNER_WARNING_VARIANT_BUTTON_TEXT_COLOR": "rgb(148, 92, 37)",
  "BANNER_WARNING_VARIANT_TEXT_LINK_TEXT_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "BANNER_WARNING_VARIANT_TEXT_LINK_TEXT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "BANNER_WARNING_VARIANT_TEXT_LINK_TEXT_COLOR": "rgb(148, 92, 37)",
  "BANNER_CRITICAL_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "BANNER_CRITICAL_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "BANNER_CRITICAL_VARIANT_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BANNER_CRITICAL_VARIANT_BORDER_LIGHT_MODE_COLOR": "rgb(255, 204, 213)",
  "BANNER_CRITICAL_VARIANT_BORDER_DARK_MODE_COLOR": "rgb(89, 0, 15)",
  "BANNER_CRITICAL_VARIANT_BORDER_COLOR": "rgb(255, 204, 213)",
  "BANNER_CRITICAL_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "BANNER_CRITICAL_VARIANT_ICON_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "BANNER_CRITICAL_VARIANT_ICON_ASSET": "exclamation-circle",
  "BANNER_CRITICAL_VARIANT_ICON_COLOR": "rgb(204, 0, 35)",
  "BANNER_CRITICAL_VARIANT_ICON_WIDTH": 24,
  "BANNER_CRITICAL_VARIANT_ICON_HEIGHT": 24,
  "BANNER_CRITICAL_VARIANT_ICON_TINTABLE": true,
  "BANNER_CRITICAL_VARIANT_ICON_SEMANTIC_NAME": "warn",
  "BANNER_CRITICAL_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_CRITICAL_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_CRITICAL_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_CRITICAL_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "BANNER_CRITICAL_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "BANNER_CRITICAL_VARIANT_BUTTON_TEXT_COLOR": "rgb(191, 0, 32)",
  "BANNER_CRITICAL_VARIANT_TEXT_LINK_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "BANNER_CRITICAL_VARIANT_TEXT_LINK_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "BANNER_CRITICAL_VARIANT_TEXT_LINK_TEXT_COLOR": "rgb(191, 0, 32)",
  "BANNER_INSIGHT_VARIANT_LIGHT_MODE_BACKGROUND_COLOR": "rgb(244, 230, 255)",
  "BANNER_INSIGHT_VARIANT_LIGHT_MODE_BORDER_COLOR": "rgb(234, 204, 255)",
  "BANNER_INSIGHT_VARIANT_LIGHT_MODE_ICON_COLOR": "rgb(135, 22, 217)",
  "BANNER_INSIGHT_VARIANT_LIGHT_MODE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_INSIGHT_VARIANT_LIGHT_MODE_BUTTON_TEXT_COLOR": "rgb(135, 22, 217)",
  "BANNER_INSIGHT_VARIANT_LIGHT_MODE_TEXT_LINK_TEXT_COLOR": "rgb(135, 22, 217)",
  "BANNER_INSIGHT_VARIANT_DARK_MODE_BACKGROUND_COLOR": "rgb(30, 0, 51)",
  "BANNER_INSIGHT_VARIANT_DARK_MODE_BORDER_COLOR": "rgb(52, 0, 89)",
  "BANNER_INSIGHT_VARIANT_DARK_MODE_ICON_COLOR": "rgb(135, 22, 217)",
  "BANNER_INSIGHT_VARIANT_DARK_MODE_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "BANNER_INSIGHT_VARIANT_DARK_MODE_BUTTON_TEXT_COLOR": "rgb(194, 110, 255)",
  "BANNER_INSIGHT_VARIANT_DARK_MODE_TEXT_LINK_TEXT_COLOR": "rgb(194, 110, 255)",
  "BANNER_INSIGHT_VARIANT_BACKGROUND_COLOR": "rgb(244, 230, 255)",
  "BANNER_INSIGHT_VARIANT_BORDER_COLOR": "rgb(234, 204, 255)",
  "BANNER_INSIGHT_VARIANT_ICON_COLOR": "rgb(135, 22, 217)",
  "BANNER_INSIGHT_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "BANNER_INSIGHT_VARIANT_BUTTON_TEXT_COLOR": "rgb(135, 22, 217)",
  "BANNER_INSIGHT_VARIANT_TEXT_LINK_TEXT_COLOR": "rgb(135, 22, 217)",
  "BUTTON_GROUP_SPACING": 16,
  "BUTTON_GROUP_OVERFLOW_BUTTON_MINIMUM_HEIGHT": 48,
  "BUTTON_GROUP_OVERFLOW_BUTTON_ICON_ASSET": "ellipsis-horizontal",
  "BUTTON_GROUP_OVERFLOW_BUTTON_ICON_WIDTH": 24,
  "BUTTON_GROUP_OVERFLOW_BUTTON_ICON_HEIGHT": 24,
  "BUTTON_GROUP_OVERFLOW_BUTTON_ICON_TINTABLE": true,
  "BUTTON_GROUP_OVERFLOW_BUTTON_ICON_SEMANTIC_NAME": "more",
  "BUTTON_GROUP_OVERFLOW_BUTTON_WIDTH": 48,
  "BUTTON_GROUP_OVERFLOW_BUTTON_SIZE_MULTIPLIER": 1,
  "BUTTON_COMPACT_HORIZONTAL_SIZE_CLASS_SAMPLE_TOKEN": 100,
  "BUTTON_REGULAR_HORIZONTAL_SIZE_CLASS_SAMPLE_TOKEN": 200,
  "BUTTON_WIDE_HORIZONTAL_SIZE_CLASS_SAMPLE_TOKEN": 300,
  "BUTTON_COMPACT_VERTICAL_SIZE_CLASS_SAMPLE_TOKEN_2": 10,
  "BUTTON_REGULAR_VERTICAL_SIZE_CLASS_SAMPLE_TOKEN_2": 20,
  "BUTTON_TALL_VERTICAL_SIZE_CLASS_SAMPLE_TOKEN_2": 30,
  "BUTTON_SMALL_SIZE_MINIMUM_HEIGHT": 40,
  "BUTTON_SMALL_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "BUTTON_SMALL_SIZE_TEXT_SIZE": 14,
  "BUTTON_SMALL_SIZE_TEXT_LEADING": 22,
  "BUTTON_SMALL_SIZE_TEXT_TRACKING": 0,
  "BUTTON_SMALL_SIZE_TEXT_WEIGHT": 600,
  "BUTTON_SMALL_SIZE_TEXT_CASE": "regular",
  "BUTTON_SMALL_SIZE_TEXT_NUMBER_SPACING": "default",
  "BUTTON_SMALL_SIZE_TEXT_SCALE": "paragraph-20",
  "BUTTON_SMALL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "BUTTON_SMALL_SIZE_CONTENT_SPACING": 8,
  "BUTTON_SMALL_SIZE_PRIMARY_RANK_HORIZONTAL_PADDING": 12,
  "BUTTON_SMALL_SIZE_PRIMARY_RANK_VERTICAL_PADDING": 9,
  "BUTTON_SMALL_SIZE_SECONDARY_RANK_HORIZONTAL_PADDING": 12,
  "BUTTON_SMALL_SIZE_SECONDARY_RANK_VERTICAL_PADDING": 9,
  "BUTTON_SMALL_SIZE_TERTIARY_RANK_HORIZONTAL_PADDING": 8,
  "BUTTON_SMALL_SIZE_TERTIARY_RANK_VERTICAL_PADDING": 9,
  "BUTTON_MEDIUM_SIZE_MINIMUM_HEIGHT": 48,
  "BUTTON_MEDIUM_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "BUTTON_MEDIUM_SIZE_TEXT_SIZE": 16,
  "BUTTON_MEDIUM_SIZE_TEXT_LEADING": 24,
  "BUTTON_MEDIUM_SIZE_TEXT_TRACKING": 0,
  "BUTTON_MEDIUM_SIZE_TEXT_WEIGHT": 600,
  "BUTTON_MEDIUM_SIZE_TEXT_CASE": "regular",
  "BUTTON_MEDIUM_SIZE_TEXT_NUMBER_SPACING": "default",
  "BUTTON_MEDIUM_SIZE_TEXT_SCALE": "paragraph-30",
  "BUTTON_MEDIUM_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "BUTTON_MEDIUM_SIZE_CONTENT_SPACING": 8,
  "BUTTON_MEDIUM_SIZE_PRIMARY_RANK_HORIZONTAL_PADDING": 16,
  "BUTTON_MEDIUM_SIZE_PRIMARY_RANK_VERTICAL_PADDING": 12,
  "BUTTON_MEDIUM_SIZE_SECONDARY_RANK_HORIZONTAL_PADDING": 16,
  "BUTTON_MEDIUM_SIZE_SECONDARY_RANK_VERTICAL_PADDING": 12,
  "BUTTON_MEDIUM_SIZE_TERTIARY_RANK_HORIZONTAL_PADDING": 8,
  "BUTTON_MEDIUM_SIZE_TERTIARY_RANK_VERTICAL_PADDING": 12,
  "BUTTON_LARGE_SIZE_MINIMUM_HEIGHT": 64,
  "BUTTON_LARGE_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "BUTTON_LARGE_SIZE_TEXT_SIZE": 16,
  "BUTTON_LARGE_SIZE_TEXT_LEADING": 24,
  "BUTTON_LARGE_SIZE_TEXT_TRACKING": 0,
  "BUTTON_LARGE_SIZE_TEXT_WEIGHT": 600,
  "BUTTON_LARGE_SIZE_TEXT_CASE": "regular",
  "BUTTON_LARGE_SIZE_TEXT_NUMBER_SPACING": "default",
  "BUTTON_LARGE_SIZE_TEXT_SCALE": "paragraph-30",
  "BUTTON_LARGE_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "BUTTON_LARGE_SIZE_CONTENT_SPACING": 8,
  "BUTTON_LARGE_SIZE_PRIMARY_RANK_HORIZONTAL_PADDING": 20,
  "BUTTON_LARGE_SIZE_PRIMARY_RANK_VERTICAL_PADDING": 20,
  "BUTTON_LARGE_SIZE_SECONDARY_RANK_HORIZONTAL_PADDING": 20,
  "BUTTON_LARGE_SIZE_SECONDARY_RANK_VERTICAL_PADDING": 20,
  "BUTTON_LARGE_SIZE_TERTIARY_RANK_HORIZONTAL_PADDING": 8,
  "BUTTON_LARGE_SIZE_TERTIARY_RANK_VERTICAL_PADDING": 20,
  "BUTTON_BORDER_RADIUS": 6,
  "BUTTON_FOCUS_RING_BUFFER_SIZE": 2,
  "BUTTON_FOCUS_RING_BORDER_SIZE": 2,
  "BUTTON_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "BUTTON_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "BUTTON_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(51, 0, 9)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(89, 0, 15)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(51, 0, 9)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(51, 0, 9)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(89, 0, 15)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 90, 118)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(191, 0, 32)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "BUTTON_LOADING_ICON_ASSET": "radial-spinner",
  "BUTTON_LOADING_ICON_WIDTH": 24,
  "BUTTON_LOADING_ICON_HEIGHT": 24,
  "BUTTON_LOADING_ICON_TINTABLE": true,
  "BUTTON_LOADING_ICON_SEMANTIC_NAME": "loading",
  "CALCULATOR_BELOW_DISPLAY_SPACING": 16,
  "CALCULATOR_INTER_BUTTON_VERTICAL_SPACING": 16,
  "CALCULATOR_INTER_BUTTON_HORIZONTAL_SPACING": 16,
  "CALCULATOR_DISPLAY_SMALL_SIZE_SMALL_CALCULATOR_HEIGHT": 48,
  "CALCULATOR_DISPLAY_SMALL_SIZE_LARGE_CALCULATOR_HEIGHT": 80,
  "CALCULATOR_DISPLAY_SMALL_SIZE_HORIZONTAL_PADDING": 20,
  "CALCULATOR_DISPLAY_SMALL_SIZE_VERTICAL_PADDING": 0,
  "CALCULATOR_DISPLAY_LARGE_SIZE_SMALL_CALCULATOR_HEIGHT": 80,
  "CALCULATOR_DISPLAY_LARGE_SIZE_LARGE_CALCULATOR_HEIGHT": 136,
  "CALCULATOR_DISPLAY_LARGE_SIZE_HORIZONTAL_PADDING": 20,
  "CALCULATOR_DISPLAY_LARGE_SIZE_VERTICAL_PADDING": 20,
  "CALCULATOR_DISPLAY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CALCULATOR_DISPLAY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CALCULATOR_DISPLAY_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "CALCULATOR_DISPLAY_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "CALCULATOR_DISPLAY_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "CALCULATOR_DISPLAY_BORDER_STROKE_WIDTH": 1,
  "CALCULATOR_DISPLAY_BORDER_CORNER_RADIUS": 6,
  "CALCULATOR_DISPLAY_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_BACKGROUND_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_FOREGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_FOREGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_FOREGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_FOREGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_FOREGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CALCULATOR_BUTTON_DEFAULT_VARIANT_FOREGROUND_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(0, 85, 204)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 85, 204)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_PRESSED_STATE_COLOR": "rgb(0, 85, 204)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_BACKGROUND_NORMAL_STATE_COLOR": "rgb(0, 106, 255)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_FOREGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_FOREGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_FOREGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_FOREGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_FOREGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "CALCULATOR_BUTTON_PRIMARY_OPERATOR_VARIANT_FOREGROUND_NORMAL_STATE_COLOR": "rgb(255, 255, 255)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_BACKGROUND_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_FOREGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_FOREGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_FOREGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_FOREGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_FOREGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "CALCULATOR_BUTTON_SECONDARY_OPERATOR_VARIANT_FOREGROUND_NORMAL_STATE_COLOR": "rgb(0, 90, 217)",
  "CALCULATOR_BUTTON_BORDER_RADIUS_SIZE": 6,
  "CALCULATOR_BUTTON_ICON_SMALL_CALCULATOR_SIZE": 24,
  "CALCULATOR_BUTTON_ICON_LARGE_CALCULATOR_SIZE": 32,
  "CALCULATOR_BUTTON_SMALL_CALCULATOR_HEIGHT": 48,
  "CALCULATOR_BUTTON_LARGE_CALCULATOR_HEIGHT": 80,
  "CAROUSEL_CONTROL_BAR_VERTICAL_PADDING": 8,
  "CAROUSEL_CONTENT_COMPACT_HORIZONTAL_SIZE_CLASS_PAGE_SPACING": 8,
  "CAROUSEL_CONTENT_REGULAR_HORIZONTAL_SIZE_CLASS_PAGE_SPACING": 16,
  "CAROUSEL_CONTENT_WIDE_HORIZONTAL_SIZE_CLASS_PAGE_SPACING": 16,
  "CHECKBOX_WIDTH": 20,
  "CHECKBOX_HEIGHT": 20,
  "CHECKBOX_BORDER_RADIUS": 4,
  "CHECKBOX_BORDER_SIZE": 2,
  "CHECKBOX_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_RING_BUFFER_SIZE": 2,
  "CHECKBOX_FOCUS_RING_BORDER_SIZE": 2,
  "CHECKBOX_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.35)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_ASSET": "checkmark",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_WIDTH": 20,
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_HEIGHT": 20,
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_TINTABLE": true,
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_SEMANTIC_NAME": "checkmark",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.35)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_ASSET": "indeterminate-mark",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_WIDTH": 20,
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_HEIGHT": 20,
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_TINTABLE": true,
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_SEMANTIC_NAME": "indeterminate",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_NORMAL_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(204, 0, 35)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_HOVER_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(0, 85, 204)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_PRESSED_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(153, 0, 26)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgb(0, 106, 255)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_FOCUS_STATE_INVALID_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgb(178, 0, 30)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.05)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.05)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_UNCHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.35)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_CHECKED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.15)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.05)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.05)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.15)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "CHECKBOX_DISABLED_STATE_NORMAL_VALIDITY_INDETERMINATE_VALUE_ICON_COLOR": "rgba(0, 0, 0, 0.15)",
  "CHOICE_BUTTON_MINIMUM_WIDTH_MULTIPLER": 1.5,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_SIZE": 14,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_LEADING": 22,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_TRACKING": 0,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_WEIGHT": 600,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_CASE": "regular",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_NUMBER_SPACING": "default",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_SCALE": "paragraph-20",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_PRIMARY_FONT_FAMILY": "Square Sans Text",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_SIZE": 14,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_LEADING": 22,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_TRACKING": 0,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_WEIGHT": 400,
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_CASE": "regular",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_NUMBER_SPACING": "default",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_SCALE": "paragraph-20",
  "CHOICE_BUTTON_SMALL_SIZE_TEXT_SECONDARY_FONT_FAMILY": "Square Sans Text",
  "CHOICE_BUTTON_SMALL_SIZE_CONTENT_SPACING": 8,
  "CHOICE_BUTTON_SMALL_SIZE_HORIZONTAL_PADDING": 12,
  "CHOICE_BUTTON_SMALL_SIZE_VERTICAL_PADDING": 9,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_SIZE": 16,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_LEADING": 24,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_TRACKING": 0,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_WEIGHT": 600,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_CASE": "regular",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_NUMBER_SPACING": "default",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_SCALE": "paragraph-30",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_PRIMARY_FONT_FAMILY": "Square Sans Text",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_SIZE": 16,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_LEADING": 24,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_TRACKING": 0,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_WEIGHT": 400,
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_CASE": "regular",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_NUMBER_SPACING": "default",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_SCALE": "paragraph-30",
  "CHOICE_BUTTON_MEDIUM_SIZE_TEXT_SECONDARY_FONT_FAMILY": "Square Sans Text",
  "CHOICE_BUTTON_MEDIUM_SIZE_CONTENT_SPACING": 8,
  "CHOICE_BUTTON_MEDIUM_SIZE_HORIZONTAL_PADDING": 16,
  "CHOICE_BUTTON_MEDIUM_SIZE_VERTICAL_PADDING": 12,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_SIZE": 16,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_LEADING": 24,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_TRACKING": 0,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_WEIGHT": 600,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_CASE": "regular",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_NUMBER_SPACING": "default",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_SCALE": "paragraph-30",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_PRIMARY_FONT_FAMILY": "Square Sans Text",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_SIZE": 16,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_LEADING": 24,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_TRACKING": 0,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_WEIGHT": 400,
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_CASE": "regular",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_NUMBER_SPACING": "default",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_SCALE": "paragraph-30",
  "CHOICE_BUTTON_LARGE_SIZE_TEXT_SECONDARY_FONT_FAMILY": "Square Sans Text",
  "CHOICE_BUTTON_LARGE_SIZE_CONTENT_SPACING": 8,
  "CHOICE_BUTTON_LARGE_SIZE_HORIZONTAL_PADDING": 20,
  "CHOICE_BUTTON_LARGE_SIZE_VERTICAL_PADDING": 20,
  "CHOICE_BUTTON_BORDER_RADIUS": 6,
  "CHOICE_BUTTON_FOCUS_RING_BUFFER_SIZE": 2,
  "CHOICE_BUTTON_FOCUS_RING_BORDER_SIZE": 2,
  "CHOICE_BUTTON_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHOICE_BUTTON_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHOICE_BUTTON_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_HOVER_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "CHOICE_BUTTON_SELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_NORMAL_STATE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_HOVER_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_HOVER_STATE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHOICE_BUTTON_SELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.35)",
  "CHOICE_BUTTON_SELECTED_VALUE_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_PRESSED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHOICE_BUTTON_SELECTED_VALUE_PRESSED_STATE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.15)",
  "CHOICE_BUTTON_SELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_BUTTON_SELECTED_VALUE_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.15)",
  "CHOICE_BUTTON_SELECTED_VALUE_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_BUTTON_SELECTED_VALUE_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.15)",
  "CHOICE_BUTTON_SELECTED_VALUE_DISABLED_STATE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_MINIMUM_WIDTH_MULTIPLER": 1,
  "CHOICE_ICON_BUTTON_SMALL_SIZE_HORIZONTAL_PADDING": 8,
  "CHOICE_ICON_BUTTON_SMALL_SIZE_VERTICAL_PADDING": 8,
  "CHOICE_ICON_BUTTON_MEDIUM_SIZE_HORIZONTAL_PADDING": 12,
  "CHOICE_ICON_BUTTON_MEDIUM_SIZE_VERTICAL_PADDING": 12,
  "CHOICE_ICON_BUTTON_LARGE_SIZE_HORIZONTAL_PADDING": 16,
  "CHOICE_ICON_BUTTON_LARGE_SIZE_VERTICAL_PADDING": 16,
  "CHOICE_ICON_BUTTON_BORDER_RADIUS": 6,
  "CHOICE_ICON_BUTTON_FOCUS_RING_BUFFER_SIZE": 2,
  "CHOICE_ICON_BUTTON_FOCUS_RING_BORDER_SIZE": 2,
  "CHOICE_ICON_BUTTON_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHOICE_ICON_BUTTON_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHOICE_ICON_BUTTON_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "CHOICE_ICON_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_NORMAL_STATE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_HOVER_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_HOVER_STATE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.35)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_PRESSED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_PRESSED_STATE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.15)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.15)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.15)",
  "CHOICE_ICON_BUTTON_SELECTED_VALUE_DISABLED_STATE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "COLOR_PICKER_VERTICAL_SPACING": 16,
  "COLOR_PICKER_DOTS_SIZE": 40,
  "COLOR_PICKER_DOTS_HORIZONTAL_SPACING": 14,
  "COLOR_PICKER_DOTS_VERTICAL_SPACING": 16,
  "COLOR_PICKER_DOTS_ICON_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "COLOR_PICKER_DOTS_ICON_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "COLOR_PICKER_DOTS_ICON_SIZE": 24,
  "COLOR_PICKER_DOTS_ICON_ASSET": "checkmark",
  "COLOR_PICKER_DOTS_ICON_COLOR": "rgb(255, 255, 255)",
  "COLOR_PICKER_DOTS_ICON_WIDTH": 20,
  "COLOR_PICKER_DOTS_ICON_HEIGHT": 20,
  "COLOR_PICKER_DOTS_ICON_TINTABLE": true,
  "COLOR_PICKER_DOTS_ICON_SEMANTIC_NAME": "checkmark",
  "COLOR_PICKER_ADJUSTMENTS_HUE_RADIUS": 6,
  "COLOR_PICKER_ADJUSTMENTS_HUE_MIN_HEIGHT": 40,
  "COLOR_PICKER_ADJUSTMENTS_SATURATION_BRIGHTNESS_RADIUS": 12,
  "COLOR_PICKER_ADJUSTMENTS_SATURATION_BRIGHTNESS_MIN_HEIGHT": 200,
  "COLOR_PICKER_ADJUSTMENTS_SCRUBBER_SIZE": 16,
  "COLOR_PICKER_ADJUSTMENTS_SCRUBBER_WIDTH": 2,
  "COLOR_PICKER_ADJUSTMENTS_SCRUBBER_PADDING": 4,
  "COLOR_PICKER_ADJUSTMENTS_SCRUBBER_MULTIPLIER": 1.25,
  "COMBOBOX_TAGS_HORIZONTAL_SPACING": 8,
  "CONTENT_CARD_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "CONTENT_CARD_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "CONTENT_CARD_BORDER_WIDTH": 1,
  "CONTENT_CARD_BORDER_RADIUS": 6,
  "CONTENT_CARD_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "CONTENT_CARD_PADDING_HORIZONTAL_SIZE": 16,
  "CONTENT_CARD_PADDING_VERTICAL_SIZE": 16,
  "CONTENT_CARD_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CONTENT_CARD_BACKGROUND_DARK_MODE_COLOR": "rgb(20, 20, 20)",
  "CONTENT_CARD_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "DATE_PICKER_MINIMUM_WIDTH": 280,
  "DATE_PICKER_HEADER_FONT_SIZE": 25,
  "DATE_PICKER_HEADER_FONT_LEADING": 32,
  "DATE_PICKER_HEADER_FONT_TRACKING": 0,
  "DATE_PICKER_HEADER_FONT_WEIGHT": 700,
  "DATE_PICKER_HEADER_FONT_CASE": "regular",
  "DATE_PICKER_HEADER_FONT_NUMBER_SPACING": "default",
  "DATE_PICKER_HEADER_FONT_SCALE": "heading-30",
  "DATE_PICKER_HEADER_FONT_FONT_FAMILY": "Square Sans Display",
  "DATE_PICKER_HEADER_FONT_IS_HEADER": true,
  "DATE_PICKER_HEADER_COLOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_HEADER_COLOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_HEADER_COLOR_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_HEADER_MINIMUM_HEIGHT": 40,
  "DATE_PICKER_HEADER_VERTICAL_SPACING": 16,
  "DATE_PICKER_HEADER_BUTTON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_HEADER_BUTTON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_HEADER_BUTTON_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "DATE_PICKER_HEADER_BUTTON_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "DATE_PICKER_HEADER_BUTTON_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DATE_PICKER_HEADER_BUTTON_BORDER_RADIUS": 6,
  "DATE_PICKER_HEADER_BUTTON_PREVIOUS_YEAR_ICON_ASSET": "arrow-left",
  "DATE_PICKER_HEADER_BUTTON_PREVIOUS_YEAR_ICON_WIDTH": 24,
  "DATE_PICKER_HEADER_BUTTON_PREVIOUS_YEAR_ICON_HEIGHT": 24,
  "DATE_PICKER_HEADER_BUTTON_PREVIOUS_YEAR_ICON_TINTABLE": true,
  "DATE_PICKER_HEADER_BUTTON_PREVIOUS_YEAR_ICON_SEMANTIC_NAME": "previous",
  "DATE_PICKER_HEADER_BUTTON_NEXT_YEAR_ICON_ASSET": "arrow-right",
  "DATE_PICKER_HEADER_BUTTON_NEXT_YEAR_ICON_WIDTH": 24,
  "DATE_PICKER_HEADER_BUTTON_NEXT_YEAR_ICON_HEIGHT": 24,
  "DATE_PICKER_HEADER_BUTTON_NEXT_YEAR_ICON_TINTABLE": true,
  "DATE_PICKER_HEADER_BUTTON_NEXT_YEAR_ICON_SEMANTIC_NAME": "next",
  "DATE_PICKER_HEADER_BUTTON_PADDING": 8,
  "DATE_PICKER_HEADER_BUTTON_HORIZONTAL_SPACING": 16,
  "DATE_PICKER_HEADER_BUTTON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_GRID_ITEM_WIDTH": 40,
  "DATE_PICKER_GRID_ITEM_HEIGHT": 40,
  "DATE_PICKER_GRID_ITEM_VERTICAL_PADDING": 8,
  "DATE_PICKER_GRID_ITEM_HORIZONTAL_PADDING": 0,
  "DATE_PICKER_WEEKDAYS_FONT_SIZE": 16,
  "DATE_PICKER_WEEKDAYS_FONT_LEADING": 24,
  "DATE_PICKER_WEEKDAYS_FONT_TRACKING": 0,
  "DATE_PICKER_WEEKDAYS_FONT_WEIGHT": 400,
  "DATE_PICKER_WEEKDAYS_FONT_CASE": "regular",
  "DATE_PICKER_WEEKDAYS_FONT_NUMBER_SPACING": "default",
  "DATE_PICKER_WEEKDAYS_FONT_SCALE": "paragraph-30",
  "DATE_PICKER_WEEKDAYS_FONT_FONT_FAMILY": "Square Sans Text",
  "DATE_PICKER_WEEKDAYS_COLOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "DATE_PICKER_WEEKDAYS_COLOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "DATE_PICKER_WEEKDAYS_COLOR_COLOR": "rgba(0, 0, 0, 0.55)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_NORMAL_STATE_COLOR": "rgb(255, 255, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_DISABLED_STATE_COLOR": "rgb(255, 255, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_HOVER_STATE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "DATE_PICKER_DATE_BACKGROUND_UNSELECTED_SELECTION_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_HOVER_STATE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_FIRST_SELECTION_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_HOVER_STATE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_MIDDLE_SELECTION_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_HOVER_STATE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "DATE_PICKER_DATE_BACKGROUND_RANGE_LAST_SELECTION_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_HOVER_STATE_COLOR": "rgb(230, 240, 255)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "DATE_PICKER_DATE_BACKGROUND_SINGLE_SELECTION_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_UNSELECTED_SELECTION_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_NORMAL_STATE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_DISABLED_STATE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_FIRST_SELECTION_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_MIDDLE_SELECTION_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_NORMAL_STATE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_DISABLED_STATE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_RANGE_LAST_SELECTION_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_NORMAL_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_NORMAL_STATE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_DISABLED_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_DISABLED_STATE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_PRESSED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_DATE_TEXT_SINGLE_SELECTION_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_DATE_BORDER_RADIUS": 6,
  "DATE_PICKER_DATE_BORDER_NORMAL_STATE_BORDER": 2,
  "DATE_PICKER_DATE_BORDER_NORMAL_STATE_COLOR_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "DATE_PICKER_DATE_BORDER_NORMAL_STATE_COLOR_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "DATE_PICKER_DATE_BORDER_NORMAL_STATE_COLOR_COLOR": "rgb(0, 106, 255)",
  "DATE_PICKER_DATE_BORDER_NORMAL_STATE_OPACITY": 0,
  "DATE_PICKER_DATE_BORDER_FOCUSED_STATE_BORDER": 2,
  "DATE_PICKER_DATE_BORDER_FOCUSED_STATE_COLOR_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "DATE_PICKER_DATE_BORDER_FOCUSED_STATE_COLOR_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "DATE_PICKER_DATE_BORDER_FOCUSED_STATE_COLOR_COLOR": "rgb(0, 106, 255)",
  "DATE_PICKER_DATE_BORDER_FOCUSED_STATE_OPACITY": 1,
  "DATE_PICKER_DATE_BORDER_DISABLED_STATE_COLOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_DATE_BORDER_DISABLED_STATE_COLOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "DATE_PICKER_DATE_BORDER_DISABLED_STATE_COLOR_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_TODAY_BORDER_WIDTH": 1,
  "DATE_PICKER_TODAY_BORDER_COLOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_TODAY_BORDER_COLOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "DATE_PICKER_TODAY_BORDER_COLOR_COLOR": "rgba(0, 0, 0, 0.9)",
  "DATE_PICKER_TODAY_FONT_SIZE": 16,
  "DATE_PICKER_TODAY_FONT_LEADING": 24,
  "DATE_PICKER_TODAY_FONT_TRACKING": 0,
  "DATE_PICKER_TODAY_FONT_WEIGHT": 600,
  "DATE_PICKER_TODAY_FONT_CASE": "regular",
  "DATE_PICKER_TODAY_FONT_NUMBER_SPACING": "default",
  "DATE_PICKER_TODAY_FONT_SCALE": "paragraph-30",
  "DATE_PICKER_TODAY_FONT_FONT_FAMILY": "Square Sans Text",
  "DATE_PICKER_TODAY_LABEL_DISABLED_STATE_COLOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_TODAY_LABEL_DISABLED_STATE_COLOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "DATE_PICKER_TODAY_LABEL_DISABLED_STATE_COLOR_COLOR": "rgba(0, 0, 0, 0.15)",
  "DATE_PICKER_MENU_TEXT_SIZE": 16,
  "DATE_PICKER_MENU_TEXT_LEADING": 24,
  "DATE_PICKER_MENU_TEXT_TRACKING": 0,
  "DATE_PICKER_MENU_TEXT_WEIGHT": 600,
  "DATE_PICKER_MENU_TEXT_CASE": "regular",
  "DATE_PICKER_MENU_TEXT_NUMBER_SPACING": "default",
  "DATE_PICKER_MENU_TEXT_SCALE": "paragraph-30",
  "DATE_PICKER_MENU_TEXT_FONT_FAMILY": "Square Sans Text",
  "DATE_PICKER_MENU_ROW_LABEL_SELECTED_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "DATE_PICKER_MENU_ROW_LABEL_SELECTED_STATE_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "DATE_PICKER_MENU_ROW_LABEL_SELECTED_STATE_TEXT_COLOR": "rgb(0, 90, 217)",
  "DATE_PICKER_MENU_ROW_HEIGHT": 48,
  "DATE_PICKER_MENU_ROW_WIDTH": 111,
  "DATE_PICKER_MENU_HORIZONTAL_SPACING": 32,
  "DATE_PICKER_MENU_VERTICAL_SPACING": 24,
  "DIVIDER_FILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "DIVIDER_FILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "DIVIDER_FILL_COLOR": "rgba(0, 0, 0, 0.05)",
  "DIVIDER_HEIGHT": 8,
  "DIVIDER_THIN_SIZE_HEIGHT": 1,
  "DIVIDER_THICK_SIZE_HEIGHT": 8,
  "DIVIDER_RADIUS": 2,
  "DIVIDER_EXTRA_SMALL_VARIANT_VERTICAL_PADDING": 0,
  "DIVIDER_SMALL_VARIANT_VERTICAL_PADDING": 8,
  "DIVIDER_MEDIUM_VARIANT_VERTICAL_PADDING": 16,
  "DIVIDER_LARGE_VARIANT_VERTICAL_PADDING": 32,
  "DROPDOWN_BUTTON_SMALL_SIZE_MINIMUM_HEIGHT": 40,
  "DROPDOWN_BUTTON_SMALL_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_SIZE": 14,
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_LEADING": 22,
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_TRACKING": 0,
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_WEIGHT": 600,
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_CASE": "regular",
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_NUMBER_SPACING": "default",
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_SCALE": "paragraph-20",
  "DROPDOWN_BUTTON_SMALL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "DROPDOWN_BUTTON_SMALL_SIZE_CONTENT_SPACING": 8,
  "DROPDOWN_BUTTON_SMALL_SIZE_PRIMARY_RANK_HORIZONTAL_PADDING": 12,
  "DROPDOWN_BUTTON_SMALL_SIZE_PRIMARY_RANK_VERTICAL_PADDING": 9,
  "DROPDOWN_BUTTON_SMALL_SIZE_SECONDARY_RANK_HORIZONTAL_PADDING": 12,
  "DROPDOWN_BUTTON_SMALL_SIZE_SECONDARY_RANK_VERTICAL_PADDING": 9,
  "DROPDOWN_BUTTON_SMALL_SIZE_TERTIARY_RANK_HORIZONTAL_PADDING": 8,
  "DROPDOWN_BUTTON_SMALL_SIZE_TERTIARY_RANK_VERTICAL_PADDING": 9,
  "DROPDOWN_BUTTON_SMALL_SIZE_CARET_ICON_ASSET": "chevron-down",
  "DROPDOWN_BUTTON_SMALL_SIZE_CARET_ICON_WIDTH": 16,
  "DROPDOWN_BUTTON_SMALL_SIZE_CARET_ICON_HEIGHT": 16,
  "DROPDOWN_BUTTON_SMALL_SIZE_CARET_ICON_TINTABLE": true,
  "DROPDOWN_BUTTON_SMALL_SIZE_CARET_ICON_SEMANTIC_NAME": "expand",
  "DROPDOWN_BUTTON_MEDIUM_SIZE_MINIMUM_HEIGHT": 48,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_SIZE": 16,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_LEADING": 24,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_TRACKING": 0,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_WEIGHT": 600,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_CASE": "regular",
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_NUMBER_SPACING": "default",
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_SCALE": "paragraph-30",
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "DROPDOWN_BUTTON_MEDIUM_SIZE_CONTENT_SPACING": 8,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_PRIMARY_RANK_HORIZONTAL_PADDING": 16,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_PRIMARY_RANK_VERTICAL_PADDING": 12,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_SECONDARY_RANK_HORIZONTAL_PADDING": 16,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_SECONDARY_RANK_VERTICAL_PADDING": 12,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TERTIARY_RANK_HORIZONTAL_PADDING": 8,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_TERTIARY_RANK_VERTICAL_PADDING": 12,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_CARET_ICON_ASSET": "chevron-down",
  "DROPDOWN_BUTTON_MEDIUM_SIZE_CARET_ICON_WIDTH": 16,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_CARET_ICON_HEIGHT": 16,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_CARET_ICON_TINTABLE": true,
  "DROPDOWN_BUTTON_MEDIUM_SIZE_CARET_ICON_SEMANTIC_NAME": "expand",
  "DROPDOWN_BUTTON_LARGE_SIZE_MINIMUM_HEIGHT": 64,
  "DROPDOWN_BUTTON_LARGE_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_SIZE": 16,
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_LEADING": 24,
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_TRACKING": 0,
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_WEIGHT": 600,
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_CASE": "regular",
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_NUMBER_SPACING": "default",
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_SCALE": "paragraph-30",
  "DROPDOWN_BUTTON_LARGE_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "DROPDOWN_BUTTON_LARGE_SIZE_CONTENT_SPACING": 8,
  "DROPDOWN_BUTTON_LARGE_SIZE_PRIMARY_RANK_HORIZONTAL_PADDING": 20,
  "DROPDOWN_BUTTON_LARGE_SIZE_PRIMARY_RANK_VERTICAL_PADDING": 20,
  "DROPDOWN_BUTTON_LARGE_SIZE_SECONDARY_RANK_HORIZONTAL_PADDING": 20,
  "DROPDOWN_BUTTON_LARGE_SIZE_SECONDARY_RANK_VERTICAL_PADDING": 20,
  "DROPDOWN_BUTTON_LARGE_SIZE_TERTIARY_RANK_HORIZONTAL_PADDING": 8,
  "DROPDOWN_BUTTON_LARGE_SIZE_TERTIARY_RANK_VERTICAL_PADDING": 20,
  "DROPDOWN_BUTTON_LARGE_SIZE_CARET_ICON_ASSET": "chevron-down",
  "DROPDOWN_BUTTON_LARGE_SIZE_CARET_ICON_WIDTH": 16,
  "DROPDOWN_BUTTON_LARGE_SIZE_CARET_ICON_HEIGHT": 16,
  "DROPDOWN_BUTTON_LARGE_SIZE_CARET_ICON_TINTABLE": true,
  "DROPDOWN_BUTTON_LARGE_SIZE_CARET_ICON_SEMANTIC_NAME": "expand",
  "DROPDOWN_BUTTON_BORDER_RADIUS": 6,
  "DROPDOWN_BUTTON_FOCUS_RING_BUFFER_SIZE": 2,
  "DROPDOWN_BUTTON_FOCUS_RING_BORDER_SIZE": 2,
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(255, 255, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_NORMAL_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_HOVER_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_PRESSED_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgb(74, 149, 255)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_FOCUS_STATE_LABEL_COLOR": "rgb(0, 90, 217)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "DROPDOWN_BUTTON_NORMAL_VARIANT_TERTIARY_RANK_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_ICON_BUTTON_SMALL_SIZE_MINIMUM_HEIGHT": 40,
  "DROPDOWN_ICON_BUTTON_SMALL_SIZE_WIDTH_MULTIPLIER": 1,
  "DROPDOWN_ICON_BUTTON_SMALL_SIZE_PADDING_SIZE": 8,
  "DROPDOWN_ICON_BUTTON_MEDIUM_SIZE_MINIMUM_HEIGHT": 48,
  "DROPDOWN_ICON_BUTTON_MEDIUM_SIZE_WIDTH_MULTIPLIER": 1,
  "DROPDOWN_ICON_BUTTON_MEDIUM_SIZE_PADDING_SIZE": 12,
  "DROPDOWN_ICON_BUTTON_MEDIUM_SIZE_HORIZONTAL_SPACING_SIZE": 8,
  "DROPDOWN_ICON_BUTTON_LARGE_SIZE_MINIMUM_HEIGHT": 64,
  "DROPDOWN_ICON_BUTTON_LARGE_SIZE_WIDTH_MULTIPLIER": 1,
  "DROPDOWN_ICON_BUTTON_LARGE_SIZE_PADDING_SIZE": 20,
  "DROPDOWN_ICON_BUTTON_BORDER_RADIUS": 6,
  "DROPDOWN_ICON_BUTTON_FOCUS_RING_BUFFER_SIZE": 2,
  "DROPDOWN_ICON_BUTTON_FOCUS_RING_BORDER_SIZE": 2,
  "DROPDOWN_ICON_BUTTON_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_ICON_BUTTON_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "DROPDOWN_ICON_BUTTON_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "DROPDOWN_ICON_BUTTON_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_ICON_BUTTON_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_ICON_BUTTON_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "DROPDOWN_ICON_BUTTON_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "DROPDOWN_ICON_BUTTON_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_ICON_BUTTON_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "DROPDOWN_ICON_BUTTON_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "DROPDOWN_ICON_BUTTON_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "DROPDOWN_ICON_BUTTON_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "DROPDOWN_ICON_BUTTON_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_ICON_BUTTON_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "DROPDOWN_ICON_BUTTON_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "DROPDOWN_ICON_BUTTON_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "DROPDOWN_ICON_BUTTON_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "DROPDOWN_ICON_BUTTON_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_ICON_BUTTON_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "DROPDOWN_ICON_BUTTON_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "DROPDOWN_ICON_BUTTON_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "DROPDOWN_ICON_BUTTON_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "DROPDOWN_ICON_BUTTON_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "EMPTY_STATE_HEADING_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "EMPTY_STATE_HEADING_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "EMPTY_STATE_HEADING_TEXT_SIZE": 19,
  "EMPTY_STATE_HEADING_TEXT_LEADING": 26,
  "EMPTY_STATE_HEADING_TEXT_TRACKING": 0,
  "EMPTY_STATE_HEADING_TEXT_WEIGHT": 700,
  "EMPTY_STATE_HEADING_TEXT_CASE": "regular",
  "EMPTY_STATE_HEADING_TEXT_NUMBER_SPACING": "default",
  "EMPTY_STATE_HEADING_TEXT_SCALE": "heading-20",
  "EMPTY_STATE_HEADING_TEXT_FONT_FAMILY": "Square Sans Display",
  "EMPTY_STATE_HEADING_TEXT_IS_HEADER": true,
  "EMPTY_STATE_HEADING_COLOR": "rgba(0, 0, 0, 0.9)",
  "EMPTY_STATE_PARAGRAPH_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "EMPTY_STATE_PARAGRAPH_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "EMPTY_STATE_PARAGRAPH_TEXT_SIZE": 16,
  "EMPTY_STATE_PARAGRAPH_TEXT_LEADING": 24,
  "EMPTY_STATE_PARAGRAPH_TEXT_TRACKING": 0,
  "EMPTY_STATE_PARAGRAPH_TEXT_WEIGHT": 400,
  "EMPTY_STATE_PARAGRAPH_TEXT_CASE": "regular",
  "EMPTY_STATE_PARAGRAPH_TEXT_NUMBER_SPACING": "default",
  "EMPTY_STATE_PARAGRAPH_TEXT_SCALE": "paragraph-30",
  "EMPTY_STATE_PARAGRAPH_TEXT_FONT_FAMILY": "Square Sans Text",
  "EMPTY_STATE_PARAGRAPH_VERTICAL_SPACING": 8,
  "EMPTY_STATE_PARAGRAPH_COLOR": "rgba(0, 0, 0, 0.9)",
  "EMPTY_STATE_BUTTON_GROUP_VERTICAL_SPACING": 32,
  "EMPTY_STATE_HORIZONTAL_PADDING": 32,
  "EMPTY_STATE_VERTICAL_PADDING": 32,
  "EMPTY_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "EMPTY_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(20, 20, 20)",
  "EMPTY_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "EMPTY_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "EMPTY_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "EMPTY_STATE_BORDER_RADIUS": 6,
  "EMPTY_STATE_BORDER_WIDTH": 1,
  "EMPTY_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "FIELD_BORDER_RADIUS": 6,
  "FIELD_BORDER_SIZE": 1,
  "FIELD_ACTION_TEXT_SIZE": 14,
  "FIELD_ACTION_TEXT_LEADING": 22,
  "FIELD_ACTION_TEXT_TRACKING": 0,
  "FIELD_ACTION_TEXT_WEIGHT": 600,
  "FIELD_ACTION_TEXT_CASE": "regular",
  "FIELD_ACTION_TEXT_NUMBER_SPACING": "default",
  "FIELD_ACTION_TEXT_SCALE": "paragraph-20",
  "FIELD_ACTION_TEXT_FONT_FAMILY": "Square Sans Text",
  "FIELD_ACTION_TEXT_COLOR": "rgb(0, 106, 255)",
  "FIELD_ACTION_VERTICAL_PADDING_SIZE": 8,
  "FIELD_ERROR_MESSAGE_ICON_ASSET": "exclamation-circle",
  "FIELD_ERROR_MESSAGE_ICON_HEIGHT": 24,
  "FIELD_ERROR_MESSAGE_ICON_WIDTH": 24,
  "FIELD_ERROR_MESSAGE_ICON_BUFFER_SIZE": 8,
  "FIELD_ERROR_MESSAGE_ICON_VERTICAL_SPACING": 8,
  "FIELD_ERROR_MESSAGE_ICON_TINTABLE": true,
  "FIELD_ERROR_MESSAGE_ICON_SEMANTIC_NAME": "warn",
  "FIELD_ERROR_MESSAGE_TEXT_SIZE": 14,
  "FIELD_ERROR_MESSAGE_TEXT_LEADING": 22,
  "FIELD_ERROR_MESSAGE_TEXT_TRACKING": 0,
  "FIELD_ERROR_MESSAGE_TEXT_WEIGHT": 400,
  "FIELD_ERROR_MESSAGE_TEXT_CASE": "regular",
  "FIELD_ERROR_MESSAGE_TEXT_NUMBER_SPACING": "default",
  "FIELD_ERROR_MESSAGE_TEXT_SCALE": "paragraph-20",
  "FIELD_ERROR_MESSAGE_TEXT_FONT_FAMILY": "Square Sans Text",
  "FIELD_ERROR_MESSAGE_TEXT_VERTICAL_SPACING": 8,
  "FIELD_ERROR_MESSAGE_TEXT_COLOR": "rgb(191, 0, 32)",
  "FIELD_HELPER_TEXT_SIZE": 14,
  "FIELD_HELPER_TEXT_LEADING": 22,
  "FIELD_HELPER_TEXT_TRACKING": 0,
  "FIELD_HELPER_TEXT_WEIGHT": 400,
  "FIELD_HELPER_TEXT_CASE": "regular",
  "FIELD_HELPER_TEXT_NUMBER_SPACING": "default",
  "FIELD_HELPER_TEXT_SCALE": "paragraph-20",
  "FIELD_HELPER_TEXT_FONT_FAMILY": "Square Sans Text",
  "FIELD_HELPER_TEXT_HORIZONTAL_SPACING": 0,
  "FIELD_HELPER_TEXT_VERTICAL_SPACING": 8,
  "FIELD_HELPER_TEXT_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_ICON_ASSET": "i-circle",
  "FIELD_ICON_BUFFER_SIZE": 16,
  "FIELD_ICON_HEIGHT": 24,
  "FIELD_ICON_WIDTH": 24,
  "FIELD_ICON_TINTABLE": true,
  "FIELD_ICON_SEMANTIC_NAME": "info",
  "FIELD_IMAGE_ACCESSORY_SPACING_LEFT_SIZE": 12,
  "FIELD_INPUT_SIZE": 16,
  "FIELD_INPUT_LEADING": 24,
  "FIELD_INPUT_TRACKING": 0,
  "FIELD_INPUT_WEIGHT": 400,
  "FIELD_INPUT_CASE": "regular",
  "FIELD_INPUT_NUMBER_SPACING": "default",
  "FIELD_INPUT_SCALE": "paragraph-30",
  "FIELD_INPUT_FONT_FAMILY": "Square Sans Text",
  "FIELD_TRAILING_ACCESSORY_BUFFER_SIZE": 16,
  "FIELD_TRAILING_ACCESSORY_HEIGHT": 48,
  "FIELD_TRAILING_ACCESSORY_WIDTH": 48,
  "FIELD_TRAILING_ACCESSORY_POSITION_BOTTOM_SIZE": 8,
  "FIELD_TRAILING_ACCESSORY_POSITION_RIGHT_SIZE": 0,
  "FIELD_LIGHT_MODE_ACTION_TEXT_COLOR": "rgb(0, 106, 255)",
  "FIELD_LIGHT_MODE_ERROR_MESSAGE_TEXT_COLOR": "rgb(191, 0, 32)",
  "FIELD_LIGHT_MODE_HELPER_TEXT_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_LIGHT_MODE_PLACEHOLDER_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_DARK_MODE_ACTION_TEXT_COLOR": "rgb(0, 106, 255)",
  "FIELD_DARK_MODE_ERROR_MESSAGE_TEXT_COLOR": "rgb(255, 90, 118)",
  "FIELD_DARK_MODE_HELPER_TEXT_TEXT_COLOR": "rgba(255, 255, 255, 0.55)",
  "FIELD_DARK_MODE_PLACEHOLDER_TEXT_COLOR": "rgba(255, 255, 255, 0.55)",
  "FIELD_EMPTY_PHASE_LABEL_TEXT_SIZE": 16,
  "FIELD_EMPTY_PHASE_LABEL_TEXT_LEADING": 24,
  "FIELD_EMPTY_PHASE_LABEL_TEXT_TRACKING": 0,
  "FIELD_EMPTY_PHASE_LABEL_TEXT_WEIGHT": 400,
  "FIELD_EMPTY_PHASE_LABEL_TEXT_CASE": "regular",
  "FIELD_EMPTY_PHASE_LABEL_TEXT_NUMBER_SPACING": "default",
  "FIELD_EMPTY_PHASE_LABEL_TEXT_SCALE": "paragraph-30",
  "FIELD_EMPTY_PHASE_LABEL_TEXT_FONT_FAMILY": "Square Sans Text",
  "FIELD_EMPTY_PHASE_HORIZONTAL_PADDING_SIZE": 16,
  "FIELD_EMPTY_PHASE_VERTICAL_PADDING_SIZE": 20,
  "FIELD_FLOAT_PHASE_LABEL_TEXT_SIZE": 14,
  "FIELD_FLOAT_PHASE_LABEL_TEXT_LEADING": 22,
  "FIELD_FLOAT_PHASE_LABEL_TEXT_TRACKING": 0,
  "FIELD_FLOAT_PHASE_LABEL_TEXT_WEIGHT": 500,
  "FIELD_FLOAT_PHASE_LABEL_TEXT_CASE": "regular",
  "FIELD_FLOAT_PHASE_LABEL_TEXT_NUMBER_SPACING": "default",
  "FIELD_FLOAT_PHASE_LABEL_TEXT_SCALE": "paragraph-20",
  "FIELD_FLOAT_PHASE_LABEL_TEXT_FONT_FAMILY": "Square Sans Text",
  "FIELD_FLOAT_PHASE_LABEL_MARGIN_TOP_SIZE": 8,
  "FIELD_FLOAT_PHASE_LABEL_MARGIN_BOTTOM_SIZE": 2,
  "FIELD_FLOAT_PHASE_HORIZONTAL_PADDING_SIZE": 16,
  "FIELD_FLOAT_PHASE_VERTICAL_PADDING_SIZE": 8,
  "FIELD_NORMAL_STATE_EMPTY_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_NORMAL_STATE_EMPTY_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.55)",
  "FIELD_NORMAL_STATE_EMPTY_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_NORMAL_STATE_FLOAT_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_NORMAL_STATE_FLOAT_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "FIELD_NORMAL_STATE_FLOAT_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_NORMAL_STATE_NORMAL_VALIDITY_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "FIELD_NORMAL_STATE_NORMAL_VALIDITY_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.15)",
  "FIELD_NORMAL_STATE_NORMAL_VALIDITY_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "FIELD_NORMAL_STATE_INVALID_VALIDITY_LIGHT_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "FIELD_NORMAL_STATE_INVALID_VALIDITY_DARK_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "FIELD_NORMAL_STATE_INVALID_VALIDITY_BORDER_COLOR": "rgb(204, 0, 35)",
  "FIELD_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "FIELD_NORMAL_STATE_LIGHT_MODE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(8, 8, 8)",
  "FIELD_NORMAL_STATE_DARK_MODE_INPUT_COLOR": "rgba(255, 255, 255, 0.95)",
  "FIELD_NORMAL_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "FIELD_NORMAL_STATE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_HOVER_STATE_EMPTY_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_HOVER_STATE_EMPTY_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.55)",
  "FIELD_HOVER_STATE_EMPTY_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FIELD_HOVER_STATE_FLOAT_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_HOVER_STATE_FLOAT_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "FIELD_HOVER_STATE_FLOAT_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_HOVER_STATE_NORMAL_VALIDITY_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_HOVER_STATE_NORMAL_VALIDITY_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_HOVER_STATE_NORMAL_VALIDITY_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_HOVER_STATE_INVALID_VALIDITY_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_HOVER_STATE_INVALID_VALIDITY_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_HOVER_STATE_INVALID_VALIDITY_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "FIELD_HOVER_STATE_LIGHT_MODE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(8, 8, 8)",
  "FIELD_HOVER_STATE_DARK_MODE_INPUT_COLOR": "rgba(255, 255, 255, 0.95)",
  "FIELD_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "FIELD_HOVER_STATE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_FOCUS_STATE_BORDER_SIZE": 2,
  "FIELD_FOCUS_STATE_FLOAT_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_FOCUS_STATE_FLOAT_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "FIELD_FOCUS_STATE_FLOAT_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_FOCUS_STATE_NORMAL_VALIDITY_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_FOCUS_STATE_NORMAL_VALIDITY_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_FOCUS_STATE_NORMAL_VALIDITY_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_FOCUS_STATE_INVALID_VALIDITY_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_FOCUS_STATE_INVALID_VALIDITY_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_FOCUS_STATE_INVALID_VALIDITY_BORDER_COLOR": "rgb(0, 106, 255)",
  "FIELD_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "FIELD_FOCUS_STATE_LIGHT_MODE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(8, 8, 8)",
  "FIELD_FOCUS_STATE_DARK_MODE_INPUT_COLOR": "rgba(255, 255, 255, 0.95)",
  "FIELD_FOCUS_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "FIELD_FOCUS_STATE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "FIELD_DISABLED_STATE_EMPTY_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "FIELD_DISABLED_STATE_EMPTY_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "FIELD_DISABLED_STATE_EMPTY_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "FIELD_DISABLED_STATE_FLOAT_PHASE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "FIELD_DISABLED_STATE_FLOAT_PHASE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "FIELD_DISABLED_STATE_FLOAT_PHASE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "FIELD_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "FIELD_DISABLED_STATE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.05)",
  "FIELD_DISABLED_STATE_LIGHT_MODE_INPUT_COLOR": "rgba(0, 0, 0, 0.3)",
  "FIELD_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "FIELD_DISABLED_STATE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.08)",
  "FIELD_DISABLED_STATE_DARK_MODE_INPUT_COLOR": "rgba(255, 255, 255, 0.3)",
  "FIELD_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "FIELD_DISABLED_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.05)",
  "FIELD_DISABLED_STATE_INPUT_COLOR": "rgba(0, 0, 0, 0.3)",
  "FIELD_PLACEHOLDER_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_BORDER_RADIUS": 6,
  "FILTER_BUTTON_BORDER_SIZE": 1,
  "FILTER_BUTTON_FEEDBACK_MAXIMUM": 99,
  "FILTER_BUTTON_LABEL_CONTENT_SPACING": 8,
  "FILTER_BUTTON_ICON_FEEDBACK_TRAILING_PADDING": 2,
  "FILTER_BUTTON_ICON_CONTENT_SPACING": 4,
  "FILTER_BUTTON_SMALL_SIZE_MINIMUM_HEIGHT": 40,
  "FILTER_BUTTON_SMALL_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1,
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_SIZE": 14,
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_LEADING": 22,
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_TRACKING": 0,
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_WEIGHT": 400,
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_CASE": "regular",
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_NUMBER_SPACING": "default",
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_SCALE": "paragraph-20",
  "FILTER_BUTTON_SMALL_SIZE_LABEL_TEXT_FONT_FAMILY": "Square Sans Text",
  "FILTER_BUTTON_SMALL_SIZE_LABEL_HORIZONTAL_PADDING": 12,
  "FILTER_BUTTON_SMALL_SIZE_LABEL_VERTICAL_PADDING": 9,
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_SIZE": 14,
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_LEADING": 22,
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_TRACKING": 0,
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_WEIGHT": 600,
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_CASE": "regular",
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_NUMBER_SPACING": "default",
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_SCALE": "paragraph-20",
  "FILTER_BUTTON_SMALL_SIZE_FEEDBACK_TEXT_FONT_FAMILY": "Square Sans Text",
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_SIZE": 16,
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_LEADING": 24,
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_TRACKING": 0,
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_WEIGHT": 600,
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_CASE": "regular",
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_NUMBER_SPACING": "default",
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_SCALE": "paragraph-30",
  "FILTER_BUTTON_SMALL_SIZE_ICON_TEXT_FONT_FAMILY": "Square Sans Text",
  "FILTER_BUTTON_SMALL_SIZE_ICON_HORIZONTAL_PADDING": 8,
  "FILTER_BUTTON_SMALL_SIZE_ICON_VERTICAL_PADDING": 8,
  "FILTER_BUTTON_MEDIUM_SIZE_MINIMUM_HEIGHT": 48,
  "FILTER_BUTTON_MEDIUM_SIZE_MINIMUM_WIDTH_MULTIPLIER": 1,
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_SIZE": 16,
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_LEADING": 24,
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_TRACKING": 0,
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_WEIGHT": 400,
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_CASE": "regular",
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_NUMBER_SPACING": "default",
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_SCALE": "paragraph-30",
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_TEXT_FONT_FAMILY": "Square Sans Text",
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_HORIZONTAL_PADDING": 16,
  "FILTER_BUTTON_MEDIUM_SIZE_LABEL_VERTICAL_PADDING": 12,
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_SIZE": 16,
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_LEADING": 24,
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_TRACKING": 0,
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_WEIGHT": 600,
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_CASE": "regular",
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_NUMBER_SPACING": "default",
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_SCALE": "paragraph-30",
  "FILTER_BUTTON_MEDIUM_SIZE_FEEDBACK_TEXT_FONT_FAMILY": "Square Sans Text",
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_SIZE": 16,
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_LEADING": 24,
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_TRACKING": 0,
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_WEIGHT": 600,
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_CASE": "regular",
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_NUMBER_SPACING": "default",
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_SCALE": "paragraph-30",
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_TEXT_FONT_FAMILY": "Square Sans Text",
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_HORIZONTAL_PADDING": 12,
  "FILTER_BUTTON_MEDIUM_SIZE_ICON_VERTICAL_PADDING": 12,
  "FILTER_BUTTON_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_NORMAL_STATE_LABEL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_NORMAL_STATE_LABEL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "FILTER_BUTTON_NORMAL_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_NORMAL_STATE_FEEDBACK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_NORMAL_STATE_FEEDBACK_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "FILTER_BUTTON_NORMAL_STATE_FEEDBACK_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_NORMAL_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "FILTER_BUTTON_NORMAL_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "FILTER_BUTTON_NORMAL_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "FILTER_BUTTON_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "FILTER_BUTTON_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "FILTER_BUTTON_HOVER_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "FILTER_BUTTON_HOVER_STATE_LABEL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_HOVER_STATE_LABEL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "FILTER_BUTTON_HOVER_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_HOVER_STATE_FEEDBACK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_HOVER_STATE_FEEDBACK_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "FILTER_BUTTON_HOVER_STATE_FEEDBACK_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_HOVER_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "FILTER_BUTTON_HOVER_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "FILTER_BUTTON_HOVER_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "FILTER_BUTTON_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_PRESSED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_PRESSED_STATE_LABEL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_PRESSED_STATE_LABEL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "FILTER_BUTTON_PRESSED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.55)",
  "FILTER_BUTTON_PRESSED_STATE_FEEDBACK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_PRESSED_STATE_FEEDBACK_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "FILTER_BUTTON_PRESSED_STATE_FEEDBACK_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_PRESSED_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_PRESSED_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "FILTER_BUTTON_PRESSED_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.9)",
  "FILTER_BUTTON_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "FILTER_BUTTON_DISABLED_STATE_LABEL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "FILTER_BUTTON_DISABLED_STATE_LABEL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "FILTER_BUTTON_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "FILTER_BUTTON_DISABLED_STATE_FEEDBACK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "FILTER_BUTTON_DISABLED_STATE_FEEDBACK_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "FILTER_BUTTON_DISABLED_STATE_FEEDBACK_COLOR": "rgba(0, 0, 0, 0.3)",
  "FILTER_BUTTON_DISABLED_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "FILTER_BUTTON_DISABLED_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "FILTER_BUTTON_DISABLED_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "FOOTER_VERTICAL_PADDING_SIZE": 16,
  "HARDWARE_SLIDER_MINIMUM_WIDTH": 48,
  "HARDWARE_SLIDER_MINIMUM_HEIGHT": 48,
  "HARDWARE_SLIDER_TRACK_ACTIVE_HEIGHT": 40,
  "HARDWARE_SLIDER_TRACK_ACTIVE_CORNER_RADIUS": 40,
  "HARDWARE_SLIDER_TRACK_ACTIVE_PADDING_HORIZONTAL_SIZE": 8,
  "HARDWARE_SLIDER_TRACK_ACTIVE_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "HARDWARE_SLIDER_TRACK_ACTIVE_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "HARDWARE_SLIDER_TRACK_ACTIVE_NORMAL_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "HARDWARE_SLIDER_TRACK_ACTIVE_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "HARDWARE_SLIDER_TRACK_ACTIVE_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "HARDWARE_SLIDER_TRACK_ACTIVE_DISABLED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "HARDWARE_SLIDER_TRACK_INACTIVE_HEIGHT": 16,
  "HARDWARE_SLIDER_TRACK_INACTIVE_CORNER_RADIUS": 16,
  "HARDWARE_SLIDER_TRACK_INACTIVE_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "HARDWARE_SLIDER_TRACK_INACTIVE_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "HARDWARE_SLIDER_TRACK_INACTIVE_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.15)",
  "HARDWARE_SLIDER_TRACK_INACTIVE_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "HARDWARE_SLIDER_TRACK_INACTIVE_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "HARDWARE_SLIDER_TRACK_INACTIVE_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "HARDWARE_SLIDER_ICON_SIZE": 24,
  "HARDWARE_SLIDER_ICON_TINT_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "HARDWARE_SLIDER_ICON_TINT_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "HARDWARE_SLIDER_ICON_TINT_COLOR": "rgb(255, 255, 255)",
  "HEADER_TOP_PADDING_COMPACT_SIZE_CLASS_SIZE": 16,
  "HEADER_TOP_PADDING_NORMAL_SIZE_CLASS_SIZE": 24,
  "HEADER_TOP_PADDING_WIDE_SIZE_CLASS_SIZE": 24,
  "HEADER_TOP_PADDING_SIZE": 24,
  "HEADER_BOTTOM_PADDING_COMPACT_SIZE_CLASS_SIZE": 16,
  "HEADER_BOTTOM_PADDING_NORMAL_SIZE_CLASS_SIZE": 16,
  "HEADER_BOTTOM_PADDING_WIDE_SIZE_CLASS_SIZE": 16,
  "HEADER_BOTTOM_PADDING_SIZE": 16,
  "HEADER_HORIZONTAL_PADDING_COMPACT_SIZE_CLASS_SIZE": 16,
  "HEADER_HORIZONTAL_PADDING_NORMAL_SIZE_CLASS_SIZE": 24,
  "HEADER_HORIZONTAL_PADDING_WIDE_SIZE_CLASS_SIZE": 24,
  "HEADER_HORIZONTAL_PADDING_SIZE": 16,
  "HEADER_NAV_ICON_BUTTON_SPACING_BUTTOM_SIZE": 24,
  "HEADER_NAV_ICON_BUTTON_SPACING_BOTTOM_SIZE": 24,
  "HEADER_CLOSE_BUTTON_ICON_ASSET": "x",
  "HEADER_CLOSE_BUTTON_ICON_WIDTH": 24,
  "HEADER_CLOSE_BUTTON_ICON_HEIGHT": 24,
  "HEADER_CLOSE_BUTTON_ICON_TINTABLE": true,
  "HEADER_CLOSE_BUTTON_ICON_SEMANTIC_NAME": "close",
  "HEADER_MAIN_TEXT_HORIZONTAL_SPACING": 16,
  "HEADER_MAIN_TEXT_MINIMUM_WIDTH": 64,
  "HEADER_MAIN_TEXT_TRANSITION_DURATION": 160,
  "HEADER_MAIN_TEXT_NORMAL_PHASE_SPACING_TOP_SIZE": 8,
  "HEADER_MAIN_TEXT_LIGHT_MODE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "HEADER_MAIN_TEXT_DARK_MODE_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "HEADER_MAIN_TEXT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "HEADER_SUB_TEXT_SPACING_BOTTOM_SIZE": 8,
  "HEADER_SUB_TEXT_LIGHT_MODE_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "HEADER_SUB_TEXT_DARK_MODE_TEXT_COLOR": "rgba(255, 255, 255, 0.55)",
  "HEADER_SUB_TEXT_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "HEADER_DIVIDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "HEADER_DIVIDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "HEADER_DIVIDER_SIZE": 1,
  "HEADER_DIVIDER_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_SMALL_SIZE_MINIMUM_HEIGHT": 40,
  "ICON_BUTTON_SMALL_SIZE_WIDTH_MULTIPLIER": 1,
  "ICON_BUTTON_SMALL_SIZE_PADDING_SIZE": 8,
  "ICON_BUTTON_MEDIUM_SIZE_MINIMUM_HEIGHT": 48,
  "ICON_BUTTON_MEDIUM_SIZE_WIDTH_MULTIPLIER": 1,
  "ICON_BUTTON_MEDIUM_SIZE_PADDING_SIZE": 12,
  "ICON_BUTTON_MEDIUM_SIZE_HORIZONTAL_SPACING_SIZE": 8,
  "ICON_BUTTON_LARGE_SIZE_MINIMUM_HEIGHT": 64,
  "ICON_BUTTON_LARGE_SIZE_WIDTH_MULTIPLIER": 1,
  "ICON_BUTTON_LARGE_SIZE_PADDING_SIZE": 20,
  "ICON_BUTTON_NORMAL_SIZE_MINIMUM_WIDTH": 48,
  "ICON_BUTTON_NORMAL_SIZE_MINIMUM_HEIGHT": 48,
  "ICON_BUTTON_NORMAL_SIZE_PADDING_SIZE": 16,
  "ICON_BUTTON_COMPACT_SIZE_MINIMUM_WIDTH": 40,
  "ICON_BUTTON_COMPACT_SIZE_MINIMUM_HEIGHT": 40,
  "ICON_BUTTON_COMPACT_SIZE_MINIMUM_PADDING_SIZE": 12,
  "ICON_BUTTON_COMPACT_SIZE_PADDING_SIZE": 12,
  "ICON_BUTTON_MINIMUM_WIDTH": 48,
  "ICON_BUTTON_MINIMUM_HEIGHT": 48,
  "ICON_BUTTON_PADDING_SIZE": 16,
  "ICON_BUTTON_FOCUS_RING_BUFFER_SIZE": 2,
  "ICON_BUTTON_FOCUS_RING_BORDER_SIZE": 2,
  "ICON_BUTTON_BORDER_RADIUS": 6,
  "ICON_BUTTON_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_PRIMARY_RANK_NORMAL_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_PRIMARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_PRIMARY_RANK_HOVER_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "ICON_BUTTON_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "ICON_BUTTON_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "ICON_BUTTON_PRIMARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_PRIMARY_RANK_FOCUS_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_PRIMARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_PRIMARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_SECONDARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_SECONDARY_RANK_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_SECONDARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_SECONDARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_SECONDARY_RANK_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "ICON_BUTTON_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_SECONDARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_SECONDARY_RANK_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_SECONDARY_RANK_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_SECONDARY_RANK_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_SECONDARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_SECONDARY_RANK_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_SECONDARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_SECONDARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_TERTIARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_TERTIARY_RANK_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_TERTIARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_TERTIARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_TERTIARY_RANK_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "ICON_BUTTON_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_TERTIARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_TERTIARY_RANK_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_TERTIARY_RANK_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_TERTIARY_RANK_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_TERTIARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_TERTIARY_RANK_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_TERTIARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_TERTIARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "ICON_BUTTON_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_FOCUS_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_NORMAL_VARIANT_SECONDARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(255, 255, 255)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 90, 118)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_NORMAL_STATE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(51, 0, 9)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 90, 118)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_HOVER_STATE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(89, 0, 15)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 90, 118)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_SECONDARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 90, 118)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_NORMAL_STATE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(51, 0, 9)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 90, 118)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_HOVER_STATE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(89, 0, 15)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgb(255, 90, 118)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(191, 0, 32)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ICON_BUTTON_DESTRUCTIVE_VARIANT_TERTIARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "INLINE_SECTION_HEADER_10_HEADING_SIZE": 14,
  "INLINE_SECTION_HEADER_10_HEADING_LEADING": 22,
  "INLINE_SECTION_HEADER_10_HEADING_TRACKING": 0,
  "INLINE_SECTION_HEADER_10_HEADING_WEIGHT": 700,
  "INLINE_SECTION_HEADER_10_HEADING_CASE": "regular",
  "INLINE_SECTION_HEADER_10_HEADING_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_10_HEADING_SCALE": "heading-10",
  "INLINE_SECTION_HEADER_10_HEADING_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_10_HEADING_IS_HEADER": true,
  "INLINE_SECTION_HEADER_10_HEADING_VERTICAL_PADDING": 9,
  "INLINE_SECTION_HEADER_10_PARAGRAPH_SIZE": 16,
  "INLINE_SECTION_HEADER_10_PARAGRAPH_LEADING": 24,
  "INLINE_SECTION_HEADER_10_PARAGRAPH_TRACKING": 0,
  "INLINE_SECTION_HEADER_10_PARAGRAPH_WEIGHT": 400,
  "INLINE_SECTION_HEADER_10_PARAGRAPH_CASE": "regular",
  "INLINE_SECTION_HEADER_10_PARAGRAPH_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_10_PARAGRAPH_SCALE": "paragraph-30",
  "INLINE_SECTION_HEADER_10_PARAGRAPH_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_10_PARAGRAPH_TOP_PADDING": 0,
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_SIZE": 14,
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_LEADING": 22,
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_TRACKING": 0,
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_WEIGHT": 600,
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_CASE": "regular",
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_SCALE": "paragraph-20",
  "INLINE_SECTION_HEADER_10_TEXT_LINK_TEXT_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_10_TEXT_LINK_VERTICAL_PADDING": 0,
  "INLINE_SECTION_HEADER_20_HEADING_SIZE": 19,
  "INLINE_SECTION_HEADER_20_HEADING_LEADING": 26,
  "INLINE_SECTION_HEADER_20_HEADING_TRACKING": 0,
  "INLINE_SECTION_HEADER_20_HEADING_WEIGHT": 700,
  "INLINE_SECTION_HEADER_20_HEADING_CASE": "regular",
  "INLINE_SECTION_HEADER_20_HEADING_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_20_HEADING_SCALE": "heading-20",
  "INLINE_SECTION_HEADER_20_HEADING_FONT_FAMILY": "Square Sans Display",
  "INLINE_SECTION_HEADER_20_HEADING_IS_HEADER": true,
  "INLINE_SECTION_HEADER_20_HEADING_VERTICAL_PADDING": 7,
  "INLINE_SECTION_HEADER_20_PARAGRAPH_SIZE": 16,
  "INLINE_SECTION_HEADER_20_PARAGRAPH_LEADING": 24,
  "INLINE_SECTION_HEADER_20_PARAGRAPH_TRACKING": 0,
  "INLINE_SECTION_HEADER_20_PARAGRAPH_WEIGHT": 400,
  "INLINE_SECTION_HEADER_20_PARAGRAPH_CASE": "regular",
  "INLINE_SECTION_HEADER_20_PARAGRAPH_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_20_PARAGRAPH_SCALE": "paragraph-30",
  "INLINE_SECTION_HEADER_20_PARAGRAPH_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_20_PARAGRAPH_TOP_PADDING": 5,
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_SIZE": 16,
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_LEADING": 24,
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_TRACKING": 0,
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_WEIGHT": 600,
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_CASE": "regular",
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_SCALE": "paragraph-30",
  "INLINE_SECTION_HEADER_20_TEXT_LINK_TEXT_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_20_TEXT_LINK_VERTICAL_PADDING": 0,
  "INLINE_SECTION_HEADER_30_HEADING_SIZE": 25,
  "INLINE_SECTION_HEADER_30_HEADING_LEADING": 32,
  "INLINE_SECTION_HEADER_30_HEADING_TRACKING": 0,
  "INLINE_SECTION_HEADER_30_HEADING_WEIGHT": 700,
  "INLINE_SECTION_HEADER_30_HEADING_CASE": "regular",
  "INLINE_SECTION_HEADER_30_HEADING_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_30_HEADING_SCALE": "heading-30",
  "INLINE_SECTION_HEADER_30_HEADING_FONT_FAMILY": "Square Sans Display",
  "INLINE_SECTION_HEADER_30_HEADING_IS_HEADER": true,
  "INLINE_SECTION_HEADER_30_HEADING_VERTICAL_PADDING": 4,
  "INLINE_SECTION_HEADER_30_PARAGRAPH_SIZE": 16,
  "INLINE_SECTION_HEADER_30_PARAGRAPH_LEADING": 24,
  "INLINE_SECTION_HEADER_30_PARAGRAPH_TRACKING": 0,
  "INLINE_SECTION_HEADER_30_PARAGRAPH_WEIGHT": 400,
  "INLINE_SECTION_HEADER_30_PARAGRAPH_CASE": "regular",
  "INLINE_SECTION_HEADER_30_PARAGRAPH_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_30_PARAGRAPH_SCALE": "paragraph-30",
  "INLINE_SECTION_HEADER_30_PARAGRAPH_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_30_PARAGRAPH_TOP_PADDING": 12,
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_SIZE": 16,
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_LEADING": 24,
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_TRACKING": 0,
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_WEIGHT": 600,
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_CASE": "regular",
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_NUMBER_SPACING": "default",
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_SCALE": "paragraph-30",
  "INLINE_SECTION_HEADER_30_TEXT_LINK_TEXT_FONT_FAMILY": "Square Sans Text",
  "INLINE_SECTION_HEADER_30_TEXT_LINK_VERTICAL_PADDING": 0,
  "INLINE_SECTION_HEADER_HEADING_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "INLINE_SECTION_HEADER_HEADING_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "INLINE_SECTION_HEADER_HEADING_COLOR": "rgba(0, 0, 0, 0.9)",
  "INLINE_SECTION_HEADER_PARAGRAPH_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "INLINE_SECTION_HEADER_PARAGRAPH_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "INLINE_SECTION_HEADER_PARAGRAPH_COLOR": "rgba(0, 0, 0, 0.9)",
  "INLINE_SECTION_HEADER_TEXT_LINK_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "INLINE_SECTION_HEADER_TEXT_LINK_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "INLINE_SECTION_HEADER_TEXT_LINK_NORMAL_STATE_OPACITY": 1,
  "INLINE_SECTION_HEADER_TEXT_LINK_HOVER_STATE_OPACITY": 0.6,
  "INLINE_SECTION_HEADER_TEXT_LINK_PRESSED_STATE_OPACITY": 0.6,
  "INLINE_SECTION_HEADER_TEXT_LINK_DISABLED_STATE_OPACITY": 0.3,
  "INLINE_SECTION_HEADER_TEXT_LINK_COLOR": "rgb(0, 90, 217)",
  "INLINE_SECTION_HEADER_HORIZONTAL_SPACING": 8,
  "INLINE_STATUS_NORMAL_SIZE_TEXT_SIZE": 14,
  "INLINE_STATUS_NORMAL_SIZE_TEXT_LEADING": 22,
  "INLINE_STATUS_NORMAL_SIZE_TEXT_TRACKING": 0,
  "INLINE_STATUS_NORMAL_SIZE_TEXT_WEIGHT": 400,
  "INLINE_STATUS_NORMAL_SIZE_TEXT_CASE": "regular",
  "INLINE_STATUS_NORMAL_SIZE_TEXT_NUMBER_SPACING": "default",
  "INLINE_STATUS_NORMAL_SIZE_TEXT_SCALE": "paragraph-20",
  "INLINE_STATUS_NORMAL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "INLINE_STATUS_NORMAL_SIZE_SPACING_HORIZONTAL": 4,
  "INLINE_STATUS_NORMAL_SIZE_ICON_SIZE": 20,
  "INLINE_STATUS_SUCCESS_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "INLINE_STATUS_SUCCESS_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "INLINE_STATUS_SUCCESS_VARIANT_TEXT_COLOR": "rgb(0, 125, 42)",
  "INLINE_STATUS_SUCCESS_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "INLINE_STATUS_SUCCESS_VARIANT_ICON_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "INLINE_STATUS_SUCCESS_VARIANT_ICON_COLOR": "rgb(0, 125, 42)",
  "INLINE_STATUS_WARNING_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "INLINE_STATUS_WARNING_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "INLINE_STATUS_WARNING_VARIANT_TEXT_COLOR": "rgb(148, 92, 37)",
  "INLINE_STATUS_WARNING_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "INLINE_STATUS_WARNING_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "INLINE_STATUS_WARNING_VARIANT_ICON_COLOR": "rgb(148, 92, 37)",
  "INLINE_STATUS_ERROR_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "INLINE_STATUS_ERROR_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "INLINE_STATUS_ERROR_VARIANT_TEXT_COLOR": "rgb(191, 0, 32)",
  "INLINE_STATUS_ERROR_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "INLINE_STATUS_ERROR_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "INLINE_STATUS_ERROR_VARIANT_ICON_COLOR": "rgb(191, 0, 32)",
  "INLINE_STATUS_INFO_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "INLINE_STATUS_INFO_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "INLINE_STATUS_INFO_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "INLINE_STATUS_INFO_VARIANT_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "INLINE_STATUS_INFO_VARIANT_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "INLINE_STATUS_INFO_VARIANT_ICON_COLOR": "rgba(0, 0, 0, 0.42)",
  "KEYBOARD_BAR_VERTICAL_PADDING": 12,
  "KEYBOARD_BAR_HORIZONTAL_PADDING": 8,
  "KEYBOARD_BAR_SPACING": 8,
  "KEYBOARD_BAR_LIGHT_MODE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "KEYBOARD_BAR_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "KEYBOARD_BAR_LIGHT_MODE_SURFACE_COLOR": "rgb(255, 255, 255)",
  "KEYBOARD_BAR_DARK_MODE_SEPARATOR_COLOR": "rgba(255, 255, 255, 0.08)",
  "KEYBOARD_BAR_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.05)",
  "KEYBOARD_BAR_DARK_MODE_SURFACE_COLOR": "rgb(8, 8, 8)",
  "KEYBOARD_BAR_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "KEYBOARD_BAR_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "KEYBOARD_BAR_SURFACE_COLOR": "rgb(255, 255, 255)",
  "MODAL_BLADE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "MODAL_BLADE_BACKGROUND_DARK_MODE_COLOR": "rgb(28, 28, 28)",
  "MODAL_BLADE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_BLADE_WIDE_VIEWPORT_PADDING_LEFT_SIZE": 32,
  "MODAL_BLADE_WIDE_VIEWPORT_PADDING_TOP_SIZE": 32,
  "MODAL_BLADE_WIDE_VIEWPORT_PADDING_RIGHT_SIZE": 32,
  "MODAL_BLADE_WIDE_VIEWPORT_PADDING_BOTTOM_SIZE": 0,
  "MODAL_BLADE_WIDE_VIEWPORT_MAX_HEIGHT_SIZE": 500,
  "MODAL_BLADE_WIDE_VIEWPORT_CONTENT_WIDTH_SIZE": 400,
  "MODAL_BLADE_WIDE_VIEWPORT_WIDTH_SIZE": 464,
  "MODAL_BLADE_COMPACT_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_BLADE_REGULAR_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_BLADE_WIDE_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_BLADE_COMPACT_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 24,
  "MODAL_BLADE_REGULAR_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 24,
  "MODAL_BLADE_MAXIMUM_WIDTH_SIZE": 464,
  "MODAL_DIALOG_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_DIALOG_DARK_MODE_BACKGROUND_COLOR": "rgb(28, 28, 28)",
  "MODAL_DIALOG_BORDER_RADIUS": 12,
  "MODAL_DIALOG_ANIMATION_ENTER_TRANSITION_DURATION": 240,
  "MODAL_DIALOG_ANIMATION_ENTER_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "MODAL_DIALOG_ANIMATION_EXIT_TRANSITION_DURATION": 160,
  "MODAL_DIALOG_ANIMATION_EXIT_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "MODAL_DIALOG_ANIMATION_DURATION": 500,
  "MODAL_DIALOG_NARROW_VIEWPORT_HORIZONTAL_PADDING_SIZE": 24,
  "MODAL_DIALOG_NARROW_VIEWPORT_VERTICAL_PADDING_SIZE": 24,
  "MODAL_DIALOG_MEDIUM_VIEWPORT_WIDTH": 480,
  "MODAL_DIALOG_MEDIUM_VIEWPORT_HORIZONTAL_PADDING_SIZE": 40,
  "MODAL_DIALOG_MEDIUM_VIEWPORT_VERTICAL_PADDING_SIZE": 24,
  "MODAL_DIALOG_WIDE_VIEWPORT_WIDTH": 480,
  "MODAL_DIALOG_WIDE_VIEWPORT_HORIZONTAL_PADDING_SIZE": 32,
  "MODAL_DIALOG_WIDE_VIEWPORT_VERTICAL_PADDING_SIZE": 24,
  "MODAL_DIALOG_COMPACT_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_DIALOG_REGULAR_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_DIALOG_WIDE_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_DIALOG_COMPACT_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 32,
  "MODAL_DIALOG_REGULAR_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 32,
  "MODAL_DIALOG_MAXIMUM_WIDTH_SIZE": 480,
  "MODAL_DIALOG_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_FULL_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_FULL_DARK_MODE_BACKGROUND_COLOR": "rgb(8, 8, 8)",
  "MODAL_FULL_ANIMATION_ENTER_TRANSITION_DURATION": 240,
  "MODAL_FULL_ANIMATION_ENTER_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "MODAL_FULL_ANIMATION_EXIT_TRANSITION_DURATION": 160,
  "MODAL_FULL_ANIMATION_EXIT_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "MODAL_FULL_FIXED_LAYOUT_WIDTH": 600,
  "MODAL_FULL_NARROW_VIEWPORT_ANIMATION_DURATION": 500,
  "MODAL_FULL_NARROW_VIEWPORT_HORIZONTAL_PADDING_SIZE": 16,
  "MODAL_FULL_NARROW_VIEWPORT_VERTICAL_PADDING_SIZE": 16,
  "MODAL_FULL_MEDIUM_VIEWPORT_ANIMATION_DURATION": 500,
  "MODAL_FULL_MEDIUM_VIEWPORT_HORIZONTAL_PADDING_SIZE": 24,
  "MODAL_FULL_MEDIUM_VIEWPORT_VERTICAL_PADDING_SIZE": 24,
  "MODAL_FULL_WIDE_VIEWPORT_ANIMATION_DURATION": 500,
  "MODAL_FULL_WIDE_VIEWPORT_HORIZONTAL_PADDING_SIZE": 32,
  "MODAL_FULL_WIDE_VIEWPORT_VERTICAL_PADDING_SIZE": 16,
  "MODAL_FULL_COMPACT_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 16,
  "MODAL_FULL_REGULAR_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 24,
  "MODAL_FULL_WIDE_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 24,
  "MODAL_FULL_COMPACT_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 12,
  "MODAL_FULL_REGULAR_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 16,
  "MODAL_FULL_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_PARTIAL_LIGHT_MODE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_PARTIAL_DARK_MODE_BACKGROUND_COLOR": "rgb(28, 28, 28)",
  "MODAL_PARTIAL_BORDER_RADIUS": 12,
  "MODAL_PARTIAL_ANIMATION_ENTER_TRANSITION_DURATION": 240,
  "MODAL_PARTIAL_ANIMATION_ENTER_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "MODAL_PARTIAL_ANIMATION_EXIT_TRANSITION_DURATION": 160,
  "MODAL_PARTIAL_ANIMATION_EXIT_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "MODAL_PARTIAL_NARROW_VIEWPORT_ANIMATION_DURATION": 500,
  "MODAL_PARTIAL_NARROW_VIEWPORT_HORIZONTAL_PADDING_SIZE": 16,
  "MODAL_PARTIAL_NARROW_VIEWPORT_HORIZONTAL_SCREEN_BUFFER_SIZE": 0,
  "MODAL_PARTIAL_NARROW_VIEWPORT_VERTICAL_PADDING_SIZE": 16,
  "MODAL_PARTIAL_NARROW_VIEWPORT_VERTICAL_SCREEN_BUFFER_SIZE": 0,
  "MODAL_PARTIAL_MEDIUM_VIEWPORT_ANIMATION_DURATION": 500,
  "MODAL_PARTIAL_MEDIUM_VIEWPORT_WIDTH": 664,
  "MODAL_PARTIAL_MEDIUM_VIEWPORT_HORIZONTAL_PADDING_SIZE": 32,
  "MODAL_PARTIAL_MEDIUM_VIEWPORT_HORIZONTAL_SCREEN_BUFFER_SIZE": 24,
  "MODAL_PARTIAL_MEDIUM_VIEWPORT_VERTICAL_PADDING_SIZE": 32,
  "MODAL_PARTIAL_MEDIUM_VIEWPORT_VERTICAL_SCREEN_BUFFER_SIZE": 24,
  "MODAL_PARTIAL_WIDE_VIEWPORT_ANIMATION_DURATION": 500,
  "MODAL_PARTIAL_WIDE_VIEWPORT_WIDTH": 664,
  "MODAL_PARTIAL_WIDE_VIEWPORT_HORIZONTAL_PADDING_SIZE": 32,
  "MODAL_PARTIAL_WIDE_VIEWPORT_HORIZONTAL_SCREEN_BUFFER_SIZE": 24,
  "MODAL_PARTIAL_WIDE_VIEWPORT_VERTICAL_PADDING_SIZE": 32,
  "MODAL_PARTIAL_WIDE_VIEWPORT_VERTICAL_SCREEN_BUFFER_SIZE": 24,
  "MODAL_PARTIAL_COMPACT_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_PARTIAL_REGULAR_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_PARTIAL_WIDE_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 32,
  "MODAL_PARTIAL_COMPACT_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 24,
  "MODAL_PARTIAL_REGULAR_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 24,
  "MODAL_PARTIAL_MAXIMUM_WIDTH_SIZE": 664,
  "MODAL_PARTIAL_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_POPOVER_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "MODAL_POPOVER_BACKGROUND_DARK_MODE_COLOR": "rgb(45, 45, 45)",
  "MODAL_POPOVER_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_POPOVER_BORDER_RADIUS": 6,
  "MODAL_POPOVER_APPEAR_ANIMATION_PERCENTAGE": 70,
  "MODAL_POPOVER_WIDE_VIEWPORT_PADDING_LEFT_SIZE": 24,
  "MODAL_POPOVER_WIDE_VIEWPORT_PADDING_TOP_SIZE": 8,
  "MODAL_POPOVER_WIDE_VIEWPORT_PADDING_RIGHT_SIZE": 24,
  "MODAL_POPOVER_WIDE_VIEWPORT_PADDING_BOTTOM_SIZE": 8,
  "MODAL_POPOVER_WIDE_VIEWPORT_MAX_HEIGHT_SIZE": 500,
  "MODAL_POPOVER_WIDE_VIEWPORT_MIN_WIDTH_SIZE": 200,
  "MODAL_POPOVER_COMPACT_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 16,
  "MODAL_POPOVER_REGULAR_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 16,
  "MODAL_POPOVER_WIDE_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 16,
  "MODAL_POPOVER_COMPACT_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 16,
  "MODAL_POPOVER_REGULAR_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 16,
  "MODAL_SHEET_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "MODAL_SHEET_BACKGROUND_DARK_MODE_COLOR": "rgb(28, 28, 28)",
  "MODAL_SHEET_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "MODAL_SHEET_BORDER_RADIUS": 12,
  "MODAL_SHEET_NARROW_VIEWPORT_PADDING_LEFT_SIZE": 16,
  "MODAL_SHEET_NARROW_VIEWPORT_PADDING_TOP_SIZE": 16,
  "MODAL_SHEET_NARROW_VIEWPORT_PADDING_RIGHT_SIZE": 16,
  "MODAL_SHEET_NARROW_VIEWPORT_PADDING_BOTTOM_SIZE": 16,
  "MODAL_SHEET_NARROW_VIEWPORT_MARGIN_BOTTOM_SIZE": 0,
  "MODAL_SHEET_WIDE_VIEWPORT_PADDING_LEFT_SIZE": 32,
  "MODAL_SHEET_WIDE_VIEWPORT_PADDING_TOP_SIZE": 32,
  "MODAL_SHEET_WIDE_VIEWPORT_PADDING_RIGHT_SIZE": 32,
  "MODAL_SHEET_WIDE_VIEWPORT_PADDING_BOTTOM_SIZE": 32,
  "MODAL_SHEET_WIDE_VIEWPORT_MARGIN_BOTTOM_SIZE": 16,
  "MODAL_SHEET_HANDLE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.2)",
  "MODAL_SHEET_HANDLE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.4)",
  "MODAL_SHEET_HANDLE_TOP_BUFFER_SIZE": 10,
  "MODAL_SHEET_HANDLE_PADDING_TOP_SIZE": 26,
  "MODAL_SHEET_HANDLE_PADDING_BOTTOM_SIZE": 8,
  "MODAL_SHEET_HANDLE_WIDTH": 56,
  "MODAL_SHEET_HANDLE_HEIGHT": 6,
  "MODAL_SHEET_HANDLE_BORDER_RADIUS": 100,
  "MODAL_SHEET_HANDLE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.4)",
  "MODAL_SHEET_COMPACT_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 16,
  "MODAL_SHEET_REGULAR_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 24,
  "MODAL_SHEET_WIDE_HORIZONTAL_SIZE_CLASS_HORIZONTAL_PADDING": 24,
  "MODAL_SHEET_COMPACT_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 16,
  "MODAL_SHEET_REGULAR_VERTICAL_SIZE_CLASS_VERTICAL_PADDING": 24,
  "PAGE_INDICATOR_DOT_SIZE": 6,
  "PAGE_INDICATOR_DOT_COLOR": "rgba(0, 0, 0, 0.55)",
  "PAGE_INDICATOR_SELECTED_SIZE": 8,
  "PAGE_INDICATOR_SELECTED_COLOR": "rgb(0, 106, 255)",
  "PAGE_INDICATOR_SPACING_SIZE": 6,
  "PAGE_INDICATOR_LIGHT_MODE_DOT_COLOR": "rgba(0, 0, 0, 0.55)",
  "PAGE_INDICATOR_LIGHT_MODE_SELECTED_COLOR": "rgb(0, 106, 255)",
  "PAGE_INDICATOR_DARK_MODE_DOT_COLOR": "rgba(255, 255, 255, 0.55)",
  "PAGE_INDICATOR_DARK_MODE_SELECTED_COLOR": "rgb(0, 106, 255)",
  "PAGINATION_NAV_VERTICAL_MARGIN": 16,
  "PAGINATION_NAV_HORIZONTAL_MARGIN": 8,
  "PAGINATION_NAV_CONTENT_SPACING": 8,
  "PAGING_INDICATOR_SPACING": 2,
  "PAGING_INDICATOR_UNSELECTED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "PAGING_INDICATOR_UNSELECTED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "PAGING_INDICATOR_UNSELECTED_STATE_HEIGHT": 2,
  "PAGING_INDICATOR_UNSELECTED_STATE_WIDTH": 24,
  "PAGING_INDICATOR_UNSELECTED_STATE_COLOR": "rgba(0, 0, 0, 0.42)",
  "PAGING_INDICATOR_SELECTED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "PAGING_INDICATOR_SELECTED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "PAGING_INDICATOR_SELECTED_STATE_HEIGHT": 4,
  "PAGING_INDICATOR_SELECTED_STATE_WIDTH": 24,
  "PAGING_INDICATOR_SELECTED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "PILL_NORMAL_SIZE_TEXT_SIZE": 14,
  "PILL_NORMAL_SIZE_TEXT_LEADING": 22,
  "PILL_NORMAL_SIZE_TEXT_TRACKING": 0,
  "PILL_NORMAL_SIZE_TEXT_WEIGHT": 600,
  "PILL_NORMAL_SIZE_TEXT_CASE": "regular",
  "PILL_NORMAL_SIZE_TEXT_NUMBER_SPACING": "default",
  "PILL_NORMAL_SIZE_TEXT_SCALE": "paragraph-20",
  "PILL_NORMAL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "PILL_NORMAL_SIZE_PADDING_HORIZONTAL_SIZE": 12,
  "PILL_NORMAL_SIZE_PADDING_VERTICAL_SIZE": 5,
  "PILL_NORMAL_SIZE_ICON_LEFT_PADDING": 8,
  "PILL_NORMAL_SIZE_TEXT_EDGE_PADDING": 12,
  "PILL_NORMAL_SIZE_CORNER_RADIUS": 100,
  "PILL_NORMAL_SIZE_ICON_DOT_RADIUS": 5,
  "PILL_NORMAL_SIZE_ICON_SIZE": 16,
  "PILL_NORMAL_SIZE_SPACING_HORIZONTAL": 8,
  "PILL_NORMAL_SIZE_ICON_TO_TEXT_SPACING": 4,
  "PILL_COMPACT_SIZE_TEXT_SIZE": 12,
  "PILL_COMPACT_SIZE_TEXT_LEADING": 18,
  "PILL_COMPACT_SIZE_TEXT_TRACKING": 0,
  "PILL_COMPACT_SIZE_TEXT_WEIGHT": 600,
  "PILL_COMPACT_SIZE_TEXT_CASE": "regular",
  "PILL_COMPACT_SIZE_TEXT_NUMBER_SPACING": "default",
  "PILL_COMPACT_SIZE_TEXT_SCALE": "paragraph-10",
  "PILL_COMPACT_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "PILL_COMPACT_SIZE_PADDING_HORIZONTAL_SIZE": 8,
  "PILL_COMPACT_SIZE_PADDING_VERTICAL_SIZE": 3,
  "PILL_COMPACT_SIZE_ICON_LEFT_PADDING": 4,
  "PILL_COMPACT_SIZE_TEXT_EDGE_PADDING": 8,
  "PILL_COMPACT_SIZE_ICON_DOT_RADIUS": 4,
  "PILL_COMPACT_SIZE_ICON_SIZE": 16,
  "PILL_COMPACT_SIZE_SPACING_HORIZONTAL": 6,
  "PILL_COMPACT_SIZE_ICON_TO_TEXT_SPACING": 3,
  "PILL_NORMAL_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "PILL_NORMAL_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "PILL_NORMAL_VARIANT_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "PILL_NORMAL_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "PILL_NORMAL_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "PILL_NORMAL_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "PILL_NORMAL_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "PILL_NORMAL_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "PILL_NORMAL_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.15)",
  "PILL_NORMAL_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "PILL_NORMAL_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "PILL_NORMAL_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "PILL_NORMAL_VARIANT_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "PILL_NORMAL_VARIANT_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "PILL_NORMAL_VARIANT_ICON_COLOR": "rgba(0, 0, 0, 0.42)",
  "PILL_EMPHASIS_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "PILL_EMPHASIS_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "PILL_EMPHASIS_VARIANT_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "PILL_EMPHASIS_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "PILL_EMPHASIS_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "PILL_EMPHASIS_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "PILL_EMPHASIS_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "PILL_EMPHASIS_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "PILL_EMPHASIS_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "PILL_EMPHASIS_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "PILL_EMPHASIS_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "PILL_EMPHASIS_VARIANT_TEXT_COLOR": "rgb(0, 90, 217)",
  "PILL_EMPHASIS_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "PILL_EMPHASIS_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "PILL_EMPHASIS_VARIANT_ICON_COLOR": "rgb(0, 106, 255)",
  "PILL_SUCCESS_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(229, 255, 238)",
  "PILL_SUCCESS_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 51, 17)",
  "PILL_SUCCESS_VARIANT_BACKGROUND_COLOR": "rgb(229, 255, 238)",
  "PILL_SUCCESS_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(229, 255, 238)",
  "PILL_SUCCESS_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 51, 17)",
  "PILL_SUCCESS_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(229, 255, 238)",
  "PILL_SUCCESS_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 255, 221)",
  "PILL_SUCCESS_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 89, 30)",
  "PILL_SUCCESS_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 255, 221)",
  "PILL_SUCCESS_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "PILL_SUCCESS_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "PILL_SUCCESS_VARIANT_TEXT_COLOR": "rgb(0, 125, 42)",
  "PILL_SUCCESS_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "PILL_SUCCESS_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "PILL_SUCCESS_VARIANT_ICON_COLOR": "rgb(0, 178, 59)",
  "PILL_WARNING_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "PILL_WARNING_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 26, 0)",
  "PILL_WARNING_VARIANT_BACKGROUND_COLOR": "rgb(255, 242, 230)",
  "PILL_WARNING_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "PILL_WARNING_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 26, 0)",
  "PILL_WARNING_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(255, 242, 230)",
  "PILL_WARNING_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 230, 204)",
  "PILL_WARNING_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(89, 45, 0)",
  "PILL_WARNING_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 230, 204)",
  "PILL_WARNING_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "PILL_WARNING_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "PILL_WARNING_VARIANT_TEXT_COLOR": "rgb(148, 92, 37)",
  "PILL_WARNING_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "PILL_WARNING_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "PILL_WARNING_VARIANT_ICON_COLOR": "rgb(255, 159, 64)",
  "PILL_CRITICAL_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "PILL_CRITICAL_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "PILL_CRITICAL_VARIANT_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "PILL_CRITICAL_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "PILL_CRITICAL_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "PILL_CRITICAL_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "PILL_CRITICAL_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 204, 213)",
  "PILL_CRITICAL_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(89, 0, 15)",
  "PILL_CRITICAL_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "PILL_CRITICAL_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "PILL_CRITICAL_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "PILL_CRITICAL_VARIANT_TEXT_COLOR": "rgb(191, 0, 32)",
  "PILL_CRITICAL_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "PILL_CRITICAL_VARIANT_ICON_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "PILL_CRITICAL_VARIANT_ICON_COLOR": "rgb(204, 0, 35)",
  "PILL_INSIGHT_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(244, 230, 255)",
  "PILL_INSIGHT_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(30, 0, 51)",
  "PILL_INSIGHT_VARIANT_BACKGROUND_COLOR": "rgb(244, 230, 255)",
  "PILL_INSIGHT_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(244, 230, 255)",
  "PILL_INSIGHT_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(30, 0, 51)",
  "PILL_INSIGHT_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(244, 230, 255)",
  "PILL_INSIGHT_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(234, 204, 255)",
  "PILL_INSIGHT_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(52, 0, 89)",
  "PILL_INSIGHT_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(234, 204, 255)",
  "PILL_INSIGHT_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "PILL_INSIGHT_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(194, 110, 255)",
  "PILL_INSIGHT_VARIANT_TEXT_COLOR": "rgb(135, 22, 217)",
  "PILL_INSIGHT_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "PILL_INSIGHT_VARIANT_ICON_DARK_MODE_COLOR": "rgb(135, 22, 217)",
  "PILL_INSIGHT_VARIANT_ICON_COLOR": "rgb(135, 22, 217)",
  "PILL_ALPHA_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 230, 249)",
  "PILL_ALPHA_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 38)",
  "PILL_ALPHA_VARIANT_BACKGROUND_COLOR": "rgb(255, 230, 249)",
  "PILL_ALPHA_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 230, 249)",
  "PILL_ALPHA_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 38)",
  "PILL_ALPHA_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(255, 230, 249)",
  "PILL_ALPHA_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 204, 242)",
  "PILL_ALPHA_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(89, 0, 67)",
  "PILL_ALPHA_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 242)",
  "PILL_ALPHA_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(168, 42, 136)",
  "PILL_ALPHA_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(255, 67, 208)",
  "PILL_ALPHA_VARIANT_TEXT_COLOR": "rgb(168, 42, 136)",
  "PILL_ALPHA_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(217, 54, 176)",
  "PILL_ALPHA_VARIANT_ICON_DARK_MODE_COLOR": "rgb(217, 54, 176)",
  "PILL_ALPHA_VARIANT_ICON_COLOR": "rgb(217, 54, 176)",
  "PILL_BETA_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 255, 249)",
  "PILL_BETA_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 51, 38)",
  "PILL_BETA_VARIANT_BACKGROUND_COLOR": "rgb(230, 255, 249)",
  "PILL_BETA_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 255, 249)",
  "PILL_BETA_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 51, 38)",
  "PILL_BETA_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgb(230, 255, 249)",
  "PILL_BETA_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 255, 242)",
  "PILL_BETA_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 89, 67)",
  "PILL_BETA_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 255, 242)",
  "PILL_BETA_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(12, 120, 93)",
  "PILL_BETA_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(22, 216, 167)",
  "PILL_BETA_VARIANT_TEXT_COLOR": "rgb(12, 120, 93)",
  "PILL_BETA_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(18, 191, 148)",
  "PILL_BETA_VARIANT_ICON_DARK_MODE_COLOR": "rgb(18, 191, 148)",
  "PILL_BETA_VARIANT_ICON_COLOR": "rgb(18, 191, 148)",
  "QRCODE_NORMAL_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "QRCODE_NORMAL_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_NORMAL_VARIANT_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "QRCODE_NORMAL_VARIANT_FOREGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_NORMAL_VARIANT_FOREGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "QRCODE_NORMAL_VARIANT_FOREGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_NORMAL_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "QRCODE_NORMAL_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "QRCODE_NORMAL_VARIANT_ICON_COLOR": "rgb(0, 106, 255)",
  "QRCODE_MONOCHROME_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "QRCODE_MONOCHROME_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_MONOCHROME_VARIANT_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "QRCODE_MONOCHROME_VARIANT_FOREGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_MONOCHROME_VARIANT_FOREGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "QRCODE_MONOCHROME_VARIANT_FOREGROUND_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_MONOCHROME_VARIANT_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "QRCODE_MONOCHROME_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "QRCODE_MONOCHROME_VARIANT_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_SIZE": 48,
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_LEADING": 56,
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_TRACKING": 0,
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_WEIGHT": 500,
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_CASE": "regular",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_NUMBER_SPACING": "monospaced",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_SCALE": "heading-30",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_FONT_FAMILY": "Square Sans Display",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_PLACEHOLDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_PLACEHOLDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_PLACEHOLDER_COLOR": "rgba(0, 0, 0, 0.3)",
  "QUANTITY_INPUT_FIELD_VALUE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "RADIO_WIDTH": 20,
  "RADIO_HEIGHT": 20,
  "RADIO_BORDER_RADIUS": 100,
  "RADIO_BORDER_SIZE": 2,
  "RADIO_SVG_RADIUS": 3,
  "RADIO_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "RADIO_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "RADIO_FOCUS_RING_BUFFER_SIZE": 2,
  "RADIO_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.35)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(0, 106, 255)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_NORMAL_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(204, 0, 35)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(204, 0, 35)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_NORMAL_STATE_INVALID_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_NORMAL_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(178, 0, 30)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_HOVER_STATE_INVALID_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 85, 204)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(0, 85, 204)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(153, 0, 26)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(153, 0, 26)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(153, 0, 26)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(153, 0, 26)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_PRESSED_STATE_INVALID_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(0, 95, 229)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_NORMAL_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(178, 0, 30)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgb(178, 0, 30)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgb(178, 0, 30)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_FOCUS_STATE_INVALID_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.05)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.05)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_LIGHT_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.35)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_DARK_MODE_ICON_COLOR": "rgb(255, 255, 255)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.42)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "RADIO_DISABLED_STATE_NORMAL_VALIDITY_SELECTED_VALUE_ICON_COLOR": "rgb(255, 255, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_MINIMUM_HEIGHT": 32,
  "RICH_TEXT_TOOLBAR_BUTTON_WIDTH_MULTIPLIER": 1,
  "RICH_TEXT_TOOLBAR_BUTTON_PADDING_SIZE": 4,
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_PRESSED_STATE_ICON_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_FOCUS_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_FOCUS_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "RICH_TEXT_TOOLBAR_BUTTON_UNSELECTED_VALUE_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_NORMAL_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_NORMAL_STATE_ICON_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_HOVER_STATE_ICON_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_FOCUS_STATE_ICON_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_FOCUS_STATE_ICON_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_FOCUS_STATE_ICON_COLOR": "rgb(0, 90, 217)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_DISABLED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_DISABLED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "RICH_TEXT_TOOLBAR_BUTTON_SELECTED_VALUE_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "RICH_TEXT_TOOLBAR_DIVIDER_VERTICAL_PADDING": 0,
  "RICH_TEXT_TOOLBAR_SPACING_HORIZONTAL": 12,
  "RICH_TEXT_TOOLBAR_PADDING_VERTICAL": 4,
  "RICH_TEXT_TOOLBAR_PADDING_HORIZONTAL": 4,
  "RICH_TEXT_TOOLBAR_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.03)",
  "RICH_TEXT_TOOLBAR_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.05)",
  "RICH_TEXT_TOOLBAR_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "RICH_TEXT_TOOLBAR_OVERFLOW_GRADIENT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "RICH_TEXT_TOOLBAR_OVERFLOW_GRADIENT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "RICH_TEXT_TOOLBAR_OVERFLOW_GRADIENT_WIDTH": 16,
  "RICH_TEXT_TOOLBAR_OVERFLOW_GRADIENT_COLOR": "rgba(0, 0, 0, 0.05)",
  "RICH_TEXT_LINK_EDIT_POPOVER_SPACING_VERTICAL": 16,
  "ROW_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_BACKGROUND_RADIUS": 6,
  "ROW_BACKGROUND_HORIZONTAL_OUTSET_PADDING": 8,
  "ROW_BACKGROUND_VERTICAL_OUTSET_PADDING": 0,
  "ROW_SEPARATOR_HEIGHT": 1,
  "ROW_NORMAL_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_NORMAL_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_NORMAL_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_NORMAL_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_HOVER_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_HOVER_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_HOVER_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_HOVER_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_HOVER_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_HOVER_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_HOVER_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_HOVER_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_HOVER_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_HOVER_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_HOVER_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_HOVER_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_HOVER_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_HOVER_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_HOVER_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_HOVER_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_HOVER_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_HOVER_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_HOVER_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_HOVER_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_HOVER_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "ROW_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "ROW_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ROW_PRESSED_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_PRESSED_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_PRESSED_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_PRESSED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_PRESSED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_PRESSED_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_PRESSED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_PRESSED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_PRESSED_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_PRESSED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_PRESSED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_PRESSED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_PRESSED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_PRESSED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_PRESSED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_PRESSED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_PRESSED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_PRESSED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_PRESSED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_PRESSED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_PRESSED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "ROW_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "ROW_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ROW_SELECTED_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_SELECTED_STATE_TEXT_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_SELECTED_STATE_SUBTEXT_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_SELECTED_STATE_TERTIARY_TEXT_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_SELECTED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_SELECTED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(0, 90, 217)",
  "ROW_SELECTED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_SELECTED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_SELECTED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_SELECTED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_SELECTED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_SELECTED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_SELECTED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_SELECTED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_SELECTED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_SELECTED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "ROW_SELECTED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "ROW_SELECTED_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ROW_FOCUS_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_FOCUS_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_FOCUS_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_FOCUS_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_FOCUS_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_FOCUS_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_FOCUS_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_FOCUS_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_FOCUS_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_FOCUS_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_FOCUS_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_FOCUS_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_FOCUS_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_FOCUS_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_FOCUS_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_FOCUS_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_FOCUS_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_FOCUS_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_FOCUS_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_FOCUS_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_FOCUS_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_FOCUS_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_FOCUS_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "ROW_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "ROW_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ROW_DISABLED_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DISABLED_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DISABLED_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DISABLED_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DISABLED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DISABLED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DISABLED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ROW_DISABLED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "ROW_DISABLED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.15)",
  "ROW_DISABLED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DISABLED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_DISABLED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DISABLED_STATE_IMAGE_OPACITY": 0.4,
  "ROW_DISABLED_STATE_LEADING_ACCESSORY_OPACITY": 0.4,
  "ROW_HORIZONTAL_SPACING": 12,
  "ROW_TEXT_ACCESSORY_SPACING": 8,
  "ROW_MEDIUM_SIZE_TEXT_SIZE": 16,
  "ROW_MEDIUM_SIZE_TEXT_LEADING": 24,
  "ROW_MEDIUM_SIZE_TEXT_TRACKING": 0,
  "ROW_MEDIUM_SIZE_TEXT_WEIGHT": 500,
  "ROW_MEDIUM_SIZE_TEXT_CASE": "regular",
  "ROW_MEDIUM_SIZE_TEXT_NUMBER_SPACING": "default",
  "ROW_MEDIUM_SIZE_TEXT_SCALE": "paragraph-30",
  "ROW_MEDIUM_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "ROW_MEDIUM_SIZE_TEXT_VERTICAL_SPACING": 2,
  "ROW_MEDIUM_SIZE_SUBTEXT_SIZE": 14,
  "ROW_MEDIUM_SIZE_SUBTEXT_LEADING": 22,
  "ROW_MEDIUM_SIZE_SUBTEXT_TRACKING": 0,
  "ROW_MEDIUM_SIZE_SUBTEXT_WEIGHT": 400,
  "ROW_MEDIUM_SIZE_SUBTEXT_CASE": "regular",
  "ROW_MEDIUM_SIZE_SUBTEXT_NUMBER_SPACING": "default",
  "ROW_MEDIUM_SIZE_SUBTEXT_SCALE": "paragraph-20",
  "ROW_MEDIUM_SIZE_SUBTEXT_FONT_FAMILY": "Square Sans Text",
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_SIZE": 14,
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_LEADING": 22,
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_TRACKING": 0,
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_WEIGHT": 400,
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_CASE": "regular",
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_NUMBER_SPACING": "default",
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_SCALE": "paragraph-20",
  "ROW_MEDIUM_SIZE_TERTIARY_TEXT_FONT_FAMILY": "Square Sans Text",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_SIZE": 16,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_LEADING": 24,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_TRACKING": 0,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_WEIGHT": 400,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_CASE": "regular",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_NUMBER_SPACING": "default",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_SCALE": "paragraph-30",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_PRIMARY_FONT_FAMILY": "Square Sans Text",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_SIZE": 14,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_LEADING": 22,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_TRACKING": 0,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_WEIGHT": 400,
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_CASE": "regular",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_NUMBER_SPACING": "default",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_SCALE": "paragraph-20",
  "ROW_MEDIUM_SIZE_SIDE_TEXT_SECONDARY_FONT_FAMILY": "Square Sans Text",
  "ROW_MEDIUM_SIZE_VERTICAL_PADDING": 16,
  "ROW_MEDIUM_SIZE_CARET_ICON_ASSET": "chevron-right",
  "ROW_MEDIUM_SIZE_CARET_ICON_WIDTH": 16,
  "ROW_MEDIUM_SIZE_CARET_ICON_HEIGHT": 16,
  "ROW_MEDIUM_SIZE_CARET_ICON_TINTABLE": true,
  "ROW_MEDIUM_SIZE_CARET_ICON_SEMANTIC_NAME": "continue",
  "ROW_SMALL_SIZE_TEXT_SIZE": 14,
  "ROW_SMALL_SIZE_TEXT_LEADING": 22,
  "ROW_SMALL_SIZE_TEXT_TRACKING": 0,
  "ROW_SMALL_SIZE_TEXT_WEIGHT": 600,
  "ROW_SMALL_SIZE_TEXT_CASE": "regular",
  "ROW_SMALL_SIZE_TEXT_NUMBER_SPACING": "default",
  "ROW_SMALL_SIZE_TEXT_SCALE": "paragraph-20",
  "ROW_SMALL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "ROW_SMALL_SIZE_TEXT_VERTICAL_SPACING": 2,
  "ROW_SMALL_SIZE_SUBTEXT_SIZE": 12,
  "ROW_SMALL_SIZE_SUBTEXT_LEADING": 18,
  "ROW_SMALL_SIZE_SUBTEXT_TRACKING": 0,
  "ROW_SMALL_SIZE_SUBTEXT_WEIGHT": 400,
  "ROW_SMALL_SIZE_SUBTEXT_CASE": "regular",
  "ROW_SMALL_SIZE_SUBTEXT_NUMBER_SPACING": "default",
  "ROW_SMALL_SIZE_SUBTEXT_SCALE": "paragraph-10",
  "ROW_SMALL_SIZE_SUBTEXT_FONT_FAMILY": "Square Sans Text",
  "ROW_SMALL_SIZE_TERTIARY_TEXT_SIZE": 12,
  "ROW_SMALL_SIZE_TERTIARY_TEXT_LEADING": 18,
  "ROW_SMALL_SIZE_TERTIARY_TEXT_TRACKING": 0,
  "ROW_SMALL_SIZE_TERTIARY_TEXT_WEIGHT": 400,
  "ROW_SMALL_SIZE_TERTIARY_TEXT_CASE": "regular",
  "ROW_SMALL_SIZE_TERTIARY_TEXT_NUMBER_SPACING": "default",
  "ROW_SMALL_SIZE_TERTIARY_TEXT_SCALE": "paragraph-10",
  "ROW_SMALL_SIZE_TERTIARY_TEXT_FONT_FAMILY": "Square Sans Text",
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_SIZE": 14,
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_LEADING": 22,
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_TRACKING": 0,
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_WEIGHT": 400,
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_CASE": "regular",
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_NUMBER_SPACING": "default",
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_SCALE": "paragraph-20",
  "ROW_SMALL_SIZE_SIDE_TEXT_PRIMARY_FONT_FAMILY": "Square Sans Text",
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_SIZE": 12,
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_LEADING": 18,
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_TRACKING": 0,
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_WEIGHT": 400,
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_CASE": "regular",
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_NUMBER_SPACING": "default",
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_SCALE": "paragraph-10",
  "ROW_SMALL_SIZE_SIDE_TEXT_SECONDARY_FONT_FAMILY": "Square Sans Text",
  "ROW_SMALL_SIZE_VERTICAL_PADDING": 9,
  "ROW_SMALL_SIZE_CARET_ICON_ASSET": "chevron-right",
  "ROW_SMALL_SIZE_CARET_ICON_WIDTH": 16,
  "ROW_SMALL_SIZE_CARET_ICON_HEIGHT": 16,
  "ROW_SMALL_SIZE_CARET_ICON_TINTABLE": true,
  "ROW_SMALL_SIZE_CARET_ICON_SEMANTIC_NAME": "continue",
  "ROW_FOCUS_RING_BUFFER_SIZE": 2,
  "ROW_FOCUS_RING_BORDER_SIZE": 2,
  "ROW_FOCUS_RING_RADIUS": 6,
  "ROW_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_DESTRUCTIVE_VARIANT_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_DESTRUCTIVE_VARIANT_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_DESTRUCTIVE_VARIANT_BACKGROUND_RADIUS": 6,
  "ROW_DESTRUCTIVE_VARIANT_BACKGROUND_HORIZONTAL_OUTSET_PADDING": 8,
  "ROW_DESTRUCTIVE_VARIANT_BACKGROUND_VERTICAL_OUTSET_PADDING": 0,
  "ROW_DESTRUCTIVE_VARIANT_SEPARATOR_HEIGHT": 1,
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SUBTEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_TERTIARY_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_DRILL_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_DRILL_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_DRILL_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SUBTEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_TERTIARY_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_DRILL_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_DRILL_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_DRILL_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "ROW_DESTRUCTIVE_VARIANT_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SUBTEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_TERTIARY_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_DRILL_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_DRILL_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_DRILL_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 204, 213)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(89, 0, 15)",
  "ROW_DESTRUCTIVE_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(255, 204, 213)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SUBTEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_TERTIARY_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_DRILL_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_DRILL_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_DRILL_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "ROW_DESTRUCTIVE_VARIANT_SELECTED_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SUBTEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_TERTIARY_TEXT_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(191, 0, 32)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_DRILL_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_DRILL_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_DRILL_COLOR": "rgb(178, 0, 30)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_STATE_BACKGROUND_COLOR": "rgb(255, 229, 234)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.15)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_IMAGE_OPACITY": 0.4,
  "ROW_DESTRUCTIVE_VARIANT_DISABLED_STATE_LEADING_ACCESSORY_OPACITY": 0.4,
  "ROW_DESTRUCTIVE_VARIANT_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_NORMAL_VARIANT_LIGHT_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_NORMAL_VARIANT_DARK_MODE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "ROW_NORMAL_VARIANT_BACKGROUND_RADIUS": 6,
  "ROW_NORMAL_VARIANT_BACKGROUND_HORIZONTAL_OUTSET_PADDING": 8,
  "ROW_NORMAL_VARIANT_BACKGROUND_VERTICAL_OUTSET_PADDING": 0,
  "ROW_NORMAL_VARIANT_SEPARATOR_HEIGHT": 1,
  "ROW_NORMAL_VARIANT_NORMAL_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "ROW_NORMAL_VARIANT_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "ROW_NORMAL_VARIANT_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_TEXT_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SUBTEXT_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_TERTIARY_TEXT_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgb(0, 90, 217)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "ROW_NORMAL_VARIANT_SELECTED_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.55)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.42)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "ROW_NORMAL_VARIANT_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SUBTEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SUBTEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SUBTEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_TERTIARY_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_TERTIARY_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_TERTIARY_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SIDE_TEXT_PRIMARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SIDE_TEXT_PRIMARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SIDE_TEXT_PRIMARY_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SIDE_TEXT_SECONDARY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SIDE_TEXT_SECONDARY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SIDE_TEXT_SECONDARY_COLOR": "rgba(0, 0, 0, 0.3)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_DRILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_DRILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_DRILL_COLOR": "rgba(0, 0, 0, 0.15)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.05)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0)",
  "ROW_NORMAL_VARIANT_DISABLED_STATE_IMAGE_OPACITY": 0.4,
  "ROW_NORMAL_VARIANT_DISABLED_STATE_LEADING_ACCESSORY_OPACITY": 0.4,
  "ROW_NORMAL_VARIANT_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "SEARCH_BORDER_RADIUS": 6,
  "SEARCH_BORDER_SIZE": 1,
  "SEARCH_INPUT_SIZE": 16,
  "SEARCH_INPUT_LEADING": 24,
  "SEARCH_INPUT_TRACKING": 0,
  "SEARCH_INPUT_WEIGHT": 400,
  "SEARCH_INPUT_CASE": "regular",
  "SEARCH_INPUT_NUMBER_SPACING": "default",
  "SEARCH_INPUT_SCALE": "paragraph-30",
  "SEARCH_INPUT_FONT_FAMILY": "Square Sans Text",
  "SEARCH_HINT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEARCH_HINT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "SEARCH_HINT_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEARCH_NORMAL_SIZE_MINIMUM_HEIGHT": 40,
  "SEARCH_NORMAL_SIZE_SPACING_HORIZONTAL": 12,
  "SEARCH_NORMAL_SIZE_PADDING_VERTICAL": 8,
  "SEARCH_NORMAL_SIZE_TAGS_SPACING_RIGHT": 8,
  "SEARCH_LARGE_SIZE_MINIMUM_HEIGHT": 56,
  "SEARCH_LARGE_SIZE_SPACING_HORIZONTAL": 12,
  "SEARCH_LARGE_SIZE_PADDING_VERTICAL": 12,
  "SEARCH_LARGE_SIZE_TAGS_SPACING_RIGHT": 8,
  "SEARCH_NORMAL_STATE_INPUT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEARCH_NORMAL_STATE_INPUT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEARCH_NORMAL_STATE_INPUT_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEARCH_NORMAL_STATE_LEADING_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEARCH_NORMAL_STATE_LEADING_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEARCH_NORMAL_STATE_LEADING_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEARCH_NORMAL_STATE_TRAILING_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "SEARCH_NORMAL_STATE_TRAILING_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "SEARCH_NORMAL_STATE_TRAILING_ICON_COLOR": "rgba(0, 0, 0, 0.42)",
  "SEARCH_NORMAL_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "SEARCH_NORMAL_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "SEARCH_NORMAL_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "SEARCH_DISABLED_STATE_INPUT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEARCH_DISABLED_STATE_INPUT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "SEARCH_DISABLED_STATE_INPUT_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEARCH_DISABLED_STATE_LEADING_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEARCH_DISABLED_STATE_LEADING_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "SEARCH_DISABLED_STATE_LEADING_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEARCH_DISABLED_STATE_TRAILING_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "SEARCH_DISABLED_STATE_TRAILING_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "SEARCH_DISABLED_STATE_TRAILING_ICON_COLOR": "rgba(0, 0, 0, 0.15)",
  "SEARCH_DISABLED_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "SEARCH_DISABLED_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "SEARCH_DISABLED_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.05)",
  "SEARCH_FOCUSED_STATE_BORDER_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "SEARCH_FOCUSED_STATE_BORDER_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "SEARCH_FOCUSED_STATE_BORDER_SIZE": 2,
  "SEARCH_FOCUSED_STATE_BORDER_COLOR": "rgb(0, 106, 255)",
  "SEGMENTED_CONTROL_BACKGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "SEGMENTED_CONTROL_BACKGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "SEGMENTED_CONTROL_BACKGROUND_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "SEGMENTED_CONTROL_BACKGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "SEGMENTED_CONTROL_BACKGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "SEGMENTED_CONTROL_BACKGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.05)",
  "SEGMENTED_CONTROL_BACKGROUND_RADIUS": 6,
  "SEGMENTED_CONTROL_PADDING_HORIZONTAL": 4,
  "SEGMENTED_CONTROL_PADDING_VERTICAL": 4,
  "SEGMENTED_CONTROL_ANIMATION_DURATION": 300,
  "SEGMENTED_CONTROL_ANIMATION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_NORMAL_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_HOVER_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_PRESSED_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_PRESSED_STATE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_DISABLED_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_UNSELECTED_VALUE_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_NORMAL_STATE_DARK_MODE_COLOR": "rgb(45, 45, 45)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_NORMAL_STATE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_HOVER_STATE_DARK_MODE_COLOR": "rgb(45, 45, 45)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_HOVER_STATE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_PRESSED_STATE_DARK_MODE_COLOR": "rgb(45, 45, 45)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_PRESSED_STATE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_DISABLED_STATE_DARK_MODE_COLOR": "rgb(45, 45, 45)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_VALUE_DISABLED_STATE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_NORMAL_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_STATE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_SELECTED_STATE_COLOR": "rgb(255, 255, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_HOVER_STATE_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_HOVER_STATE_COLOR": "rgb(230, 240, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_PRESSED_STATE_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_PRESSED_STATE_COLOR": "rgb(204, 225, 255)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_DISABLED_STATE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0)",
  "SEGMENTED_CONTROL_OPTION_BACKGROUND_RADIUS": 4,
  "SEGMENTED_CONTROL_OPTION_PADDING_HORIZONTAL": 8,
  "SEGMENTED_CONTROL_OPTION_PADDING_VERTICAL": 8,
  "SEGMENTED_CONTROL_OPTION_SPACING_HORIZONTAL": 8,
  "SEGMENTED_CONTROL_OPTION_BADGE_NORMAL_STATE_OPACITY": 1,
  "SEGMENTED_CONTROL_OPTION_BADGE_SELECTED_STATE_OPACITY": 1,
  "SEGMENTED_CONTROL_OPTION_BADGE_HOVER_STATE_OPACITY": 1,
  "SEGMENTED_CONTROL_OPTION_BADGE_PRESSED_STATE_OPACITY": 1,
  "SEGMENTED_CONTROL_OPTION_BADGE_DISABLED_STATE_OPACITY": 0.3,
  "SEGMENTED_CONTROL_OPTION_LABEL_SIZE": 16,
  "SEGMENTED_CONTROL_OPTION_LABEL_LEADING": 24,
  "SEGMENTED_CONTROL_OPTION_LABEL_TRACKING": 0,
  "SEGMENTED_CONTROL_OPTION_LABEL_WEIGHT": 600,
  "SEGMENTED_CONTROL_OPTION_LABEL_CASE": "regular",
  "SEGMENTED_CONTROL_OPTION_LABEL_NUMBER_SPACING": "default",
  "SEGMENTED_CONTROL_OPTION_LABEL_SCALE": "paragraph-30",
  "SEGMENTED_CONTROL_OPTION_LABEL_FONT_FAMILY": "Square Sans Text",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_HOVER_STATE_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_HOVER_STATE_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_HOVER_STATE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_PRESSED_STATE_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_PRESSED_STATE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_UNSELECTED_VALUE_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_PRESSED_STATE_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_PRESSED_STATE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_VALUE_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEGMENTED_CONTROL_OPTION_LABEL_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEGMENTED_CONTROL_OPTION_LABEL_SELECTED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_HOVER_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_HOVER_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SEGMENTED_CONTROL_OPTION_LABEL_HOVER_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SEGMENTED_CONTROL_OPTION_LABEL_PRESSED_STATE_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_PRESSED_STATE_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "SEGMENTED_CONTROL_OPTION_LABEL_PRESSED_STATE_COLOR": "rgb(0, 90, 217)",
  "SEGMENTED_CONTROL_OPTION_LABEL_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "SEGMENTED_CONTROL_OPTION_LABEL_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.3)",
  "SELECT_CARET_ICON_ASSET": "chevron-down",
  "SELECT_CARET_ICON_HEIGHT": 16,
  "SELECT_CARET_ICON_WIDTH": 16,
  "SELECT_CARET_ICON_TINTABLE": true,
  "SELECT_CARET_ICON_SEMANTIC_NAME": "expand",
  "SELECT_CARET_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "SELECT_CARET_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "SELECT_CARET_COLOR": "rgba(0, 0, 0, 0.42)",
  "SKELETON_LOADER_FILL_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "SKELETON_LOADER_FILL_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "SKELETON_LOADER_FILL_COLOR": "rgba(0, 0, 0, 0.05)",
  "SKELETON_LOADER_GRADIENT_1_COLOR": "rgba(0, 0, 0, 0)",
  "SKELETON_LOADER_GRADIENT_2_COLOR": "rgba(0, 0, 0, 0.05)",
  "SKELETON_LOADER_GRADIENT_3_COLOR": "rgba(0, 0, 0, 0.08)",
  "SKELETON_LOADER_GRADIENT_LIGHT_MODE_1_COLOR": "rgba(0, 0, 0, 0)",
  "SKELETON_LOADER_GRADIENT_LIGHT_MODE_2_COLOR": "rgba(0, 0, 0, 0.05)",
  "SKELETON_LOADER_GRADIENT_LIGHT_MODE_3_COLOR": "rgba(0, 0, 0, 0.08)",
  "SKELETON_LOADER_GRADIENT_DARK_MODE_1_COLOR": "rgba(255, 255, 255, 0)",
  "SKELETON_LOADER_GRADIENT_DARK_MODE_2_COLOR": "rgba(255, 255, 255, 0.1)",
  "SKELETON_LOADER_GRADIENT_DARK_MODE_3_COLOR": "rgba(255, 255, 255, 0.15)",
  "SKELETON_LOADER_GRADIENT_WIDTH_RATIO": "0.5",
  "SKELETON_LOADER_BORDER_RADIUS": 6,
  "SKELETON_LOADER_ANIMATION_DURATION": "3000",
  "SKELETON_LOADER_ANIMATION_EASING": "cubic-bezier(0.0, 0.0, 1.0, 1.0)",
  "STEPPER_BORDER_RADIUS": 6,
  "STEPPER_NORMAL_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "STEPPER_NORMAL_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "STEPPER_NORMAL_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "STEPPER_NORMAL_STATE_BORDER_SIZE": 1,
  "STEPPER_NORMAL_STATE_NORMAL_VALIDITY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "STEPPER_NORMAL_STATE_NORMAL_VALIDITY_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "STEPPER_NORMAL_STATE_NORMAL_VALIDITY_COLOR": "rgba(0, 0, 0, 0.15)",
  "STEPPER_NORMAL_STATE_INVALID_VALIDITY_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "STEPPER_NORMAL_STATE_INVALID_VALIDITY_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "STEPPER_NORMAL_STATE_INVALID_VALIDITY_COLOR": "rgb(204, 0, 35)",
  "STEPPER_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "STEPPER_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "STEPPER_HOVER_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "STEPPER_HOVER_STATE_BORDER_SIZE": 1,
  "STEPPER_HOVER_STATE_NORMAL_VALIDITY_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_HOVER_STATE_NORMAL_VALIDITY_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_HOVER_STATE_NORMAL_VALIDITY_COLOR": "rgb(0, 106, 255)",
  "STEPPER_HOVER_STATE_INVALID_VALIDITY_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_HOVER_STATE_INVALID_VALIDITY_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_HOVER_STATE_INVALID_VALIDITY_COLOR": "rgb(0, 106, 255)",
  "STEPPER_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "STEPPER_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "STEPPER_FOCUS_STATE_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "STEPPER_FOCUS_STATE_BORDER_SIZE": 2,
  "STEPPER_FOCUS_STATE_NORMAL_VALIDITY_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_FOCUS_STATE_NORMAL_VALIDITY_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_FOCUS_STATE_NORMAL_VALIDITY_COLOR": "rgb(0, 106, 255)",
  "STEPPER_FOCUS_STATE_INVALID_VALIDITY_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_FOCUS_STATE_INVALID_VALIDITY_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "STEPPER_FOCUS_STATE_INVALID_VALIDITY_COLOR": "rgb(0, 106, 255)",
  "STEPPER_DISABLED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_DISABLED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "STEPPER_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_DISABLED_STATE_BORDER_SIZE": 1,
  "STEPPER_DISABLED_STATE_BORDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_DISABLED_STATE_BORDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "STEPPER_DISABLED_STATE_BORDER_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_PADDING_SIZE": 12,
  "STEPPER_HORIZONTAL_SPACING": 12,
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_SIZE": 16,
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_LEADING": 24,
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_TRACKING": 0,
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_WEIGHT": 400,
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_CASE": "regular",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_NUMBER_SPACING": "monospaced",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_SCALE": "paragraph-30",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_FONT_FAMILY": "Square Sans Text",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.55)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_PLACEHOLDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_PLACEHOLDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "STEPPER_QUANTITY_INPUT_FIELD_VALUE_TEXT_PLACEHOLDER_COLOR": "rgba(0, 0, 0, 0.3)",
  "STEPPER_QUANTITY_INPUT_FIELD_MINIMUM_WIDTH_MULTIPLIER": 1.66,
  "STEPPER_BUTTON_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_BUTTON_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "STEPPER_BUTTON_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "STEPPER_BUTTON_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_BUTTON_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "STEPPER_BUTTON_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "STEPPER_BUTTON_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "STEPPER_BUTTON_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "STEPPER_BUTTON_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "STEPPER_BUTTON_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "STEPPER_BUTTON_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "STEPPER_BUTTON_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "STEPPER_BUTTON_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "STEPPER_BUTTON_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "STEPPER_BUTTON_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "STEPPER_BUTTON_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "STEPPER_BUTTON_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "STEPPER_BUTTON_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_BUTTON_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "STEPPER_BUTTON_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "STEPPER_BUTTON_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.3)",
  "STEPPER_BUTTON_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "STEPPER_BUTTON_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.3)",
  "STEPPER_BUTTON_BORDER_RADIUS": 4,
  "STEPPER_BUTTON_PADDING_SIZE": 4,
  "STEPPER_BUTTON_WIDTH_MULTIPLIER": 1,
  "STEPPER_BUTTON_MINIMUM_HEIGHT": 24,
  "STEPPER_BUTTON_INCREMENT_ICON_ASSET": "plus",
  "STEPPER_BUTTON_INCREMENT_ICON_WIDTH": 24,
  "STEPPER_BUTTON_INCREMENT_ICON_HEIGHT": 24,
  "STEPPER_BUTTON_INCREMENT_ICON_TINTABLE": true,
  "STEPPER_BUTTON_INCREMENT_ICON_SEMANTIC_NAME": "add",
  "STEPPER_BUTTON_INCREMENT_WIDTH": 16,
  "STEPPER_BUTTON_INCREMENT_HEIGHT": 16,
  "STEPPER_BUTTON_INCREMENT_SCALE": "paragraph-20",
  "STEPPER_BUTTON_DECREMENT_ICON_ASSET": "minus",
  "STEPPER_BUTTON_DECREMENT_ICON_WIDTH": 24,
  "STEPPER_BUTTON_DECREMENT_ICON_HEIGHT": 24,
  "STEPPER_BUTTON_DECREMENT_ICON_TINTABLE": true,
  "STEPPER_BUTTON_DECREMENT_ICON_SEMANTIC_NAME": "remove",
  "STEPPER_BUTTON_DECREMENT_WIDTH": 16,
  "STEPPER_BUTTON_DECREMENT_HEIGHT": 16,
  "STEPPER_BUTTON_DECREMENT_SCALE": "paragraph-20",
  "STICKY_SECTION_HEADER_TEXT_SIZE": 14,
  "STICKY_SECTION_HEADER_TEXT_LEADING": 22,
  "STICKY_SECTION_HEADER_TEXT_TRACKING": 0,
  "STICKY_SECTION_HEADER_TEXT_WEIGHT": 700,
  "STICKY_SECTION_HEADER_TEXT_CASE": "regular",
  "STICKY_SECTION_HEADER_TEXT_NUMBER_SPACING": "default",
  "STICKY_SECTION_HEADER_TEXT_SCALE": "heading-10",
  "STICKY_SECTION_HEADER_TEXT_FONT_FAMILY": "Square Sans Text",
  "STICKY_SECTION_HEADER_TEXT_IS_HEADER": true,
  "STICKY_SECTION_HEADER_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "STICKY_SECTION_HEADER_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "STICKY_SECTION_HEADER_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "STICKY_SECTION_HEADER_TEXT_LINK_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "STICKY_SECTION_HEADER_TEXT_LINK_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_SIZE": 14,
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_LEADING": 22,
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_TRACKING": 0,
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_WEIGHT": 600,
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_CASE": "regular",
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_NUMBER_SPACING": "default",
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_SCALE": "paragraph-20",
  "STICKY_SECTION_HEADER_TEXT_LINK_TEXT_FONT_FAMILY": "Square Sans Text",
  "STICKY_SECTION_HEADER_TEXT_LINK_VERTICAL_PADDING": 0,
  "STICKY_SECTION_HEADER_TEXT_LINK_NORMAL_STATE_OPACITY": 1,
  "STICKY_SECTION_HEADER_TEXT_LINK_HOVER_STATE_OPACITY": 0.6,
  "STICKY_SECTION_HEADER_TEXT_LINK_PRESSED_STATE_OPACITY": 0.6,
  "STICKY_SECTION_HEADER_TEXT_LINK_DISABLED_STATE_OPACITY": 0.3,
  "STICKY_SECTION_HEADER_TEXT_LINK_COLOR": "rgb(0, 90, 217)",
  "STICKY_SECTION_HEADER_VERTICAL_PADDING": 9,
  "STICKY_SECTION_HEADER_HORIZONTAL_SPACING": 8,
  "STICKY_SECTION_HEADER_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "STICKY_SECTION_HEADER_BACKGROUND_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "STICKY_SECTION_HEADER_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "STICKY_SECTION_HEADER_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "STICKY_SECTION_HEADER_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "STICKY_SECTION_HEADER_SEPARATOR_HEIGHT": 1,
  "STICKY_SECTION_HEADER_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.3)",
  "SUBTLE_BUTTON_PADDING_SIZE": 0,
  "SUBTLE_BUTTON_HORIZONTAL_SPACING_SIZE": 8,
  "SUBTLE_BUTTON_MINIMUM_HEIGHT": 24,
  "SUBTLE_BUTTON_WIDTH_MULTIPLIER": 1,
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.42)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(0, 106, 255)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "SUBTLE_BUTTON_NORMAL_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.15)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.42)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_HOVER_STATE_ICON_COLOR": "rgb(204, 0, 35)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_LIGHT_MODE_COLOR": "rgb(153, 0, 26)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_DARK_MODE_COLOR": "rgb(153, 0, 26)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_PRESSED_STATE_ICON_COLOR": "rgb(153, 0, 26)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "SUBTLE_BUTTON_DESTRUCTIVE_VARIANT_PRIMARY_RANK_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.15)",
  "TABLE_CELL_HOVER_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.03)",
  "TABLE_CELL_HOVER_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.05)",
  "TABLE_CELL_HOVER_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "TABLE_CELL_PRESSED_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "TABLE_CELL_PRESSED_STATE_BACKGROUND_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "TABLE_CELL_PRESSED_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "TABLE_CELL_FOCUS_STATE_BACKGROUND_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.03)",
  "TABLE_CELL_FOCUS_STATE_BACKGROUND_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.05)",
  "TABLE_CELL_FOCUS_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.03)",
  "TABLE_CELL_DISABLED_STATE_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "TABLE_CELL_DISABLED_STATE_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "TABLE_CELL_DISABLED_STATE_TEXT_COLOR": "rgba(0, 0, 0, 0.3)",
  "TAG_HORIZONTAL_SPACING": 4,
  "TAG_MINIMUM_WIDTH_MULTIPLIER": 1.5,
  "TAG_REMOVE_INDICATOR_ICON_ASSET": "x",
  "TAG_REMOVE_INDICATOR_ICON_WIDTH": 24,
  "TAG_REMOVE_INDICATOR_ICON_HEIGHT": 24,
  "TAG_REMOVE_INDICATOR_ICON_SCALE": "paragraph-10",
  "TAG_REMOVE_INDICATOR_ICON_TINTABLE": true,
  "TAG_REMOVE_INDICATOR_ICON_SEMANTIC_NAME": "clear",
  "TAG_REMOVE_INDICATOR_WIDTH": 16,
  "TAG_REMOVE_INDICATOR_HEIGHT": 16,
  "TAG_REMOVE_INDICATOR_SCALE": "paragraph-10",
  "TAG_DISABLED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "TAG_DISABLED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_DISABLED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.3)",
  "TAG_DISABLED_STATE_DARK_MODE_REMOVE_INDICATOR_COLOR": "rgba(255, 255, 255, 0.15)",
  "TAG_DISABLED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "TAG_DISABLED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_DISABLED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "TAG_DISABLED_STATE_LIGHT_MODE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.15)",
  "TAG_DISABLED_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "TAG_DISABLED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_DISABLED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.3)",
  "TAG_DISABLED_STATE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.15)",
  "TAG_FOCUS_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "TAG_FOCUS_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_FOCUS_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_FOCUS_STATE_DARK_MODE_REMOVE_INDICATOR_COLOR": "rgba(255, 255, 255, 0.35)",
  "TAG_FOCUS_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "TAG_FOCUS_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_FOCUS_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_FOCUS_STATE_LIGHT_MODE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_FOCUS_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "TAG_FOCUS_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_FOCUS_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_FOCUS_STATE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_HOVER_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 21, 51)",
  "TAG_HOVER_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_HOVER_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_HOVER_STATE_DARK_MODE_REMOVE_INDICATOR_COLOR": "rgba(255, 255, 255, 0.35)",
  "TAG_HOVER_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "TAG_HOVER_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_HOVER_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_HOVER_STATE_LIGHT_MODE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_HOVER_STATE_BACKGROUND_COLOR": "rgb(230, 240, 255)",
  "TAG_HOVER_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_HOVER_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_HOVER_STATE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_NORMAL_STATE_DARK_MODE_BACKGROUND_COLOR": "rgba(255, 255, 255, 0.08)",
  "TAG_NORMAL_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_NORMAL_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_NORMAL_STATE_DARK_MODE_REMOVE_INDICATOR_COLOR": "rgba(255, 255, 255, 0.35)",
  "TAG_NORMAL_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "TAG_NORMAL_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_NORMAL_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_NORMAL_STATE_LIGHT_MODE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_NORMAL_STATE_BACKGROUND_COLOR": "rgba(0, 0, 0, 0.05)",
  "TAG_NORMAL_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_NORMAL_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_NORMAL_STATE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_PRESSED_STATE_DARK_MODE_BACKGROUND_COLOR": "rgb(0, 37, 89)",
  "TAG_PRESSED_STATE_DARK_MODE_ICON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_PRESSED_STATE_DARK_MODE_LABEL_COLOR": "rgba(255, 255, 255, 0.95)",
  "TAG_PRESSED_STATE_DARK_MODE_REMOVE_INDICATOR_COLOR": "rgba(255, 255, 255, 0.35)",
  "TAG_PRESSED_STATE_LIGHT_MODE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "TAG_PRESSED_STATE_LIGHT_MODE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_PRESSED_STATE_LIGHT_MODE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_PRESSED_STATE_LIGHT_MODE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_PRESSED_STATE_BACKGROUND_COLOR": "rgb(204, 225, 255)",
  "TAG_PRESSED_STATE_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_PRESSED_STATE_LABEL_COLOR": "rgba(0, 0, 0, 0.9)",
  "TAG_PRESSED_STATE_REMOVE_INDICATOR_COLOR": "rgba(0, 0, 0, 0.42)",
  "TAG_TEXT_SIZE": 12,
  "TAG_TEXT_LEADING": 18,
  "TAG_TEXT_TRACKING": 0,
  "TAG_TEXT_WEIGHT": 400,
  "TAG_TEXT_CASE": "regular",
  "TAG_TEXT_NUMBER_SPACING": "default",
  "TAG_TEXT_SCALE": "paragraph-10",
  "TAG_TEXT_FONT_FAMILY": "Square Sans Text",
  "TAG_BASIC_FORMAT_LEFT_PADDING": 12,
  "TAG_BASIC_FORMAT_TOP_PADDING": 7,
  "TAG_BASIC_FORMAT_RIGHT_PADDING": 8,
  "TAG_BASIC_FORMAT_BOTTOM_PADDING": 7,
  "TAG_WITH_ICON_FORMAT_LEFT_PADDING": 8,
  "TAG_WITH_ICON_FORMAT_TOP_PADDING": 8,
  "TAG_WITH_ICON_FORMAT_RIGHT_PADDING": 8,
  "TAG_WITH_ICON_FORMAT_BOTTOM_PADDING": 8,
  "TEXT_LINK_GROUP_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TEXT_LINK_GROUP_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TEXT_LINK_GROUP_SEPARATOR_OPACITY": 0.3,
  "TEXT_LINK_GROUP_SEPARATOR_HEIGHT": 8,
  "TEXT_LINK_GROUP_SEPARATOR_WIDTH": 1,
  "TEXT_LINK_GROUP_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.9)",
  "TEXT_LINK_GROUP_HORIZONTAL_SPACING": 12,
  "TEXT_LINK_GROUP_VERTICAL_SPACING": 16,
  "TEXT_LINK_SMALL_SIZE_TEXT_SIZE": 14,
  "TEXT_LINK_SMALL_SIZE_TEXT_LEADING": 22,
  "TEXT_LINK_SMALL_SIZE_TEXT_TRACKING": 0,
  "TEXT_LINK_SMALL_SIZE_TEXT_WEIGHT": 600,
  "TEXT_LINK_SMALL_SIZE_TEXT_CASE": "regular",
  "TEXT_LINK_SMALL_SIZE_TEXT_NUMBER_SPACING": "default",
  "TEXT_LINK_SMALL_SIZE_TEXT_SCALE": "paragraph-20",
  "TEXT_LINK_SMALL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "TEXT_LINK_SMALL_SIZE_VERTICAL_PADDING": 0,
  "TEXT_LINK_MEDIUM_SIZE_TEXT_SIZE": 16,
  "TEXT_LINK_MEDIUM_SIZE_TEXT_LEADING": 24,
  "TEXT_LINK_MEDIUM_SIZE_TEXT_TRACKING": 0,
  "TEXT_LINK_MEDIUM_SIZE_TEXT_WEIGHT": 600,
  "TEXT_LINK_MEDIUM_SIZE_TEXT_CASE": "regular",
  "TEXT_LINK_MEDIUM_SIZE_TEXT_NUMBER_SPACING": "default",
  "TEXT_LINK_MEDIUM_SIZE_TEXT_SCALE": "paragraph-30",
  "TEXT_LINK_MEDIUM_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "TEXT_LINK_MEDIUM_SIZE_VERTICAL_PADDING": 0,
  "TEXT_LINK_NORMAL_STATE_OPACITY": 1,
  "TEXT_LINK_HOVER_STATE_OPACITY": 0.6,
  "TEXT_LINK_PRESSED_STATE_OPACITY": 0.6,
  "TEXT_LINK_DISABLED_STATE_OPACITY": 0.3,
  "TEXT_LINK_NORMAL_VARIANT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "TEXT_LINK_NORMAL_VARIANT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "TEXT_LINK_NORMAL_VARIANT_COLOR": "rgb(0, 90, 217)",
  "TEXT_LINK_DESTRUCTIVE_VARIANT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "TEXT_LINK_DESTRUCTIVE_VARIANT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "TEXT_LINK_DESTRUCTIVE_VARIANT_COLOR": "rgb(191, 0, 32)",
  "TEXTAREA_FONT_SIZE": 16,
  "TEXTAREA_FONT_LEADING": 24,
  "TEXTAREA_FONT_TRACKING": 0,
  "TEXTAREA_FONT_WEIGHT": 400,
  "TEXTAREA_FONT_CASE": "regular",
  "TEXTAREA_FONT_NUMBER_SPACING": "default",
  "TEXTAREA_FONT_SCALE": "paragraph-30",
  "TEXTAREA_FONT_FONT_FAMILY": "Square Sans Text",
  "TEXTAREA_HEIGHT": 112,
  "TEXTAREA_MIN_HEIGHT": 112,
  "TEXTAREA_MINIMUM_HEIGHT": 112,
  "TEXTAREA_MAXIMUM_HEIGHT": 320,
  "TEXTAREA_PLACEHOLDER_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TEXTAREA_PLACEHOLDER_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TEXTAREA_PLACEHOLDER_COLOR": "rgba(0, 0, 0, 0.15)",
  "TOAST_BACKGROUND_LIGHT_MODE_COLOR": "rgb(26, 26, 26)",
  "TOAST_BACKGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_BACKGROUND_COLOR": "rgb(26, 26, 26)",
  "TOAST_ACCENT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_ACCENT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_ACCENT_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_MAXIMUM_WIDTH": 600,
  "TOAST_HORIZONTAL_PADDING_SIZE": 16,
  "TOAST_VERTICAL_PADDING_SIZE": 16,
  "TOAST_RADIUS": 6,
  "TOAST_ICON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_ICON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_ICON_SPACING": 12,
  "TOAST_ICON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_CONTENT_SPACING": 12,
  "TOAST_BUTTON_TEXT_SIZE": 16,
  "TOAST_BUTTON_TEXT_LEADING": 24,
  "TOAST_BUTTON_TEXT_TRACKING": 0,
  "TOAST_BUTTON_TEXT_WEIGHT": 600,
  "TOAST_BUTTON_TEXT_CASE": "regular",
  "TOAST_BUTTON_TEXT_NUMBER_SPACING": "default",
  "TOAST_BUTTON_TEXT_SCALE": "paragraph-30",
  "TOAST_BUTTON_TEXT_FONT_FAMILY": "Square Sans Text",
  "TOAST_BUTTON_SPACING": 12,
  "TOAST_SEPARATOR_WIDTH": 1,
  "TOAST_SEPARATOR_HEIGHT": 8,
  "TOAST_SEPARATOR_OPACITY": 0.3,
  "TOAST_TEXT_SIZE": 16,
  "TOAST_TEXT_LEADING": 24,
  "TOAST_TEXT_TRACKING": 0,
  "TOAST_TEXT_WEIGHT": 400,
  "TOAST_TEXT_CASE": "regular",
  "TOAST_TEXT_NUMBER_SPACING": "default",
  "TOAST_TEXT_SCALE": "paragraph-30",
  "TOAST_TEXT_FONT_FAMILY": "Square Sans Text",
  "TOAST_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_TEXT_MULTILINE_SPACING": 12,
  "TOAST_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_LINK_SMALL_SIZE_TEXT_SIZE": 14,
  "TOAST_LINK_SMALL_SIZE_TEXT_LEADING": 22,
  "TOAST_LINK_SMALL_SIZE_TEXT_TRACKING": 0,
  "TOAST_LINK_SMALL_SIZE_TEXT_WEIGHT": 600,
  "TOAST_LINK_SMALL_SIZE_TEXT_CASE": "regular",
  "TOAST_LINK_SMALL_SIZE_TEXT_NUMBER_SPACING": "default",
  "TOAST_LINK_SMALL_SIZE_TEXT_SCALE": "paragraph-20",
  "TOAST_LINK_SMALL_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "TOAST_LINK_SMALL_SIZE_VERTICAL_PADDING": 0,
  "TOAST_LINK_MEDIUM_SIZE_TEXT_SIZE": 16,
  "TOAST_LINK_MEDIUM_SIZE_TEXT_LEADING": 24,
  "TOAST_LINK_MEDIUM_SIZE_TEXT_TRACKING": 0,
  "TOAST_LINK_MEDIUM_SIZE_TEXT_WEIGHT": 600,
  "TOAST_LINK_MEDIUM_SIZE_TEXT_CASE": "regular",
  "TOAST_LINK_MEDIUM_SIZE_TEXT_NUMBER_SPACING": "default",
  "TOAST_LINK_MEDIUM_SIZE_TEXT_SCALE": "paragraph-30",
  "TOAST_LINK_MEDIUM_SIZE_TEXT_FONT_FAMILY": "Square Sans Text",
  "TOAST_LINK_MEDIUM_SIZE_VERTICAL_PADDING": 0,
  "TOAST_LINK_NORMAL_STATE_OPACITY": 1,
  "TOAST_LINK_HOVER_STATE_OPACITY": 0.6,
  "TOAST_LINK_PRESSED_STATE_OPACITY": 0.6,
  "TOAST_LINK_DISABLED_STATE_OPACITY": 0.3,
  "TOAST_LINK_NORMAL_VARIANT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "TOAST_LINK_NORMAL_VARIANT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "TOAST_LINK_NORMAL_VARIANT_COLOR": "rgb(0, 90, 217)",
  "TOAST_LINK_DESTRUCTIVE_VARIANT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "TOAST_LINK_DESTRUCTIVE_VARIANT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "TOAST_LINK_DESTRUCTIVE_VARIANT_COLOR": "rgb(191, 0, 32)",
  "TOAST_PROGRESS_BAR_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_PROGRESS_BAR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_PROGRESS_BAR_HEIGHT": 4,
  "TOAST_PROGRESS_BAR_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_DISMISS_BUTTON_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_DISMISS_BUTTON_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_DISMISS_BUTTON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(26, 26, 26)",
  "TOAST_INFO_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_INFO_VARIANT_BACKGROUND_COLOR": "rgb(26, 26, 26)",
  "TOAST_INFO_VARIANT_ACCENT_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_ACCENT_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_ACCENT_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INFO_VARIANT_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_ICON_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_LINK_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_LINK_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INFO_VARIANT_LINK_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INFO_VARIANT_BUTTON_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_PROGRESS_BAR_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_PROGRESS_BAR_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_PROGRESS_BAR_COLOR": "rgb(0, 106, 255)",
  "TOAST_INFO_VARIANT_DISMISS_BUTTON_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_DISMISS_BUTTON_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INFO_VARIANT_DISMISS_BUTTON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INFO_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INFO_VARIANT_SEPARATOR_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(26, 26, 26)",
  "TOAST_SUCCESS_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_SUCCESS_VARIANT_BACKGROUND_COLOR": "rgb(26, 26, 26)",
  "TOAST_SUCCESS_VARIANT_ACCENT_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "TOAST_SUCCESS_VARIANT_ACCENT_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "TOAST_SUCCESS_VARIANT_ACCENT_COLOR": "rgb(0, 178, 59)",
  "TOAST_SUCCESS_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_SUCCESS_VARIANT_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "TOAST_SUCCESS_VARIANT_ICON_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "TOAST_SUCCESS_VARIANT_ICON_COLOR": "rgb(0, 178, 59)",
  "TOAST_SUCCESS_VARIANT_LINK_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_LINK_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_SUCCESS_VARIANT_LINK_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_SUCCESS_VARIANT_BUTTON_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_PROGRESS_BAR_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "TOAST_SUCCESS_VARIANT_PROGRESS_BAR_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "TOAST_SUCCESS_VARIANT_PROGRESS_BAR_COLOR": "rgb(0, 178, 59)",
  "TOAST_SUCCESS_VARIANT_DISMISS_BUTTON_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_DISMISS_BUTTON_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_SUCCESS_VARIANT_DISMISS_BUTTON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_SUCCESS_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_SUCCESS_VARIANT_SEPARATOR_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(26, 26, 26)",
  "TOAST_WARNING_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_WARNING_VARIANT_BACKGROUND_COLOR": "rgb(26, 26, 26)",
  "TOAST_WARNING_VARIANT_ACCENT_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_ACCENT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_ACCENT_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_WARNING_VARIANT_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_ICON_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_LINK_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_LINK_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_WARNING_VARIANT_LINK_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_WARNING_VARIANT_BUTTON_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_PROGRESS_BAR_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_PROGRESS_BAR_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_PROGRESS_BAR_COLOR": "rgb(255, 159, 64)",
  "TOAST_WARNING_VARIANT_DISMISS_BUTTON_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_DISMISS_BUTTON_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_WARNING_VARIANT_DISMISS_BUTTON_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_WARNING_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_WARNING_VARIANT_SEPARATOR_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_CRITICAL_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "TOAST_CRITICAL_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "TOAST_CRITICAL_VARIANT_BACKGROUND_COLOR": "rgb(204, 0, 35)",
  "TOAST_CRITICAL_VARIANT_ACCENT_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_ACCENT_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_ACCENT_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_TEXT_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_TEXT_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_ICON_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_ICON_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_LINK_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_LINK_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_LINK_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_BUTTON_TEXT_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_PROGRESS_BAR_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_PROGRESS_BAR_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_PROGRESS_BAR_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_DISMISS_BUTTON_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_DISMISS_BUTTON_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_DISMISS_BUTTON_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_CRITICAL_VARIANT_SEPARATOR_COLOR": "rgb(255, 255, 255)",
  "TOAST_INSIGHT_VARIANT_BACKGROUND_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "TOAST_INSIGHT_VARIANT_BACKGROUND_DARK_MODE_COLOR": "rgb(20, 20, 20)",
  "TOAST_INSIGHT_VARIANT_BACKGROUND_COLOR": "rgb(255, 255, 255)",
  "TOAST_INSIGHT_VARIANT_ACCENT_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_ACCENT_DARK_MODE_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_ACCENT_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INSIGHT_VARIANT_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_ICON_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_ICON_DARK_MODE_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_ICON_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_LINK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_LINK_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INSIGHT_VARIANT_LINK_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_BUTTON_TEXT_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_BUTTON_TEXT_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INSIGHT_VARIANT_BUTTON_TEXT_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_PROGRESS_BAR_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_PROGRESS_BAR_DARK_MODE_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_PROGRESS_BAR_COLOR": "rgb(135, 22, 217)",
  "TOAST_INSIGHT_VARIANT_DISMISS_BUTTON_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_DISMISS_BUTTON_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INSIGHT_VARIANT_DISMISS_BUTTON_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_SEPARATOR_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOAST_INSIGHT_VARIANT_SEPARATOR_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOAST_INSIGHT_VARIANT_SEPARATOR_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOGGLE_WIDTH": 40,
  "TOGGLE_HEIGHT": 24,
  "TOGGLE_BORDER_RADIUS": 100,
  "TOGGLE_BORDER_SIZE": 2,
  "TOGGLE_PADDING_VERTICAL": 5,
  "TOGGLE_PADDING_HORIZONTAL": 5,
  "TOGGLE_FOCUS_RING_BUFFER_SIZE": 0,
  "TOGGLE_FOCUS_RING_BORDER_SIZE": 2,
  "TOGGLE_FOCUS_RING_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_RING_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.35)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgba(255, 255, 255, 0.35)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_NORMAL_STATE_UNSELECTED_VALUE_THUMB_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_TRACK_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_NORMAL_STATE_SELECTED_VALUE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_HOVER_STATE_UNSELECTED_VALUE_THUMB_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_TRACK_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_HOVER_STATE_SELECTED_VALUE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_PRESSED_STATE_UNSELECTED_VALUE_THUMB_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_TRACK_COLOR": "rgb(0, 85, 204)",
  "TOGGLE_PRESSED_STATE_SELECTED_VALUE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_TRACK_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_FOCUS_STATE_UNSELECTED_VALUE_THUMB_COLOR": "rgb(0, 106, 255)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_BORDER_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_TRACK_COLOR": "rgb(0, 95, 229)",
  "TOGGLE_FOCUS_STATE_SELECTED_VALUE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0.03)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgba(0, 0, 0, 0.15)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(255, 255, 255, 0.05)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgba(255, 255, 255, 0.05)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgba(255, 255, 255, 0.15)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0.03)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_TRACK_COLOR": "rgba(0, 0, 0, 0.03)",
  "TOGGLE_DISABLED_STATE_UNSELECTED_VALUE_THUMB_COLOR": "rgba(0, 0, 0, 0.15)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_LIGHT_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_LIGHT_MODE_TRACK_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_LIGHT_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_DARK_MODE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_DARK_MODE_TRACK_COLOR": "rgba(255, 255, 255, 0.35)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_DARK_MODE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_BORDER_COLOR": "rgba(0, 0, 0, 0)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_TRACK_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOGGLE_DISABLED_STATE_SELECTED_VALUE_THUMB_COLOR": "rgb(255, 255, 255)",
  "TOOLTIP_MINIMUM_WIDTH": 40,
  "TOOLTIP_MINIMUM_HEIGHT": 40,
  "TOOLTIP_MAXIMUM_WIDTH": 400,
  "TOOLTIP_RADIUS": 6,
  "TOOLTIP_BACKGROUND_LIGHT_MODE_COLOR": "rgb(26, 26, 26)",
  "TOOLTIP_BACKGROUND_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "TOOLTIP_BACKGROUND_COLOR": "rgb(26, 26, 26)",
  "TOOLTIP_PADDING_VERTICAL_SIZE": 8,
  "TOOLTIP_PADDING_HORIZONTAL_SIZE": 12,
  "TOOLTIP_TEXT_SIZE": 14,
  "TOOLTIP_TEXT_LEADING": 22,
  "TOOLTIP_TEXT_TRACKING": 0,
  "TOOLTIP_TEXT_WEIGHT": 400,
  "TOOLTIP_TEXT_CASE": "regular",
  "TOOLTIP_TEXT_NUMBER_SPACING": "default",
  "TOOLTIP_TEXT_SCALE": "paragraph-20",
  "TOOLTIP_TEXT_FONT_FAMILY": "Square Sans Text",
  "TOOLTIP_TEXT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOOLTIP_TEXT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOOLTIP_TEXT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOOLTIP_LINK_SIZE": 14,
  "TOOLTIP_LINK_LEADING": 22,
  "TOOLTIP_LINK_TRACKING": 0,
  "TOOLTIP_LINK_WEIGHT": 600,
  "TOOLTIP_LINK_CASE": "regular",
  "TOOLTIP_LINK_NUMBER_SPACING": "default",
  "TOOLTIP_LINK_SCALE": "paragraph-20",
  "TOOLTIP_LINK_FONT_FAMILY": "Square Sans Text",
  "TOOLTIP_LINK_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOOLTIP_LINK_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOOLTIP_LINK_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOOLTIP_ANIMATION_MOVE_TRANSITION_DURATION": 240,
  "TOOLTIP_TRIGGER_ICON_NORMAL_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOOLTIP_TRIGGER_ICON_NORMAL_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "TOOLTIP_TRIGGER_ICON_NORMAL_STATE_COLOR": "rgba(0, 0, 0, 0.42)",
  "TOOLTIP_TRIGGER_ICON_ACTIVE_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOOLTIP_TRIGGER_ICON_ACTIVE_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOOLTIP_TRIGGER_ICON_ACTIVE_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOOLTIP_TRIGGER_ICON_DISABLED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TOOLTIP_TRIGGER_ICON_DISABLED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TOOLTIP_TRIGGER_ICON_DISABLED_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TOOLTIP_TRIGGER_TEXT_NORMAL_STATE_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "TOOLTIP_TRIGGER_TEXT_NORMAL_STATE_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "TOOLTIP_TRIGGER_TEXT_NORMAL_STATE_COLOR": "rgb(0, 90, 217)",
  "TOOLTIP_TRIGGER_TEXT_ACTIVE_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOOLTIP_TRIGGER_TEXT_ACTIVE_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TOOLTIP_TRIGGER_TEXT_ACTIVE_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TOOLTIP_TRIGGER_TEXT_UNDERLINE_SIZE": 1,
  "TOOLTIP_TRIGGER_ANIMATION_FADE_TRANSITION_DURATION": 240,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_SMALL_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 19,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 26,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 700,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "heading-20",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Display",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 100,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 19,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 26,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 700,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "heading-20",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Display",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 100,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 19,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 26,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 700,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "heading-20",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Display",
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 100,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_COMPACT_DENSITY_LARGE_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 32,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_SPACING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 32,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 32,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_SPACING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_SMALL_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_REGULAR_DENSITY_LARGE_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 32,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 32,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 32,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_STEP_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_SMALL_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_STEP_SPACING": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 18,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-10",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 80,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_STEP_SPACING": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_MEDIUM_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 4,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_STEP_SPACING": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_CURRENT_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_STEP_SPACING": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_IN_PROGRESS_STATE_COLOR": "rgba(0, 0, 0, 0.15)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_PADDING": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CHECKMARK_VARIANT_CUSTOM_TINT_COLOR": "rgba(255, 255, 255, 0.95)",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_PADDING": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CIRCLE_VARIANT_STROKE_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_INDICATOR_CUSTOM_VARIANT_STROKE_WIDTH": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_WIDTH": 12,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_HEIGHT": 1,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_RADIUS": 2,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_CONNECTOR_VERTICAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_CONTENT_HORIZONTAL_PADDING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_CONTENT_VERTICAL_PADDING": 9,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SIZE": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_LEADING": 24,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_TRACKING": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_WEIGHT": 600,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_CASE": "regular",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_NUMBER_SPACING": "default",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SCALE": "paragraph-30",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_FONT_FAMILY": "Square Sans Text",
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_SPACING": 8,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_LABEL_IS_HEADER": true,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_MINIMUM_WIDTH": 0,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_MAXIMUM_WIDTH": 90,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_STEP_SPACING": 16,
  "TRACKER_HORIZONTAL_ORIENTATION_CONNECTORS_DENSITY_LARGE_SIZE_COMPLETED_STATE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_ANIMATION_ENTER_TRANSITION_EASING": "cubic-bezier(0.26, 0.10, 0.48, 1.0)",
  "CORE_ANIMATION_ENTER_TRANSITION_FAST_SPEED_DURATION": 100,
  "CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION": 240,
  "CORE_ANIMATION_ENTER_TRANSITION_SLOW_SPEED_DURATION": 400,
  "CORE_ANIMATION_EXIT_TRANSITION_EASING": "cubic-bezier(0.52, 0.0, 0.74, 0.0)",
  "CORE_ANIMATION_EXIT_TRANSITION_FAST_SPEED_DURATION": 100,
  "CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION": 160,
  "CORE_ANIMATION_EXIT_TRANSITION_SLOW_SPEED_DURATION": 300,
  "CORE_ANIMATION_MOVE_TRANSITION_EASING": "cubic-bezier(0.76, 0.0, 0.24, 1.0)",
  "CORE_ANIMATION_MOVE_TRANSITION_FAST_SPEED_DURATION": 100,
  "CORE_ANIMATION_MOVE_TRANSITION_MODERATE_SPEED_DURATION": 240,
  "CORE_ANIMATION_MOVE_TRANSITION_SLOW_SPEED_DURATION": 400,
  "CORE_BORDER_10": 1,
  "CORE_BREAKPOINT_EXTRA_WIDE_MIN_WIDTH": 1024,
  "CORE_BREAKPOINT_WIDE_MIN_WIDTH": 800,
  "CORE_BREAKPOINT_WIDE_MIN_MAX_WIDTH": 1023,
  "CORE_BREAKPOINT_MEDIUM_MIN_WIDTH": 600,
  "CORE_BREAKPOINT_MEDIUM_MAX_WIDTH": 839,
  "CORE_BREAKPOINT_NARROW_MIN_WIDTH": 0,
  "CORE_BREAKPOINT_NARROW_MAX_WIDTH": 599,
  "CORE_TEXT_10_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_TEXT_10_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CORE_TEXT_10_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_TEXT_20_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.55)",
  "CORE_TEXT_20_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.55)",
  "CORE_TEXT_20_COLOR": "rgba(0, 0, 0, 0.55)",
  "CORE_TEXT_30_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CORE_TEXT_30_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "CORE_TEXT_30_COLOR": "rgba(0, 0, 0, 0.3)",
  "CORE_TEXT_INVERSE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CORE_TEXT_INVERSE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_TEXT_INVERSE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CORE_TEXT_BLACK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_TEXT_BLACK_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_TEXT_BLACK_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_TEXT_WHITE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_TEXT_WHITE_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_TEXT_WHITE_COLOR": "rgb(255, 255, 255)",
  "CORE_FILL_10_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_FILL_10_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CORE_FILL_10_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_FILL_20_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.42)",
  "CORE_FILL_20_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.35)",
  "CORE_FILL_20_COLOR": "rgba(0, 0, 0, 0.42)",
  "CORE_FILL_30_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.15)",
  "CORE_FILL_30_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.15)",
  "CORE_FILL_30_COLOR": "rgba(0, 0, 0, 0.15)",
  "CORE_FILL_40_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CORE_FILL_40_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CORE_FILL_40_COLOR": "rgba(0, 0, 0, 0.05)",
  "CORE_FILL_50_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.03)",
  "CORE_FILL_50_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.05)",
  "CORE_FILL_50_COLOR": "rgba(0, 0, 0, 0.03)",
  "CORE_FILL_INVERSE_LIGHT_MODE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CORE_FILL_INVERSE_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_FILL_INVERSE_COLOR": "rgba(255, 255, 255, 0.95)",
  "CORE_FILL_BLACK_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_FILL_BLACK_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_FILL_BLACK_COLOR": "rgba(0, 0, 0, 0.9)",
  "CORE_FILL_WHITE_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_FILL_WHITE_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_FILL_WHITE_COLOR": "rgb(255, 255, 255)",
  "CORE_DIVIDER_10_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.3)",
  "CORE_DIVIDER_10_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.3)",
  "CORE_DIVIDER_10_COLOR": "rgba(0, 0, 0, 0.3)",
  "CORE_DIVIDER_20_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.05)",
  "CORE_DIVIDER_20_DARK_MODE_COLOR": "rgba(255, 255, 255, 0.08)",
  "CORE_DIVIDER_20_COLOR": "rgba(0, 0, 0, 0.05)",
  "CORE_SURFACE_5_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_5_DARK_MODE_COLOR": "rgb(8, 8, 8)",
  "CORE_SURFACE_5_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_10_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_10_DARK_MODE_COLOR": "rgb(20, 20, 20)",
  "CORE_SURFACE_10_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_20_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_20_DARK_MODE_COLOR": "rgb(28, 28, 28)",
  "CORE_SURFACE_20_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_30_LIGHT_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_30_DARK_MODE_COLOR": "rgb(45, 45, 45)",
  "CORE_SURFACE_30_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_INVERSE_LIGHT_MODE_COLOR": "rgb(26, 26, 26)",
  "CORE_SURFACE_INVERSE_DARK_MODE_COLOR": "rgb(255, 255, 255)",
  "CORE_SURFACE_INVERSE_COLOR": "rgb(26, 26, 26)",
  "CORE_SURFACE_OVERLAY_LIGHT_MODE_COLOR": "rgba(0, 0, 0, 0.8)",
  "CORE_SURFACE_OVERLAY_DARK_MODE_COLOR": "rgba(0, 0, 0, 0.8)",
  "CORE_SURFACE_OVERLAY_COLOR": "rgba(0, 0, 0, 0.8)",
  "CORE_EMPHASIS_FILL_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_EMPHASIS_FILL_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_EMPHASIS_FILL_COLOR": "rgb(0, 106, 255)",
  "CORE_EMPHASIS_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "CORE_EMPHASIS_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "CORE_EMPHASIS_TEXT_COLOR": "rgb(0, 90, 217)",
  "CORE_EMPHASIS_10_LIGHT_MODE_COLOR": "rgb(0, 85, 204)",
  "CORE_EMPHASIS_10_DARK_MODE_COLOR": "rgb(0, 85, 204)",
  "CORE_EMPHASIS_10_COLOR": "rgb(0, 85, 204)",
  "CORE_EMPHASIS_20_LIGHT_MODE_COLOR": "rgb(0, 95, 229)",
  "CORE_EMPHASIS_20_DARK_MODE_COLOR": "rgb(0, 95, 229)",
  "CORE_EMPHASIS_20_COLOR": "rgb(0, 95, 229)",
  "CORE_EMPHASIS_30_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "CORE_EMPHASIS_30_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "CORE_EMPHASIS_30_COLOR": "rgb(204, 225, 255)",
  "CORE_EMPHASIS_40_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "CORE_EMPHASIS_40_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "CORE_EMPHASIS_40_COLOR": "rgb(230, 240, 255)",
  "CORE_SUCCESS_FILL_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "CORE_SUCCESS_FILL_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "CORE_SUCCESS_FILL_COLOR": "rgb(0, 178, 59)",
  "CORE_SUCCESS_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "CORE_SUCCESS_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "CORE_SUCCESS_TEXT_COLOR": "rgb(0, 125, 42)",
  "CORE_SUCCESS_10_LIGHT_MODE_COLOR": "rgb(0, 128, 42)",
  "CORE_SUCCESS_10_DARK_MODE_COLOR": "rgb(0, 128, 42)",
  "CORE_SUCCESS_10_COLOR": "rgb(0, 128, 42)",
  "CORE_SUCCESS_20_LIGHT_MODE_COLOR": "rgb(0, 153, 51)",
  "CORE_SUCCESS_20_DARK_MODE_COLOR": "rgb(0, 153, 51)",
  "CORE_SUCCESS_20_COLOR": "rgb(0, 153, 51)",
  "CORE_SUCCESS_30_LIGHT_MODE_COLOR": "rgb(204, 255, 221)",
  "CORE_SUCCESS_30_DARK_MODE_COLOR": "rgb(0, 89, 30)",
  "CORE_SUCCESS_30_COLOR": "rgb(204, 255, 221)",
  "CORE_SUCCESS_40_LIGHT_MODE_COLOR": "rgb(229, 255, 238)",
  "CORE_SUCCESS_40_DARK_MODE_COLOR": "rgb(0, 51, 17)",
  "CORE_SUCCESS_40_COLOR": "rgb(229, 255, 238)",
  "CORE_WARNING_FILL_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "CORE_WARNING_FILL_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "CORE_WARNING_FILL_COLOR": "rgb(255, 159, 64)",
  "CORE_WARNING_TEXT_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "CORE_WARNING_TEXT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "CORE_WARNING_TEXT_COLOR": "rgb(148, 92, 37)",
  "CORE_WARNING_10_LIGHT_MODE_COLOR": "rgb(204, 128, 51)",
  "CORE_WARNING_10_DARK_MODE_COLOR": "rgb(204, 128, 51)",
  "CORE_WARNING_10_COLOR": "rgb(204, 128, 51)",
  "CORE_WARNING_20_LIGHT_MODE_COLOR": "rgb(230, 143, 57)",
  "CORE_WARNING_20_DARK_MODE_COLOR": "rgb(230, 143, 57)",
  "CORE_WARNING_20_COLOR": "rgb(230, 143, 57)",
  "CORE_WARNING_30_LIGHT_MODE_COLOR": "rgb(255, 230, 204)",
  "CORE_WARNING_30_DARK_MODE_COLOR": "rgb(89, 45, 0)",
  "CORE_WARNING_30_COLOR": "rgb(255, 230, 204)",
  "CORE_WARNING_40_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "CORE_WARNING_40_DARK_MODE_COLOR": "rgb(51, 26, 0)",
  "CORE_WARNING_40_COLOR": "rgb(255, 242, 230)",
  "CORE_CRITICAL_FILL_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "CORE_CRITICAL_FILL_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "CORE_CRITICAL_FILL_COLOR": "rgb(204, 0, 35)",
  "CORE_CRITICAL_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "CORE_CRITICAL_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "CORE_CRITICAL_TEXT_COLOR": "rgb(191, 0, 32)",
  "CORE_CRITICAL_10_LIGHT_MODE_COLOR": "rgb(153, 0, 26)",
  "CORE_CRITICAL_10_DARK_MODE_COLOR": "rgb(153, 0, 26)",
  "CORE_CRITICAL_10_COLOR": "rgb(153, 0, 26)",
  "CORE_CRITICAL_20_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "CORE_CRITICAL_20_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "CORE_CRITICAL_20_COLOR": "rgb(178, 0, 30)",
  "CORE_CRITICAL_30_LIGHT_MODE_COLOR": "rgb(255, 204, 213)",
  "CORE_CRITICAL_30_DARK_MODE_COLOR": "rgb(89, 0, 15)",
  "CORE_CRITICAL_30_COLOR": "rgb(255, 204, 213)",
  "CORE_CRITICAL_40_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "CORE_CRITICAL_40_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "CORE_CRITICAL_40_COLOR": "rgb(255, 229, 234)",
  "CORE_FOCUS_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_FOCUS_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_FOCUS_COLOR": "rgb(0, 106, 255)",
  "CORE_GREEN_FILL_LIGHT_MODE_COLOR": "rgb(0, 178, 59)",
  "CORE_GREEN_FILL_DARK_MODE_COLOR": "rgb(0, 179, 59)",
  "CORE_GREEN_FILL_COLOR": "rgb(0, 178, 59)",
  "CORE_GREEN_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "CORE_GREEN_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "CORE_GREEN_TEXT_COLOR": "rgb(0, 125, 42)",
  "CORE_GREEN_10_LIGHT_MODE_COLOR": "rgb(0, 128, 42)",
  "CORE_GREEN_10_DARK_MODE_COLOR": "rgb(0, 128, 42)",
  "CORE_GREEN_10_COLOR": "rgb(0, 128, 42)",
  "CORE_GREEN_20_LIGHT_MODE_COLOR": "rgb(0, 153, 51)",
  "CORE_GREEN_20_DARK_MODE_COLOR": "rgb(0, 153, 51)",
  "CORE_GREEN_20_COLOR": "rgb(0, 153, 51)",
  "CORE_GREEN_30_LIGHT_MODE_COLOR": "rgb(204, 255, 221)",
  "CORE_GREEN_30_DARK_MODE_COLOR": "rgb(0, 89, 30)",
  "CORE_GREEN_30_COLOR": "rgb(204, 255, 221)",
  "CORE_GREEN_40_LIGHT_MODE_COLOR": "rgb(229, 255, 238)",
  "CORE_GREEN_40_DARK_MODE_COLOR": "rgb(0, 51, 17)",
  "CORE_GREEN_40_COLOR": "rgb(229, 255, 238)",
  "CORE_FOREST_FILL_LIGHT_MODE_COLOR": "rgb(25, 128, 42)",
  "CORE_FOREST_FILL_DARK_MODE_COLOR": "rgb(25, 128, 42)",
  "CORE_FOREST_FILL_COLOR": "rgb(25, 128, 42)",
  "CORE_FOREST_TEXT_LIGHT_MODE_COLOR": "rgb(0, 125, 42)",
  "CORE_FOREST_TEXT_DARK_MODE_COLOR": "rgb(22, 217, 86)",
  "CORE_FOREST_TEXT_COLOR": "rgb(0, 125, 42)",
  "CORE_FOREST_10_LIGHT_MODE_COLOR": "rgb(15, 77, 25)",
  "CORE_FOREST_10_DARK_MODE_COLOR": "rgb(15, 77, 25)",
  "CORE_FOREST_10_COLOR": "rgb(15, 77, 25)",
  "CORE_FOREST_20_LIGHT_MODE_COLOR": "rgb(20, 102, 34)",
  "CORE_FOREST_20_DARK_MODE_COLOR": "rgb(20, 102, 34)",
  "CORE_FOREST_20_COLOR": "rgb(20, 102, 34)",
  "CORE_FOREST_30_LIGHT_MODE_COLOR": "rgb(204, 255, 213)",
  "CORE_FOREST_30_DARK_MODE_COLOR": "rgb(0, 89, 15)",
  "CORE_FOREST_30_COLOR": "rgb(204, 255, 213)",
  "CORE_FOREST_40_LIGHT_MODE_COLOR": "rgb(230, 255, 234)",
  "CORE_FOREST_40_DARK_MODE_COLOR": "rgb(0, 51, 8)",
  "CORE_FOREST_40_COLOR": "rgb(230, 255, 234)",
  "CORE_TEAL_FILL_LIGHT_MODE_COLOR": "rgb(18, 191, 148)",
  "CORE_TEAL_FILL_DARK_MODE_COLOR": "rgb(18, 191, 148)",
  "CORE_TEAL_FILL_COLOR": "rgb(18, 191, 148)",
  "CORE_TEAL_TEXT_LIGHT_MODE_COLOR": "rgb(12, 120, 93)",
  "CORE_TEAL_TEXT_DARK_MODE_COLOR": "rgb(22, 216, 167)",
  "CORE_TEAL_TEXT_COLOR": "rgb(12, 120, 93)",
  "CORE_TEAL_10_LIGHT_MODE_COLOR": "rgb(13, 140, 109)",
  "CORE_TEAL_10_DARK_MODE_COLOR": "rgb(13, 140, 109)",
  "CORE_TEAL_10_COLOR": "rgb(13, 140, 109)",
  "CORE_TEAL_20_LIGHT_MODE_COLOR": "rgb(16, 166, 128)",
  "CORE_TEAL_20_DARK_MODE_COLOR": "rgb(16, 166, 128)",
  "CORE_TEAL_20_COLOR": "rgb(16, 166, 128)",
  "CORE_TEAL_30_LIGHT_MODE_COLOR": "rgb(204, 255, 242)",
  "CORE_TEAL_30_DARK_MODE_COLOR": "rgb(0, 89, 67)",
  "CORE_TEAL_30_COLOR": "rgb(204, 255, 242)",
  "CORE_TEAL_40_LIGHT_MODE_COLOR": "rgb(230, 255, 249)",
  "CORE_TEAL_40_DARK_MODE_COLOR": "rgb(0, 51, 38)",
  "CORE_TEAL_40_COLOR": "rgb(230, 255, 249)",
  "CORE_BLUE_FILL_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_BLUE_FILL_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_BLUE_FILL_COLOR": "rgb(0, 106, 255)",
  "CORE_BLUE_TEXT_LIGHT_MODE_COLOR": "rgb(0, 90, 217)",
  "CORE_BLUE_TEXT_DARK_MODE_COLOR": "rgb(74, 149, 255)",
  "CORE_BLUE_TEXT_COLOR": "rgb(0, 90, 217)",
  "CORE_BLUE_10_LIGHT_MODE_COLOR": "rgb(0, 85, 204)",
  "CORE_BLUE_10_DARK_MODE_COLOR": "rgb(0, 85, 204)",
  "CORE_BLUE_10_COLOR": "rgb(0, 85, 204)",
  "CORE_BLUE_20_LIGHT_MODE_COLOR": "rgb(0, 95, 229)",
  "CORE_BLUE_20_DARK_MODE_COLOR": "rgb(0, 95, 229)",
  "CORE_BLUE_20_COLOR": "rgb(0, 95, 229)",
  "CORE_BLUE_30_LIGHT_MODE_COLOR": "rgb(204, 225, 255)",
  "CORE_BLUE_30_DARK_MODE_COLOR": "rgb(0, 37, 89)",
  "CORE_BLUE_30_COLOR": "rgb(204, 225, 255)",
  "CORE_BLUE_40_LIGHT_MODE_COLOR": "rgb(230, 240, 255)",
  "CORE_BLUE_40_DARK_MODE_COLOR": "rgb(0, 21, 51)",
  "CORE_BLUE_40_COLOR": "rgb(230, 240, 255)",
  "CORE_SKY_FILL_LIGHT_MODE_COLOR": "rgb(38, 147, 255)",
  "CORE_SKY_FILL_DARK_MODE_COLOR": "rgb(38, 147, 255)",
  "CORE_SKY_FILL_COLOR": "rgb(38, 147, 255)",
  "CORE_SKY_TEXT_LIGHT_MODE_COLOR": "rgb(15, 101, 186)",
  "CORE_SKY_TEXT_DARK_MODE_COLOR": "rgb(46, 151, 255)",
  "CORE_SKY_TEXT_COLOR": "rgb(15, 101, 186)",
  "CORE_SKY_10_LIGHT_MODE_COLOR": "rgb(31, 117, 204)",
  "CORE_SKY_10_DARK_MODE_COLOR": "rgb(31, 117, 204)",
  "CORE_SKY_10_COLOR": "rgb(31, 117, 204)",
  "CORE_SKY_20_LIGHT_MODE_COLOR": "rgb(34, 132, 230)",
  "CORE_SKY_20_DARK_MODE_COLOR": "rgb(34, 132, 230)",
  "CORE_SKY_20_COLOR": "rgb(34, 132, 230)",
  "CORE_SKY_30_LIGHT_MODE_COLOR": "rgb(204, 230, 255)",
  "CORE_SKY_30_DARK_MODE_COLOR": "rgb(0, 45, 89)",
  "CORE_SKY_30_COLOR": "rgb(204, 230, 255)",
  "CORE_SKY_40_LIGHT_MODE_COLOR": "rgb(230, 242, 255)",
  "CORE_SKY_40_DARK_MODE_COLOR": "rgb(0, 26, 51)",
  "CORE_SKY_40_COLOR": "rgb(230, 242, 255)",
  "CORE_PURPLE_FILL_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "CORE_PURPLE_FILL_DARK_MODE_COLOR": "rgb(135, 22, 217)",
  "CORE_PURPLE_FILL_COLOR": "rgb(135, 22, 217)",
  "CORE_PURPLE_TEXT_LIGHT_MODE_COLOR": "rgb(135, 22, 217)",
  "CORE_PURPLE_TEXT_DARK_MODE_COLOR": "rgb(194, 110, 255)",
  "CORE_PURPLE_TEXT_COLOR": "rgb(135, 22, 217)",
  "CORE_PURPLE_10_LIGHT_MODE_COLOR": "rgb(104, 17, 166)",
  "CORE_PURPLE_10_DARK_MODE_COLOR": "rgb(104, 17, 166)",
  "CORE_PURPLE_10_COLOR": "rgb(104, 17, 166)",
  "CORE_PURPLE_20_LIGHT_MODE_COLOR": "rgb(120, 19, 191)",
  "CORE_PURPLE_20_DARK_MODE_COLOR": "rgb(120, 19, 191)",
  "CORE_PURPLE_20_COLOR": "rgb(120, 19, 191)",
  "CORE_PURPLE_30_LIGHT_MODE_COLOR": "rgb(234, 204, 255)",
  "CORE_PURPLE_30_DARK_MODE_COLOR": "rgb(52, 0, 89)",
  "CORE_PURPLE_30_COLOR": "rgb(234, 204, 255)",
  "CORE_PURPLE_40_LIGHT_MODE_COLOR": "rgb(244, 230, 255)",
  "CORE_PURPLE_40_DARK_MODE_COLOR": "rgb(30, 0, 51)",
  "CORE_PURPLE_40_COLOR": "rgb(244, 230, 255)",
  "CORE_PINK_FILL_LIGHT_MODE_COLOR": "rgb(217, 54, 176)",
  "CORE_PINK_FILL_DARK_MODE_COLOR": "rgb(217, 54, 176)",
  "CORE_PINK_FILL_COLOR": "rgb(217, 54, 176)",
  "CORE_PINK_TEXT_LIGHT_MODE_COLOR": "rgb(168, 42, 136)",
  "CORE_PINK_TEXT_DARK_MODE_COLOR": "rgb(255, 67, 208)",
  "CORE_PINK_TEXT_COLOR": "rgb(168, 42, 136)",
  "CORE_PINK_10_LIGHT_MODE_COLOR": "rgb(166, 41, 135)",
  "CORE_PINK_10_DARK_MODE_COLOR": "rgb(166, 41, 135)",
  "CORE_PINK_10_COLOR": "rgb(166, 41, 135)",
  "CORE_PINK_20_LIGHT_MODE_COLOR": "rgb(191, 48, 155)",
  "CORE_PINK_20_DARK_MODE_COLOR": "rgb(191, 48, 155)",
  "CORE_PINK_20_COLOR": "rgb(191, 48, 155)",
  "CORE_PINK_30_LIGHT_MODE_COLOR": "rgb(255, 204, 242)",
  "CORE_PINK_30_DARK_MODE_COLOR": "rgb(89, 0, 67)",
  "CORE_PINK_30_COLOR": "rgb(255, 204, 242)",
  "CORE_PINK_40_LIGHT_MODE_COLOR": "rgb(255, 230, 249)",
  "CORE_PINK_40_DARK_MODE_COLOR": "rgb(51, 0, 38)",
  "CORE_PINK_40_COLOR": "rgb(255, 230, 249)",
  "CORE_BURGUNDY_FILL_LIGHT_MODE_COLOR": "rgb(153, 8, 56)",
  "CORE_BURGUNDY_FILL_DARK_MODE_COLOR": "rgb(153, 8, 56)",
  "CORE_BURGUNDY_FILL_COLOR": "rgb(153, 8, 56)",
  "CORE_BURGUNDY_TEXT_LIGHT_MODE_COLOR": "rgb(153, 8, 56)",
  "CORE_BURGUNDY_TEXT_DARK_MODE_COLOR": "rgb(255, 86, 142)",
  "CORE_BURGUNDY_TEXT_COLOR": "rgb(153, 8, 56)",
  "CORE_BURGUNDY_10_LIGHT_MODE_COLOR": "rgb(102, 5, 37)",
  "CORE_BURGUNDY_10_DARK_MODE_COLOR": "rgb(102, 5, 37)",
  "CORE_BURGUNDY_10_COLOR": "rgb(102, 5, 37)",
  "CORE_BURGUNDY_20_LIGHT_MODE_COLOR": "rgb(128, 6, 47)",
  "CORE_BURGUNDY_20_DARK_MODE_COLOR": "rgb(128, 6, 47)",
  "CORE_BURGUNDY_20_COLOR": "rgb(128, 6, 47)",
  "CORE_BURGUNDY_30_LIGHT_MODE_COLOR": "rgb(255, 204, 221)",
  "CORE_BURGUNDY_30_DARK_MODE_COLOR": "rgb(89, 0, 30)",
  "CORE_BURGUNDY_30_COLOR": "rgb(255, 204, 221)",
  "CORE_BURGUNDY_40_LIGHT_MODE_COLOR": "rgb(255, 230, 238)",
  "CORE_BURGUNDY_40_DARK_MODE_COLOR": "rgb(51, 0, 17)",
  "CORE_BURGUNDY_40_COLOR": "rgb(255, 230, 238)",
  "CORE_RED_FILL_LIGHT_MODE_COLOR": "rgb(204, 0, 35)",
  "CORE_RED_FILL_DARK_MODE_COLOR": "rgb(204, 0, 35)",
  "CORE_RED_FILL_COLOR": "rgb(204, 0, 35)",
  "CORE_RED_TEXT_LIGHT_MODE_COLOR": "rgb(191, 0, 32)",
  "CORE_RED_TEXT_DARK_MODE_COLOR": "rgb(255, 90, 118)",
  "CORE_RED_TEXT_COLOR": "rgb(191, 0, 32)",
  "CORE_RED_10_LIGHT_MODE_COLOR": "rgb(153, 0, 26)",
  "CORE_RED_10_DARK_MODE_COLOR": "rgb(153, 0, 26)",
  "CORE_RED_10_COLOR": "rgb(153, 0, 26)",
  "CORE_RED_20_LIGHT_MODE_COLOR": "rgb(178, 0, 30)",
  "CORE_RED_20_DARK_MODE_COLOR": "rgb(178, 0, 30)",
  "CORE_RED_20_COLOR": "rgb(178, 0, 30)",
  "CORE_RED_30_LIGHT_MODE_COLOR": "rgb(255, 204, 213)",
  "CORE_RED_30_DARK_MODE_COLOR": "rgb(89, 0, 15)",
  "CORE_RED_30_COLOR": "rgb(255, 204, 213)",
  "CORE_RED_40_LIGHT_MODE_COLOR": "rgb(255, 229, 234)",
  "CORE_RED_40_DARK_MODE_COLOR": "rgb(51, 0, 9)",
  "CORE_RED_40_COLOR": "rgb(255, 229, 234)",
  "CORE_ORANGE_FILL_LIGHT_MODE_COLOR": "rgb(242, 91, 61)",
  "CORE_ORANGE_FILL_DARK_MODE_COLOR": "rgb(242, 91, 61)",
  "CORE_ORANGE_FILL_COLOR": "rgb(242, 91, 61)",
  "CORE_ORANGE_TEXT_LIGHT_MODE_COLOR": "rgb(168, 63, 42)",
  "CORE_ORANGE_TEXT_DARK_MODE_COLOR": "rgb(255, 95, 63)",
  "CORE_ORANGE_TEXT_COLOR": "rgb(168, 63, 42)",
  "CORE_ORANGE_10_LIGHT_MODE_COLOR": "rgb(191, 72, 48)",
  "CORE_ORANGE_10_DARK_MODE_COLOR": "rgb(191, 72, 48)",
  "CORE_ORANGE_10_COLOR": "rgb(191, 72, 48)",
  "CORE_ORANGE_20_LIGHT_MODE_COLOR": "rgb(219, 82, 55)",
  "CORE_ORANGE_20_DARK_MODE_COLOR": "rgb(219, 82, 55)",
  "CORE_ORANGE_20_COLOR": "rgb(219, 82, 55)",
  "CORE_ORANGE_30_LIGHT_MODE_COLOR": "rgb(255, 213, 204)",
  "CORE_ORANGE_30_DARK_MODE_COLOR": "rgb(89, 15, 0)",
  "CORE_ORANGE_30_COLOR": "rgb(255, 213, 204)",
  "CORE_ORANGE_40_LIGHT_MODE_COLOR": "rgb(255, 234, 230)",
  "CORE_ORANGE_40_DARK_MODE_COLOR": "rgb(51, 8, 0)",
  "CORE_ORANGE_40_COLOR": "rgb(255, 234, 230)",
  "CORE_GOLD_FILL_LIGHT_MODE_COLOR": "rgb(255, 159, 64)",
  "CORE_GOLD_FILL_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "CORE_GOLD_FILL_COLOR": "rgb(255, 159, 64)",
  "CORE_GOLD_TEXT_LIGHT_MODE_COLOR": "rgb(148, 92, 37)",
  "CORE_GOLD_TEXT_DARK_MODE_COLOR": "rgb(255, 159, 64)",
  "CORE_GOLD_TEXT_COLOR": "rgb(148, 92, 37)",
  "CORE_GOLD_10_LIGHT_MODE_COLOR": "rgb(204, 128, 51)",
  "CORE_GOLD_10_DARK_MODE_COLOR": "rgb(204, 128, 51)",
  "CORE_GOLD_10_COLOR": "rgb(204, 128, 51)",
  "CORE_GOLD_20_LIGHT_MODE_COLOR": "rgb(230, 143, 57)",
  "CORE_GOLD_20_DARK_MODE_COLOR": "rgb(230, 143, 57)",
  "CORE_GOLD_20_COLOR": "rgb(230, 143, 57)",
  "CORE_GOLD_30_LIGHT_MODE_COLOR": "rgb(255, 230, 204)",
  "CORE_GOLD_30_DARK_MODE_COLOR": "rgb(89, 45, 0)",
  "CORE_GOLD_30_COLOR": "rgb(255, 230, 204)",
  "CORE_GOLD_40_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "CORE_GOLD_40_DARK_MODE_COLOR": "rgb(51, 26, 0)",
  "CORE_GOLD_40_COLOR": "rgb(255, 242, 230)",
  "CORE_YELLOW_FILL_LIGHT_MODE_COLOR": "rgb(255, 191, 0)",
  "CORE_YELLOW_FILL_DARK_MODE_COLOR": "rgb(255, 191, 0)",
  "CORE_YELLOW_FILL_COLOR": "rgb(255, 191, 0)",
  "CORE_YELLOW_TEXT_LIGHT_MODE_COLOR": "rgb(135, 101, 0)",
  "CORE_YELLOW_TEXT_DARK_MODE_COLOR": "rgb(255, 191, 0)",
  "CORE_YELLOW_TEXT_COLOR": "rgb(135, 101, 0)",
  "CORE_YELLOW_10_LIGHT_MODE_COLOR": "rgb(204, 153, 0)",
  "CORE_YELLOW_10_DARK_MODE_COLOR": "rgb(204, 153, 0)",
  "CORE_YELLOW_10_COLOR": "rgb(204, 153, 0)",
  "CORE_YELLOW_20_LIGHT_MODE_COLOR": "rgb(229, 172, 0)",
  "CORE_YELLOW_20_DARK_MODE_COLOR": "rgb(229, 172, 0)",
  "CORE_YELLOW_20_COLOR": "rgb(229, 172, 0)",
  "CORE_YELLOW_30_LIGHT_MODE_COLOR": "rgb(255, 242, 204)",
  "CORE_YELLOW_30_DARK_MODE_COLOR": "rgb(89, 67, 0)",
  "CORE_YELLOW_30_COLOR": "rgb(255, 242, 204)",
  "CORE_YELLOW_40_LIGHT_MODE_COLOR": "rgb(255, 249, 229)",
  "CORE_YELLOW_40_DARK_MODE_COLOR": "rgb(51, 38, 0)",
  "CORE_YELLOW_40_COLOR": "rgb(255, 249, 229)",
  "CORE_TAUPE_FILL_LIGHT_MODE_COLOR": "rgb(166, 124, 83)",
  "CORE_TAUPE_FILL_DARK_MODE_COLOR": "rgb(166, 124, 83)",
  "CORE_TAUPE_FILL_COLOR": "rgb(166, 124, 83)",
  "CORE_TAUPE_TEXT_LIGHT_MODE_COLOR": "rgb(130, 97, 65)",
  "CORE_TAUPE_TEXT_DARK_MODE_COLOR": "rgb(201, 152, 102)",
  "CORE_TAUPE_TEXT_COLOR": "rgb(130, 97, 65)",
  "CORE_TAUPE_10_LIGHT_MODE_COLOR": "rgb(115, 86, 57)",
  "CORE_TAUPE_10_DARK_MODE_COLOR": "rgb(115, 86, 57)",
  "CORE_TAUPE_10_COLOR": "rgb(115, 86, 57)",
  "CORE_TAUPE_20_LIGHT_MODE_COLOR": "rgb(140, 105, 70)",
  "CORE_TAUPE_20_DARK_MODE_COLOR": "rgb(140, 105, 70)",
  "CORE_TAUPE_20_COLOR": "rgb(140, 105, 70)",
  "CORE_TAUPE_30_LIGHT_MODE_COLOR": "rgb(255, 230, 204)",
  "CORE_TAUPE_30_DARK_MODE_COLOR": "rgb(89, 45, 0)",
  "CORE_TAUPE_30_COLOR": "rgb(255, 230, 204)",
  "CORE_TAUPE_40_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "CORE_TAUPE_40_DARK_MODE_COLOR": "rgb(51, 26, 0)",
  "CORE_TAUPE_40_COLOR": "rgb(255, 242, 230)",
  "CORE_BROWN_FILL_LIGHT_MODE_COLOR": "rgb(102, 74, 46)",
  "CORE_BROWN_FILL_DARK_MODE_COLOR": "rgb(102, 77, 51)",
  "CORE_BROWN_FILL_COLOR": "rgb(102, 74, 46)",
  "CORE_BROWN_TEXT_LIGHT_MODE_COLOR": "rgb(102, 74, 46)",
  "CORE_BROWN_TEXT_DARK_MODE_COLOR": "rgb(201, 152, 102)",
  "CORE_BROWN_TEXT_COLOR": "rgb(102, 74, 46)",
  "CORE_BROWN_10_LIGHT_MODE_COLOR": "rgb(51, 37, 23)",
  "CORE_BROWN_10_DARK_MODE_COLOR": "rgb(51, 38, 26)",
  "CORE_BROWN_10_COLOR": "rgb(51, 37, 23)",
  "CORE_BROWN_20_LIGHT_MODE_COLOR": "rgb(77, 55, 34)",
  "CORE_BROWN_20_DARK_MODE_COLOR": "rgb(77, 57, 38)",
  "CORE_BROWN_20_COLOR": "rgb(77, 55, 34)",
  "CORE_BROWN_30_LIGHT_MODE_COLOR": "rgb(255, 230, 204)",
  "CORE_BROWN_30_DARK_MODE_COLOR": "rgb(89, 45, 0)",
  "CORE_BROWN_30_COLOR": "rgb(255, 230, 204)",
  "CORE_BROWN_40_LIGHT_MODE_COLOR": "rgb(255, 242, 230)",
  "CORE_BROWN_40_DARK_MODE_COLOR": "rgb(51, 25, 0)",
  "CORE_BROWN_40_COLOR": "rgb(255, 242, 230)",
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_COLUMN_COUNT": 4,
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_HORIZONTAL_SPACING": 16,
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_VERTICAL_SPACING": 16,
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_ITEM_SMALL_SIZE_COLUMN_SPAN": 1,
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_ITEM_MEDIUM_SIZE_COLUMN_SPAN": 2,
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_ITEM_LARGE_SIZE_COLUMN_SPAN": 3,
  "CORE_EXTRA_WIDE_VIEWPORT_GRID_ITEM_FULL_SIZE_COLUMN_SPAN": 4,
  "CORE_WIDE_VIEWPORT_GRID_COLUMN_COUNT": 4,
  "CORE_WIDE_VIEWPORT_GRID_HORIZONTAL_SPACING": 16,
  "CORE_WIDE_VIEWPORT_GRID_VERTICAL_SPACING": 16,
  "CORE_WIDE_VIEWPORT_GRID_ITEM_SMALL_SIZE_COLUMN_SPAN": 1,
  "CORE_WIDE_VIEWPORT_GRID_ITEM_MEDIUM_SIZE_COLUMN_SPAN": 2,
  "CORE_WIDE_VIEWPORT_GRID_ITEM_LARGE_SIZE_COLUMN_SPAN": 3,
  "CORE_WIDE_VIEWPORT_GRID_ITEM_FULL_SIZE_COLUMN_SPAN": 4,
  "CORE_MEDIUM_VIEWPORT_GRID_COLUMN_COUNT": 2,
  "CORE_MEDIUM_VIEWPORT_GRID_HORIZONTAL_SPACING": 16,
  "CORE_MEDIUM_VIEWPORT_GRID_VERTICAL_SPACING": 16,
  "CORE_MEDIUM_VIEWPORT_GRID_ITEM_SMALL_SIZE_COLUMN_SPAN": 1,
  "CORE_MEDIUM_VIEWPORT_GRID_ITEM_MEDIUM_SIZE_COLUMN_SPAN": 1,
  "CORE_MEDIUM_VIEWPORT_GRID_ITEM_LARGE_SIZE_COLUMN_SPAN": 1,
  "CORE_MEDIUM_VIEWPORT_GRID_ITEM_FULL_SIZE_COLUMN_SPAN": 2,
  "CORE_NARROW_VIEWPORT_GRID_COLUMN_COUNT": 1,
  "CORE_NARROW_VIEWPORT_GRID_HORIZONTAL_SPACING": 16,
  "CORE_NARROW_VIEWPORT_GRID_VERTICAL_SPACING": 16,
  "CORE_NARROW_VIEWPORT_GRID_ITEM_SMALL_SIZE_COLUMN_SPAN": 1,
  "CORE_NARROW_VIEWPORT_GRID_ITEM_MEDIUM_SIZE_COLUMN_SPAN": 1,
  "CORE_NARROW_VIEWPORT_GRID_ITEM_LARGE_SIZE_COLUMN_SPAN": 1,
  "CORE_NARROW_VIEWPORT_GRID_ITEM_FULL_SIZE_COLUMN_SPAN": 1,
  "CORE_ICON_EXPAND_16_FIDELITY_ASSET": "chevron-down",
  "CORE_ICON_EXPAND_16_FIDELITY_SIZE": 16,
  "CORE_ICON_EXPAND_16_FIDELITY_WIDTH": 16,
  "CORE_ICON_EXPAND_16_FIDELITY_HEIGHT": 16,
  "CORE_ICON_EXPAND_16_FIDELITY_TINTABLE": true,
  "CORE_ICON_EXPAND_16_FIDELITY_SEMANTIC_NAME": "chevron-down",
  "CORE_ICON_COLLAPSE_16_FIDELITY_ASSET": "chevron-up",
  "CORE_ICON_COLLAPSE_16_FIDELITY_SIZE": 16,
  "CORE_ICON_COLLAPSE_16_FIDELITY_WIDTH": 16,
  "CORE_ICON_COLLAPSE_16_FIDELITY_HEIGHT": 16,
  "CORE_ICON_COLLAPSE_16_FIDELITY_TINTABLE": true,
  "CORE_ICON_COLLAPSE_16_FIDELITY_SEMANTIC_NAME": "chevron-up",
  "CORE_ICON_CONTINUE_16_FIDELITY_ASSET": "chevron-right",
  "CORE_ICON_CONTINUE_16_FIDELITY_SIZE": 16,
  "CORE_ICON_CONTINUE_16_FIDELITY_WIDTH": 16,
  "CORE_ICON_CONTINUE_16_FIDELITY_HEIGHT": 16,
  "CORE_ICON_CONTINUE_16_FIDELITY_TINTABLE": true,
  "CORE_ICON_CONTINUE_16_FIDELITY_SEMANTIC_NAME": "chevron-right",
  "CORE_ICON_RETURN_16_FIDELITY_ASSET": "chevron-left",
  "CORE_ICON_RETURN_16_FIDELITY_SIZE": 16,
  "CORE_ICON_RETURN_16_FIDELITY_WIDTH": 16,
  "CORE_ICON_RETURN_16_FIDELITY_HEIGHT": 16,
  "CORE_ICON_RETURN_16_FIDELITY_TINTABLE": true,
  "CORE_ICON_RETURN_16_FIDELITY_SEMANTIC_NAME": "chevron-left",
  "CORE_ICON_CLEAR_24_FIDELITY_ASSET": "x",
  "CORE_ICON_CLEAR_24_FIDELITY_SIZE": 24,
  "CORE_ICON_CLEAR_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_CLEAR_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_CLEAR_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_CLEAR_24_FIDELITY_SEMANTIC_NAME": "x",
  "CORE_ICON_CLOSE_24_FIDELITY_ASSET": "x",
  "CORE_ICON_CLOSE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_CLOSE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_CLOSE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_CLOSE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_CLOSE_24_FIDELITY_SEMANTIC_NAME": "clear",
  "CORE_ICON_ADD_24_FIDELITY_ASSET": "plus",
  "CORE_ICON_ADD_24_FIDELITY_SIZE": 24,
  "CORE_ICON_ADD_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_ADD_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_ADD_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_ADD_24_FIDELITY_SEMANTIC_NAME": "plus",
  "CORE_ICON_REMOVE_24_FIDELITY_ASSET": "minus",
  "CORE_ICON_REMOVE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_REMOVE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_REMOVE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_REMOVE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_REMOVE_24_FIDELITY_SEMANTIC_NAME": "minus",
  "CORE_ICON_BACK_24_FIDELITY_ASSET": "arrow-left",
  "CORE_ICON_BACK_24_FIDELITY_SIZE": 24,
  "CORE_ICON_BACK_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_BACK_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_BACK_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_BACK_24_FIDELITY_SEMANTIC_NAME": "arrow-left",
  "CORE_ICON_PREVIOUS_24_FIDELITY_ASSET": "arrow-left",
  "CORE_ICON_PREVIOUS_24_FIDELITY_SIZE": 24,
  "CORE_ICON_PREVIOUS_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_PREVIOUS_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_PREVIOUS_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_PREVIOUS_24_FIDELITY_SEMANTIC_NAME": "back",
  "CORE_ICON_FORWARD_24_FIDELITY_ASSET": "arrow-right",
  "CORE_ICON_FORWARD_24_FIDELITY_SIZE": 24,
  "CORE_ICON_FORWARD_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_FORWARD_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_FORWARD_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_FORWARD_24_FIDELITY_SEMANTIC_NAME": "arrow-right",
  "CORE_ICON_NEXT_24_FIDELITY_ASSET": "arrow-right",
  "CORE_ICON_NEXT_24_FIDELITY_SIZE": 24,
  "CORE_ICON_NEXT_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_NEXT_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_NEXT_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_NEXT_24_FIDELITY_SEMANTIC_NAME": "forward",
  "CORE_ICON_ASCEND_24_FIDELITY_ASSET": "arrow-up",
  "CORE_ICON_ASCEND_24_FIDELITY_SIZE": 24,
  "CORE_ICON_ASCEND_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_ASCEND_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_ASCEND_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_ASCEND_24_FIDELITY_SEMANTIC_NAME": "arrow-up",
  "CORE_ICON_DESCEND_24_FIDELITY_ASSET": "arrow-down",
  "CORE_ICON_DESCEND_24_FIDELITY_SIZE": 24,
  "CORE_ICON_DESCEND_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_DESCEND_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_DESCEND_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_DESCEND_24_FIDELITY_SEMANTIC_NAME": "arrow-down",
  "CORE_ICON_MORE_24_FIDELITY_ASSET": "ellipsis-horizontal",
  "CORE_ICON_MORE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_MORE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_MORE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_MORE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_MORE_24_FIDELITY_SEMANTIC_NAME": "ellipsis-horizontal",
  "CORE_ICON_MENU_24_FIDELITY_ASSET": "hamburger-lines",
  "CORE_ICON_MENU_24_FIDELITY_SIZE": 24,
  "CORE_ICON_MENU_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_MENU_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_MENU_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_MENU_24_FIDELITY_SEMANTIC_NAME": "hamburger-lines",
  "CORE_ICON_LOADING_24_FIDELITY_ASSET": "radial-spinner",
  "CORE_ICON_LOADING_24_FIDELITY_SIZE": 24,
  "CORE_ICON_LOADING_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_LOADING_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_LOADING_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_LOADING_24_FIDELITY_SEMANTIC_NAME": "radial-spinner",
  "CORE_ICON_SEARCH_24_FIDELITY_ASSET": "magnifying-glass",
  "CORE_ICON_SEARCH_24_FIDELITY_SIZE": 24,
  "CORE_ICON_SEARCH_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_SEARCH_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_SEARCH_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_SEARCH_24_FIDELITY_SEMANTIC_NAME": "magnifying-glass",
  "CORE_ICON_DRAG_24_FIDELITY_ASSET": "grip-dots-vertical",
  "CORE_ICON_DRAG_24_FIDELITY_SIZE": 24,
  "CORE_ICON_DRAG_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_DRAG_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_DRAG_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_DRAG_24_FIDELITY_SEMANTIC_NAME": "grip-dots-vertical",
  "CORE_ICON_WARN_24_FIDELITY_ASSET": "exclamation-circle",
  "CORE_ICON_WARN_24_FIDELITY_SIZE": 24,
  "CORE_ICON_WARN_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_WARN_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_WARN_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_WARN_24_FIDELITY_SEMANTIC_NAME": "exclamation-circle",
  "CORE_ICON_WARNING_24_FIDELITY_ASSET": "exclamation-circle",
  "CORE_ICON_WARNING_24_FIDELITY_SIZE": 24,
  "CORE_ICON_WARNING_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_WARNING_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_WARNING_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_WARNING_24_FIDELITY_SEMANTIC_NAME": "warn",
  "CORE_ICON_ALERT_24_FIDELITY_ASSET": "exclamation-triangle",
  "CORE_ICON_ALERT_24_FIDELITY_SIZE": 24,
  "CORE_ICON_ALERT_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_ALERT_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_ALERT_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_ALERT_24_FIDELITY_SEMANTIC_NAME": "exclamation-triangle",
  "CORE_ICON_ATTENTION_24_FIDELITY_ASSET": "exclamation-triangle",
  "CORE_ICON_ATTENTION_24_FIDELITY_SIZE": 24,
  "CORE_ICON_ATTENTION_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_ATTENTION_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_ATTENTION_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_ATTENTION_24_FIDELITY_SEMANTIC_NAME": "alert",
  "CORE_ICON_SUCCEED_24_FIDELITY_ASSET": "checkmark-circle",
  "CORE_ICON_SUCCEED_24_FIDELITY_SIZE": 24,
  "CORE_ICON_SUCCEED_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_SUCCEED_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_SUCCEED_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_SUCCEED_24_FIDELITY_SEMANTIC_NAME": "checkmark-circle",
  "CORE_ICON_SUCCESS_24_FIDELITY_ASSET": "checkmark-circle",
  "CORE_ICON_SUCCESS_24_FIDELITY_SIZE": 24,
  "CORE_ICON_SUCCESS_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_SUCCESS_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_SUCCESS_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_SUCCESS_24_FIDELITY_SEMANTIC_NAME": "succeed",
  "CORE_ICON_INFORM_24_FIDELITY_ASSET": "i-circle",
  "CORE_ICON_INFORM_24_FIDELITY_SIZE": 24,
  "CORE_ICON_INFORM_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_INFORM_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_INFORM_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_INFORM_24_FIDELITY_SEMANTIC_NAME": "i-circle",
  "CORE_ICON_INFO_24_FIDELITY_ASSET": "i-circle",
  "CORE_ICON_INFO_24_FIDELITY_SIZE": 24,
  "CORE_ICON_INFO_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_INFO_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_INFO_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_INFO_24_FIDELITY_SEMANTIC_NAME": "inform",
  "CORE_ICON_DENY_24_FIDELITY_ASSET": "no-entry-circle",
  "CORE_ICON_DENY_24_FIDELITY_SIZE": 24,
  "CORE_ICON_DENY_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_DENY_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_DENY_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_DENY_24_FIDELITY_SEMANTIC_NAME": "no-entry-circle",
  "CORE_ICON_DENIED_24_FIDELITY_ASSET": "no-entry-circle",
  "CORE_ICON_DENIED_24_FIDELITY_SIZE": 24,
  "CORE_ICON_DENIED_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_DENIED_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_DENIED_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_DENIED_24_FIDELITY_SEMANTIC_NAME": "deny",
  "CORE_ICON_CANCEL_24_FIDELITY_ASSET": "x-circle",
  "CORE_ICON_CANCEL_24_FIDELITY_SIZE": 24,
  "CORE_ICON_CANCEL_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_CANCEL_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_CANCEL_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_CANCEL_24_FIDELITY_SEMANTIC_NAME": "x-circle",
  "CORE_ICON_CANCELLED_24_FIDELITY_ASSET": "x-circle",
  "CORE_ICON_CANCELLED_24_FIDELITY_SIZE": 24,
  "CORE_ICON_CANCELLED_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_CANCELLED_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_CANCELLED_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_CANCELLED_24_FIDELITY_SEMANTIC_NAME": "cancel",
  "CORE_ICON_RECOMMEND_24_FIDELITY_ASSET": "lightning-bolt",
  "CORE_ICON_RECOMMEND_24_FIDELITY_SIZE": 24,
  "CORE_ICON_RECOMMEND_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_RECOMMEND_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_RECOMMEND_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_RECOMMEND_24_FIDELITY_SEMANTIC_NAME": "lightning-bolt",
  "CORE_ICON_RECOMMENDATION_24_FIDELITY_ASSET": "lightning-bolt",
  "CORE_ICON_RECOMMENDATION_24_FIDELITY_SIZE": 24,
  "CORE_ICON_RECOMMENDATION_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_RECOMMENDATION_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_RECOMMENDATION_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_RECOMMENDATION_24_FIDELITY_SEMANTIC_NAME": "recommend",
  "CORE_ICON_REFRESH_24_FIDELITY_ASSET": "dual-rotating-arrows",
  "CORE_ICON_REFRESH_24_FIDELITY_SIZE": 24,
  "CORE_ICON_REFRESH_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_REFRESH_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_REFRESH_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_REFRESH_24_FIDELITY_SEMANTIC_NAME": "dual-rotating-arrows",
  "CORE_ICON_CYCLE_24_FIDELITY_ASSET": "dual-rotating-arrows",
  "CORE_ICON_CYCLE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_CYCLE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_CYCLE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_CYCLE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_CYCLE_24_FIDELITY_SEMANTIC_NAME": "refresh",
  "CORE_ICON_DELETE_24_FIDELITY_ASSET": "trashcan",
  "CORE_ICON_DELETE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_DELETE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_DELETE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_DELETE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_DELETE_24_FIDELITY_SEMANTIC_NAME": "trashcan",
  "CORE_ICON_CHECKMARK_24_FIDELITY_ASSET": "checkmark",
  "CORE_ICON_CHECKMARK_24_FIDELITY_SIZE": 24,
  "CORE_ICON_CHECKMARK_24_FIDELITY_WIDTH": 20,
  "CORE_ICON_CHECKMARK_24_FIDELITY_HEIGHT": 20,
  "CORE_ICON_CHECKMARK_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_CHECKMARK_24_FIDELITY_SEMANTIC_NAME": "checkmark",
  "CORE_ICON_CHECKMARK_20_FIDELITY_ASSET": "checkmark",
  "CORE_ICON_CHECKMARK_20_FIDELITY_SIZE": 20,
  "CORE_ICON_CHECKMARK_20_FIDELITY_WIDTH": 20,
  "CORE_ICON_CHECKMARK_20_FIDELITY_HEIGHT": 20,
  "CORE_ICON_CHECKMARK_20_FIDELITY_TINTABLE": true,
  "CORE_ICON_CHECKMARK_20_FIDELITY_SEMANTIC_NAME": "checkmark",
  "CORE_ICON_INDETERMINATE_20_FIDELITY_ASSET": "indeterminate-mark",
  "CORE_ICON_INDETERMINATE_20_FIDELITY_SIZE": 20,
  "CORE_ICON_INDETERMINATE_20_FIDELITY_WIDTH": 20,
  "CORE_ICON_INDETERMINATE_20_FIDELITY_HEIGHT": 20,
  "CORE_ICON_INDETERMINATE_20_FIDELITY_TINTABLE": true,
  "CORE_ICON_INDETERMINATE_20_FIDELITY_SEMANTIC_NAME": "indeterminate-mark",
  "CORE_ICON_HELP_24_FIDELITY_ASSET": "question-mark-circle",
  "CORE_ICON_HELP_24_FIDELITY_SIZE": 24,
  "CORE_ICON_HELP_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_HELP_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_HELP_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_HELP_24_FIDELITY_SEMANTIC_NAME": "question-mark-circle",
  "CORE_ICON_SHOW_24_FIDELITY_ASSET": "eye",
  "CORE_ICON_SHOW_24_FIDELITY_SIZE": 24,
  "CORE_ICON_SHOW_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_SHOW_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_SHOW_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_SHOW_24_FIDELITY_SEMANTIC_NAME": "eye",
  "CORE_ICON_HIDE_24_FIDELITY_ASSET": "eye-slash",
  "CORE_ICON_HIDE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_HIDE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_HIDE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_HIDE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_HIDE_24_FIDELITY_SEMANTIC_NAME": "eye-slash",
  "CORE_ICON_FILTER_24_FIDELITY_ASSET": "filter",
  "CORE_ICON_FILTER_24_FIDELITY_SIZE": 24,
  "CORE_ICON_FILTER_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_FILTER_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_FILTER_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_FILTER_24_FIDELITY_SEMANTIC_NAME": "filter",
  "CORE_ICON_FILE_24_FIDELITY_ASSET": "dogeared-paper",
  "CORE_ICON_FILE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_FILE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_FILE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_FILE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_FILE_24_FIDELITY_SEMANTIC_NAME": "dogeared-paper",
  "CORE_ICON_LOOK_24_FIDELITY_ASSET": "binoculars",
  "CORE_ICON_LOOK_24_FIDELITY_SIZE": 24,
  "CORE_ICON_LOOK_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_LOOK_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_LOOK_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_LOOK_24_FIDELITY_SEMANTIC_NAME": "binoculars",
  "CORE_ICON_ASCENDING_24_FIDELITY_ASSET": "arrow-up",
  "CORE_ICON_ASCENDING_24_FIDELITY_SIZE": 24,
  "CORE_ICON_ASCENDING_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_ASCENDING_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_ASCENDING_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_ASCENDING_24_FIDELITY_SEMANTIC_NAME": "arrow-up",
  "CORE_ICON_DESCENDING_24_FIDELITY_ASSET": "arrow-down",
  "CORE_ICON_DESCENDING_24_FIDELITY_SIZE": 24,
  "CORE_ICON_DESCENDING_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_DESCENDING_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_DESCENDING_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_DESCENDING_24_FIDELITY_SEMANTIC_NAME": "arrow-down",
  "CORE_ICON_UNSORTED_24_FIDELITY_ASSET": "up-down",
  "CORE_ICON_UNSORTED_24_FIDELITY_SIZE": 24,
  "CORE_ICON_UNSORTED_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_UNSORTED_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_UNSORTED_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_UNSORTED_24_FIDELITY_SEMANTIC_NAME": "up-down",
  "CORE_ICON_SETTINGS_24_FIDELITY_ASSET": "sliders-horizontal",
  "CORE_ICON_SETTINGS_24_FIDELITY_SIZE": 24,
  "CORE_ICON_SETTINGS_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_SETTINGS_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_SETTINGS_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_SETTINGS_24_FIDELITY_SEMANTIC_NAME": "sliders-horizontal",
  "CORE_ICON_UNDO_24_FIDELITY_ASSET": "cycle-backward",
  "CORE_ICON_UNDO_24_FIDELITY_SIZE": 24,
  "CORE_ICON_UNDO_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_UNDO_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_UNDO_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_UNDO_24_FIDELITY_SEMANTIC_NAME": "cycle-backward",
  "CORE_ICON_REDO_24_FIDELITY_ASSET": "cycle-forward",
  "CORE_ICON_REDO_24_FIDELITY_SIZE": 24,
  "CORE_ICON_REDO_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_REDO_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_REDO_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_REDO_24_FIDELITY_SEMANTIC_NAME": "cycle-forward",
  "CORE_ICON_EDIT_24_FIDELITY_ASSET": "pencil-writing",
  "CORE_ICON_EDIT_24_FIDELITY_SIZE": 24,
  "CORE_ICON_EDIT_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_EDIT_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_EDIT_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_EDIT_24_FIDELITY_SEMANTIC_NAME": "pencil-writing",
  "CORE_ICON_PICTURE_24_FIDELITY_ASSET": "image",
  "CORE_ICON_PICTURE_24_FIDELITY_SIZE": 24,
  "CORE_ICON_PICTURE_24_FIDELITY_WIDTH": 24,
  "CORE_ICON_PICTURE_24_FIDELITY_HEIGHT": 24,
  "CORE_ICON_PICTURE_24_FIDELITY_TINTABLE": true,
  "CORE_ICON_PICTURE_24_FIDELITY_SEMANTIC_NAME": "image",
  "CORE_BASE_SIZE": 8,
  "CORE_TEXT_SIZE": 16,
  "CORE_SPACE_10_SIZE": 8,
  "CORE_METRICS_SPACING_25": 2,
  "CORE_METRICS_SPACING_50": 4,
  "CORE_METRICS_SPACING_100": 8,
  "CORE_METRICS_SPACING_150": 12,
  "CORE_METRICS_SPACING_200": 16,
  "CORE_METRICS_SPACING_300": 24,
  "CORE_METRICS_SPACING_400": 32,
  "CORE_METRICS_SPACING_500": 40,
  "CORE_METRICS_SPACING_600": 48,
  "CORE_METRICS_SPACING_800": 64,
  "CORE_METRICS_SPACING_1000": 80,
  "CORE_METRICS_SPACING_1500": 120,
  "CORE_METRICS_SPACING_2000": 160,
  "CORE_RADIUS_6": 4,
  "CORE_RADIUS_10": 6,
  "CORE_RADIUS_20": 12,
  "CORE_HORIZONTAL_SIZE_CLASS_REGULAR_THRESHOLD": 600,
  "CORE_HORIZONTAL_SIZE_CLASS_WIDE_THRESHOLD": 1200,
  "CORE_VERTICAL_SIZE_CLASS_REGULAR_THRESHOLD": 600,
  "CORE_VERTICAL_SIZE_CLASS_TALL_THRESHOLD": 864,
  "CORE_SMALL_SIZE_MINIMUM_HEIGHT": 40,
  "CORE_MEDIUM_SIZE_MINIMUM_HEIGHT": 48,
  "CORE_LARGE_SIZE_MINIMUM_HEIGHT": 64,
  "CORE_FOCUS_RING_BUFFER_SIZE": 2,
  "CORE_FOCUS_RING_BORDER_SIZE": 2,
  "CORE_FOCUS_RING_LIGHT_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_FOCUS_RING_DARK_MODE_COLOR": "rgb(0, 106, 255)",
  "CORE_FOCUS_RING_COLOR": "rgb(0, 106, 255)",
  "CORE_TYPE_DISPLAY_10_SIZE": 32,
  "CORE_TYPE_DISPLAY_10_LEADING": 40,
  "CORE_TYPE_DISPLAY_10_TRACKING": 0,
  "CORE_TYPE_DISPLAY_10_WEIGHT": 700,
  "CORE_TYPE_DISPLAY_10_CASE": "regular",
  "CORE_TYPE_DISPLAY_10_NUMBER_SPACING": "default",
  "CORE_TYPE_DISPLAY_10_SCALE": "heading-30",
  "CORE_TYPE_DISPLAY_10_FONT_FAMILY": "Square Sans Display",
  "CORE_TYPE_DISPLAY_20_SIZE": 48,
  "CORE_TYPE_DISPLAY_20_LEADING": 56,
  "CORE_TYPE_DISPLAY_20_TRACKING": 0,
  "CORE_TYPE_DISPLAY_20_WEIGHT": 500,
  "CORE_TYPE_DISPLAY_20_CASE": "regular",
  "CORE_TYPE_DISPLAY_20_NUMBER_SPACING": "default",
  "CORE_TYPE_DISPLAY_20_SCALE": "heading-30",
  "CORE_TYPE_DISPLAY_20_FONT_FAMILY": "Square Sans Display",
  "CORE_TYPE_DISPLAY_FONT_FAMILY": "Square Sans Display",
  "CORE_TYPE_HEADING_5_SIZE": 12,
  "CORE_TYPE_HEADING_5_LEADING": 20,
  "CORE_TYPE_HEADING_5_TRACKING": 0.05,
  "CORE_TYPE_HEADING_5_WEIGHT": 500,
  "CORE_TYPE_HEADING_5_CASE": "uppercase",
  "CORE_TYPE_HEADING_5_NUMBER_SPACING": "default",
  "CORE_TYPE_HEADING_5_SCALE": "heading-5",
  "CORE_TYPE_HEADING_5_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_HEADING_5_IS_HEADER": true,
  "CORE_TYPE_HEADING_10_SIZE": 14,
  "CORE_TYPE_HEADING_10_LEADING": 22,
  "CORE_TYPE_HEADING_10_TRACKING": 0,
  "CORE_TYPE_HEADING_10_WEIGHT": 700,
  "CORE_TYPE_HEADING_10_CASE": "regular",
  "CORE_TYPE_HEADING_10_NUMBER_SPACING": "default",
  "CORE_TYPE_HEADING_10_SCALE": "heading-10",
  "CORE_TYPE_HEADING_10_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_HEADING_10_IS_HEADER": true,
  "CORE_TYPE_HEADING_20_SIZE": 19,
  "CORE_TYPE_HEADING_20_LEADING": 26,
  "CORE_TYPE_HEADING_20_TRACKING": 0,
  "CORE_TYPE_HEADING_20_WEIGHT": 700,
  "CORE_TYPE_HEADING_20_CASE": "regular",
  "CORE_TYPE_HEADING_20_NUMBER_SPACING": "default",
  "CORE_TYPE_HEADING_20_SCALE": "heading-20",
  "CORE_TYPE_HEADING_20_FONT_FAMILY": "Square Sans Display",
  "CORE_TYPE_HEADING_20_IS_HEADER": true,
  "CORE_TYPE_HEADING_30_SIZE": 25,
  "CORE_TYPE_HEADING_30_LEADING": 32,
  "CORE_TYPE_HEADING_30_TRACKING": 0,
  "CORE_TYPE_HEADING_30_WEIGHT": 700,
  "CORE_TYPE_HEADING_30_CASE": "regular",
  "CORE_TYPE_HEADING_30_NUMBER_SPACING": "default",
  "CORE_TYPE_HEADING_30_SCALE": "heading-30",
  "CORE_TYPE_HEADING_30_FONT_FAMILY": "Square Sans Display",
  "CORE_TYPE_HEADING_30_IS_HEADER": true,
  "CORE_TYPE_PARAGRAPH_10_SIZE": 12,
  "CORE_TYPE_PARAGRAPH_10_LEADING": 18,
  "CORE_TYPE_PARAGRAPH_10_TRACKING": 0,
  "CORE_TYPE_PARAGRAPH_10_WEIGHT": 400,
  "CORE_TYPE_PARAGRAPH_10_CASE": "regular",
  "CORE_TYPE_PARAGRAPH_10_NUMBER_SPACING": "default",
  "CORE_TYPE_PARAGRAPH_10_SCALE": "paragraph-10",
  "CORE_TYPE_PARAGRAPH_10_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_PARAGRAPH_20_SIZE": 14,
  "CORE_TYPE_PARAGRAPH_20_LEADING": 22,
  "CORE_TYPE_PARAGRAPH_20_TRACKING": 0,
  "CORE_TYPE_PARAGRAPH_20_WEIGHT": 400,
  "CORE_TYPE_PARAGRAPH_20_CASE": "regular",
  "CORE_TYPE_PARAGRAPH_20_NUMBER_SPACING": "default",
  "CORE_TYPE_PARAGRAPH_20_SCALE": "paragraph-20",
  "CORE_TYPE_PARAGRAPH_20_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_PARAGRAPH_30_SIZE": 16,
  "CORE_TYPE_PARAGRAPH_30_LEADING": 24,
  "CORE_TYPE_PARAGRAPH_30_TRACKING": 0,
  "CORE_TYPE_PARAGRAPH_30_WEIGHT": 400,
  "CORE_TYPE_PARAGRAPH_30_CASE": "regular",
  "CORE_TYPE_PARAGRAPH_30_NUMBER_SPACING": "default",
  "CORE_TYPE_PARAGRAPH_30_SCALE": "paragraph-30",
  "CORE_TYPE_PARAGRAPH_30_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_MEDIUM_10_SIZE": 12,
  "CORE_TYPE_MEDIUM_10_LEADING": 18,
  "CORE_TYPE_MEDIUM_10_TRACKING": 0,
  "CORE_TYPE_MEDIUM_10_WEIGHT": 500,
  "CORE_TYPE_MEDIUM_10_CASE": "regular",
  "CORE_TYPE_MEDIUM_10_NUMBER_SPACING": "default",
  "CORE_TYPE_MEDIUM_10_SCALE": "paragraph-10",
  "CORE_TYPE_MEDIUM_10_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_MEDIUM_20_SIZE": 14,
  "CORE_TYPE_MEDIUM_20_LEADING": 22,
  "CORE_TYPE_MEDIUM_20_TRACKING": 0,
  "CORE_TYPE_MEDIUM_20_WEIGHT": 500,
  "CORE_TYPE_MEDIUM_20_CASE": "regular",
  "CORE_TYPE_MEDIUM_20_NUMBER_SPACING": "default",
  "CORE_TYPE_MEDIUM_20_SCALE": "paragraph-20",
  "CORE_TYPE_MEDIUM_20_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_MEDIUM_30_SIZE": 16,
  "CORE_TYPE_MEDIUM_30_LEADING": 24,
  "CORE_TYPE_MEDIUM_30_TRACKING": 0,
  "CORE_TYPE_MEDIUM_30_WEIGHT": 500,
  "CORE_TYPE_MEDIUM_30_CASE": "regular",
  "CORE_TYPE_MEDIUM_30_NUMBER_SPACING": "default",
  "CORE_TYPE_MEDIUM_30_SCALE": "paragraph-30",
  "CORE_TYPE_MEDIUM_30_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_MEDIUM_WEIGHT": 500,
  "CORE_TYPE_SEMIBOLD_10_SIZE": 12,
  "CORE_TYPE_SEMIBOLD_10_LEADING": 18,
  "CORE_TYPE_SEMIBOLD_10_TRACKING": 0,
  "CORE_TYPE_SEMIBOLD_10_WEIGHT": 600,
  "CORE_TYPE_SEMIBOLD_10_CASE": "regular",
  "CORE_TYPE_SEMIBOLD_10_NUMBER_SPACING": "default",
  "CORE_TYPE_SEMIBOLD_10_SCALE": "paragraph-10",
  "CORE_TYPE_SEMIBOLD_10_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_SEMIBOLD_20_SIZE": 14,
  "CORE_TYPE_SEMIBOLD_20_LEADING": 22,
  "CORE_TYPE_SEMIBOLD_20_TRACKING": 0,
  "CORE_TYPE_SEMIBOLD_20_WEIGHT": 600,
  "CORE_TYPE_SEMIBOLD_20_CASE": "regular",
  "CORE_TYPE_SEMIBOLD_20_NUMBER_SPACING": "default",
  "CORE_TYPE_SEMIBOLD_20_SCALE": "paragraph-20",
  "CORE_TYPE_SEMIBOLD_20_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_SEMIBOLD_30_SIZE": 16,
  "CORE_TYPE_SEMIBOLD_30_LEADING": 24,
  "CORE_TYPE_SEMIBOLD_30_TRACKING": 0,
  "CORE_TYPE_SEMIBOLD_30_WEIGHT": 600,
  "CORE_TYPE_SEMIBOLD_30_CASE": "regular",
  "CORE_TYPE_SEMIBOLD_30_NUMBER_SPACING": "default",
  "CORE_TYPE_SEMIBOLD_30_SCALE": "paragraph-30",
  "CORE_TYPE_SEMIBOLD_30_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_SEMIBOLD_WEIGHT": 600,
  "CORE_TYPE_REGULAR_WEIGHT": 400,
  "CORE_TYPE_BOLD_WEIGHT": 700,
  "CORE_TYPE_FONT_FAMILY": "Square Sans Text",
  "CORE_TYPE_MONO_FONT_FAMILY": "Square Sans Mono"
};

const marketAccordionItemCss = "/*!@:host*/.sc-market-accordion-item-h{display:block;box-shadow:inset\n    0\n    calc(var(--accordion-heading-30-variant-separator-size) * -1)\n    0\n    var(--accordion-heading-30-variant-separator-color)}/*!@button*/button.sc-market-accordion-item{all:unset;display:flex;justify-content:space-between;align-items:center;width:100%;color:var(--accordion-normal-state-content-color);cursor:pointer}/*!@button:focus-visible*/button.sc-market-accordion-item:focus-visible{outline:var(--core-focus-ring-border-size) solid var(--core-focus-ring-color)}/*!@button:hover*/button.sc-market-accordion-item:hover{color:var(--accordion-hover-state-content-color)}/*!@button:active*/button.sc-market-accordion-item:active{color:var(--accordion-pressed-state-content-color)}/*!@:host([disabled]) button*/[disabled].sc-market-accordion-item-h button.sc-market-accordion-item{color:var(--accordion-disabled-state-content-color);cursor:not-allowed;pointer-events:none}/*!@.market-icon*/.market-icon.sc-market-accordion-item{transition-duration:300ms}/*!@:host([expanded]) .market-icon*/[expanded].sc-market-accordion-item-h .market-icon.sc-market-accordion-item{transform:rotate(-180deg)}/*!@h2*/h2.sc-market-accordion-item{margin:0;font-weight:var(--accordion-heading-30-variant-text-weight);font-size:var(--accordion-heading-30-variant-text-size);font-family:var(--accordion-heading-30-variant-text-font-family)}/*!@h2 button*/h2.sc-market-accordion-item button.sc-market-accordion-item{padding:var(--accordion-heading-30-variant-vertical-padding)\n      var(--accordion-heading-30-variant-horizontal-padding)}/*!@h2 + .accordion-content*/h2.sc-market-accordion-item+.accordion-content.sc-market-accordion-item{padding-bottom:var(--accordion-heading-30-variant-vertical-padding)}/*!@h2 .market-icon*/h2.sc-market-accordion-item .market-icon.sc-market-accordion-item{width:var(--accordion-heading-30-variant-expanded-phase-icon-width);height:var(--accordion-heading-30-variant-expanded-phase-icon-height)}/*!@h3*/h3.sc-market-accordion-item{margin:0;font-weight:var(--accordion-heading-20-variant-text-weight);font-size:var(--accordion-heading-20-variant-text-size);font-family:var(--accordion-heading-20-variant-text-font-family)}/*!@h3 button*/h3.sc-market-accordion-item button.sc-market-accordion-item{padding:var(--accordion-heading-20-variant-vertical-padding)\n      var(--accordion-heading-20-variant-horizontal-padding)}/*!@h3 + .accordion-content*/h3.sc-market-accordion-item+.accordion-content.sc-market-accordion-item{padding-bottom:var(--accordion-heading-20-variant-vertical-padding)}/*!@h3 .market-icon*/h3.sc-market-accordion-item .market-icon.sc-market-accordion-item{width:var(--accordion-heading-20-variant-expanded-phase-icon-width);height:var(--accordion-heading-20-variant-expanded-phase-icon-height)}/*!@h4*/h4.sc-market-accordion-item{margin:0;font-weight:var(--accordion-heading-10-variant-text-weight);font-size:var(--accordion-heading-10-variant-text-size);font-family:var(--accordion-heading-10-variant-text-font-family)}/*!@h4 button*/h4.sc-market-accordion-item button.sc-market-accordion-item{padding:var(--accordion-heading-10-variant-vertical-padding)\n      var(--accordion-heading-10-variant-horizontal-padding)}/*!@h4 + .accordion-content*/h4.sc-market-accordion-item+.accordion-content.sc-market-accordion-item{padding-bottom:var(--accordion-heading-10-variant-vertical-padding)}/*!@h4 .market-icon*/h4.sc-market-accordion-item .market-icon.sc-market-accordion-item{width:var(--accordion-heading-10-variant-expanded-phase-icon-width);height:var(--accordion-heading-10-variant-expanded-phase-icon-height)}/*!@:host([size=\"medium\"]) svg*/[size=\"medium\"].sc-market-accordion-item-h svg.sc-market-accordion-item{width:20px;height:20px}/*!@:host([size=\"small\"]) svg*/[size=\"small\"].sc-market-accordion-item-h svg.sc-market-accordion-item{width:16px;height:16px}";
var MarketAccordionItemStyle0 = marketAccordionItemCss;

const sizeToHeadingType = {
    large: '2',
    medium: '3',
    small: '4',
};
class MarketAccordionItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketAccordionItemExpandedChange = createEvent(this, "marketAccordionItemExpandedChange", 7);
        this.name = undefined;
        this.expanded = false;
        this.disabled = false;
        this.size = 'medium';
        this.customTrigger = undefined;
    }
    marketAccordionToggleHandler(e) {
        e.stopPropagation();
        this.setExpanded(!this.expanded);
    }
    /**
     * Used to set the "open" state of the accordion.
     */
    setExpanded(newExpanded) {
        const oldExpanded = this.expanded;
        if (newExpanded !== oldExpanded) {
            const { defaultPrevented } = this.marketAccordionItemExpandedChange.emit({
                expanded: newExpanded,
            });
            if (!defaultPrevented) {
                this.expanded = newExpanded;
                if (this.customTrigger) {
                    this.customTrigger.expanded = newExpanded;
                }
            }
        }
        return Promise.resolve();
    }
    /**
     * Sets `disabled` state. Allows external elements to programmatically trigger disabled styling.
     */
    setDisabled(value) {
        this.disabled = value;
        return Promise.resolve();
    }
    getAccordionIcon() {
        switch (this.size) {
            case 'small':
                return cjs.ACCORDION_HEADING_10_VARIANT_EXPANDED_PHASE_ICON_ASSET;
            case 'large':
                return cjs.ACCORDION_HEADING_30_VARIANT_EXPANDED_PHASE_ICON_ASSET;
            default: // medium
                return cjs.ACCORDION_HEADING_20_VARIANT_EXPANDED_PHASE_ICON_ASSET;
        }
    }
    componentWillLoad() {
        this.customTrigger = this.el.querySelector('[slot="custom-trigger"]');
        if (this.customTrigger) {
            this.customTrigger.expanded = this.expanded;
        }
    }
    render() {
        const Heading = `h${sizeToHeadingType[this.size]}`;
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        return (hAsync(Host, { key: '9bf53527577d02430c7a2e71fcdcd1e9f46002f8', class: "market-accordion-item" }, this.customTrigger ? (hAsync("slot", { name: "custom-trigger" })) : (hAsync(Heading, null, hAsync("button", { id: `${this.name}__button`, type: "button", "aria-expanded": this.expanded, "aria-controls": `${this.name}__content`, "aria-disabled": this.disabled, disabled: this.disabled, onClick: () => this.setExpanded(!this.expanded) }, hAsync("slot", { name: "label" }), hAsync(MarketIconTagName, { name: this.getAccordionIcon() })))), this.expanded && (hAsync("div", { key: '698e4a519769aab483d1d273221a92b310f32d27', id: `${this.name}__content`, class: "accordion-content", role: "region", "aria-labelledby": `${this.name}__button` }, hAsync("slot", { key: '65b7d758f1ee1fda7e3355a35a2dd9b465655265' })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketAccordionItemStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-accordion-item",
        "$members$": {
            "name": [513],
            "expanded": [1540],
            "disabled": [1540],
            "size": [513],
            "customTrigger": [32],
            "setExpanded": [64],
            "setDisabled": [64]
        },
        "$listeners$": [[0, "marketAccordionToggled", "marketAccordionToggleHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["name", "name"], ["expanded", "expanded"], ["disabled", "disabled"], ["size", "size"]]
    }; }
}

/**
 * @param {unknown} el - element to be checked
 * @returns {boolean} whether `el` is a `HTMLMarketCheckboxElement`
 */
function isCheckboxElement(el) {
    return (el === null || el === void 0 ? void 0 : el.tagName) === getNamespacedTagFor('market-checkbox').toUpperCase();
}
/**
 * @param {unknown} el - element to be checked
 * @returns {boolean} whether `el` is a `HTMLMarketRadioElement`
 */
function isRadioElement(el) {
    return (el === null || el === void 0 ? void 0 : el.tagName) === getNamespacedTagFor('market-radio').toUpperCase();
}
/**
 * @param {unknown} el - element to be checked
 * @returns {boolean} whether `el` is a `HTMLMarketRowElement`
 */
function isRowElement(el) {
    return (el === null || el === void 0 ? void 0 : el.tagName) === getNamespacedTagFor('market-row').toUpperCase();
}
/**
 * @param {unknown} el - element to be checked
 * @returns {boolean} whether `el` is a `HTMLMarketToggleElement`
 */
function isToggleElement(el) {
    return (el === null || el === void 0 ? void 0 : el.tagName) === getNamespacedTagFor('market-toggle').toUpperCase();
}

/**
 * Finds the row that's slotted in the action card
 *
 * @param {HTMLMarketActionCardElement} actionCardEl - the action card element
 * @returns {HTMLMarketRowElement | null} the row element, if found
 */
function getRowInActionCard(actionCardEl) {
    if (!(actionCardEl === null || actionCardEl === void 0 ? void 0 : actionCardEl.children)) {
        return null;
    }
    return [...actionCardEl.children].find(isRowElement);
}

const marketActionCardCss = "/*!@:host, ::slotted(*), **/.sc-market-action-card-h,.sc-market-action-card-s>*,*.sc-market-action-card{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-action-card-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-action-card-h *.sc-market-action-card,.sc-market-action-card-h[disabled].sc-market-action-card-s>*,.sc-market-action-card-h[disabled] .sc-market-action-card-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-action-card-h{--focus-ring-color:color-mix(in srgb, var(--action-card-focus-ring-color) 100%, transparent);display:block;padding:var(--action-card-padding-vertical-size) var(--action-card-padding-horizontal-size);border-radius:var(--action-card-border-radius);background-color:var(--action-card-background-color);box-shadow:inset\n    0\n    0\n    0\n    var(--action-card-normal-state-unselected-value-border-width)\n    var(--action-card-normal-state-unselected-value-border-color);opacity:var(--action-card-normal-state-content-opacity);cursor:pointer}/*!@:host(:hover)*/.sc-market-action-card-h:hover{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-hover-state-unselected-value-border-width)\n      var(--action-card-hover-state-unselected-value-border-color)}/*!@:host(:active)*/.sc-market-action-card-h:active{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-active-state-unselected-value-border-width)\n      var(--action-card-active-state-unselected-value-border-color)}/*!@:host([disabled])*/[disabled].sc-market-action-card-h{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-disabled-state-unselected-value-border-width)\n      var(--action-card-disabled-state-unselected-value-border-color);opacity:var(--action-card-disabled-state-content-opacity)}/*!@:host([selected])*/[selected].sc-market-action-card-h{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-normal-state-selected-value-border-width)\n      var(--action-card-normal-state-selected-value-border-color)}/*!@:host([selected]:hover)*/[selected].sc-market-action-card-h:hover{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-hover-state-selected-value-border-width)\n      var(--action-card-hover-state-selected-value-border-color)}/*!@:host([selected]:active)*/[selected].sc-market-action-card-h:active{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-active-state-selected-value-border-width)\n      var(--action-card-active-state-selected-value-border-color)}/*!@:host([selected][disabled])*/[selected][disabled].sc-market-action-card-h{box-shadow:inset\n      0\n      0\n      0\n      var(--action-card-disabled-state-selected-value-border-width)\n      var(--action-card-disabled-state-selected-value-border-color)}/*!@:host(.has-slotted-row)*/.has-slotted-row.sc-market-action-card-h{padding:0 var(--row-background-horizontal-outset-padding)}/*!@:host(.has-slotted-row) ::slotted(.market-row)*/.sc-market-action-card-h.has-slotted-row .sc-market-action-card-s>.market-row{--row-normal-variant-hover-state-text-color:var(--row-normal-variant-normal-state-text-color);--row-normal-variant-hover-state-subtext-color:var(--row-normal-variant-normal-state-subtext-color);--row-normal-variant-hover-state-side-text-primary-color:var(--row-normal-variant-normal-state-side-text-primary-color);--row-normal-variant-hover-state-side-text-secondary-color:var(--row-normal-variant-normal-state-side-text-secondary-color);--row-normal-variant-selected-state-text-color:var(--row-normal-variant-normal-state-text-color);--row-normal-variant-selected-state-subtext-color:var(--row-normal-variant-normal-state-subtext-color);--row-normal-variant-selected-state-side-text-primary-color:var(--row-normal-variant-normal-state-side-text-primary-color);--row-normal-variant-selected-state-side-text-secondary-color:var(--row-normal-variant-normal-state-side-text-secondary-color);--row-normal-variant-pressed-state-text-color:var(--row-normal-variant-normal-state-text-color);--row-normal-variant-pressed-state-subtext-color:var(--row-normal-variant-normal-state-subtext-color);--row-normal-variant-pressed-state-side-text-primary-color:var(--row-normal-variant-normal-state-side-text-primary-color);--row-normal-variant-pressed-state-side-text-secondary-color:var(--row-normal-variant-normal-state-side-text-secondary-color);padding-right:calc(\n          var(--action-card-padding-horizontal-size) -\n          var(--row-normal-variant-background-horizontal-outset-padding)\n        );padding-left:calc(\n          var(--action-card-padding-horizontal-size) -\n          var(--row-normal-variant-background-horizontal-outset-padding)\n        );background-color:transparent}/*!@:host(:focus-visible)*/.sc-market-action-card-h:focus-visible{outline:var(--action-card-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--action-card-focus-ring-buffer-size)}";
var MarketActionCardStyle0 = marketActionCardCss;

/**
 * @slot - Optimized for use w/ slotted `<market-row>`s but can take any content. All slotted `market-row`s will automatically be set to interactive mode.
 */
class MarketActionCard {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketCardSelected = createEvent(this, "marketCardSelected", 7);
        this.marketCardDeselected = createEvent(this, "marketCardDeselected", 7);
        this.selected = false;
        this.disabled = false;
        this.value = undefined;
        this.transient = false;
    }
    /**
     * When rows are slotted into cards, we want to catch their selection events
     * and emit our own, so that the containing `market-list` only gets one set
     * of selection events.
     */
    handleRowSelection(e) {
        this.select();
        // Prevent `marketRowSelected` from bubbling up to containing lists, since we expect
        // them to listen to our card selection events instead.
        e.stopPropagation();
    }
    /**
     * When rows are slotted into cards, we want to catch their selection events
     * and emit our own, so that the containing `market-list` only gets one set
     * of selection events.
     */
    handleRowDeselection(e) {
        this.deselect();
        // Prevent `marketRowSelected` from bubbling up to containing lists, since we expect
        // them to listen to our card selection events instead.
        e.stopPropagation();
    }
    /**
     * Set `selected` to `true` and emit `marketCardSelected`. Generally speaking,
     * it is preferable to avoid using this method from outside this component
     * and allow `market-action-card` to manage its own selection state based on user
     * interaction. It should only be used for parent components that need to
     * manage a group of rows, such as `market-list`.
     */
    async select() {
        var _a, _b;
        this.selected = true;
        await ((_a = this.rowEl) === null || _a === void 0 ? void 0 : _a.silentlySelect());
        const { defaultPrevented } = this.marketCardSelected.emit({ value: this.value });
        if (defaultPrevented) {
            this.selected = false;
            await ((_b = this.rowEl) === null || _b === void 0 ? void 0 : _b.silentlyDeselect());
        }
    }
    /**
     * Set `selected` to `false` and emit `marketCardDeselected`. Generally speaking,
     * it is preferable to avoid using this method from outside this component
     * and allow `market-action-card` to manage its own selection state based on user
     * interaction. It should only be used for parent components that need to
     * manage a group of rows, such as `market-list`.
     */
    async deselect() {
        var _a, _b;
        this.selected = false;
        await ((_a = this.rowEl) === null || _a === void 0 ? void 0 : _a.silentlyDeselect());
        const { defaultPrevented } = this.marketCardDeselected.emit({ value: this.value });
        if (defaultPrevented) {
            this.selected = true;
            await ((_b = this.rowEl) === null || _b === void 0 ? void 0 : _b.silentlySelect());
        }
    }
    /**
     * Used for setting the selection state to true without emitting events.
     * Useful for scenarios where another component (ex. `<market-list>`) needs
     * to sync state with slotted `<market-action-card>`s.
     */
    async silentlySelect() {
        var _a;
        this.selected = true;
        await ((_a = this.rowEl) === null || _a === void 0 ? void 0 : _a.silentlySelect());
        return Promise.resolve();
    }
    /**
     * Set `selected` to `false`. Generally speaking,
     * it is preferable to avoid using this method from outside this component
     * and allow `market-action-card` to manage its own selection state based on user
     * interaction. It should only be used for parent components that need to
     * manage a group of rows, such as `market-list`.
     */
    async silentlyDeselect() {
        var _a;
        this.selected = false;
        await ((_a = this.rowEl) === null || _a === void 0 ? void 0 : _a.silentlyDeselect());
        return Promise.resolve();
    }
    isContentEditable(el) {
        // check whether element (Market or HTML) accepts text input
        const inputTagnames = ['input', 'textarea'];
        return inputTagnames.some((str) => el.tagName.includes(str)) || el.isContentEditable;
    }
    handleClick(e) {
        // clicks to text inputs should not select action card
        if (this.isContentEditable(e.target)) {
            return;
        }
        // Rows handle selected state when slotted. The only way you can click directly on
        // the card is by clicking the border, and we want to just ignore that edge case.
        if (this.disabled || this.transient || this.rowEl) {
            return;
        }
        if (!this.selected) {
            this.select();
        }
        else {
            this.deselect();
        }
    }
    handleKeydown(e) {
        // user should be able to type normally in text inputs
        if (this.isContentEditable(e.target)) {
            return;
        }
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault(); // prevents scroll down when Space is pressed
            if (this.rowEl) {
                this.rowEl.click();
            }
            else {
                this.el.click();
            }
        }
    }
    syncRowAttributes() {
        if (!this.rowEl) {
            return;
        }
        this.rowEl.interactive = true;
        this.rowEl.selected = this.selected;
        this.rowEl.removeAttribute('tabIndex');
    }
    handleSlotChangeDefault() {
        this.rowEl = getRowInActionCard(this.el);
        this.el.classList.toggle('has-slotted-row', Boolean(this.rowEl));
        this.syncRowAttributes();
    }
    componentDidRender() {
        // slotted rows inside action cards should not be able to receive focus because
        // they are controlled by interaction w/ the action card
        if (this.rowEl) {
            this.rowEl.removeAttribute('tabIndex');
        }
    }
    render() {
        return (hAsync(Host, { key: '0bf60bf0a77712869982bdc9a8928ecc0fa19fc7', "aria-selected": this.selected, class: "market-action-card", onClick: this.handleClick.bind(this), onKeydown: this.handleKeydown.bind(this), role: "option", tabindex: this.disabled ? null : '0' }, hAsync("slot", { key: '53d189d1a684ad82734157e67be5b640ed0a397b', onSlotchange: () => this.handleSlotChangeDefault() })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketActionCardStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-action-card",
        "$members$": {
            "selected": [1540],
            "disabled": [516],
            "value": [513],
            "transient": [4],
            "select": [64],
            "deselect": [64],
            "silentlySelect": [64],
            "silentlyDeselect": [64]
        },
        "$listeners$": [[0, "marketRowSelected", "handleRowSelection"], [0, "marketRowDeselected", "handleRowDeselection"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selected", "selected"], ["disabled", "disabled"], ["value", "value"]]
    }; }
}

const marketActivityIndicatorCss = "/*!@:host, ::slotted(*), **/.sc-market-activity-indicator-h,.sc-market-activity-indicator-s>*,*.sc-market-activity-indicator{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-activity-indicator-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-activity-indicator-h *.sc-market-activity-indicator,.sc-market-activity-indicator-h[disabled].sc-market-activity-indicator-s>*,.sc-market-activity-indicator-h[disabled] .sc-market-activity-indicator-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host([size=\"large\"]) .market-icon*/[size=\"large\"].sc-market-activity-indicator-h .market-icon.sc-market-activity-indicator{width:48px;height:48px}/*!@:host([size=\"small\"]) .market-icon*/[size=\"small\"].sc-market-activity-indicator-h .market-icon.sc-market-activity-indicator{width:24px;height:24px}/*!@.market-icon*/.market-icon.sc-market-activity-indicator{position:static;flex:none;fill:currentcolor;animation:rotation 1s infinite linear}@keyframes rotation{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}";
var MarketActivityIndicatorStyle0 = marketActivityIndicatorCss;

class MarketActivityIndicator {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.size = 'large';
    }
    render() {
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        return (hAsync(Host, { key: 'c13642455d6b245c715c753184dacb23e340e24d', class: "market-activity-indicator" }, hAsync(MarketIconTagName, { key: 'cbfa4da92d24e125d4edbe192475faa710c94102', name: "radial-spinner" })));
    }
    static get style() { return MarketActivityIndicatorStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-activity-indicator",
        "$members$": {
            "size": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["size", "size"]]
    }; }
}

const marketActivityIndicatorBarCss = "/*!@:host, ::slotted(*), **/.sc-market-activity-indicator-bar-h,.sc-market-activity-indicator-bar-s>*,*.sc-market-activity-indicator-bar{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-activity-indicator-bar-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-activity-indicator-bar-h *.sc-market-activity-indicator-bar,.sc-market-activity-indicator-bar-h[disabled].sc-market-activity-indicator-bar-s>*,.sc-market-activity-indicator-bar-h[disabled] .sc-market-activity-indicator-bar-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-activity-indicator-bar-h{--activity-indicator-bar-height:4px;--activity-indicator-bar-border-radius:6px;--activity-indicator-bar-bar-color:var(--core-fill-40-color);--activity-indicator-bar-value-color:var(--core-emphasis-fill-color);display:block;height:var(--activity-indicator-bar-height)}/*!@progress*/progress.sc-market-activity-indicator-bar{display:block;width:100%;height:100%;border:none;border-radius:var(--activity-indicator-bar-border-radius);background-color:var(--activity-indicator-bar-bar-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@progress[value]::-webkit-progress-value*/progress[value].sc-market-activity-indicator-bar::-webkit-progress-value{border-radius:var(--activity-indicator-bar-border-radius);background-color:var(--activity-indicator-bar-value-color)}/*!@progress[value]::-webkit-progress-bar, progress:not([value])::-webkit-progress-bar*/progress[value].sc-market-activity-indicator-bar::-webkit-progress-bar,progress.sc-market-activity-indicator-bar:not([value])::-webkit-progress-bar{border-radius:var(--activity-indicator-bar-border-radius);background-color:var(--activity-indicator-bar-bar-color)}/*!@progress[value]::-moz-progress-bar*/progress[value].sc-market-activity-indicator-bar::-moz-progress-bar{border-radius:var(--activity-indicator-bar-border-radius);background-color:var(--activity-indicator-bar-value-color)}/*!@progress:not([value])::-moz-progress-bar*/progress.sc-market-activity-indicator-bar:not([value])::-moz-progress-bar{visibility:hidden}/*!@.progress-bar*/.progress-bar.sc-market-activity-indicator-bar{width:100%;height:100%;border-radius:var(--activity-indicator-bar-border-radius);background-color:var(--activity-indicator-bar-bar-color)}/*!@.progress-bar > span*/.progress-bar.sc-market-activity-indicator-bar>span.sc-market-activity-indicator-bar{display:block;height:100%;border-radius:var(--activity-indicator-bar-border-radius);background-color:var(--activity-indicator-bar-value-color);text-indent:-9999px}";
var MarketActivityIndicatorBarStyle0 = marketActivityIndicatorBarCss;

class MarketActivityIndicatorBar {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.value = 0;
        this.max = 1;
    }
    render() {
        const max = this.max > 0 ? this.max : 1;
        const value = this.value > 0 ? Math.min(this.value, this.max) : 0;
        const percentComplete = (value / max) * 100;
        return (hAsync(Host, { key: '2e9db0488c0dc203483e1e9e56e41959a8329b1d', class: "market-activity-indicator-bar", role: "progressbar", "aria-valuenow": value, "aria-valuemin": "0", "aria-valuemax": max, "aria-valuetext": `${percentComplete}%` }, hAsync("progress", { key: '5dfd6befd05042fa11d9488f0f20ecd83cda9a5c', value: value, max: max }, hAsync("div", { key: 'cb0711db187e63011f1c2d12c4297c470f131445', class: "progress-bar" }, hAsync("span", { key: '164fa23663f68bb1058f457f57e878971709773a', style: { width: `${percentComplete}%` } })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketActivityIndicatorBarStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-activity-indicator-bar",
        "$members$": {
            "value": [2],
            "max": [2]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

const marketBannerCss = "/*!@:host, ::slotted(*), **/.sc-market-banner-h,.sc-market-banner-s>*,*.sc-market-banner{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-banner-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-banner-h *.sc-market-banner,.sc-market-banner-h[disabled].sc-market-banner-s>*,.sc-market-banner-h[disabled] .sc-market-banner-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-banner-h{display:flex;align-items:flex-start;width:100%;padding:var(--banner-vertical-padding) var(--banner-horizontal-padding);border-width:calc(var(--banner-border-width) * 1px);border-style:solid;border-radius:var(--banner-border-radius);font-weight:var(--banner-text-weight);font-size:var(--banner-text-size);line-height:var(--banner-text-leading);letter-spacing:var(--banner-text-tracking);text-transform:var(--banner-text-case);-moz-column-gap:var(--banner-icon-spacing);column-gap:var(--banner-icon-spacing)}/*!@.icon-container, .dismiss-container*/.icon-container.sc-market-banner,.dismiss-container.sc-market-banner{display:flex;flex-shrink:0;align-items:center}/*!@.dismiss-container button*/.dismiss-container.sc-market-banner button.sc-market-banner{display:flex;justify-content:center;align-items:center;margin:0;padding:0;border:none;background-color:transparent;cursor:pointer;transition:opacity 0.2s;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.dismiss-container button svg*/.dismiss-container.sc-market-banner button.sc-market-banner svg.sc-market-banner{fill:var(--banner-dismiss-button-normal-state-color)}/*!@.dismiss-container button:active svg*/.dismiss-container.sc-market-banner button.sc-market-banner:active svg.sc-market-banner{fill:var(--banner-dismiss-button-pressed-state-color)}/*!@.main*/.main.sc-market-banner{display:flex;flex-grow:1;flex-wrap:wrap;row-gap:var(--banner-multiline-spacing);-moz-column-gap:var(--banner-content-spacing);column-gap:var(--banner-content-spacing)}/*!@.main.has-title*/.main.has-title.sc-market-banner{flex-direction:column}/*!@.main.has-title .actions*/.main.has-title.sc-market-banner .actions.sc-market-banner{justify-content:unset}/*!@::slotted([slot=\"title\"])*/.sc-market-banner-s>[slot=\"title\"]{margin:0;font-weight:var(--banner-title-weight);font-size:var(--banner-title-size);font-family:inherit;line-height:var(--banner-title-leading);letter-spacing:var(--banner-title-tracking);text-transform:var(--banner-title-case)}/*!@section*/section.sc-market-banner{flex-grow:1}/*!@nav*/nav.sc-market-banner{display:flex;flex-wrap:wrap;justify-content:flex-end}/*!@nav.hidden*/nav.hidden.sc-market-banner{display:none}/*!@::slotted(a), ::slotted(button)*/.sc-market-banner-s>a,.sc-market-banner-s>button{margin:0;padding:0;border:none;background-color:transparent;font-weight:var(--banner-button-text-weight);font-size:var(--banner-button-text-size);font-family:inherit;line-height:var(--banner-button-text-leading);letter-spacing:var(--banner-button-text-tracking);text-decoration:none;text-transform:var(--banner-button-text-case);cursor:pointer;transition:opacity 0.2s}/*!@::slotted(a:hover), ::slotted(button:hover)*/.sc-market-banner-s>a:hover,.sc-market-banner-s>button:hover{opacity:var(--text-link-hover-state-opacity)}/*!@::slotted(a:active), ::slotted(button:active)*/.sc-market-banner-s>a:active,.sc-market-banner-s>button:active{opacity:var(--text-link-pressed-state-opacity)}/*!@::slotted([slot=\"action\"])*/.sc-market-banner-s>[slot=\"action\"]{display:flex;justify-content:center;align-items:center}/*!@::slotted([slot=\"action\"]:not(:last-child))*/.sc-market-banner-s>[slot=\"action\"]:not(:last-child){margin-right:calc(var(--banner-button-spacing) * 2 + var(--banner-button-separator-width))}/*!@::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-banner-s>[slot=\"action\"]:not(:last-child)::after{content:\"\";display:inline-block;width:var(--banner-button-separator-width);height:var(--banner-button-separator-height);margin-right:calc(-1 * var(--banner-button-spacing) - var(--banner-button-separator-width));margin-left:var(--banner-button-spacing);background-color:var(--banner-button-separator-color);opacity:var(--banner-button-separator-opacity);pointer-events:none}/*!@:host([variant=\"info\"])*/[variant=\"info\"].sc-market-banner-h{border-color:var(--banner-info-variant-border-color);background-color:var(--banner-info-variant-background-color);color:var(--banner-info-variant-text-color)}/*!@:host([variant=\"info\"]) .icon-container svg, :host([variant=\"info\"]) ::slotted([slot=\"icon\"])*/[variant=\"info\"].sc-market-banner-h .icon-container.sc-market-banner svg.sc-market-banner,.sc-market-banner-h[variant=\"info\"].sc-market-banner-s>[slot=\"icon\"],.sc-market-banner-h[variant=\"info\"] .sc-market-banner-s>[slot=\"icon\"]{fill:var(--banner-info-variant-icon-color)}/*!@:host([variant=\"info\"]) ::slotted(a)*/.sc-market-banner-h[variant=\"info\"] .sc-market-banner-s>a{color:var(--banner-info-variant-text-link-text-color)}/*!@:host([variant=\"info\"]) ::slotted(button)*/.sc-market-banner-h[variant=\"info\"] .sc-market-banner-s>button{color:var(--banner-info-variant-button-text-color)}/*!@:host([variant=\"success\"])*/[variant=\"success\"].sc-market-banner-h{border-color:var(--banner-success-variant-border-color);background-color:var(--banner-success-variant-background-color);color:var(--banner-success-variant-text-color)}/*!@:host([variant=\"success\"]) .icon-container svg, :host([variant=\"success\"]) ::slotted([slot=\"icon\"])*/[variant=\"success\"].sc-market-banner-h .icon-container.sc-market-banner svg.sc-market-banner,.sc-market-banner-h[variant=\"success\"].sc-market-banner-s>[slot=\"icon\"],.sc-market-banner-h[variant=\"success\"] .sc-market-banner-s>[slot=\"icon\"]{fill:var(--banner-success-variant-icon-color)}/*!@:host([variant=\"success\"]) ::slotted(a)*/.sc-market-banner-h[variant=\"success\"] .sc-market-banner-s>a{color:var(--banner-success-variant-text-link-text-color)}/*!@:host([variant=\"success\"]) ::slotted(button)*/.sc-market-banner-h[variant=\"success\"] .sc-market-banner-s>button{color:var(--banner-success-variant-button-text-color)}/*!@:host([variant=\"warning\"])*/[variant=\"warning\"].sc-market-banner-h{border-color:var(--banner-warning-variant-border-color);background-color:var(--banner-warning-variant-background-color);color:var(--banner-warning-variant-text-color)}/*!@:host([variant=\"warning\"]) .icon-container svg, :host([variant=\"warning\"]) ::slotted([slot=\"icon\"])*/[variant=\"warning\"].sc-market-banner-h .icon-container.sc-market-banner svg.sc-market-banner,.sc-market-banner-h[variant=\"warning\"].sc-market-banner-s>[slot=\"icon\"],.sc-market-banner-h[variant=\"warning\"] .sc-market-banner-s>[slot=\"icon\"]{fill:var(--banner-warning-variant-icon-color)}/*!@:host([variant=\"warning\"]) ::slotted(a)*/.sc-market-banner-h[variant=\"warning\"] .sc-market-banner-s>a{color:var(--banner-warning-variant-text-link-text-color)}/*!@:host([variant=\"warning\"]) ::slotted(button)*/.sc-market-banner-h[variant=\"warning\"] .sc-market-banner-s>button{color:var(--banner-warning-variant-button-text-color)}/*!@:host([variant=\"critical\"])*/[variant=\"critical\"].sc-market-banner-h{border-color:var(--banner-critical-variant-border-color);background-color:var(--banner-critical-variant-background-color);color:var(--banner-critical-variant-text-color)}/*!@:host([variant=\"critical\"]) .icon-container svg, :host([variant=\"critical\"]) ::slotted([slot=\"icon\"])*/[variant=\"critical\"].sc-market-banner-h .icon-container.sc-market-banner svg.sc-market-banner,.sc-market-banner-h[variant=\"critical\"].sc-market-banner-s>[slot=\"icon\"],.sc-market-banner-h[variant=\"critical\"] .sc-market-banner-s>[slot=\"icon\"]{fill:var(--banner-critical-variant-icon-color)}/*!@:host([variant=\"critical\"]) ::slotted(a)*/.sc-market-banner-h[variant=\"critical\"] .sc-market-banner-s>a{color:var(--banner-critical-variant-text-color)}/*!@:host([variant=\"critical\"]) ::slotted(button)*/.sc-market-banner-h[variant=\"critical\"] .sc-market-banner-s>button{color:var(--banner-critical-variant-button-text-color)}/*!@:host([variant=\"insight\"])*/[variant=\"insight\"].sc-market-banner-h{border-color:var(--banner-insight-variant-border-color);background-color:var(--banner-insight-variant-background-color);color:var(--banner-insight-variant-text-color)}/*!@:host([variant=\"insight\"]) .icon-container svg, :host([variant=\"insight\"]) ::slotted([slot=\"icon\"])*/[variant=\"insight\"].sc-market-banner-h .icon-container.sc-market-banner svg.sc-market-banner,.sc-market-banner-h[variant=\"insight\"].sc-market-banner-s>[slot=\"icon\"],.sc-market-banner-h[variant=\"insight\"] .sc-market-banner-s>[slot=\"icon\"]{fill:var(--banner-insight-variant-icon-color)}/*!@:host([variant=\"insight\"]) ::slotted(a)*/.sc-market-banner-h[variant=\"insight\"] .sc-market-banner-s>a{color:var(--banner-insight-variant-text-link-text-color)}/*!@:host([variant=\"insight\"]) ::slotted(button)*/.sc-market-banner-h[variant=\"insight\"] .sc-market-banner-s>button{color:var(--banner-insight-variant-button-text-color)}";
var MarketBannerStyle0 = marketBannerCss;

/**
 * @slot - The text for the banner
 * @slot title - Optional title text for the banner
 * @slot action - for `<a href>` or `<button>` (not a `<market-button>`)
 * @slot icon - for use with a custom icon
 */
class MarketBanner {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketBannerDismissed = createEvent(this, "marketBannerDismissed", 7);
        this.iconImageTitleId = v4();
        this.variant = 'info';
        this.dismissable = false;
        this.dismissButtonAriaLabel = 'Dismiss';
        this.iconImageTitle = '';
        this.hasTitle = false;
        this.hasAction = false;
    }
    renderIcon() {
        if (this.variant === 'success') {
            return (hAsync("svg", { role: "img", "aria-labelledby": this.iconImageTitleId, width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("title", { id: this.iconImageTitleId }, this.iconImageTitle || 'Success'), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M3 12C3 7.03 7.03 3 12 3C16.97 3 21 7.03 21 12C21 16.97 16.97 21 12 21C7.03 21 3 16.97 3 12ZM5 12C5 15.86 8.14 19 12 19C15.86 19 19 15.86 19 12C19 8.14 15.86 5 12 5C8.14 5 5 8.14 5 12ZM8.71005 10.8L11 13.09L15.3101 8.80005L16.72 10.21L11.72 15.21C11.52 15.4 11.27 15.5 11.01 15.5C10.75 15.5 10.5 15.41 10.3 15.21L7.30005 12.21L8.71005 10.8Z" })));
        }
        else if (this.variant === 'info') {
            return (hAsync("svg", { role: "img", "aria-labelledby": this.iconImageTitleId, width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("title", { id: this.iconImageTitleId }, this.iconImageTitle || 'Info'), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3ZM12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19ZM11 10.5V17H13V10.5H11ZM13.25 8.25C13.25 8.94036 12.6904 9.5 12 9.5C11.3096 9.5 10.75 8.94036 10.75 8.25C10.75 7.55964 11.3096 7 12 7C12.6904 7 13.25 7.55964 13.25 8.25Z" })));
        }
        else if (this.variant === 'insight') {
            return (hAsync("svg", { role: "img", "aria-labelledby": this.iconImageTitleId, width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("title", { id: this.iconImageTitleId }, this.iconImageTitle || 'Insight'), hAsync("path", { d: "M11 23.1701V15.0001H3.07996L13 0.830078V9.00008H20.92L11 23.1701ZM6.91996 13.0001H13V16.8301L17.08 11.0001H11V7.17008L6.91996 13.0001Z" })));
        }
        else if (this.variant === 'warning') {
            return (hAsync("svg", { role: "img", "aria-labelledby": this.iconImageTitleId, width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("title", { id: this.iconImageTitleId }, this.iconImageTitle || 'Warning'), hAsync("path", { d: "M11 9.00005H13V14.5H11V9.00005Z" }), hAsync("path", { d: "M12 18C12.6904 18 13.25 17.4404 13.25 16.75C13.25 16.0596 12.6904 15.5 12 15.5C11.3096 15.5 10.75 16.0596 10.75 16.75C10.75 17.4404 11.3096 18 12 18Z" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12.866 2.17944C12.6874 1.87004 12.3573 1.67944 12 1.67944C11.6427 1.67944 11.3126 1.87004 11.134 2.17944L1.13397 19.5C0.955342 19.8094 0.955342 20.1905 1.13397 20.5C1.31261 20.8094 1.64273 21 2 21H22C22.3573 21 22.6874 20.8094 22.866 20.5C23.0447 20.1905 23.0447 19.8094 22.866 19.5L12.866 2.17944ZM12 4.67944L20.268 19H3.73205L12 4.67944Z" })));
        }
        else {
            return (hAsync("svg", { role: "img", "aria-labelledby": this.iconImageTitleId, width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("title", { id: this.iconImageTitleId }, this.iconImageTitle || 'Critical'), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21ZM12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5ZM12 17C12.6904 17 13.25 16.4404 13.25 15.75C13.25 15.0596 12.6904 14.5 12 14.5C11.3096 14.5 10.75 15.0596 10.75 15.75C10.75 16.4404 11.3096 17 12 17ZM11 7H13V13.5H11V7Z" })));
        }
    }
    handleTitleSlotChange() {
        this.hasTitle = Boolean(this.el.querySelector('[slot="title"]'));
    }
    handleActionSlotChange() {
        this.hasAction = Boolean(this.el.querySelector('[slot="action"]'));
    }
    componentWillLoad() {
        this.handleTitleSlotChange();
        this.handleActionSlotChange();
    }
    dismiss() {
        const { defaultPrevented } = this.marketBannerDismissed.emit();
        if (defaultPrevented) {
            return;
        }
        this.el.remove();
    }
    render() {
        const MarketAccessoryTag = getNamespacedTagFor('market-accessory');
        return (hAsync(Host, { key: 'ffb5574b44bc37b38d23efd7307d7415a4c3ceaf', class: "market-banner", role: "region", "aria-label": "Announcement" }, hAsync("span", { key: '5935fe0a725184b2ec2a7a0dfdf23173f5252869', class: "icon-container" }, hAsync("slot", { key: 'fcbf0a6047b5050c61a579635357a83d77d64926', name: "icon" }, hAsync(MarketAccessoryTag, { key: '2bd70945af27aa5abdf98fe9cc58b9b0dd8bb628' }, this.renderIcon()))), hAsync("div", { key: '62ef145918434a57336b3c111ddc36cce75370c0', class: classNames('main', { 'has-title': this.hasTitle }) }, hAsync("section", { key: '3da66ddffb51bf5e5f901ceb375db16ad64ccd3a' }, hAsync("header", { key: '2c5e807ae88351662d1fa2a8df9ad4d18c0048ee', class: "title" }, hAsync("slot", { key: '69a3be7dd31ff30c99c1340365e8a287c6b796dd', name: "title", onSlotchange: () => this.handleTitleSlotChange() })), hAsync("slot", { key: '2c67b3f1c634f981caad07ebb1d55ac4b6036a3c' })), hAsync("nav", { key: '09220d97def465dbd2df1a9f7c48369dc78aa1a1', class: classNames('actions', { hidden: !this.hasAction }) }, hAsync("slot", { key: 'e59da0a55031ad40136cf1266d4576b659364c67', name: "action", onSlotchange: () => this.handleActionSlotChange() }))), this.dismissable && (hAsync("nav", { key: 'c075f617de3956f6cd0f63af1b37b6c314625250', class: "dismiss-container" }, hAsync("button", { key: '19211edf4ff14faba7ff45dad9d7eb59995b9a79', type: "button", "aria-label": this.dismissButtonAriaLabel, onClick: () => this.dismiss() }, hAsync("svg", { key: 'd0653fc50daff8e3335b59a2df41dd44b450e7ca', role: "presentation", "aria-hidden": "true", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '40960b4f1d753ae6422f23e6be4969fa65ca37a6', d: "M6.71004 18.71L12 13.41L17.29 18.71L18.71 17.29L13.41 12L18.71 6.71004L17.29 5.29004L12 10.59L6.71004 5.29004L5.29004 6.71004L10.59 12L5.29004 17.29L6.71004 18.71Z" })))))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketBannerStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-banner",
        "$members$": {
            "variant": [513],
            "dismissable": [516],
            "dismissButtonAriaLabel": [513, "dismiss-button-aria-label"],
            "iconImageTitle": [1, "icon-image-title"],
            "hasTitle": [32],
            "hasAction": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["variant", "variant"], ["dismissable", "dismissable"], ["dismissButtonAriaLabel", "dismiss-button-aria-label"]]
    }; }
}

/**
 * [PR 29510](https://github.com/Microsoft/TypeScript/pull/29510), available in
 * TypeScript 3.4+, enables us to define the literal string union type
 * `DialogType` based on a readonly array of all possible values (`as const`
 * makes `ALL_DIALOG_TYPES` readonly). This is required to support refactoring
 * from enum to union type while also allowing us to enumerate all possible
 * values (see references of `ALL_DIALOG_TYPES` for use cases).
 *
 * Motivation for the refactor from enum to union type can be found in the
 * description for [PR 1554](https://github.com/squareup/market/pull/1554).
 */
const ALL_DIALOG_TYPES = ['modal-full', 'modal-partial', 'blade', 'dialog', 'sheet'];
const DIALOGS_META = {
    'modal-full': { veil: true },
    'modal-partial': { veil: true },
    blade: { veil: false },
    dialog: { veil: true },
    sheet: { veil: true },
};
const getDialogSelector = () => ALL_DIALOG_TYPES.map((type) => {
    return getNamespacedTagFor(`market-${type}`);
}).join(',');
function setupDialogCompactHandler(modal) {
    const main = modal.querySelector('main, .main');
    const header = modal.querySelector(getNamespacedTagFor('market-header'));
    // Manage compact header on scroll unless it's already explicitly set
    if (main && header && !header.compact) {
        main.addEventListener('scroll', () => {
            if (main.scrollTop > 0) {
                if (!header.compact) {
                    const headingDiv = header.shadowRoot.querySelector('.heading');
                    const headingDivStyles = getComputedStyle(headingDiv);
                    const paddingTop = Number.parseInt(headingDivStyles.height, 10) + Number.parseInt(headingDivStyles.marginTop, 10);
                    main.style.paddingTop = `${paddingTop}px`;
                    header.compact = true;
                }
            }
            else {
                if (header.compact) {
                    main.style.paddingTop = '';
                    header.compact = false;
                }
            }
        });
    }
}

/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
// NOTE: separate `:not()` selectors has broader browser support than the newer
//  `:not([inert], [inert] *)` (Feb 2023)
// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes
//  the entire query to fail, resulting in no nodes found, which will break a lot
//  of things... so we have to rely on JS to identify nodes inside an inert container
var candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable="false"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function (element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

/**
 * Determines if a node is inert or in an inert ancestor.
 * @param {Element} [node]
 * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
 *  see if any of them are inert. If false, only `node` itself is considered.
 * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
 *  False if `node` is falsy.
 */
var isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
  //  JS API property; we have to check the attribute, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's an active element
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');
  var inert = inertAtt === '' || inertAtt === 'true';

  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
  //  if it weren't for `matches()` not being a function on shadow roots; the following
  //  code works for any kind of node
  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`
  //  so it likely would not support `:is([inert] *)` either...
  var result = inert || lookUp && node && isInert(node.parentNode); // recursive

  return result;
};

/**
 * Determines if a node's content is editable.
 * @param {Element} [node]
 * @returns True if it's content-editable; false if it's not or `node` is falsy.
 */
var isContentEditable = function isContentEditable(node) {
  var _node$getAttribute2;
  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
  //  to use the attribute directly to check for this, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's a non-editable element
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');
  return attValue === '' || attValue === 'true';
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  // even if `includeContainer=false`, we still have to check it for inertness because
  //  if it's inert, all its children are inert
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      // no need to look up since we're drilling down
      // anything inside this container will also be inert
      continue;
    }
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);

      // no inert look up because we're already drilling down and checking for inertness
      //  on the way down, so all containers to this root node should have already been
      //  vetted as non-inert
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};

/**
 * @private
 * Determines if the node has an explicitly specified `tabindex` attribute.
 * @param {HTMLElement} node
 * @returns {boolean} True if so; false if not.
 */
var hasTabIndex = function hasTabIndex(node) {
  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));
};

/**
 * Determine the tab index of a given node.
 * @param {HTMLElement} node
 * @returns {number} Tab order (negative, 0, or positive number).
 * @throws {Error} If `node` is falsy.
 */
var getTabIndex = function getTabIndex(node) {
  if (!node) {
    throw new Error('No node provided');
  }
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};

/**
 * Determine the tab index of a given node __for sort order purposes__.
 * @param {HTMLElement} node
 * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,
 *  has tabIndex -1, but needs to be sorted by document order in order for its content to be
 *  inserted into the correct sort position.
 * @returns {number} Tab order (negative, 0, or positive number).
 */
var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRoot;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
  //  `ownerDocument` will be `null`, hence the optional chaining on it.
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;

  // in some cases, a detached node will return itself as the root instead of a document or
  //  shadow root object, in which case, we shouldn't try to look further up the host chain
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled ||
  // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty$1(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      // move this existing trap to the front of the queue
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput(node) {
  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};

// checks for TAB by default
var isKeyForward = function isKeyForward(e) {
  return isTabEvent(e) && !e.shiftKey;
};

// checks for SHIFT+TAB by default
var isKeyBackward = function isKeyBackward(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay$2 = function delay(fn) {
  return setTimeout(fn, 0);
};

// Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs
var findIndex$1 = function findIndex(arr, fn) {
  var idx = -1;
  arr.every(function (value, i) {
    if (fn(value)) {
      idx = i;
      return false; // break
    }

    return true; // next
  });

  return idx;
};

/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */
var valueOrHandler = function valueOrHandler(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
  //  shadow host. However, event.target.composedPath() will be an array of
  //  nodes "clicked" from inner-most (the actual element inside the shadow) to
  //  outer-most (the host HTML document). If we have access to composedPath(),
  //  then use its first element; otherwise, fall back to event.target (and
  //  this only works for an _open_ shadow DOM; otherwise,
  //  composedPath()[0] === event.target always).
  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};

// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this
//  current instance use the same stack if `userOptions.trapStack` isn't specified
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap(elements, userOptions) {
  // SSR: a live trap shouldn't be created in this type of environment so this
  //  should be safe code to execute if the `document` option isn't specified
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward: isKeyForward,
    isKeyBackward: isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list

    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: undefined,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: undefined
  };
  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

  /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */
  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };

  /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event] If available, and `element` isn't directly found in any container,
   *  the event's composed path is used to see if includes any known trap containers in the
   *  case where the element is inside a Shadow DOM.
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */
  var findContainerIndex = function findContainerIndex(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;
    // NOTE: search `containerGroups` because it's possible a group contains no tabbable
    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
    //  and we still need to find the element in there
    return state.containerGroups.findIndex(function (_ref) {
      var container = _ref.container,
        tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {
        return node === element;
      });
    });
  };

  /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */
  var getNodeForOption = function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === 'function') {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = undefined; // use default value
    }

    if (!optionValue) {
      if (optionValue === undefined || optionValue === false) {
        return optionValue;
      }
      // else, empty string (invalid), null (invalid), 0 (invalid)

      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point

    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue); // resolve to node, or null if fails
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode() {
    var node = getNodeForOption('initialFocus');

    // false explicitly indicates we want no initialFocus at all
    if (node === false) {
      return false;
    }
    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {
      // option not specified nor focusable: use fallback options
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;

        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
        node = firstTabbableNode || getNodeForOption('fallbackFocus');
      }
    }
    if (!node) {
      throw new Error('Your focus-trap needs to have at least one focusable element');
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes() {
    state.containerGroups = state.containers.map(function (container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);

      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes
      //  are focusable but not tabbable
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;
      var firstDomTabbableNode = focusableNodes.find(function (node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function (node) {
        return getTabIndex(node) > 0;
      });
      return {
        container: container,
        tabbableNodes: tabbableNodes,
        focusableNodes: focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):
            //  since `node` should at least have been focusable, we assume that's the case and mimic
            //  what browsers do, which is set focus to the next node in __document position order__,
            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE
            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to
            //  basic DOM order
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function (group) {
      return group.tabbableNodes.length > 0;
    });

    // throw if no groups have tabbable nodes and we don't have a fallback focus node either
    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
    ) {
      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
    }

    // NOTE: Positive tabindexes are only properly supported in single-container traps because
    //  doing it across multiple containers where tabindexes could be all over the place
    //  would require Tabbable to support multiple containers, would require additional
    //  specialized Shadow DOM support, and would require Tabbable's multi-container support
    //  to look at those containers in document position order rather than user-provided
    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on
    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.
    if (state.containerGroups.find(function (g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };

  /**
   * Gets the current activeElement. If it's a web-component and has open shadow-root
   * it will recursively search inside shadow roots for the "true" activeElement.
   *
   * @param {Document | ShadowRoot} el
   *
   * @returns {HTMLElement} The element that currently has the focus
   **/
  var getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    // NOTE: focus() API does not trigger focusIn event so set MRU node manually
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus', previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };

  /**
   * Finds the next node (in either direction) where focus should move according to a
   *  keyboard focus-in event.
   * @param {Object} params
   * @param {Node} [params.target] Known target __from which__ to navigate, if any.
   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event
   *  will be used to determine the `target`). Ignored if `target` is specified.
   * @param {boolean} [params.isBackward] True if focus should move backward.
   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be
   *  determined given the current state of the trap.
   */
  var findNextNavNode = function findNextNavNode(_ref2) {
    var target = _ref2.target,
      event = _ref2.event,
      _ref2$isBackward = _ref2.isBackward,
      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      // make sure the target is actually contained in a group
      // NOTE: the target may also be the container itself if it's focusable
      //  with tabIndex='-1' and was given initial focus
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
      if (containerIndex < 0) {
        // target not found in any group: quite possible focus has escaped the trap,
        //  so bring it back into...
        if (isBackward) {
          // ...the last node in the last group
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          // ...the first node in the first group
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        // REVERSE

        // is the target the first tabbable node in a group?
        var startOfGroupIndex = findIndex$1(state.tabbableGroups, function (_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          // an exception case where the target is either the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle shift+tab as if focus were on the container's
          //  first tabbable node, and go to the last tabbable node of the LAST group
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          // YES: then shift+tab should go to the last tabbable node in the
          //  previous group (and wrap around to the last tabbable node of
          //  the LAST group if it's the first tabbable node of the FIRST group)
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        // FORWARD

        // is the target the last tabbable node in a group?
        var lastOfGroupIndex = findIndex$1(state.tabbableGroups, function (_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          // an exception case where the target is the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle tab as if focus were on the container's
          //  last tabbable node, and go to the first tabbable node of the FIRST group
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          // YES: then tab should go to the first tabbable node in the next
          //  group (and wrap around to the first tabbable node of the FIRST
          //  group if it's the last tabbable node of the LAST group)
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      // no groups available
      // NOTE: the fallbackFocus option does not support returning false to opt-out
      destinationNode = getNodeForOption('fallbackFocus');
    }
    return destinationNode;
  };

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  var checkPointerDown = function checkPointerDown(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      // allow the click since it ocurred inside the trap
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      // immediately deactivate the trap
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }

    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (valueOrHandler(config.allowOutsideClick, e)) {
      // allow the click outside the trap to take place
      return;
    }

    // otherwise, prevent the click
    e.preventDefault();
  };

  // In case focus escapes the trap for some strange reason, pull it back in.
  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected
  //  scrolling if the node that got focused was out of view; there's nothing we can do to
  //  prevent that from happening by the time we discover that focus escaped
  var checkFocusIn = function checkFocusIn(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;

    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      // escaped! pull it back in to where it just left
      event.stopImmediatePropagation();

      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;
      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward
      //  toward a node with a positive tab index
      var nextNode; // next node to focus, if we find one
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          // there MAY not be any tabbable nodes in the container if there are at least 2 containers
          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container
          //  with at least one tabbable node in order to function, so this could be the other container
          //  with nothing tabbable in it)
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable
            var mruTabIdx = tabbableNodes.findIndex(function (node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
                // else, don't wrap within the container as focus should move to next/previous
                //  container
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
                // else, don't wrap within the container as focus should move to next/previous
                //  container
              }
              // else, don't find in container order without considering direction too
            }
          }
          // else, no tabbable nodes in that container (which means we must have at least one other
          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown
          //  an error the last time updateTabbableNodes() was run): find next node among all known
          //  containers
        } else {
          // check to see if there's at least one tabbable node with a positive tab index inside
          //  the trap because focus seems to escape when navigating backward from a tabbable node
          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with
          //  the greatest positive tab index like it should)
          if (!state.containerGroups.some(function (g) {
            return g.tabbableNodes.some(function (n) {
              return getTabIndex(n) > 0;
            });
          })) {
            // no containers with tabbable nodes with positive tab indexes which means the focus
            //  escaped for some other reason and we should just execute the fallback to the
            //  MRU node or initial focus node, if any
            navAcrossContainers = false;
          }
        }
      } else {
        // no MRU node means we're likely in some initial condition when the trap has just
        //  been activated and initial focus hasn't been given yet, in which case we should
        //  fall through to trying to focus the initial focus node, which is what should
        //  happen below at this point in the logic
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        tryFocus(nextNode);
      } else {
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = undefined; // clear
  };

  // Hijack key nav events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  var checkKeyNav = function checkKeyNav(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event: event,
      isBackward: isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        // since tab natively moves focus, we wouldn't have a destination node unless we
        //  were on the edge of a container and had to move to the next/previous edge, in
        //  which case we want to prevent default to keep the browser from moving focus
        //  to where it normally would
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
    // else, let the browser take care of [shift+]tab and move the focus
  };

  var checkKey = function checkKey(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  //
  // EVENT LISTENERS
  //

  var addListeners = function addListeners() {
    if (!state.active) {
      return;
    }

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trapStack, trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay$2(function () {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);
    return trap;
  };

  //
  // MUTATION OBSERVER
  //

  var checkDomRemoval = function checkDomRemoval(mutations) {
    var isFocusedNodeRemoved = mutations.some(function (mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function (node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });

    // If the currently focused is removed then browsers will move focus to the
    // <body> element. If this happens, try to move focus back into the trap.
    if (isFocusedNodeRemoved) {
      tryFocus(getInitialFocusNode());
    }
  };

  // Use MutationObserver - if supported - to detect if focused node is removed
  // from the DOM.
  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;
  var updateObservedNodes = function updateObservedNodes() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function (container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };

  //
  // TRAP DEFINITION
  //

  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, 'onActivate');
      var onPostActivate = getOption(activateOptions, 'onPostActivate');
      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer); // noop if undefined
      state.delayInitialFocusTimer = undefined;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, 'onDeactivate');
      var onPostDeactivate = getOption(options, 'onPostDeactivate');
      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation() {
        delay$2(function () {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, 'onPause');
      var onPostPause = getOption(pauseOptions, 'onPostPause');
      state.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, 'onUnpause');
      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');
      state.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function (element) {
        return typeof element === 'string' ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };

  // initialize container elements
  trap.updateContainerElements(elements);
  return trap;
};

const createAndActivateFocusTrap = ({ activateOptions, el, options, }) => {
    // Prevent runtime errors when attempting to activate focus trap
    try {
        return createFocusTrap(el, Object.assign(Object.assign({ allowOutsideClick: true, document, escapeDeactivates: false }, options), { tabbableOptions: Object.assign({ getShadowRoot: true }, options === null || options === void 0 ? void 0 : options.tabbableOptions) }))
            .activate(activateOptions);
    }
    catch (e) {
        console.warn(e); // eslint-disable-line no-console
    }
    return undefined;
};

const marketBladeCss = "/*!@:host, ::slotted(*), **/.sc-market-blade-h,.sc-market-blade-s>*,*.sc-market-blade{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-blade-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-blade-h *.sc-market-blade,.sc-market-blade-h[disabled].sc-market-blade-s>*,.sc-market-blade-h[disabled] .sc-market-blade-s>*{cursor:not-allowed !important;pointer-events:none !important}@keyframes market-popup{from{opacity:0%;transform:scale(0.9, 0.9)}to{opacity:100%;transform:scale(1, 1)}}@keyframes market-popdown{from{opacity:100%;transform:scale(1, 1)}to{opacity:0%;transform:scale(0.9, 0.9)}}@keyframes market-slideup{from{opacity:0%;transform:translateY(80vh)}to{opacity:100%;transform:translateY(0)}}@keyframes market-slidedown{from{opacity:100%;transform:translateY(0)}to{opacity:0%;transform:translateY(80vh)}}@keyframes market-slide-left-enter{from{transform:translateX(100%)}to{transform:translateX(0)}}@keyframes market-slide-left-exit{from{transform:translateX(0)}to{transform:translateX(100%)}}@keyframes market-fade-in{from{opacity:0%}to{opacity:100%}}@keyframes market-fade-out{from{opacity:100%}to{opacity:0%}}@keyframes market-input-autofill-start{from{}to{}}@keyframes market-input-autofill-cancel{from{}to{}}@keyframes market-input-search-compact-enter{from{}to{}}@keyframes market-input-search-compact-exit{from{}to{}}/*!@:host*/.sc-market-blade-h{display:flex;flex-direction:column;justify-content:stretch;overflow:hidden}/*!@:host ::slotted(main), :host ::slotted(.main)*/.sc-market-blade-h .sc-market-blade-s>main,.sc-market-blade-h.sc-market-blade-s>.main,.sc-market-blade-h .sc-market-blade-s>.main{flex:0 1 100%;overflow-y:auto;height:100%}/*!@:host ::slotted(.market-header)*/.sc-market-blade-h .sc-market-blade-s>.market-header{margin-bottom:var(--core-metrics-spacing-300);padding-top:0}/*!@:host ::slotted(.market-footer)*/.sc-market-blade-h .sc-market-blade-s>.market-footer{padding-bottom:0}/*!@:host*/.sc-market-blade-h{position:fixed;top:0;right:0;width:100%;max-width:var(--modal-blade-maximum-width-size);height:100vh;padding-top:var(--modal-blade-regular-vertical-size-class-vertical-padding);padding-bottom:var(--modal-blade-regular-vertical-size-class-vertical-padding);background-color:var(--modal-blade-background-color);box-shadow:var(--elevation-20-shadow);animation-name:market-slide-left-enter;animation-duration:var(\n      --blade-animation-enter-transition-duration,\n      var(--core-animation-enter-transition-moderate-speed-duration)\n    );animation-timing-function:var(\n      --blade-animation-enter-transition-easing,\n      var(--core-animation-enter-transition-easing)\n    );animation-fill-mode:forwards}/*!@:host ::slotted(*)*/.sc-market-blade-h .sc-market-blade-s>*{padding-right:var(--modal-blade-regular-horizontal-size-class-horizontal-padding);padding-left:var(--modal-blade-regular-horizontal-size-class-horizontal-padding)}/*!@:host([hidden])*/[hidden].sc-market-blade-h{animation-name:market-slide-left-exit;animation-duration:var(\n        --blade-animation-exit-transition-duration,\n        var(--core-animation-exit-transition-moderate-speed-duration)\n      );animation-timing-function:var(\n        --blade-animation-exit-transition-easing,\n        var(--core-animation-exit-transition-easing)\n      )}/*!@:host([hidden].skip-animation)*/[hidden].skip-animation.sc-market-blade-h{transform:translateX(100%);animation:none}@media only screen and (min-width: 1200px){/*!@:host*/.sc-market-blade-h{max-width:var(--modal-blade-wide-viewport-width-size);padding-top:var(--modal-blade-wide-viewport-padding-top-size);padding-bottom:var(--modal-blade-wide-viewport-padding-bottom-size)}/*!@::slotted(*)*/.sc-market-blade-s>*{padding-right:var(--modal-blade-wide-viewport-padding-right-size);padding-left:var(--modal-blade-wide-viewport-padding-left-size)}}";
var MarketBladeStyle0 = marketBladeCss;

/**
 * @slot - The main content of the blade. Use `<section class="main">` tag.
 */
class MarketBlade {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDialogLoaded = createEvent(this, "marketDialogLoaded", 7);
        this.marketDialogDismissed = createEvent(this, "marketDialogDismissed", 7);
        this.marketDialogDidDismiss = createEvent(this, "marketDialogDidDismiss", 7);
        this.type = 'blade';
        /* Used to skip the exit animation for <market-blade hidden> on load */
        this.skipAnimation = false;
        this.hidden = false;
        this.dialogID = undefined;
        this.index = undefined;
        this.animationDuration = cjs.CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION;
        this.animationEnterDuration = cjs.CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION;
        this.animationExitDuration = cjs.CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION;
        this.trapFocus = false;
    }
    reenableAnimation() {
        this.skipAnimation = false;
    }
    /**
     * Listen to the marketHeaderNavigate event emitted by a market-header child component
     * so we can emit a close event if needed
     */
    headerNavigateEventHandler(event) {
        const { detail, target } = event;
        // TODO: 'close' should probably come from an enum of some sort
        if (detail.action === 'close') {
            // only dismiss if this is the first ancestor dialog
            if (target.closest(getDialogSelector()) === this.el) {
                this.dismiss();
            }
        }
    }
    /**
     * Emits the dismiss event
     * The parent context will handle actually removing elements from the DOM,
     * All the blade needs to do it emit an event so actually closing it can be
     * some other elements problem
     */
    dismiss(dismissOptions) {
        const { defaultPrevented } = this.marketDialogDismissed.emit({
            dialog: this.el,
            type: this.type,
            origin: (dismissOptions === null || dismissOptions === void 0 ? void 0 : dismissOptions.origin) || this.el,
        });
        if (!defaultPrevented) {
            this.hidden = true;
            /**
             * Emit a marketDialogDidDismiss event when modal gets fully dismissed (after animation).
             */
            setTimeout(() => {
                this.marketDialogDidDismiss.emit({
                    dialog: this.el,
                    type: this.type,
                    origin: this.el,
                });
            }, this.animationExitDuration);
        }
        return Promise.resolve();
    }
    onTrapFocusChanged(newValue, oldValue) {
        // only activate/deactivate when the `trapFocus` prop value changes
        if (newValue !== oldValue) {
            if (newValue) {
                this.activateFocusTrap();
            }
            else {
                this.deactivateFocusTrap();
            }
        }
    }
    /**
     * Activates the focus trap
     *
     * See [`focus-trap.ts`](../../utils/focus-trap.ts) for default options
     *
     * @param {Object} [options] [focus-trap create options](https://github.com/focus-trap/focus-trap#createoptions)
     * @param {Object} [activateOptions] set options for [onActivate, onPostActivate, and checkCanFocusTrap](https://github.com/focus-trap/focus-trap#trapactivate)
     */
    activateFocusTrap(options, activateOptions) {
        if (this.focusTrap) {
            this.focusTrap.activate(activateOptions !== null && activateOptions !== void 0 ? activateOptions : {});
            if (!this.trapFocus) {
                this.trapFocus = true;
            }
        }
        else {
            this.focusTrap = createAndActivateFocusTrap({
                activateOptions,
                el: this.el,
                options,
            });
        }
        return Promise.resolve();
    }
    /**
     * Deactivates the focus trap
     *
     * @param {FocusTrapDeactivateOptions} [deactivateOptions] set options for [onDeactivate, onPostDeactivate, and checkCanReturnFocus](https://github.com/focus-trap/focus-trap#trapdeactivate)
     */
    deactivateFocusTrap(deactivateOptions) {
        if (this.focusTrap) {
            this.focusTrap.deactivate(Object.assign({ returnFocus: true, checkCanReturnFocus: (trigger) => new Promise((resolve) => {
                    if (typeof (trigger === null || trigger === void 0 ? void 0 : trigger.setFocus) === 'function') {
                        trigger.setFocus();
                    }
                    else {
                        resolve(); // node.focus(); will be called by focus-trap
                    }
                }) }, deactivateOptions));
            this.focusTrap = undefined;
        }
        return Promise.resolve();
    }
    /**
     * Emit a marketDialogLoaded event when the component connects.
     * Need this so the context manager isn't rummaging around it's DOM
     * to try and find the dialog that was just appended
     */
    connectedCallback() {
        setTimeout(() => {
            this.marketDialogLoaded.emit({
                dialog: this.el,
                type: this.type,
            });
            if (this.trapFocus) {
                this.activateFocusTrap();
            }
        }, this.animationEnterDuration);
    }
    componentWillLoad() {
        const header = this.el.querySelector(getNamespacedTagFor('market-header'));
        if (header) {
            // We want to force the header to be navigable when slotted into blade
            header.showNavigation = true;
        }
        if (this.hidden) {
            this.skipAnimation = true;
        }
        setupDialogCompactHandler(this.el);
    }
    disconnectedCallback() {
        this.deactivateFocusTrap();
    }
    render() {
        return (hAsync(Host, { key: '06712e57a83ac4e3a59ad347b7dd3ee64345849e', role: "dialog", class: classNames('market-blade', {
                'skip-animation': this.skipAnimation,
            }) }, hAsync("slot", { key: '99deb622ccd2263d07aedda7146998984498b3e6' })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "hidden": ["reenableAnimation"],
        "trapFocus": ["onTrapFocusChanged"]
    }; }
    static get style() { return MarketBladeStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-blade",
        "$members$": {
            "hidden": [1540],
            "dialogID": [513, "data-dialog-id"],
            "index": [514, "data-dialog-index"],
            "animationDuration": [2, "animation-duration"],
            "animationEnterDuration": [2, "animation-enter-duration"],
            "animationExitDuration": [2, "animation-exit-duration"],
            "trapFocus": [1028, "trap-focus"],
            "dismiss": [64],
            "activateFocusTrap": [64],
            "deactivateFocusTrap": [64]
        },
        "$listeners$": [[0, "marketHeaderNavigate", "headerNavigateEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"], ["dialogID", "data-dialog-id"], ["index", "data-dialog-index"]]
    }; }
}

const marketButtonCss = "/*!@:host, ::slotted(*), **/.sc-market-button-h,.sc-market-button-s>*,*.sc-market-button{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-button-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-button-h *.sc-market-button,.sc-market-button-h[disabled].sc-market-button-s>*,.sc-market-button-h[disabled] .sc-market-button-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-button-h{--transition-duration:0.2s;--focus-ring-color:color-mix(in srgb, var(--button-focus-ring-color) 100%, transparent);position:relative;display:inline-block;border-radius:var(--button-border-radius);transition:background-color color var(--transition-duration)}/*!@.inner-tag*/.inner-tag.sc-market-button{display:inline-flex;justify-content:center;align-items:center;width:100%;border:none;border-radius:var(--button-border-radius);background-color:transparent;color:inherit;outline:none;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;text-align:center;text-decoration:none;cursor:pointer}/*!@.inner-tag:focus-visible*/.inner-tag.sc-market-button:focus-visible{outline:var(--button-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--button-focus-ring-buffer-size)}/*!@::slotted([slot=\"icon\"])*/.sc-market-button-s>[slot=\"icon\"]{position:relative;display:flex;color:inherit;fill:currentcolor;stroke:inherit}/*!@.market-activity-indicator*/.market-activity-indicator.sc-market-button{position:absolute;top:50%;left:50%;line-height:0;opacity:0%;transform:translate(-50%, -50%)}/*!@:host([is-loading])*/[is-loading].sc-market-button-h{pointer-events:none}/*!@:host([is-loading]) .inner-tag*/[is-loading].sc-market-button-h .inner-tag.sc-market-button{opacity:0%}/*!@:host([is-loading]) .market-activity-indicator*/[is-loading].sc-market-button-h .market-activity-indicator.sc-market-button{opacity:100%}/*!@:host([size=\"small\"])*/[size=\"small\"].sc-market-button-h{--button-small-size-minimum-width:var(--button-small-size-minimum-height);font-weight:var(--button-small-size-text-weight);font-size:var(--button-small-size-text-size);line-height:var(--button-small-size-text-leading);letter-spacing:var(--button-small-size-text-tracking)}/*!@:host([size=\"small\"]) .inner-tag*/[size=\"small\"].sc-market-button-h .inner-tag.sc-market-button{min-width:var(--button-small-size-minimum-width);min-height:var(--button-small-size-minimum-height);-moz-column-gap:var(--button-small-size-content-spacing);column-gap:var(--button-small-size-content-spacing)}/*!@:host([size=\"small\"][rank=\"primary\"]) .inner-tag*/[size=\"small\"][rank=\"primary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-small-size-primary-rank-vertical-padding)\n      var(--button-small-size-primary-rank-horizontal-padding)}/*!@:host([size=\"small\"][rank=\"primary\"]) svg, :host([size=\"small\"][rank=\"primary\"]) ::slotted([slot=\"icon\"])*/[size=\"small\"][rank=\"primary\"].sc-market-button-h svg.sc-market-button,.sc-market-button-h[size=\"small\"][rank=\"primary\"].sc-market-button-s>[slot=\"icon\"],.sc-market-button-h[size=\"small\"][rank=\"primary\"] .sc-market-button-s>[slot=\"icon\"]{margin:calc(\n        (var(--button-small-size-minimum-height) - var(--accessory-icon-variant-size)) / 2\n        - var(--button-small-size-primary-rank-vertical-padding)\n      ) 0}/*!@:host([size=\"small\"][rank=\"secondary\"]) .inner-tag*/[size=\"small\"][rank=\"secondary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-small-size-secondary-rank-vertical-padding)\n      var(--button-small-size-secondary-rank-horizontal-padding)}/*!@:host([size=\"small\"][rank=\"secondary\"]) svg, :host([size=\"small\"][rank=\"secondary\"]) ::slotted([slot=\"icon\"])*/[size=\"small\"][rank=\"secondary\"].sc-market-button-h svg.sc-market-button,.sc-market-button-h[size=\"small\"][rank=\"secondary\"].sc-market-button-s>[slot=\"icon\"],.sc-market-button-h[size=\"small\"][rank=\"secondary\"] .sc-market-button-s>[slot=\"icon\"]{margin:calc(\n        (var(--button-small-size-minimum-height) - var(--accessory-icon-variant-size)) / 2\n        - var(--button-small-size-secondary-rank-vertical-padding)\n      ) 0}/*!@:host([size=\"small\"][rank=\"tertiary\"]) .inner-tag*/[size=\"small\"][rank=\"tertiary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-small-size-tertiary-rank-vertical-padding)\n      var(--button-small-size-tertiary-rank-horizontal-padding)}/*!@:host([size=\"small\"][rank=\"tertiary\"]) svg, :host([size=\"small\"][rank=\"tertiary\"]) ::slotted([slot=\"icon\"])*/[size=\"small\"][rank=\"tertiary\"].sc-market-button-h svg.sc-market-button,.sc-market-button-h[size=\"small\"][rank=\"tertiary\"].sc-market-button-s>[slot=\"icon\"],.sc-market-button-h[size=\"small\"][rank=\"tertiary\"] .sc-market-button-s>[slot=\"icon\"]{margin:calc(\n        (var(--button-small-size-minimum-height) - var(--accessory-icon-variant-size)) / 2\n        - var(--button-small-size-tertiary-rank-vertical-padding)\n      ) 0}/*!@:host([size=\"small\"][icon-only]) .inner-tag*/[size=\"small\"][icon-only].sc-market-button-h .inner-tag.sc-market-button{padding:var(--icon-button-small-size-padding-size)}/*!@:host([size=\"medium\"])*/[size=\"medium\"].sc-market-button-h{--button-medium-size-minimum-width:var(--button-medium-size-minimum-height);font-weight:var(--button-medium-size-text-weight);font-size:var(--button-medium-size-text-size);line-height:var(--button-medium-size-text-leading);letter-spacing:var(--button-medium-size-text-tracking)}/*!@:host([size=\"medium\"]) .inner-tag*/[size=\"medium\"].sc-market-button-h .inner-tag.sc-market-button{min-width:var(--button-medium-size-minimum-width);min-height:var(--button-medium-size-minimum-height);-moz-column-gap:var(--button-medium-size-content-spacing);column-gap:var(--button-medium-size-content-spacing)}/*!@:host([size=\"medium\"][rank=\"primary\"]) .inner-tag*/[size=\"medium\"][rank=\"primary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-medium-size-primary-rank-vertical-padding)\n      var(--button-medium-size-primary-rank-horizontal-padding)}/*!@:host([size=\"medium\"][rank=\"secondary\"]) .inner-tag*/[size=\"medium\"][rank=\"secondary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-medium-size-secondary-rank-vertical-padding)\n      var(--button-medium-size-secondary-rank-horizontal-padding)}/*!@:host([size=\"medium\"][rank=\"tertiary\"]) .inner-tag*/[size=\"medium\"][rank=\"tertiary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-medium-size-tertiary-rank-vertical-padding)\n      var(--button-medium-size-tertiary-rank-horizontal-padding)}/*!@:host([size=\"medium\"][icon-only]) .inner-tag*/[size=\"medium\"][icon-only].sc-market-button-h .inner-tag.sc-market-button{padding:var(--icon-button-medium-size-padding-size)}/*!@:host([size=\"large\"])*/[size=\"large\"].sc-market-button-h{--button-large-size-minimum-width:var(--button-large-size-minimum-height);font-weight:var(--button-large-size-text-weight);font-size:var(--button-large-size-text-size);line-height:var(--button-large-size-text-leading);letter-spacing:var(--button-large-size-text-tracking)}/*!@:host([size=\"large\"]) .inner-tag*/[size=\"large\"].sc-market-button-h .inner-tag.sc-market-button{min-width:var(--button-large-size-minimum-width);min-height:var(--button-large-size-minimum-height);-moz-column-gap:var(--button-large-size-content-spacing);column-gap:var(--button-large-size-content-spacing)}/*!@:host([size=\"large\"][rank=\"primary\"]) .inner-tag*/[size=\"large\"][rank=\"primary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-large-size-primary-rank-vertical-padding)\n      var(--button-large-size-primary-rank-horizontal-padding)}/*!@:host([size=\"large\"][rank=\"secondary\"]) .inner-tag*/[size=\"large\"][rank=\"secondary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-large-size-secondary-rank-vertical-padding)\n      var(--button-large-size-secondary-rank-horizontal-padding)}/*!@:host([size=\"large\"][rank=\"tertiary\"]) .inner-tag*/[size=\"large\"][rank=\"tertiary\"].sc-market-button-h .inner-tag.sc-market-button{padding:var(--button-large-size-tertiary-rank-vertical-padding)\n      var(--button-large-size-tertiary-rank-horizontal-padding)}/*!@:host([size=\"large\"][icon-only]) .inner-tag*/[size=\"large\"][icon-only].sc-market-button-h .inner-tag.sc-market-button{padding:var(--icon-button-large-size-padding-size)}/*!@:host([rank=\"primary\"])*/[rank=\"primary\"].sc-market-button-h{background-color:var(--button-normal-variant-primary-rank-normal-state-background-color);color:var(--button-normal-variant-primary-rank-normal-state-label-color)}/*!@:host([rank=\"primary\"][icon-only])*/[rank=\"primary\"][icon-only].sc-market-button-h{color:var(--icon-button-primary-rank-normal-state-icon-color)}@media (hover: hover){/*!@:host([rank=\"primary\"]:hover)*/[rank=\"primary\"].sc-market-button-h:hover{background-color:var(--button-normal-variant-primary-rank-hover-state-background-color);color:var(--button-normal-variant-primary-rank-hover-state-label-color)}/*!@:host([rank=\"primary\"][icon-only]:hover)*/[rank=\"primary\"][icon-only].sc-market-button-h:hover{color:var(--icon-button-primary-rank-hover-state-icon-color)}}/*!@:host([rank=\"primary\"][focused])*/[rank=\"primary\"][focused].sc-market-button-h{background-color:var(--button-normal-variant-primary-rank-focus-state-background-color);color:var(--button-normal-variant-primary-rank-focus-state-label-color)}/*!@:host([rank=\"primary\"][icon-only][focused])*/[rank=\"primary\"][icon-only][focused].sc-market-button-h{color:var(--icon-button-primary-rank-focus-state-icon-color)}/*!@:host([rank=\"primary\"]:active)*/[rank=\"primary\"].sc-market-button-h:active{background-color:var(--button-normal-variant-primary-rank-pressed-state-background-color);color:var(--button-normal-variant-primary-rank-pressed-state-label-color)}/*!@:host([rank=\"primary\"][icon-only]:active)*/[rank=\"primary\"][icon-only].sc-market-button-h:active{color:var(--icon-button-primary-rank-pressed-state-icon-color)}/*!@:host([rank=\"primary\"][disabled])*/[rank=\"primary\"][disabled].sc-market-button-h{background-color:var(--button-normal-variant-primary-rank-disabled-state-background-color);color:var(--button-normal-variant-primary-rank-disabled-state-label-color)}/*!@:host([rank=\"primary\"][icon-only][disabled])*/[rank=\"primary\"][icon-only][disabled].sc-market-button-h{color:var(--icon-button-primary-rank-disabled-state-icon-color)}/*!@:host([rank=\"secondary\"])*/[rank=\"secondary\"].sc-market-button-h{background-color:var(--button-normal-variant-secondary-rank-normal-state-background-color);color:var(--button-normal-variant-secondary-rank-normal-state-label-color)}/*!@:host([rank=\"secondary\"][icon-only])*/[rank=\"secondary\"][icon-only].sc-market-button-h{color:var(--icon-button-secondary-rank-normal-state-icon-color)}@media (hover: hover){/*!@:host([rank=\"secondary\"]:hover)*/[rank=\"secondary\"].sc-market-button-h:hover{background-color:var(--button-normal-variant-secondary-rank-hover-state-background-color);color:var(--button-normal-variant-secondary-rank-hover-state-label-color)}/*!@:host([rank=\"secondary\"][icon-only]:hover)*/[rank=\"secondary\"][icon-only].sc-market-button-h:hover{color:var(--icon-button-secondary-rank-hover-state-icon-color)}}/*!@:host([rank=\"secondary\"][focused])*/[rank=\"secondary\"][focused].sc-market-button-h{background-color:var(--button-normal-variant-secondary-rank-focus-state-background-color);color:var(--button-normal-variant-secondary-rank-focus-state-label-color)}/*!@:host([rank=\"secondary\"][icon-only][focused])*/[rank=\"secondary\"][icon-only][focused].sc-market-button-h{color:var(--icon-button-secondary-rank-focus-state-icon-color)}/*!@:host([rank=\"secondary\"]:active)*/[rank=\"secondary\"].sc-market-button-h:active{background-color:var(--button-normal-variant-secondary-rank-pressed-state-background-color);color:var(--button-normal-variant-secondary-rank-pressed-state-label-color)}/*!@:host([rank=\"secondary\"][icon-only]:active)*/[rank=\"secondary\"][icon-only].sc-market-button-h:active{color:var(--icon-button-secondary-rank-pressed-state-icon-color)}/*!@:host([rank=\"secondary\"][disabled])*/[rank=\"secondary\"][disabled].sc-market-button-h{background-color:var(--button-normal-variant-secondary-rank-disabled-state-background-color);color:var(--button-normal-variant-secondary-rank-disabled-state-label-color)}/*!@:host([rank=\"secondary\"][icon-only][disabled])*/[rank=\"secondary\"][icon-only][disabled].sc-market-button-h{color:var(--icon-button-secondary-rank-disabled-state-icon-color)}/*!@:host([rank=\"tertiary\"])*/[rank=\"tertiary\"].sc-market-button-h{background-color:var(--button-normal-variant-tertiary-rank-normal-state-background-color);color:var(--button-normal-variant-tertiary-rank-normal-state-label-color)}/*!@:host([rank=\"tertiary\"][icon-only])*/[rank=\"tertiary\"][icon-only].sc-market-button-h{color:var(--icon-button-tertiary-rank-normal-state-icon-color)}@media (hover: hover){/*!@:host([rank=\"tertiary\"]:hover)*/[rank=\"tertiary\"].sc-market-button-h:hover{background-color:var(--button-normal-variant-tertiary-rank-hover-state-background-color);color:var(--button-normal-variant-tertiary-rank-hover-state-label-color)}/*!@:host([rank=\"tertiary\"][icon-only]:hover)*/[rank=\"tertiary\"][icon-only].sc-market-button-h:hover{color:var(--icon-button-tertiary-rank-hover-state-icon-color)}}/*!@:host([rank=\"tertiary\"][focused])*/[rank=\"tertiary\"][focused].sc-market-button-h{background-color:var(--button-normal-variant-tertiary-rank-focus-state-background-color);color:var(--button-normal-variant-tertiary-rank-focus-state-label-color)}/*!@:host([rank=\"tertiary\"][icon-only][focused])*/[rank=\"tertiary\"][icon-only][focused].sc-market-button-h{color:var(--icon-button-tertiary-rank-focus-state-icon-color)}/*!@:host([rank=\"tertiary\"]:active)*/[rank=\"tertiary\"].sc-market-button-h:active{background-color:var(--button-normal-variant-tertiary-rank-pressed-state-background-color);color:var(--button-normal-variant-tertiary-rank-pressed-state-label-color)}/*!@:host([rank=\"tertiary\"][icon-only]:active)*/[rank=\"tertiary\"][icon-only].sc-market-button-h:active{color:var(--icon-button-tertiary-rank-pressed-state-icon-color)}/*!@:host([rank=\"tertiary\"][disabled])*/[rank=\"tertiary\"][disabled].sc-market-button-h{background-color:var(--button-normal-variant-tertiary-rank-disabled-state-background-color);color:var(--button-normal-variant-tertiary-rank-disabled-state-label-color)}/*!@:host([rank=\"tertiary\"][icon-only][disabled])*/[rank=\"tertiary\"][icon-only][disabled].sc-market-button-h{color:var(--icon-button-tertiary-rank-disabled-state-icon-color)}/*!@:host([variant=\"destructive\"][rank=\"primary\"])*/[variant=\"destructive\"][rank=\"primary\"].sc-market-button-h{background-color:var(--button-destructive-variant-primary-rank-normal-state-background-color);color:var(--button-destructive-variant-primary-rank-normal-state-label-color)}@media (hover: hover){/*!@:host([variant=\"destructive\"][rank=\"primary\"]:hover)*/[variant=\"destructive\"][rank=\"primary\"].sc-market-button-h:hover{background-color:var(--button-destructive-variant-primary-rank-hover-state-background-color);color:var(--button-destructive-variant-primary-rank-hover-state-label-color)}}/*!@:host([variant=\"destructive\"][rank=\"primary\"][focused])*/[variant=\"destructive\"][rank=\"primary\"][focused].sc-market-button-h{background-color:var(--button-destructive-variant-primary-rank-focus-state-background-color);color:var(--button-destructive-variant-primary-rank-focus-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"primary\"]:active)*/[variant=\"destructive\"][rank=\"primary\"].sc-market-button-h:active{background-color:var(--button-destructive-variant-primary-rank-pressed-state-background-color);color:var(--button-destructive-variant-primary-rank-pressed-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"primary\"][disabled])*/[variant=\"destructive\"][rank=\"primary\"][disabled].sc-market-button-h{background-color:var(--button-destructive-variant-primary-rank-disabled-state-background-color);color:var(--button-destructive-variant-primary-rank-disabled-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"secondary\"])*/[variant=\"destructive\"][rank=\"secondary\"].sc-market-button-h{background-color:var(--button-destructive-variant-secondary-rank-normal-state-background-color);color:var(--button-destructive-variant-secondary-rank-normal-state-label-color)}@media (hover: hover){/*!@:host([variant=\"destructive\"][rank=\"secondary\"]:hover)*/[variant=\"destructive\"][rank=\"secondary\"].sc-market-button-h:hover{background-color:var(--button-destructive-variant-secondary-rank-hover-state-background-color);color:var(--button-destructive-variant-secondary-rank-hover-state-label-color)}}/*!@:host([variant=\"destructive\"][rank=\"secondary\"][focused])*/[variant=\"destructive\"][rank=\"secondary\"][focused].sc-market-button-h{background-color:var(--button-destructive-variant-secondary-rank-focus-state-background-color);color:var(--button-destructive-variant-secondary-rank-focus-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"secondary\"]:active)*/[variant=\"destructive\"][rank=\"secondary\"].sc-market-button-h:active{background-color:var(--button-destructive-variant-secondary-rank-pressed-state-background-color);color:var(--button-destructive-variant-secondary-rank-pressed-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"secondary\"][disabled])*/[variant=\"destructive\"][rank=\"secondary\"][disabled].sc-market-button-h{background-color:var(--button-destructive-variant-secondary-rank-disabled-state-background-color);color:var(--button-destructive-variant-secondary-rank-disabled-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"tertiary\"])*/[variant=\"destructive\"][rank=\"tertiary\"].sc-market-button-h{background-color:var(--button-destructive-variant-tertiary-rank-normal-state-background-color);color:var(--button-destructive-variant-tertiary-rank-normal-state-label-color)}@media (hover: hover){/*!@:host([variant=\"destructive\"][rank=\"tertiary\"]:hover)*/[variant=\"destructive\"][rank=\"tertiary\"].sc-market-button-h:hover{background-color:var(--button-destructive-variant-tertiary-rank-hover-state-background-color);color:var(--button-destructive-variant-tertiary-rank-hover-state-label-color)}}/*!@:host([variant=\"destructive\"][rank=\"tertiary\"][focused])*/[variant=\"destructive\"][rank=\"tertiary\"][focused].sc-market-button-h{background-color:var(--button-destructive-variant-tertiary-rank-focus-state-background-color);color:var(--button-destructive-variant-tertiary-rank-focus-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"tertiary\"]:active)*/[variant=\"destructive\"][rank=\"tertiary\"].sc-market-button-h:active{background-color:var(--button-destructive-variant-tertiary-rank-pressed-state-background-color);color:var(--button-destructive-variant-tertiary-rank-pressed-state-label-color)}/*!@:host([variant=\"destructive\"][rank=\"tertiary\"][disabled])*/[variant=\"destructive\"][rank=\"tertiary\"][disabled].sc-market-button-h{background-color:var(--button-destructive-variant-tertiary-rank-disabled-state-background-color);color:var(--button-destructive-variant-tertiary-rank-disabled-state-label-color)}";
var MarketButtonStyle0 = marketButtonCss;

/**
 * @slot - The text used for the button label
 * @slot icon - an icon that is to the left of button text, or centered if there is no text
 */
class MarketButton {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        // Implicit submission is when an interaction within a form fires a click event on the form's first submit button in tree order.
        // Because the inner <button> of <market-button> is in the shadow dom and not in tree order, we lose this functionality.
        // To ensure we have the exact behavior that a plain button would have had in this situation,
        // we add a hidden button to the form and click it for the implicit submission.
        // https://www.hjorthhansen.dev/shadow-dom-and-forms/
        // note: this is attached in the host element's onclick instead of with the @Listen decorator
        // to ensure the following fire in the correct order:
        // 1) handleClick
        // 2) the event passed to market-button
        // 3) implicit submission
        // In Ember, the @Listen would fire before the event passed to the button, which could result in the event not happening.
        this.handleImplicitSubmission = () => {
            if (this.type === 'submit') {
                const form = this.el.closest('form');
                if (form) {
                    const fakeButton = document.createElement('button');
                    fakeButton.type = this.type;
                    fakeButton.style.display = 'none';
                    form.appendChild(fakeButton);
                    fakeButton.click();
                    fakeButton.remove();
                }
            }
        };
        this.onMutationObserved = (ariaAttributes) => {
            this.ariaAttributes = ariaAttributes;
        };
        this.caret = 'none';
        this.disabled = false;
        this.download = undefined;
        this.focused = false;
        this.href = undefined;
        this.iconOnly = false;
        this.innerTabindex = undefined;
        this.isLoading = false;
        this.rank = 'secondary';
        this.rel = undefined;
        this.size = 'medium';
        this.target = undefined;
        this.type = 'button';
        this.variant = 'regular';
        this.ariaAttributes = undefined;
    }
    focusedChangeHandler(newValue) {
        if (!this.innerTag) {
            return;
        }
        if (newValue) {
            this.innerTag.focus();
        }
    }
    /* Listening for click events here allows us to stop bubbling when
    disabled. Attaching listeners to Host (as the Stencil linter prefers),
    seems to also work in Stencil tests, but fails in Ember for some reason.
    We listen in the "capture" phase to ensure we're hit before any external
    click handlers. See here for details:
    https://www.sitepoint.com/event-bubbling-javascript/ */
    handleClick(event) {
        if (this.disabled || this.isLoading) {
            // Calling `stopImmediatePropagation` instead of `stopPropagation`
            // allows us to block current and future "sibling" event listeners
            // that have also been attached to this element, as opposed to just
            // those higher in the DOM tree.
            event.stopImmediatePropagation();
        }
    }
    /**
     * Sets `focused` state, except when disabled. Allows external consumers to programmatically
     * trigger focused styling.
     */
    setFocus(value = true) {
        if (this.disabled) {
            return Promise.resolve();
        }
        this.focused = value; // this will cause the `focusedChangeHandler` to be triggered
        if (!value && this.innerTag) {
            this.innerTag.blur();
        }
        return Promise.resolve();
    }
    handleSlotChange() {
        const iconSlot = this.el.querySelector('[slot="icon"]');
        const hasIcon = Boolean(iconSlot);
        const buttonText = this.el.textContent.trim();
        let hasLabelText;
        if (hasIcon) {
            // Check for text in the icon itself, such as icon badge text. This text is considered part of the icon and not a label.
            // Since buttonText contains all text in the element including the svg, only set hasLabelText to true if text exists outside of the icon.
            const iconText = iconSlot.textContent.trim();
            hasLabelText = buttonText.length > iconText.length;
        }
        else {
            hasLabelText = buttonText.length > 0;
        }
        this.iconOnly = hasIcon && !hasLabelText;
    }
    componentWillLoad() {
        this.mutationObserver = observeAriaAttributes(this.el, this.onMutationObserved);
        this.handleSlotChange();
    }
    render() {
        const { 
        // props
        caret, disabled, href, innerTabindex, isLoading, target, type, rel, download, 
        // state
        ariaAttributes, 
        // methods
        handleImplicitSubmission, } = this;
        const TagType = href === undefined ? 'button' : 'a';
        const TagTypeAttrs = TagType === 'button' ? { type, disabled } : { href, target, rel, download };
        const MarketActivityIndicatorTagName = getNamespacedTagFor('market-activity-indicator');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        return (hAsync(Host, { key: '7ab029a8c99a088b7f4f6c780c74e07f89bcd73e', class: "market-button", onClick: handleImplicitSubmission }, hAsync(TagType, Object.assign({ key: 'a82d9c744e51ae71d12e6611613dd3b19a9f32c9', class: "inner-tag" }, TagTypeAttrs, ariaAttributes, { tabindex: disabled ? -1 : innerTabindex, onFocus: () => {
                this.focused = true;
            }, onBlur: () => {
                this.focused = false;
            }, ref: (el) => (this.innerTag = el) }), hAsync("slot", { key: '06c02b4d1e5896412bbfbe956394dd8c01f86ba6', name: "icon", onSlotchange: () => this.handleSlotChange() }), hAsync("slot", { key: '79754fbad2cbd532c278c2702680e63ecdfecfb1', onSlotchange: () => this.handleSlotChange() }), caret === 'down' && hAsync(MarketIconTagName, { key: 'e120aab00ab825ae0071014050f69f3bf1d2d256', name: "expand" }), caret === 'up' && hAsync(MarketIconTagName, { key: '9c87ab277fe0826899270f5475cd95290c17aa36', name: "collapse" })), isLoading && hAsync(MarketActivityIndicatorTagName, { key: '924783840ca804abfe7cb09e25c0303015805e1c', size: "small" })));
    }
    disconnectedCallback() {
        var _a;
        (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focused": ["focusedChangeHandler"]
    }; }
    static get style() { return MarketButtonStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-button",
        "$members$": {
            "caret": [1],
            "disabled": [516],
            "download": [1],
            "focused": [1540],
            "href": [1],
            "iconOnly": [1540, "icon-only"],
            "innerTabindex": [2, "inner-tabindex"],
            "isLoading": [516, "is-loading"],
            "rank": [513],
            "rel": [1],
            "size": [513],
            "target": [1],
            "type": [513],
            "variant": [513],
            "ariaAttributes": [32],
            "setFocus": [64]
        },
        "$listeners$": [[2, "click", "handleClick"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["focused", "focused"], ["iconOnly", "icon-only"], ["isLoading", "is-loading"], ["rank", "rank"], ["size", "size"], ["type", "type"], ["variant", "variant"]]
    }; }
}

const supportedDropdownTriggers = Object.freeze([
    getNamespacedTagFor('market-button'),
    getNamespacedTagFor('market-link'),
    getNamespacedTagFor('market-filter-button'),
]);

const marketButtonDropdownCss = "/*!@:host*/.sc-market-button-dropdown-h{display:inline-block}/*!@market-dropdown, .market-dropdown*/market-dropdown.sc-market-button-dropdown,.market-dropdown.sc-market-button-dropdown{width:100%}/*!@svg*/svg.sc-market-button-dropdown{fill:transparent}";
var MarketButtonDropdownStyle0 = marketButtonDropdownCss;

/**
 * Type guard to check if the supported trigger element is a `market-button`
 */
function isMarketButton(el) {
    return el.tagName.toLowerCase() === getNamespacedTagFor('market-button');
}
/**
 * @slot trigger - Expects a slotted `market-button` or `market-filter-button`.
 * @slot content - Content slotted here will appear in `market-popover`, which
 * becomes visible when the slotted trigger content is interacted with.
 * @part popover - The inner market-popover.
 */
class MarketButtonDropdown {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketButtonDropdownOpened = createEvent(this, "marketButtonDropdownOpened", 7);
        this.marketButtonDropdownClosed = createEvent(this, "marketButtonDropdownClosed", 7);
        this.onMutationObserved = (ariaAttributes) => {
            this.ariaAttributes = ariaAttributes;
        };
        this.interaction = 'click';
        this.disabled = false;
        this.noCaret = false;
        this.popoverPlacement = 'bottom-end';
        this.popoverStrategy = 'absolute';
        this.persistListSelections = false;
        this.dropdownIsActive = false;
        this.ariaAttributes = undefined;
    }
    dropdownOpenedEventHandler(e) {
        if (e.target !== this.el)
            return;
        this.dropdownIsActive = true;
        this.setCaret();
        this.marketButtonDropdownOpened.emit();
    }
    dropdownClosedEventHandler(e) {
        if (e.target !== this.el)
            return;
        this.dropdownIsActive = false;
        this.setCaret();
        this.marketButtonDropdownClosed.emit();
    }
    syncTriggerDisabledState() {
        if (this.slottedButton) {
            this.slottedButton.disabled = this.disabled;
        }
    }
    setCaret() {
        if (this.noCaret || !isMarketButton(this.slottedButton)) {
            return;
        }
        if (this.dropdownIsActive) {
            this.slottedButton.caret = 'up';
        }
        else {
            this.slottedButton.caret = 'down';
        }
    }
    registerTrigger() {
        this.slottedButton = this.el.querySelector(supportedDropdownTriggers.join(','));
        this.syncTriggerDisabledState();
        this.setCaret();
    }
    componentWillLoad() {
        this.mutationObserver = observeAriaAttributes(this.el, this.onMutationObserved);
    }
    componentWillRender() {
        const MarketListTagName = getNamespacedTagFor('market-list');
        const list = this.el.querySelector(MarketListTagName);
        const popoverContent = this.el.querySelector(`[slot="content"]`);
        if (list) {
            // We set this here even though market-popover also sets it,
            // because the slotted market-list's componentWillLoad hook
            // will fire before market-popover's, and we need it to be set
            // before the row processing that happens in that hook.
            list.interactive = true;
            list.transient = !this.persistListSelections;
        }
        if (this.slottedButton) {
            // Ensure popover has an ID and role for aria support
            if (!popoverContent.id) {
                popoverContent.id = `popover-${v4()}`;
            }
            // Persist aria attributes on the slotted button
            applyExpandableAriaControls(this.slottedButton, {
                expanded: this.dropdownIsActive.toString(),
                popoverId: popoverContent.id,
            });
        }
    }
    render() {
        const MarketDropdownTagName = getNamespacedTagFor('market-dropdown');
        const MarketPopoverTagName = getNamespacedTagFor('market-popover');
        return (hAsync(Host, { key: '35a277377595acc3448cf6725c2026ef398df787', class: "market-button-dropdown" }, hAsync(MarketDropdownTagName, { key: '706d03f37636b4a77ce2378279a85ecbbc563259', interaction: this.interaction, "popover-strategy": this.popoverStrategy, "popover-placement": this.popoverPlacement, disabled: this.disabled }, hAsync("slot", { key: 'eb6a8ad8f2d20b110fea23dcca3f13ef4f888640', name: "trigger", slot: "trigger", onSlotchange: () => this.registerTrigger() }), hAsync(MarketPopoverTagName, { key: '6eda9f25ab04d65c27fa96145fde542e040882c2', slot: "popover", part: "popover" }, hAsync("slot", { key: '1a9a9e1e0fd8c895482d4a08e4d016530340e2cd', name: "content" })))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["syncTriggerDisabledState"]
    }; }
    static get style() { return MarketButtonDropdownStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-button-dropdown",
        "$members$": {
            "interaction": [1],
            "disabled": [516],
            "noCaret": [4, "no-caret"],
            "popoverPlacement": [1, "popover-placement"],
            "popoverStrategy": [1, "popover-strategy"],
            "persistListSelections": [4, "persist-list"],
            "dropdownIsActive": [32],
            "ariaAttributes": [32]
        },
        "$listeners$": [[0, "marketDropdownOpened", "dropdownOpenedEventHandler"], [0, "marketDropdownClosed", "dropdownClosedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"]]
    }; }
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

var freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal$1 || freeSelf || Function('return this')();

var root$1 = root;

/** Built-in value references. */
var Symbol$1 = root$1.Symbol;

var Symbol$2 = Symbol$1;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$d.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$d.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$c.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$1);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray$1 = isArray;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];

var coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$b = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$9).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root$1, 'WeakMap');

var WeakMap$2 = WeakMap$1;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

var baseSetToString$1 = baseSetToString;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString$1);

var setToString$1 = setToString;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$8.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments$1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Built-in value references. */
var Buffer = moduleExports$1 ? root$1.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

var isBuffer$1 = isBuffer;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    mapTag$3 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$3 = '[object Set]',
    stringTag$1 = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$3] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$3] = typedArrayTags[stringTag$1] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal$1.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

var nodeUtil$1 = nodeUtil;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

var isTypedArray$1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$6.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

var nativeKeys$1 = nativeKeys;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

var nativeCreate$1 = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$1, 'Map');

var Map$2 = Map$1;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$2 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT$3 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var stringToPath$1 = stringToPath;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$1(value) || isArguments$1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString$1(overRest(func, undefined, flatten), func + '');
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var getSymbols$1 = getSymbols;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root$1, 'DataView');

var DataView$1 = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root$1, 'Promise');

var Promise$2 = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root$1, 'Set');

var Set$2 = Set$1;

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag$1 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$2);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1) ||
    (Map$2 && getTag(new Map$2) != mapTag$2) ||
    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
    (Set$2 && getTag(new Set$2) != setTag$2) ||
    (WeakMap$2 && getTag(new WeakMap$2) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$2;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$2;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Built-in value references. */
var Uint8Array$1 = root$1.Uint8Array;

var Uint8Array$2 = Uint8Array$1;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray$1(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray$1(object) || isArguments$1(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray$1(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root$1.Date.now();
};

var now$1 = now;

/** Error message constants. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$2(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }

  function debounced() {
    var time = now$1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * The base implementation of `_.delay` and `_.defer` which accepts `args`
 * to provide to `func`.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Array} args The arguments to provide to `func`.
 * @returns {number|Object} Returns the timer id or timeout object.
 */
function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  return setTimeout(function() { func.apply(undefined, args); }, wait);
}

/**
 * Invokes `func` after `wait` milliseconds. Any additional arguments are
 * provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.delay(function(text) {
 *   console.log(text);
 * }, 1000, 'later');
 * // => Logs 'later' after one second.
 */
var delay = baseRest(function(func, wait, args) {
  return baseDelay(func, toNumber(wait) || 0, args);
});

var delay$1 = delay;

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray$1(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

var pick$1 = pick;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce$2(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$2 && (1 / setToArray(new Set$2([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set$2(values);
};

var createSet$1 = createSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet$1(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee)) : [];
}

/**
 * Promisified `window.requestAnimationFrame`
 */
function asyncRequestAnimationFrame() {
    return new Promise((resolve) => {
        var _a;
        ((_a = window === null || window === void 0 ? void 0 : window.requestAnimationFrame) === null || _a === void 0 ? void 0 : _a.call(window, () => resolve())) || resolve();
    });
}

const marketButtonGroupCss = "/*!@:host, ::slotted(*), **/.sc-market-button-group-h,.sc-market-button-group-s>*,*.sc-market-button-group{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-button-group-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-button-group-h *.sc-market-button-group,.sc-market-button-group-h[disabled].sc-market-button-group-s>*,.sc-market-button-group-h[disabled] .sc-market-button-group-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-button-group-h{display:flex;flex-grow:1}/*!@.content*/.content.sc-market-button-group{display:flex;flex:1;flex-flow:row nowrap;gap:var(--button-group-spacing)}/*!@:host([alignment=\"right\"]) .content*/[alignment=\"right\"].sc-market-button-group-h .content.sc-market-button-group{flex-direction:row-reverse}/*!@:host([alignment=\"left\"]) .content*/[alignment=\"left\"].sc-market-button-group-h .content.sc-market-button-group{justify-content:flex-start}/*!@:host([alignment=\"split\"]) .content*/[alignment=\"split\"].sc-market-button-group-h .content.sc-market-button-group{flex-direction:row-reverse;justify-content:flex-end}/*!@:host([alignment=\"split\"]) .content ::slotted(.market-button:first-of-type)*/.sc-market-button-group-h[alignment=\"split\"] .content .sc-market-button-group-s>.market-button:first-of-type{margin-left:auto}/*!@:host([alignment=\"fill\"]) .content*/[alignment=\"fill\"].sc-market-button-group-h .content.sc-market-button-group{flex-direction:row-reverse}/*!@:host([alignment=\"fill\"]) .content ::slotted(.market-button)*/.sc-market-button-group-h[alignment=\"fill\"] .content .sc-market-button-group-s>.market-button{flex:1}/*!@:host([alignment=\"stack\"]) .content*/[alignment=\"stack\"].sc-market-button-group-h .content.sc-market-button-group{flex-direction:column}/*!@[slot=\"content\"]*/[slot=\"content\"].sc-market-button-group{display:flex;flex-direction:column;gap:var(--button-group-spacing)}/*!@::slotted([slot=\"overflow-buttons\"])*/.sc-market-button-group-s>[slot=\"overflow-buttons\"]{width:100%}";
var MarketButtonGroupStyle0 = marketButtonGroupCss;

const MAX_VISIBLE_BUTTONS = 2;
const DROPDOWN_MENU_BUTTON_WIDTH = 48;
const RESIZE_DEBOUNCE_DURATION$4 = 16; // 60fps
/**
 * @slot - Intended to slot any number of `<market-button>` components here.
 * @slot overflow-buttons - Not intended for external consumers. Used by
 * `<market-button-group>` when programmatically arranging visible vs overflow
 * buttons based on available space.
 */
class MarketButtonGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * References to the button elements
         */
        this._buttonEls = [];
        /**
         * Observers
         */
        this._observers = {};
        this.throttledHandleResize = throttle(this.handleResize.bind(this), RESIZE_DEBOUNCE_DURATION$4);
        this.alignment = 'right';
        this.popoverStrategy = 'absolute';
        this._sortedButtonEls = {
            overflow: [],
            visible: [],
        };
    }
    getComputedWidth(el) {
        return Number.parseFloat(window.getComputedStyle(el).width);
    }
    /**
     * Find out where the cutoff will happen.
     * Main chunk of the overflow logic happens here
     */
    async findButtonCutoffIndex() {
        if (this.alignment === 'stack') {
            // buttons are full width so no overflow necessary
            return this._buttonEls.length;
        }
        const buttonGroupWidth = this.getComputedWidth(this.el);
        /**
         * Temporary container where we can measure button widths
         * https://dev.to/sstraatemans/calculate-html-element-width-before-render-4ii7
         */
        const tempEl = document.createElement('div');
        tempEl.style.width = 'auto';
        tempEl.style.position = 'absolute';
        tempEl.style.visibility = 'hidden';
        this.el.shadowRoot.appendChild(tempEl);
        let index = 0;
        let buttonWidths = 0;
        for (const buttonEl of this._buttonEls) {
            if (index === MAX_VISIBLE_BUTTONS) {
                break;
            }
            /**
             * Presuming that all the remaining buttons (**excluding** the current one, i.e. `buttonEl`)
             * will be overflowed, calculate the potential dropdown menu button width.
             * If this is the last button, it will not be followed by a `market-button-dropdown-menu`.
             */
            const dropdownMenuButtonWidth = index + 1 === this._buttonEls.length // is this the last one?
                ? 0
                : cjs.BUTTON_GROUP_SPACING + DROPDOWN_MENU_BUTTON_WIDTH;
            // measure the button's width in the temporary container
            const clonedButtonEl = buttonEl.cloneNode(true);
            clonedButtonEl.style.display = 'block';
            tempEl.appendChild(clonedButtonEl);
            // let the shadow DOM render within the temp container first before measuring its width
            await asyncRequestAnimationFrame();
            const buttonElWidth = this.getComputedWidth(tempEl);
            tempEl.removeChild(clonedButtonEl);
            // width of all the buttons so far; gap is only added for buttons after the first
            buttonWidths += (index > 0 ? cjs.BUTTON_GROUP_SPACING : 0) + buttonElWidth;
            // check if button can fit
            const potentialWidth = buttonWidths + dropdownMenuButtonWidth;
            if (potentialWidth >= buttonGroupWidth) {
                // it won't fit; breaking the loop sets the cutoff
                break;
            }
            ++index;
        }
        // cleanup
        this.el.shadowRoot.removeChild(tempEl);
        tempEl.remove();
        return index;
    }
    /**
     * Sort buttons:
     * - split by `this._buttonCutoffIndex`
     * - visible buttons: remove attr `[slot="overflow-buttons"]`; remove `display: none;`
     * - overflow buttons: set attr `[slot="overflow-buttons"]`; add `display: none;`
     */
    sortVisibleAndOverflowButtons() {
        this._sortedButtonEls = {
            visible: this._buttonEls.slice(0, this._buttonCutoffIndex),
            overflow: this._buttonEls.slice(this._buttonCutoffIndex),
        };
        this._sortedButtonEls.visible.forEach((buttonEl) => {
            // if (buttonEl.style.display) {
            //   buttonEl.style.removeProperty('display');
            // }
            if (buttonEl.getAttribute('slot') === 'overflow-buttons') {
                buttonEl.removeAttribute('slot');
            }
        });
        this._sortedButtonEls.overflow.forEach((buttonEl) => {
            // if (buttonEl.style.display !== 'none') {
            //   buttonEl.style.display = 'none';
            // }
            if (buttonEl.getAttribute('slot') !== 'overflow-buttons') {
                buttonEl.setAttribute('slot', 'overflow-buttons');
            }
        });
    }
    /**
     * Handle screen / component resize
     */
    async handleResize() {
        if (!this.getComputedWidth(this.el)) {
            // element isn't fully rendered yet
            return;
        }
        const index = await this.findButtonCutoffIndex();
        const isButtonCutoffUpdated = index !== this._buttonCutoffIndex;
        if (isButtonCutoffUpdated) {
            this._buttonCutoffIndex = index;
            await asyncRequestAnimationFrame();
            this.sortVisibleAndOverflowButtons();
        }
        this.el.style.visibility = '';
    }
    registerSlottedButtons() {
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        this._buttonEls = [...this.el.querySelectorAll(MarketButtonTagName)];
    }
    observeContent(el) {
        if (!this._observers.content) {
            this._observers.content = new ResizeObserver(this.throttledHandleResize);
            this._observers.content.observe(el);
        }
    }
    connectedCallback() {
        if (!this._observers.host) {
            this._observers.host = new ResizeObserver(this.throttledHandleResize);
            this._observers.host.observe(this.el);
        }
    }
    componentWillLoad() {
        // hide component until handleResize()
        this.el.style.visibility = 'hidden';
        this.registerSlottedButtons();
        this.handleResize();
    }
    disconnectedCallback() {
        Object.entries(this._observers).forEach(([key, observer]) => {
            if (observer) {
                observer.disconnect();
                this._observers[key] = undefined;
            }
        });
    }
    render() {
        const MarketButtonDropdownTagName = getNamespacedTagFor('market-button-dropdown');
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        return (hAsync(Host, { key: '0057bde7c5189dc71782960ea6a0a05ab850ffae', class: "market-button-group" }, hAsync("div", { key: 'bb2bae68c3f6bcce4a467153493c54e5bf74a8d8', class: "content", ref: (el) => this.observeContent(el) }, hAsync("slot", { key: 'aa97b649151b3dae1d6f98b07b55ebd5b59124a8', onSlotchange: () => this.registerSlottedButtons() }), this._sortedButtonEls.overflow.length > 0 && (hAsync(MarketButtonDropdownTagName, { key: 'ed1403f69d8bdf9a2b177ab7d16274e78cd1c3bf', "no-caret": true, "popover-strategy": this.popoverStrategy }, hAsync(MarketButtonTagName, { key: '633ade9faa3248a77fe539d03c3593778ce2647f', slot: "trigger" }, hAsync(MarketIconTagName, { key: '61a4cf7a55a68750d827d9950232a564e1664150', slot: "icon", name: cjs.BUTTON_GROUP_OVERFLOW_BUTTON_ICON_ASSET })), hAsync("div", { key: '1e30bc26ee0d90bbd1ca0324d7054d74beea088e', slot: "content" }, hAsync("slot", { key: 'f02cea12d210b2170d13c14a10ac8027360cc445', name: "overflow-buttons", slot: "overflow-buttons" })))))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketButtonGroupStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-button-group",
        "$members$": {
            "alignment": [513],
            "popoverStrategy": [1, "popover-strategy"],
            "_sortedButtonEls": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"]]
    }; }
}

const marketCheckboxCss = "/*!@:host, ::slotted(*), **/.sc-market-checkbox-h,.sc-market-checkbox-s>*,*.sc-market-checkbox{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-checkbox-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-checkbox-h *.sc-market-checkbox,.sc-market-checkbox-h[disabled].sc-market-checkbox-s>*,.sc-market-checkbox-h[disabled] .sc-market-checkbox-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-checkbox-h{--checkbox-offset:calc(-1 * var(--checkbox-border-size));--focus-ring-color:color-mix(in srgb, var(--checkbox-focus-ring-color) 100%, transparent);position:relative;display:inline-block;width:var(--checkbox-width);height:var(--checkbox-height);border:var(--checkbox-border-size) solid var(--checkbox-normal-state-normal-validity-unchecked-value-border-color);border-radius:var(--checkbox-border-radius);background-color:var(--checkbox-normal-state-normal-validity-unchecked-value-background-color)}/*!@input*/input.sc-market-checkbox{position:absolute;top:var(--checkbox-offset);left:var(--checkbox-offset);width:var(--checkbox-width);height:var(--checkbox-height);margin:0;border-radius:var(--checkbox-border-radius);background:transparent;outline:none;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@input:focus-visible*/input.sc-market-checkbox:focus-visible{outline:var(--checkbox-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--checkbox-focus-ring-buffer-size)}/*!@svg*/svg.sc-market-checkbox{position:absolute;top:var(--checkbox-offset);left:var(--checkbox-offset);pointer-events:none}/*!@:host(:hover), :host([hovered])*/.sc-market-checkbox-h:hover,[hovered].sc-market-checkbox-h{border-color:var(--checkbox-hover-state-normal-validity-unchecked-value-border-color);background-color:var(--checkbox-hover-state-normal-validity-unchecked-value-background-color)}/*!@:host([focused])*/[focused].sc-market-checkbox-h{border-color:var(--checkbox-focus-state-normal-validity-unchecked-value-border-color);background-color:var(--checkbox-focus-state-normal-validity-unchecked-value-background-color)}/*!@:host(:active), :host([active])*/.sc-market-checkbox-h:active,[active].sc-market-checkbox-h{border-color:var(--checkbox-pressed-state-normal-validity-unchecked-value-border-color);background-color:var(--checkbox-pressed-state-normal-validity-unchecked-value-background-color)}/*!@:host([checked])*/[checked].sc-market-checkbox-h{border-color:var(--checkbox-normal-state-normal-validity-checked-value-border-color);background-color:var(--checkbox-normal-state-normal-validity-checked-value-background-color)}/*!@:host([checked]) path*/[checked].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-normal-state-normal-validity-checked-value-icon-color)}/*!@:host([checked]:hover), :host([checked][hovered])*/[checked].sc-market-checkbox-h:hover,[checked][hovered].sc-market-checkbox-h{border-color:var(--checkbox-hover-state-normal-validity-checked-value-border-color);background-color:var(--checkbox-hover-state-normal-validity-checked-value-background-color)}/*!@:host([checked]:hover) path, :host([checked][hovered]) path*/[checked].sc-market-checkbox-h:hover path.sc-market-checkbox,[checked][hovered].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-hover-state-normal-validity-checked-value-icon-color)}/*!@:host([checked][focused])*/[checked][focused].sc-market-checkbox-h{border-color:var(--checkbox-focus-state-normal-validity-checked-value-border-color);background-color:var(--checkbox-focus-state-normal-validity-checked-value-background-color)}/*!@:host([checked][focused]) path*/[checked][focused].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-focus-state-normal-validity-checked-value-icon-color)}/*!@:host([checked]:active), :host([checked][active])*/[checked].sc-market-checkbox-h:active,[checked][active].sc-market-checkbox-h{border-color:var(--checkbox-pressed-state-normal-validity-checked-value-border-color);background-color:var(--checkbox-pressed-state-normal-validity-checked-value-background-color)}/*!@:host([checked]:active) path, :host([checked][active]) path*/[checked].sc-market-checkbox-h:active path.sc-market-checkbox,[checked][active].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-pressed-state-normal-validity-checked-value-icon-color)}/*!@:host([indeterminate])*/[indeterminate].sc-market-checkbox-h{border-color:var(--checkbox-normal-state-normal-validity-indeterminate-value-border-color);background-color:var(--checkbox-normal-state-normal-validity-indeterminate-value-background-color)}/*!@:host([indeterminate]) path*/[indeterminate].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-normal-state-normal-validity-indeterminate-value-icon-color)}/*!@:host([indeterminate]:hover), :host([indeterminate][hovered])*/[indeterminate].sc-market-checkbox-h:hover,[indeterminate][hovered].sc-market-checkbox-h{border-color:var(--checkbox-hover-state-normal-validity-indeterminate-value-border-color);background-color:var(--checkbox-hover-state-normal-validity-indeterminate-value-background-color)}/*!@:host([indeterminate]:hover) path, :host([indeterminate][hovered]) path*/[indeterminate].sc-market-checkbox-h:hover path.sc-market-checkbox,[indeterminate][hovered].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-hover-state-normal-validity-indeterminate-value-icon-color)}/*!@:host([indeterminate][focused])*/[indeterminate][focused].sc-market-checkbox-h{border-color:var(--checkbox-focus-state-normal-validity-indeterminate-value-border-color);background-color:var(--checkbox-focus-state-normal-validity-indeterminate-value-background-color)}/*!@:host([indeterminate][focused]) path*/[indeterminate][focused].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-focus-state-normal-validity-indeterminate-value-icon-color)}/*!@:host([indeterminate]:active), :host([indeterminate][active])*/[indeterminate].sc-market-checkbox-h:active,[indeterminate][active].sc-market-checkbox-h{border-color:var(--checkbox-pressed-state-normal-validity-indeterminate-value-border-color);background-color:var(--checkbox-pressed-state-normal-validity-indeterminate-value-background-color)}/*!@:host([indeterminate]:active) path, :host([indeterminate][active]) path*/[indeterminate].sc-market-checkbox-h:active path.sc-market-checkbox,[indeterminate][active].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-pressed-state-normal-validity-indeterminate-value-icon-color)}/*!@:host([invalid])*/[invalid].sc-market-checkbox-h{border-color:var(--checkbox-normal-state-invalid-validity-unchecked-value-border-color);background-color:var(--checkbox-normal-state-invalid-validity-unchecked-value-background-color)}/*!@:host([invalid]:hover)*/[invalid].sc-market-checkbox-h:hover{border-color:var(--checkbox-hover-state-invalid-validity-unchecked-value-border-color);background-color:var(--checkbox-hover-state-invalid-validity-unchecked-value-background-color)}/*!@:host([invalid][focused])*/[invalid][focused].sc-market-checkbox-h{border-color:var(--checkbox-focus-state-invalid-validity-unchecked-value-border-color);background-color:var(--checkbox-focus-state-invalid-validity-unchecked-value-background-color)}/*!@:host([invalid]:active)*/[invalid].sc-market-checkbox-h:active{border-color:var(--checkbox-pressed-state-invalid-validity-unchecked-value-border-color);background-color:var(--checkbox-pressed-state-invalid-validity-unchecked-value-background-color)}/*!@:host([invalid][checked])*/[invalid][checked].sc-market-checkbox-h{border-color:var(--checkbox-normal-state-invalid-validity-checked-value-border-color);background-color:var(--checkbox-normal-state-invalid-validity-checked-value-background-color)}/*!@:host([invalid][checked]) path*/[invalid][checked].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-normal-state-invalid-validity-checked-value-icon-color)}/*!@:host([invalid][checked]:hover)*/[invalid][checked].sc-market-checkbox-h:hover{border-color:var(--checkbox-hover-state-invalid-validity-checked-value-border-color);background-color:var(--checkbox-hover-state-invalid-validity-checked-value-background-color)}/*!@:host([invalid][checked]:hover) path*/[invalid][checked].sc-market-checkbox-h:hover path.sc-market-checkbox{stroke:var(--checkbox-hover-state-invalid-validity-checked-value-icon-color)}/*!@:host([invalid][checked][focused])*/[invalid][checked][focused].sc-market-checkbox-h{border-color:var(--checkbox-focus-state-invalid-validity-checked-value-border-color);background-color:var(--checkbox-focus-state-invalid-validity-checked-value-background-color)}/*!@:host([invalid][checked][focused]) path*/[invalid][checked][focused].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-focus-state-invalid-validity-checked-value-icon-color)}/*!@:host([invalid][checked]:active)*/[invalid][checked].sc-market-checkbox-h:active{border-color:var(--checkbox-pressed-state-invalid-validity-checked-value-border-color);background-color:var(--checkbox-pressed-state-invalid-validity-checked-value-background-color)}/*!@:host([invalid][checked]:active) path*/[invalid][checked].sc-market-checkbox-h:active path.sc-market-checkbox{stroke:var(--checkbox-pressed-state-invalid-validity-checked-value-icon-color)}/*!@:host([invalid][indeterminate])*/[invalid][indeterminate].sc-market-checkbox-h{border-color:var(--checkbox-normal-state-invalid-validity-indeterminate-value-border-color);background-color:var(--checkbox-normal-state-invalid-validity-indeterminate-value-background-color)}/*!@:host([invalid][indeterminate]) path*/[invalid][indeterminate].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-normal-state-invalid-validity-indeterminate-value-icon-color)}/*!@:host([invalid][indeterminate]:hover)*/[invalid][indeterminate].sc-market-checkbox-h:hover{border-color:var(--checkbox-hover-state-invalid-validity-indeterminate-value-border-color);background-color:var(--checkbox-hover-state-invalid-validity-indeterminate-value-background-color)}/*!@:host([invalid][indeterminate]:hover) path*/[invalid][indeterminate].sc-market-checkbox-h:hover path.sc-market-checkbox{stroke:var(--checkbox-hover-state-invalid-validity-indeterminate-value-icon-color)}/*!@:host([invalid][indeterminate][focused])*/[invalid][indeterminate][focused].sc-market-checkbox-h{border-color:var(--checkbox-focus-state-invalid-validity-indeterminate-value-border-color);background-color:var(--checkbox-focus-state-invalid-validity-indeterminate-value-background-color)}/*!@:host([invalid][indeterminate]:active)*/[invalid][indeterminate].sc-market-checkbox-h:active{border-color:var(--checkbox-pressed-state-invalid-validity-indeterminate-value-border-color);background-color:var(--checkbox-pressed-state-invalid-validity-indeterminate-value-background-color)}/*!@:host([invalid][indeterminate]:active) path*/[invalid][indeterminate].sc-market-checkbox-h:active path.sc-market-checkbox{stroke:var(--checkbox-pressed-state-invalid-validity-indeterminate-value-icon-color)}/*!@:host([disabled])*/[disabled].sc-market-checkbox-h{border-color:var(--checkbox-disabled-state-normal-validity-unchecked-value-border-color);background-color:var(--checkbox-disabled-state-normal-validity-unchecked-value-background-color);cursor:not-allowed}/*!@:host([disabled]) input*/[disabled].sc-market-checkbox-h input.sc-market-checkbox{cursor:not-allowed}/*!@:host([checked][disabled])*/[checked][disabled].sc-market-checkbox-h{border-color:var(--checkbox-disabled-state-normal-validity-checked-value-border-color);background-color:var(--checkbox-disabled-state-normal-validity-checked-value-background-color)}/*!@:host([checked][disabled]) path*/[checked][disabled].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-disabled-state-normal-validity-checked-value-icon-color)}/*!@:host([indeterminate][disabled])*/[indeterminate][disabled].sc-market-checkbox-h{border-color:var(--checkbox-disabled-state-normal-validity-indeterminate-value-border-color);background-color:var(--checkbox-disabled-state-normal-validity-indeterminate-value-background-color)}/*!@:host([indeterminate][disabled]) path*/[indeterminate][disabled].sc-market-checkbox-h path.sc-market-checkbox{stroke:var(--checkbox-disabled-state-normal-validity-indeterminate-value-icon-color)}";
var MarketCheckboxStyle0 = marketCheckboxCss;

class MarketCheckbox {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketCheckboxValueChange = createEvent(this, "marketCheckboxValueChange", 7);
        this.checked = false;
        this.disabled = false;
        this.indeterminate = false;
        this.invalid = false;
        this.focused = false;
        this.hovered = false;
        this.active = false;
    }
    /**
     * Toggles `checked` prop, and emits a change event accordingly.
     * Used by `market-row` to sync its selected state w/ slotted checkboxes.
     */
    setSelection(newValue, { silent = false } = {}) {
        // this method's implementation could be cleaned up and simplified
        // (see analogous setSelection methods in toggle & radio),
        // but the extra indeterminate state complicates things a bit.
        // so just implementing this in a roundabout way for now in order to
        // keep the tests the same, until we decide to handle it differently.
        // ideally the indeterminate state wouldn't change if the event is prevented,
        // but this could be a breaking change which would need to be addressed.
        const { marketCheckboxValueChange, checked: prevValue, innerInput } = this;
        if (typeof newValue !== 'boolean')
            return Promise.resolve();
        this.indeterminate = false;
        if (prevValue === newValue)
            return Promise.resolve();
        if (!silent) {
            const { defaultPrevented } = marketCheckboxValueChange.emit({
                current: newValue,
                previous: prevValue,
            });
            if (defaultPrevented) {
                return Promise.resolve();
            }
        }
        this.checked = newValue;
        // When using the non-lazy output target, this method sometimes gets called
        // from market-row's watcher after innerInput is removed, hence this check.
        if (innerInput) {
            innerInput.checked = newValue;
        }
        return Promise.resolve();
    }
    /**
     * Toggles `indeterminate` prop. Operates independently of the `checked` property but if `true`,
     * indeterminate visual appearance takes precedence over checked/unchecked.
     */
    setIndeterminate(newValue) {
        this.indeterminate = newValue;
        return Promise.resolve();
    }
    /**
     * DEPRECATED (3.x): Toggles `selected` state (unrelated to the HTML attribute `value`).
     */
    setValue(newValue) {
        /* eslint-disable-next-line no-console */
        console.warn("market-checkbox's setValue() method has been deprecated. Use setSelection() instead.", this.el);
        this.setSelection(newValue);
        return Promise.resolve();
    }
    /**
     * Sets `active` state. Allows external elements to programmatically
     * trigger active styling, ex. when slotted as a control into `market-row`.
     */
    setActive(value) {
        this.active = value;
        return Promise.resolve();
    }
    /**
     * Sets `hovered` state. Allows external elements to programmatically
     * trigger hover styling, ex. when slotted as a control into `market-row`.
     */
    setHover(value) {
        this.hovered = value;
        return Promise.resolve();
    }
    /**
     * Sets `disabled` state. Allows external elements to programmatically
     * trigger disabled styling, ex. when slotted as a control into `market-row`.
     */
    setDisabled(value) {
        this.disabled = value;
        return Promise.resolve();
    }
    /**
     * Sets `focused` state, except when disabled.
     * Allows external consumers to programmatically
     * trigger focused styling.
     */
    setFocus(value = true) {
        if (this.disabled) {
            return Promise.resolve();
        }
        this.focused = value;
        return Promise.resolve();
    }
    handleClick(event) {
        // Always prevent default so we can manually control the selection
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        this.setFocus();
        this.setSelection(!this.checked);
    }
    getCheckedState() {
        return this.indeterminate ? 'indeterminate' : this.checked;
    }
    componentDidRender() {
        if (!this.innerInput) {
            this.innerInput = this.el.shadowRoot.querySelector('input');
        }
    }
    render() {
        return (hAsync(Host, { key: '986021083a3fee4efb0f7f4c815ba933b8bc74be', class: "market-checkbox", onBlur: () => {
                this.setFocus(false);
            }, onClick: this.handleClick, onFocus: () => {
                this.setFocus();
            } }, hAsync("input", { key: '6e48efe625e8a2bf41973d53494bc986bfabfc53', ref: (el) => (this.innerInput = el), type: "checkbox", "aria-label": getControlInputAriaLabel(this.el), checked: this.checked, indeterminate: this.indeterminate, disabled: this.disabled }), this.checked && !this.indeterminate && (hAsync("svg", { key: 'bb79e0d37686e6439c90f5cb1cf5cb8254f644bf', width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", "data-testid": "check" }, hAsync("path", { key: 'a04b9d93b99f30815a97a3f0c63d9bbc14c1fd09', d: "M6 10L8.85714 13L14 7", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }))), this.indeterminate && (hAsync("svg", { key: 'a3f4496a0b99ef3cd29ef3a631eb2aa0e57bcc21', width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", "data-testid": "indeterminate" }, hAsync("path", { key: '2e3e2bd50a4f8ec1f10ad186b603463d20c73916', d: "M6 10H14", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketCheckboxStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-checkbox",
        "$members$": {
            "checked": [1540],
            "disabled": [1540],
            "indeterminate": [1540],
            "invalid": [516],
            "focused": [1540],
            "hovered": [1540],
            "active": [1540],
            "setSelection": [64],
            "setIndeterminate": [64],
            "setValue": [64],
            "setActive": [64],
            "setHover": [64],
            "setDisabled": [64],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["checked", "checked"], ["disabled", "disabled"], ["indeterminate", "indeterminate"], ["invalid", "invalid"], ["focused", "focused"], ["hovered", "hovered"], ["active", "active"]]
    }; }
}

const marketChoiceButtonCss = "/*!@:host, ::slotted(*), **/.sc-market-choice-button-h,.sc-market-choice-button-s>*,*.sc-market-choice-button{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-choice-button-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-choice-button-h *.sc-market-choice-button,.sc-market-choice-button-h[disabled].sc-market-choice-button-s>*,.sc-market-choice-button-h[disabled] .sc-market-choice-button-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-choice-button-h{--transition-duration:0.2s;--focus-ring-color:color-mix(in srgb, var(--choice-button-focus-ring-color) 100%, transparent);position:relative;display:inline-block;border-radius:var(--choice-button-border-radius);background-color:var(--choice-button-unselected-value-normal-state-background-color);color:var(--choice-button-unselected-value-normal-state-label-color);cursor:pointer;transition:background-color color var(--transition-duration)}/*!@button*/button.sc-market-choice-button{display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;width:100%;margin:0;padding:0;border:none;border-radius:var(--choice-button-border-radius);background-color:transparent;color:inherit;outline:none;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;text-align:center;cursor:inherit}/*!@button:focus-visible*/button.sc-market-choice-button:focus-visible{outline:var(--choice-button-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--choice-button-focus-ring-buffer-size)}/*!@::slotted([slot=\"secondary-text\"])*/.sc-market-choice-button-s>[slot=\"secondary-text\"]{cursor:inherit}/*!@:host([size=\"medium\"]) button*/[size=\"medium\"].sc-market-choice-button-h button.sc-market-choice-button{padding:var(--choice-button-medium-size-vertical-padding) var(--choice-button-medium-size-horizontal-padding);font-weight:var(--choice-button-medium-size-text-primary-weight);font-size:var(--choice-button-medium-size-text-primary-size);line-height:var(--choice-button-medium-size-text-primary-leading);letter-spacing:var(--choice-button-medium-size-text-primary-tracking);text-transform:var(--choice-button-medium-size-text-primary-case);-moz-column-gap:var(--choice-button-medium-size-content-spacing);column-gap:var(--choice-button-medium-size-content-spacing)}/*!@:host([size=\"medium\"]) ::slotted([slot=\"secondary-text\"])*/.sc-market-choice-button-h[size=\"medium\"] .sc-market-choice-button-s>[slot=\"secondary-text\"]{font-weight:var(--choice-button-medium-size-text-secondary-weight);font-size:var(--choice-button-medium-size-text-secondary-size);line-height:var(--choice-button-medium-size-text-secondary-leading);letter-spacing:var(--choice-button-medium-size-text-secondary-tracking);text-transform:var(--choice-button-medium-size-text-secondary-case)}/*!@:host([size=\"small\"]) button*/[size=\"small\"].sc-market-choice-button-h button.sc-market-choice-button{padding:var(--choice-button-small-size-vertical-padding) var(--choice-button-small-size-horizontal-padding);font-weight:var(--choice-button-small-size-text-primary-weight);font-size:var(--choice-button-small-size-text-primary-size);line-height:var(--choice-button-small-size-text-primary-leading);letter-spacing:var(--choice-button-small-size-text-primary-tracking);text-transform:var(--choice-button-small-size-text-primary-case);-moz-column-gap:var(--choice-button-small-size-content-spacing);column-gap:var(--choice-button-small-size-content-spacing)}/*!@:host([size=\"small\"]) ::slotted([slot=\"secondary-text\"])*/.sc-market-choice-button-h[size=\"small\"] .sc-market-choice-button-s>[slot=\"secondary-text\"]{font-weight:var(--choice-button-small-size-text-secondary-weight);font-size:var(--choice-button-small-size-text-secondary-size);line-height:var(--choice-button-small-size-text-secondary-leading);letter-spacing:var(--choice-button-small-size-text-secondary-tracking);text-transform:var(--choice-button-small-size-text-secondary-case)}/*!@:host([size=\"large\"]) button*/[size=\"large\"].sc-market-choice-button-h button.sc-market-choice-button{padding:var(--choice-button-large-size-vertical-padding) var(--choice-button-large-size-horizontal-padding);font-weight:var(--choice-button-large-size-text-primary-weight);font-size:var(--choice-button-large-size-text-primary-size);line-height:var(--choice-button-large-size-text-primary-leading);letter-spacing:var(--choice-button-large-size-text-primary-tracking);text-transform:var(--choice-button-large-size-text-primary-case);-moz-column-gap:var(--choice-button-large-size-content-spacing);column-gap:var(--choice-button-large-size-content-spacing)}/*!@:host([size=\"large\"]) ::slotted([slot=\"secondary-text\"])*/.sc-market-choice-button-h[size=\"large\"] .sc-market-choice-button-s>[slot=\"secondary-text\"]{font-weight:var(--choice-button-large-size-text-secondary-weight);font-size:var(--choice-button-large-size-text-secondary-size);line-height:var(--choice-button-large-size-text-secondary-leading);letter-spacing:var(--choice-button-large-size-text-secondary-tracking);text-transform:var(--choice-button-large-size-text-secondary-case)}@media (hover: hover){/*!@:host(:hover)*/.sc-market-choice-button-h:hover{background-color:var(--choice-button-unselected-value-hover-state-background-color);color:var(--choice-button-unselected-value-hover-state-label-color)}}/*!@:host(:active)*/.sc-market-choice-button-h:active{background-color:var(--choice-button-unselected-value-pressed-state-background-color);color:var(--choice-button-unselected-value-pressed-state-label-color)}/*!@:host([disabled])*/[disabled].sc-market-choice-button-h{background-color:var(--choice-button-unselected-value-disabled-state-background-color);color:var(--choice-button-unselected-value-disabled-state-label-color)}/*!@:host([selected])*/[selected].sc-market-choice-button-h{background-color:var(--choice-button-selected-value-normal-state-background-color);color:var(--choice-button-selected-value-normal-state-label-color)}@media (hover: hover){/*!@:host([selected]:hover)*/[selected].sc-market-choice-button-h:hover{background-color:var(--choice-button-selected-value-hover-state-background-color);color:var(--choice-button-selected-value-hover-state-label-color)}}/*!@:host([selected]:active)*/[selected].sc-market-choice-button-h:active{background-color:var(--choice-button-selected-value-pressed-state-background-color);color:var(--choice-button-selected-value-pressed-state-label-color)}/*!@:host([selected][disabled])*/[selected][disabled].sc-market-choice-button-h{background-color:var(--choice-button-selected-value-disabled-state-background-color);color:var(--choice-button-selected-value-disabled-state-label-color)}";
var MarketChoiceButtonStyle0 = marketChoiceButtonCss;

/**
 * @slot - The text used for the choice button label
 * @slot secondary-text - text to the right side of choice button
 */
class MarketChoiceButton {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketChoiceButtonSelected = createEvent(this, "marketChoiceButtonSelected", 7);
        this.marketChoiceButtonDeselected = createEvent(this, "marketChoiceButtonDeselected", 7);
        this.disabled = false;
        this.selected = false;
        this.size = 'medium';
    }
    onClick(e) {
        if (this.disabled) {
            e.stopImmediatePropagation();
            return;
        }
        if (this.selected) {
            this.selected = false;
            this.marketChoiceButtonDeselected.emit();
        }
        else {
            this.selected = true;
            this.marketChoiceButtonSelected.emit();
        }
    }
    render() {
        const { disabled } = this;
        return (hAsync(Host, { key: '5fed443777aa284760086db85df12d195aada3cc', class: "market-choice-button", tabindex: disabled ? -1 : undefined, onClick: (e) => {
                this.onClick(e);
            } }, hAsync("button", { key: 'c8e8aff08358a621202d705f6aa63f9dbeb7ab37', "aria-disabled": disabled }, hAsync("slot", { key: '032cec3910431ad73dffef0d7fae6dfb72a3a4e2' }), hAsync("slot", { key: '1921baa2a22e9ef012979d7232ac4dee74353776', name: "secondary-text" }))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketChoiceButtonStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-choice-button",
        "$members$": {
            "disabled": [516],
            "selected": [1540],
            "size": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["selected", "selected"], ["size", "size"]]
    }; }
}

const marketCodeDisplayCss = "/*!@:host, ::slotted(*), **/.sc-market-code-display-h,.sc-market-code-display-s>*,*.sc-market-code-display{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-code-display-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-code-display-h *.sc-market-code-display,.sc-market-code-display-h[disabled].sc-market-code-display-s>*,.sc-market-code-display-h[disabled] .sc-market-code-display-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-code-display-h{display:flex;justify-content:space-between;align-items:center;width:-moz-min-content;width:min-content;min-width:var(--code-display-width, 320px);min-height:var(--code-display-height, 48px);margin:var(--code-display-margin, 12px);padding:var(--code-display-padding-vertical, 12px)\n    var(--code-display-padding-right, 16px)\n    var(--code-display-padding-vertical, 12px)\n    var(--code-display-zero-value, 0);border-radius:var(--code-display-border-radius, 6px);background-color:var(--code-display-background-color, var(--core-fill-40-color));font-weight:var(--code-display-code-font-weight, var(--core-type-bold-weight));font-size:var(--code-display-code-font-size, var(--core-type-heading-20-size));font-family:var(--code-display-font-family, var(--core-type-font-family));font-feature-settings:\"tnum\"}/*!@:host(:not([disabled])) button:hover, :host ::slotted(button:hover), :host ::slotted(a:hover)*/.sc-market-code-display-h:not([disabled]) button.sc-market-code-display:hover,.sc-market-code-display-h.sc-market-code-display-s>button:hover,.sc-market-code-display-h.sc-market-code-display-s>button,.sc-market-code-display-h .sc-market-code-display-s>button:hover,.sc-market-code-display-h.sc-market-code-display-s>a:hover,.sc-market-code-display-h.sc-market-code-display-s>a,.sc-market-code-display-h .sc-market-code-display-s>a:hover{opacity:var(--code-display-action-interaction-opacity, 60%)}/*!@:host(:not([disabled])) button:active, :host ::slotted(button:active), :host ::slotted(a:active)*/.sc-market-code-display-h:not([disabled]) button.sc-market-code-display:active,.sc-market-code-display-h.sc-market-code-display-s>button:active,.sc-market-code-display-h.sc-market-code-display-s>button,.sc-market-code-display-h .sc-market-code-display-s>button:active,.sc-market-code-display-h.sc-market-code-display-s>a:active,.sc-market-code-display-h.sc-market-code-display-s>a,.sc-market-code-display-h .sc-market-code-display-s>a:active{opacity:var(--code-display-action-interaction-opacity, 60%)}/*!@:host([disabled])*/[disabled].sc-market-code-display-h{color:var(--code-display-disabled-text-color, var(--core-text-30-color))}/*!@:host([disabled]) ::slotted(button), :host ::slotted(a)*/.sc-market-code-display-h[disabled] .sc-market-code-display-s>button,.sc-market-code-display-h.sc-market-code-display-s>a,.sc-market-code-display-h .sc-market-code-display-s>a{color:var(--code-display-disabled-text-color, var(--core-text-30-color))}/*!@:host .code-container*/.sc-market-code-display-h .code-container.sc-market-code-display{display:flex;flex-grow:2;justify-content:space-between;min-width:var(--code-display-code-container-min-width, 269px)}/*!@:host .code-char*/.sc-market-code-display-h .code-char.sc-market-code-display{flex-basis:100%;font-family:var(--core-type-mono-font-family, monospace);text-align:center}/*!@:host .actions-container*/.sc-market-code-display-h .actions-container.sc-market-code-display{display:flex;justify-content:center;align-items:center}/*!@:host .actions-container ::slotted([slot=\"actions\"]:not(:last-child))*/.sc-market-code-display-h .actions-container .sc-market-code-display-s>[slot=\"actions\"]:not(:last-child){margin-right:var(--code-display-extra-actions-margin-right, 25px)}/*!@:host .actions-container ::slotted([slot=\"actions\"]:not(:last-child))::after*/.sc-market-code-display-h .actions-container .sc-market-code-display-s>[slot=\"actions\"]:not(:last-child)::after{content:\"\";display:inline-block;width:var(--code-display-button-separator-width, 1px);height:var(--code-display-button-separator-height, 8px);margin-right:var(--code-display-separator-margin-right, -13px);margin-left:var(--code-display-button-content-spacing, 12px);background-color:var(--code-display-button-separator-color, var(--core-fill-10-color));opacity:var(--code-display-button-separator-opacity, 30%);pointer-events:none}/*!@:host button, :host ::slotted(button), :host ::slotted(a)*/.sc-market-code-display-h button.sc-market-code-display,.sc-market-code-display-h.sc-market-code-display-s>button,.sc-market-code-display-h .sc-market-code-display-s>button,.sc-market-code-display-h.sc-market-code-display-s>a,.sc-market-code-display-h .sc-market-code-display-s>a{margin:var(--code-display-zero-value, 0);padding:var(--code-display-zero-value, 0);border:none;background-color:transparent;color:var(--code-display-button-font-color, var(--core-blue-text-color));font-weight:var(--code-display-button-font-weight, var(--core-type-semibold-weight));font-size:var(--code-display-button-font-size, var(--core-type-paragraph-20-size));font-family:inherit;line-height:var(--code-display-button-line-height, var(--core-type-paragraph-20-leading));text-decoration:none;cursor:pointer}@media only screen and (max-width: 320px){/*!@:host*/.sc-market-code-display-h{flex-wrap:wrap;width:100%;min-width:var(--code-display-zero-value, 0)}/*!@:host .code-container*/.sc-market-code-display-h .code-container.sc-market-code-display{min-width:var(--code-display-zero-value, 0)}}";
var MarketCodeDisplayStyle0 = marketCodeDisplayCss;

/**
 * When code is split up, represents how many characters are in each group.
 */
const CODE_GROUP_LEN = 4;
class MarketCodeDisplay {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketCodeCopied = createEvent(this, "marketCodeCopied", 7);
        /**
         * A string holding the code inputted by the user through a slot.
         */
        this.code = '';
        /**
         * An array holding spans containing each character in the code, with some blanks.
         * Used for styling and spacing.
         */
        this.codeChars = [];
        this.disabled = false;
        this.focused = false;
    }
    /**
     * Component Lifecycle Event:
     * Grab the code and its len from inputted code slot.
     * Set relevant props and insert the Copy button programmatically so that it appears in the light DOM.
     */
    componentWillLoad() {
        // Set code and codeGroups
        const slottedCodeTag = this.el.querySelector('[slot=code]');
        const code = slottedCodeTag.textContent;
        // Remove whitespace from slotted code
        this.code = code.replace(/\s/g, '');
        this.initCodeChars(this.code);
        // Programmatically insert default Copy button into light DOM
        this.copyButton = document.createElement('button');
        Object.assign(this.copyButton, {
            slot: 'actions',
            type: 'button',
            tabIndex: this.disabled ? -1 : 0,
            onclick: () => this.copyToClipboard(),
        });
        // NOTE: The following code is brittle! Relies on the fact that the consumer
        //       slotted in elements in order of 'code' -> 'copy-text' -> 'actions'
        // If consumer slotted in alt copy-text, place copyButton after code & copy-text
        if (this.el.querySelector('[slot=copy-text]')) {
            // Set text of the Copy button to slotted copy-text
            const slottedCopyText = this.el.querySelector('[slot=copy-text]');
            const copyText = slottedCopyText.textContent;
            this.copyButton.innerHTML = copyText;
            slottedCopyText.insertAdjacentElement('afterend', this.copyButton);
        }
        else {
            this.copyButton.innerHTML = `Copy`;
            slottedCodeTag.insertAdjacentElement('afterend', this.copyButton);
        }
    }
    /**
     * Inits this.codeChars to an array of <span> tags containing each character in the code string.
     * Additionally contains empty strings at certain indices based on codeLen.
     * By default, blanks are only placed at the front & back of the array.
     *    ['', 'x', 'x', 'x', 'x', '']
     * If codeLen is divisible by 4, put blanks every 4 spots too.
     *    ['', 'x', 'x', 'x', 'x', '', 'x', 'x', 'x', 'x', '']
     * The exception to this is if codeLen===4, in which case we use the default.
     * This codeChars arr is used in render() to space and style characters appropriately.
     * Called only once on componentWillLoad() as to not cause re-renders
     */
    initCodeChars(code) {
        const codeLen = code.length;
        const BLANK_CODE_SPAN = hAsync("span", { class: "code-char" });
        // Place blanks every 4 chars
        if (codeLen !== CODE_GROUP_LEN && codeLen % CODE_GROUP_LEN === 0) {
            for (let i = 0; i < codeLen; i++) {
                if (i % CODE_GROUP_LEN === 0)
                    this.codeChars.push(BLANK_CODE_SPAN);
                this.codeChars.push(hAsync("span", { class: "code-char" }, code[i]));
            }
        }
        // Only place blank at the front & back
        else {
            this.codeChars.push(BLANK_CODE_SPAN);
            for (let i = 0; i < codeLen; i++) {
                this.codeChars.push(hAsync("span", { class: "code-char" }, code[i]));
            }
        }
        this.codeChars.push(BLANK_CODE_SPAN);
    }
    /**
     * When user presses the 'Copy' button, copy code to clipboard & emit an event.
     */
    copyToClipboard() {
        navigator.clipboard.writeText(this.code);
        this.marketCodeCopied.emit();
    }
    render() {
        return (hAsync(Host, { key: 'd20b66bb6de60a11d86a92b2fa8faafa594727b7', class: "market-code-display", tabIndex: this.disabled ? null : 0, "aria-label": this.code }, hAsync("span", { key: 'd403656bd834ecea1b9deb6409d9d0747e41e27b', class: "code-container" }, this.codeChars), hAsync("span", { key: '87a4cc31d2bcf6dd393b247e43a75067cd65b0e0', class: "actions-container" }, hAsync("slot", { key: '42ceb91d39adfef778a695c1c4b3700d78d77a55', name: "actions" }))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketCodeDisplayStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-code-display",
        "$members$": {
            "disabled": [1540],
            "focused": [1540]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["focused", "focused"]]
    }; }
}

const marketCodeInputCss = "/*!@:host, ::slotted(*), **/.sc-market-code-input-h,.sc-market-code-input-s>*,*.sc-market-code-input{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-code-input-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-code-input-h *.sc-market-code-input,.sc-market-code-input-h[disabled].sc-market-code-input-s>*,.sc-market-code-input-h[disabled] .sc-market-code-input-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-code-input-h{position:relative;outline:none;font-weight:var(--field-input-weight);font-size:var(--field-input-size);line-height:var(--field-input-leading);cursor:text}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-code-input-h input.sc-market-code-input,.sc-market-code-input-h.sc-market-code-input-s>input,.sc-market-code-input-h .sc-market-code-input-s>input,.sc-market-code-input-h textarea.sc-market-code-input,.sc-market-code-input-h.sc-market-code-input-s>textarea,.sc-market-code-input-h .sc-market-code-input-s>textarea{width:100%;margin:0;padding:0;border:none;background-color:transparent;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;cursor:inherit}/*!@:host ::slotted(label)*/.sc-market-code-input-h .sc-market-code-input-s>label{cursor:inherit}/*!@:host input:focus, :host ::slotted(input:focus), :host textarea:focus, :host ::slotted(textarea:focus)*/.sc-market-code-input-h input.sc-market-code-input:focus,.sc-market-code-input-h.sc-market-code-input-s>input,.sc-market-code-input-h.sc-market-code-input-s>input:focus,.sc-market-code-input-h .sc-market-code-input-s>input:focus,.sc-market-code-input-h textarea.sc-market-code-input:focus,.sc-market-code-input-h.sc-market-code-input-s>textarea,.sc-market-code-input-h.sc-market-code-input-s>textarea:focus,.sc-market-code-input-h .sc-market-code-input-s>textarea:focus{outline:none}/*!@:host input::-moz-placeholder, :host textarea::-moz-placeholder*/.sc-market-code-input-h input.sc-market-code-input::-moz-placeholder,.sc-market-code-input-h textarea.sc-market-code-input::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host input::placeholder, :host textarea::placeholder*/.sc-market-code-input-h input.sc-market-code-input::placeholder,.sc-market-code-input-h textarea.sc-market-code-input::placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::-moz-placeholder, :host ::slotted(textarea)::-moz-placeholder*/.sc-market-code-input-h.sc-market-code-input-s>input,.sc-market-code-input-h .sc-market-code-input-s>input::-moz-placeholder,.sc-market-code-input-h.sc-market-code-input-s>textarea,.sc-market-code-input-h.sc-market-code-input-s>textarea::-moz-placeholder,.sc-market-code-input-h .sc-market-code-input-s>textarea::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::placeholder, :host ::slotted(textarea)::placeholder*/.sc-market-code-input-h.sc-market-code-input-s>input,.sc-market-code-input-h .sc-market-code-input-s>input::placeholder,.sc-market-code-input-h.sc-market-code-input-s>textarea,.sc-market-code-input-h.sc-market-code-input-s>textarea::placeholder,.sc-market-code-input-h .sc-market-code-input-s>textarea::placeholder{color:var(--field-placeholder-text-color)}/*!@:host([size='small'])*/[size='small'].sc-market-code-input-h{font-size:var(--core-type-paragraph-20-size);line-height:var(--core-type-paragraph-20-leading)}/*!@:host*/.sc-market-code-input-h{border-radius:var(--field-border-radius);background-color:var(--field-normal-state-background-color);color:var(--field-normal-state-input-color)}/*!@:host::after*/.sc-market-code-input-h::after{content:\"\";position:absolute;inset:0;border-radius:var(--field-border-radius);box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color);pointer-events:none}/*!@:host([invalid])::after*/[invalid].sc-market-code-input-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-invalid-validity-border-color)}/*!@:host(:hover)*/.sc-market-code-input-h:hover{background-color:var(--field-hover-state-background-color);color:var(--field-hover-state-input-color)}/*!@:host(:hover)::after*/.sc-market-code-input-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-normal-validity-border-color)}/*!@:host([invalid]:hover)::after*/[invalid].sc-market-code-input-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-invalid-validity-border-color)}/*!@:host([focused])*/[focused].sc-market-code-input-h{color:var(--field-focus-state-input-color)}/*!@:host([focused])::after*/[focused].sc-market-code-input-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size)\n        var(--field-focus-state-normal-validity-border-color)}/*!@:host([focused][invalid])::after*/[focused][invalid].sc-market-code-input-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size) var(--field-focus-state-invalid-validity-border-color)}/*!@:host([readonly]:hover)::after*/[readonly].sc-market-code-input-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color)}/*!@:host([disabled])*/[disabled].sc-market-code-input-h{background-color:var(--field-disabled-state-background-color) !important;color:var(--field-disabled-state-input-color) !important;cursor:not-allowed !important}/*!@:host([disabled])::after*/[disabled].sc-market-code-input-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-disabled-state-border-color) !important}/*!@:host([disabled]) ::slotted(.market-accessory), :host([disabled]) ::slotted(img[slot*=\"accessory\"]), :host([disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([disabled]) ::slotted(div[slot*=\"accessory\"])*/.sc-market-code-input-h[disabled] .sc-market-code-input-s>.market-accessory,.sc-market-code-input-h[disabled].sc-market-code-input-s>img[slot*=\"accessory\"],.sc-market-code-input-h[disabled] .sc-market-code-input-s>img[slot*=\"accessory\"],.sc-market-code-input-h[disabled].sc-market-code-input-s>svg[slot*=\"accessory\"],.sc-market-code-input-h[disabled] .sc-market-code-input-s>svg[slot*=\"accessory\"],.sc-market-code-input-h[disabled].sc-market-code-input-s>div[slot*=\"accessory\"],.sc-market-code-input-h[disabled] .sc-market-code-input-s>div[slot*=\"accessory\"]{--field-disabled-state-accessory-opacity:var(--row-disabled-state-leading-accessory-opacity);opacity:var(--field-disabled-state-accessory-opacity)}/*!@:host([value=\"\"]) ::slotted(label)*/.sc-market-code-input-h[value=\"\"] .sc-market-code-input-s>label{color:var(--field-normal-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"][autofilled]) ::slotted(label)*/.sc-market-code-input-h:not([value=\"\"]) .sc-market-code-input-s>label,.sc-market-code-input-h[value=\"\"][autofilled].sc-market-code-input-s>label,.sc-market-code-input-h[value=\"\"][autofilled] .sc-market-code-input-s>label{color:var(--field-normal-state-float-phase-label-color)}/*!@:host(:hover) ::slotted(label)*/.sc-market-code-input-h:hover .sc-market-code-input-s>label{color:var(--field-hover-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"]):hover) ::slotted(label), :host([value=\"\"][autofilled]:hover) ::slotted(label)*/.sc-market-code-input-h:not([value=\"\"]):hover .sc-market-code-input-s>label,.sc-market-code-input-h[value=\"\"][autofilled]:hover.sc-market-code-input-s>label,.sc-market-code-input-h[value=\"\"][autofilled]:hover .sc-market-code-input-s>label{color:var(--field-hover-state-float-phase-label-color)}/*!@:host([focused]) ::slotted(label)*/.sc-market-code-input-h[focused] .sc-market-code-input-s>label{color:var(--field-focus-state-float-phase-label-color)}/*!@:host([value=\"\"][disabled]) ::slotted(label)*/.sc-market-code-input-h[value=\"\"][disabled] .sc-market-code-input-s>label{color:var(--field-disabled-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])[disabled]) ::slotted(label), :host([value=\"\"][autofilled][disabled]) ::slotted(label)*/.sc-market-code-input-h:not([value=\"\"])[disabled] .sc-market-code-input-s>label,.sc-market-code-input-h[value=\"\"][autofilled][disabled].sc-market-code-input-s>label,.sc-market-code-input-h[value=\"\"][autofilled][disabled] .sc-market-code-input-s>label{color:var(--field-disabled-state-float-phase-label-color)}/*!@:host*/.sc-market-code-input-h{display:flex;align-items:center;height:var(--input-code-height, 64px)}/*!@:host input*/.sc-market-code-input-h input.sc-market-code-input{font-weight:var(--input-code-font-weight, var(--core-type-bold-weight));font-family:var(--core-type-mono-font-family, monospace);text-align:center}/*!@:host input:-webkit-autofill, :host input:-webkit-autofill:hover, :host input:-webkit-autofill:focus*/.sc-market-code-input-h input.sc-market-code-input:-webkit-autofill,.sc-market-code-input-h input.sc-market-code-input:-webkit-autofill:hover,.sc-market-code-input-h input.sc-market-code-input:-webkit-autofill:focus{box-shadow:0 0 0 calc(var(--input-code-height, 64px) / 2) var(--field-normal-state-background-color) inset}/*!@.code-input-container*/.code-input-container.sc-market-code-input{display:flex;justify-content:center;width:100%;height:100%}/*!@.code-input-container::before, .code-input-container::after*/.code-input-container.sc-market-code-input::before,.code-input-container.sc-market-code-input::after{content:\"\";flex-basis:100%;pointer-events:none}/*!@::slotted([slot=\"trailing-accessory\"])*/.sc-market-code-input-s>[slot=\"trailing-accessory\"]{margin-right:var(--input-code-trailing-accessory-spacing, 12px)}/*!@input::-moz-placeholder*/input.sc-market-code-input::-moz-placeholder{color:var(--input-code-placeholder-color, var(--core-fill-30-color));font-size:var(--input-code-placeholder-font-size, 24px)}/*!@input::placeholder*/input.sc-market-code-input::placeholder{color:var(--input-code-placeholder-color, var(--core-fill-30-color));font-size:var(--input-code-placeholder-font-size, 24px)}";
var MarketCodeInputStyle0 = marketCodeInputCss;

/**
 * @slot trailing-accessory - An icon set on the right side of the input.
 */
class MarketCodeInput {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketCodeInputValueChange = createEvent(this, "marketCodeInputValueChange", 7);
        this.type = 'number';
        this.name = undefined;
        this.length = 4;
        this.focused = false;
        this.value = '';
        this.readonly = false;
        this.invalid = false;
        this.disabled = false;
        this._code = undefined;
    }
    valueChangeHandler(value) {
        const sanitized = this.sanitizeValue(value);
        if (this.value !== sanitized) {
            this.value = sanitized;
        }
        this.setInputsFromValue(this.value);
    }
    /**
     * Trigger focus styling on `<market-input-text>`
     * and focus the cursor on the first empty `<input />`.
     */
    setFocus(value = true) {
        var _a;
        this.focused = value;
        if (value) {
            this.focusFirstEmptyInput();
        }
        else {
            (_a = this.el.shadowRoot.activeElement) === null || _a === void 0 ? void 0 : _a.blur();
        }
        return Promise.resolve();
    }
    isNumber(value) {
        return /^\d+$/.test(value);
    }
    isValidChar(char) {
        // no whitespace
        if (/\s/.test(char))
            return false;
        // number check
        return ['text', 'password'].includes(this.type) || this.isNumber(char);
    }
    focusFirstEmptyInput() {
        const inputs = this.el.shadowRoot.querySelectorAll('input');
        let input;
        inputs.forEach((i) => {
            if (!i.value && !input)
                input = i;
        });
        if (!input)
            input = inputs[this.length - 1];
        input.focus();
    }
    /**
     * Inits this._code to the passed-in `value` prop or to an
     * empty array representation of the code input i.e ['', '', '', '']
     * Called only once on componentWillLoad() as to not cause re-renders
     */
    initCode(value) {
        if (value) {
            this._code = value.split('');
            // ensure that this._code is always of size this.length
            if (this._code.length < this.length) {
                const padding = Array.from({ length: this.length - this._code.length }).fill('');
                this._code = [...this._code, ...padding];
            }
            else if (this._code.length > this.length) {
                this._code = this._code.slice(0, this.length);
            }
        }
        else {
            this._code = Array.from({ length: this.length }).fill('');
        }
    }
    sanitizeValue(value) {
        return value
            .split('')
            .filter((char) => this.isValidChar(char))
            .join('')
            .slice(0, this.length);
    }
    getValueFromInputs() {
        let value = '';
        this.el.shadowRoot.querySelectorAll('input').forEach((input) => {
            value += input.value;
        });
        return value;
    }
    setInputsFromValue(value) {
        const inputs = this.el.shadowRoot.querySelectorAll('input');
        inputs.forEach((input, i) => {
            const char = value[i];
            const prevChar = value[i - 1];
            // set the input value
            input.value = char || '';
            // set the input tabindex
            if (i === 0 || prevChar) {
                input.removeAttribute('tabindex');
            }
            else {
                input.tabIndex = -1;
            }
        });
    }
    spreadChars(e) {
        const { target, data } = e;
        const chars = data || target.value;
        if (!chars)
            return;
        const sanitized = this.sanitizeValue(chars);
        if (sanitized) {
            this.insertChars(target, sanitized.split(''));
        }
        else {
            target.value = '';
        }
    }
    insertChars(input, chars) {
        const { nextElementSibling } = input;
        const [first, ...rest] = chars;
        input.value = first;
        nextElementSibling === null || nextElementSibling === void 0 ? void 0 : nextElementSibling.focus();
        if (nextElementSibling && rest.length > 0) {
            this.insertChars(nextElementSibling, rest);
        }
    }
    updateValue() {
        const previousValue = this.value;
        const newValue = this.sanitizeValue(this.getValueFromInputs());
        if (previousValue !== newValue) {
            const { defaultPrevented } = this.marketCodeInputValueChange.emit({ code: newValue });
            if (defaultPrevented) {
                this.setInputsFromValue(previousValue);
            }
            else {
                this.value = newValue;
            }
        }
    }
    onInput(e) {
        // Handle paste or autocomplete of multiple chars
        this.spreadChars(e);
        this.updateValue();
    }
    onFocus(e) {
        const { target } = e;
        this.focused = true;
        if (target.value) {
            target.select();
        }
        else {
            this.focusFirstEmptyInput();
        }
    }
    onBlur() {
        this.focused = false;
    }
    onKeyDown(e) {
        const { target, key } = e;
        const { value, previousElementSibling, nextElementSibling } = target;
        switch (key) {
            case 'ArrowLeft':
                e.preventDefault();
                previousElementSibling === null || previousElementSibling === void 0 ? void 0 : previousElementSibling.select();
                break;
            case 'ArrowRight':
                e.preventDefault();
                nextElementSibling === null || nextElementSibling === void 0 ? void 0 : nextElementSibling.select();
                break;
            case 'Backspace':
                if (!value)
                    previousElementSibling === null || previousElementSibling === void 0 ? void 0 : previousElementSibling.select();
                break;
        }
    }
    onKeyUp(e) {
        const { target } = e;
        const { value } = target;
        if (value.length > 1) {
            this.spreadChars(e);
        }
        else if (!this.isValidChar(value)) {
            target.value = '';
            target.focus();
        }
    }
    onHostClick() {
        // if a child input does not already have focus
        if (!this.el.shadowRoot.activeElement) {
            this.setFocus();
        }
    }
    componentWillLoad() {
        this.valueChangeHandler(this.value);
        this.initCode(this.value);
    }
    render() {
        const inputs = [];
        this._code.forEach((char, index) => {
            const tabindex = this._code[index - 1] || index === 0 ? null : -1;
            inputs.push(hAsync("input", { required: true, type: this.type === 'password' ? 'password' : 'text', inputmode: this.type === 'number' ? 'numeric' : null, autocomplete: index === 0 ? 'one-time-code' : null, value: char, maxlength: index === this.length - 1 ? '1' : null, readOnly: this.readonly, disabled: this.disabled, placeholder: "\u25CF", tabindex: tabindex, onFocus: (e) => this.onFocus(e), onBlur: () => this.onBlur(), onInput: (e) => this.onInput(e), onKeyDown: (e) => this.onKeyDown(e), onKeyUp: (e) => this.onKeyUp(e) }));
        });
        return (hAsync(Host, { key: 'c11c05f9414698bd9d8f87b3e98adc021b233f1c', class: "market-code-input", name: this.name, onClick: () => this.onHostClick() }, hAsync("span", { key: 'd3b5a43bb80ee199628650c96e6f9b17cf8fee88', class: "code-input-container" }, inputs), hAsync("slot", { key: '8f0aa799fa46d759e6015488a07a2f6bb7c64669', name: "trailing-accessory" })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueChangeHandler"]
    }; }
    static get style() { return MarketCodeInputStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-code-input",
        "$members$": {
            "type": [513],
            "name": [1],
            "length": [2],
            "focused": [1540],
            "value": [1537],
            "readonly": [516],
            "invalid": [516],
            "disabled": [516],
            "_code": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["type", "type"], ["focused", "focused"], ["value", "value"], ["readonly", "readonly"], ["invalid", "invalid"], ["disabled", "disabled"]]
    }; }
}

// Formulas pulled from
// https://github.com/simonwep/pickr/blob/master/src/js/utils/color.js#L28
// Shorthands
const { min: min$2, max: max$2, floor: floor$1, round: round$2 } = Math;
function hsvToRgb(hArg, sArg, vArg) {
    let h = hArg;
    let s = sArg;
    let v = vArg;
    h = (h / 360) * 6;
    s /= 100;
    v /= 100;
    const i = floor$1(h);
    const f = h - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    const mod = i % 6;
    const r = [v, q, p, p, t, v][mod];
    const g = [t, v, v, q, p, p][mod];
    const b = [p, p, t, v, v, q][mod];
    return [r * 255, g * 255, b * 255];
}
/**
 * Convert HSV spectrum to Hex.
 * @param h Hue
 * @param s Saturation
 * @param v Value
 * @returns {string[]} Hex values
 */
function hsvToHex(h, s, v) {
    return hsvToRgb(h, s, v).map((v) => round$2(v).toString(16).padStart(2, '0'));
}
/**
 * Convert RGB to HSV.
 * @param r Red
 * @param g Green
 * @param b Blue
 * @return {number[]} HSV values.
 */
function rgbToHsv(rArg, gArg, bArg) {
    let r = rArg;
    let g = gArg;
    let b = bArg;
    r /= 255;
    g /= 255;
    b /= 255;
    const minVal = min$2(r, g, b);
    const maxVal = max$2(r, g, b);
    const delta = maxVal - minVal;
    let h, s;
    const v = maxVal;
    if (delta === 0) {
        h = s = 0;
    }
    else {
        s = delta / maxVal;
        const dr = ((maxVal - r) / 6 + delta / 2) / delta;
        const dg = ((maxVal - g) / 6 + delta / 2) / delta;
        const db = ((maxVal - b) / 6 + delta / 2) / delta;
        if (r === maxVal) {
            h = db - dg;
        }
        else if (g === maxVal) {
            h = 1 / 3 + dr - db;
        }
        else if (b === maxVal) {
            h = 2 / 3 + dg - dr;
        }
        if (h < 0) {
            h += 1;
        }
        else if (h > 1) {
            h -= 1;
        }
    }
    return [h * 360, s * 100, v * 100];
}
/**
 * Convert HSL to HSV.
 * @param h Hue
 * @param s Saturation
 * @param l Lightness
 * @return {number[]} HSV values.
 */
function hslToHsv(h, sArg, lArg) {
    let s = sArg;
    let l = lArg;
    s /= 100;
    l /= 100;
    s *= l < 0.5 ? l : 1 - l;
    const ns = ((2 * s) / (l + s)) * 100;
    const v = (l + s) * 100;
    return [h, Number.isNaN(ns) ? 0 : ns, v];
}
/**
 * Convert HEX to HSV.
 * @param hex Hexadecimal string of rgb colors, can have length 3 or 6.
 * @return {number[]} HSV values.
 */
function hexToHsv(hex) {
    const result = hex.match(/.{2}/g);
    const numResult = result.map((v) => Number.parseInt(v, 16));
    return rgbToHsv(numResult[0], numResult[1], numResult[2]);
}
/**
 * Takes an Array of any type, convert strings which represents
 * a number to a number and anything else to undefined.
 * @param array
 * @return {*}
 */
function numarize(array) {
    return array.map((v) => {
        const n = Number(v);
        return Number.isNaN(v) ? undefined : n;
    });
}
/**
 * Try's to parse a string which represents a color to a HSV array.
 * Current supported types are rgba, hsla and hexadecimal.
 * @param str
 * @return {*}
 */
/* eslint-disable complexity */
function parseToHSVA(str) {
    // Check if string is a color-name
    // str = str.match(/^[a-zA-Z]+$/) ? standardizeColor(str) : str;
    // Regular expressions to match different types of color represention
    const validColorValueRegex = {
        rgba: /^rgba?\D+([\d.]+)(%?)\D+([\d.]+)(%?)\D+([\d.]+)(%?)\D*?(([\d.]+)(%?)|$)/i,
        hsla: /^hsla?\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D*?(([\d.]+)(%?)|$)/i,
        hsva: /^hsva?\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D*?(([\d.]+)(%?)|$)/i,
        hexa: /^#?(([\da-f]{3,4})|([\da-f]{6})|([\da-f]{8}))$/i,
    };
    for (const [colorType, regex] of Object.entries(validColorValueRegex)) {
        const match = regex.exec(str);
        if (!match) {
            continue;
        }
        // Try to convert
        switch (colorType) {
            case 'rgba': {
                const numarizedResult = numarize(match);
                let r = numarizedResult[1];
                let g = numarizedResult[3];
                let b = numarizedResult[5];
                let a = numarizedResult[8];
                r = match[2] === '%' ? (r / 100) * 255 : r;
                g = match[4] === '%' ? (g / 100) * 255 : g;
                b = match[6] === '%' ? (b / 100) * 255 : b;
                a = match[9] === '%' ? a / 100 : a;
                if (r > 255 || g > 255 || b > 255 || a < 0 || a > 1) {
                    break;
                }
                return { values: [...rgbToHsv(r, g, b), a], a, colorType };
            }
            case 'hexa': {
                let [, hex] = match;
                if (hex.length === 4 || hex.length === 3) {
                    hex = hex
                        .split('')
                        .map((v) => v + v)
                        .join('');
                }
                const raw = hex.slice(0, 6);
                let a = hex.slice(6);
                // Convert 0 - 255 to 0 - 1 for opacity
                a = a ? Number.parseInt(a, 16) / 255 : undefined;
                return { values: [...hexToHsv(raw), a], a, colorType };
            }
            case 'hsla': {
                const numarizedResult = numarize(match);
                const h = numarizedResult[1];
                const s = numarizedResult[2];
                const l = numarizedResult[3];
                let a = numarizedResult[5];
                a = match[6] === '%' ? a / 100 : a;
                if (h > 360 || s > 100 || l > 100 || a < 0 || a > 1) {
                    break;
                }
                return { values: [...hslToHsv(h, s, l), a], a, colorType };
            }
            case 'hsva': {
                const numarizedResult = numarize(match);
                const h = numarizedResult[1];
                const s = numarizedResult[2];
                const v = numarizedResult[3];
                let a = numarizedResult[5];
                a = match[6] === '%' ? a / 100 : a;
                if (h > 360 || s > 100 || v > 100 || a < 0 || a > 1) {
                    break;
                }
                return { values: [h, s, v, a], a, colorType };
            }
        }
    }
    return { values: null, colorType: null };
}
/* eslint-enable complexity */

const marketColorPickerCss = "/*!@:host*/.sc-market-color-picker-h{display:flex;flex-direction:column;gap:var(--color-picker-vertical-spacing)}";
var MarketColorPickerStyle0 = marketColorPickerCss;

class MarketColorPicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketColorPickerValueChange = createEvent(this, "marketColorPickerValueChange", 7);
        this.value = undefined;
        this.inputValue = undefined;
    }
    /**
     * Listener for gradient value change. This only fires when the gradient is dragged manually, which currently will only pass a hex value.
     * Since it's a hex value, we know the value will be formatted for inputs.
     * @param event
     */
    gradientValueChange(event) {
        const { detail } = event;
        const { defaultPrevented } = this.marketColorPickerValueChange.emit({
            value: detail.value,
            prevValue: this.value,
        });
        if (!defaultPrevented) {
            this.value = detail.value;
            this.inputValue = detail.value;
            if (this.swatchList) {
                this.swatchList.value = this.value;
            }
            if (this.colorInput) {
                this.colorInput.value = this.inputValue;
            }
        }
    }
    swatchValueChange(event) {
        const { detail } = event;
        const { defaultPrevented } = this.marketColorPickerValueChange.emit({
            value: detail.value,
            prevValue: this.value,
        });
        if (!defaultPrevented) {
            this.inputValue = this.formatInputValue(detail.value);
            this.value = detail.value;
            if (this.gradientPicker) {
                this.gradientPicker.value = this.value;
            }
            if (this.colorInput) {
                this.colorInput.value = this.inputValue;
            }
        }
    }
    inputValueChange(event) {
        const { detail } = event;
        const { defaultPrevented } = this.marketColorPickerValueChange.emit({
            value: detail.value,
            prevValue: this.value,
        });
        if (!defaultPrevented) {
            this.value = detail.value;
            if (this.gradientPicker) {
                this.gradientPicker.value = this.value;
            }
            if (this.swatchList) {
                this.swatchList.value = this.value;
            }
        }
    }
    /**
     * Helper function taking a color string and converting it to Hex if it's in rgba format.
     * @param colorString
     * @returns { string } Hex color string
     */
    formatInputValue(colorString) {
        const parsedValue = parseToHSVA(colorString);
        // If it is a valid color format, convert to hex
        if (parsedValue.colorType && parsedValue.colorType !== 'hexa') {
            return `#${hsvToHex(parsedValue.values[0], parsedValue.values[1], parsedValue.values[2]).join('')}`;
        }
        return colorString;
    }
    setSubcomponentValues() {
        this.gradientPicker = this.el.querySelector(getNamespacedTagFor('market-color-picker-gradient'));
        this.swatchList = this.el.querySelector(getNamespacedTagFor('market-color-swatch-list'));
        this.colorInput = this.el.querySelector(getNamespacedTagFor('market-color-picker-input'));
        if (this.gradientPicker) {
            this.gradientPicker.value = this.value;
        }
        if (this.swatchList) {
            this.swatchList.value = this.value;
        }
        if (this.colorInput) {
            this.colorInput.value = this.inputValue;
        }
    }
    handleSlotChange() {
        this.setSubcomponentValues();
    }
    componentWillLoad() {
        this.inputValue = this.formatInputValue(this.value);
    }
    componentDidLoad() {
        this.setSubcomponentValues();
    }
    render() {
        return (hAsync(Host, { key: '928249a34e21a700eb7d1ddfe495f395a68c647c', class: "market-color-picker" }, hAsync("slot", { key: '0624906ac6684321a6a74638299afd90d44fc12c', onSlotchange: () => this.handleSlotChange() })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketColorPickerStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-color-picker",
        "$members$": {
            "value": [1537],
            "inputValue": [32]
        },
        "$listeners$": [[0, "marketColorPickerGradientValueChange", "gradientValueChange"], [0, "marketColorSwatchListValueChange", "swatchValueChange"], [0, "marketColorPickerInputValueChange", "inputValueChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"]]
    }; }
}

/**
 * Check if the event is a TouchEvent
 * @param {TMouseOrTouchEvent} event
 */
function isTouchEvent(event) {
    return Boolean(event === null || event === void 0 ? void 0 : event.changedTouches);
}
// gets coords depending on touch vs mouse event
function getCoordsFromEvent(e) {
    const x = isTouchEvent(e) ? e.changedTouches[0].clientX : e.clientX;
    const y = isTouchEvent(e) ? e.changedTouches[0].clientY : e.clientY;
    return { x, y };
}

const marketColorPickerGradientCss = "/*!@:host*/.sc-market-color-picker-gradient-h{--primary-gradient-height:var(--color-picker-adjustments-hue-min-height);--gradient-border-radius:var(--color-picker-adjustments-hue-radius);--gradient-margin:var(--color-picker-vertical-spacing);--secondary-gradient-height:calc(var(--color-picker-adjustments-saturation-brightness-min-height) * 1px);--gradient-pointer-width:12px;--gradient-pointer-height:12px;--gradient-pointer-border:2px white solid;--gradient-pointer-border-radius:50%;display:block}/*!@.primary-gradient*/.primary-gradient.sc-market-color-picker-gradient{position:relative;width:100%;height:var(--primary-gradient-height);border-radius:var(--gradient-border-radius);background:linear-gradient(\n      to right,\n      hsl(0deg 100% 50%),\n      hsl(60deg 100% 50%),\n      hsl(120deg 100% 50%),\n      hsl(180deg 100% 50%),\n      hsl(240deg 100% 50%),\n      hsl(300deg 100% 50%),\n      hsl(0deg 100% 50%)\n    )}/*!@.secondary-gradient*/.secondary-gradient.sc-market-color-picker-gradient{position:relative;width:100%;height:var(--secondary-gradient-height);margin-top:var(--gradient-margin);border-radius:var(--gradient-border-radius)}/*!@.pointer*/.pointer.sc-market-color-picker-gradient{position:absolute;z-index:2;width:var(--gradient-pointer-width);height:var(--gradient-pointer-height);border:var(--gradient-pointer-border);border-radius:var(--gradient-pointer-border-radius);box-shadow:var(--elevation-20-shadow)}/*!@#primary-pointer*/#primary-pointer.sc-market-color-picker-gradient{top:calc(50% - 8px)}";
var MarketColorPickerGradientStyle0 = marketColorPickerGradientCss;

const RESIZE_DEBOUNCE_DURATION$3 = 16; // 60fps
/**
 * String values for pointer ids.
 */
const PRIMARY_ID = 'primary-pointer';
const SECONDARY_ID = 'secondary-pointer';
/**
 * Default constants as percentages. Looks different at different viewport sizes, so no obvious coordinates available.
 */
const PRIMARY_COORDINATES = [50, 50];
const SECONDARY_COORDINATES = [95, 10];
class MarketColorPickerGradient {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketColorPickerGradientValueChange = createEvent(this, "marketColorPickerGradientValueChange", 7);
        /**
         * Secondary pointer location. Used to determine secondary pointer color when secondary gradient changes.
         */
        this.secondaryPointerCoordinates = SECONDARY_COORDINATES;
        /**
         * Drag and drop logic for pointers.
         */
        this.boundOnDragMove = this.onDragMove.bind(this);
        this.boundOnDragEnd = this.onDragEnd.bind(this);
        this.throttledUpdatePointerOnDrag = throttle(this.updatePointerOnDrag.bind(this), RESIZE_DEBOUNCE_DURATION$3);
        this.value = undefined;
    }
    onDragStart(e, pointer) {
        e.preventDefault();
        e.stopPropagation();
        // only start drag on touch events or left mouse clicks
        if (!isTouchEvent(e) && e.button !== 0)
            return;
        const coords = getCoordsFromEvent(e);
        this.updatePointerOnDrag(coords.x, coords.y, pointer);
        this.draggablePointer = pointer;
        document.addEventListener('mousemove', this.boundOnDragMove);
        document.addEventListener('mouseup', this.boundOnDragEnd);
        // don't use passive touch event listeners so we can call preventDefault()
        document.addEventListener('touchmove', this.boundOnDragMove, { passive: false });
        document.addEventListener('touchend', this.boundOnDragEnd, { passive: false });
    }
    onDragMove(e) {
        e.preventDefault();
        const coords = getCoordsFromEvent(e);
        this.throttledUpdatePointerOnDrag(coords.x, coords.y, this.draggablePointer);
    }
    onDragEnd(e) {
        e.preventDefault();
        this.draggablePointer = null;
        document.removeEventListener('mousemove', this.boundOnDragMove);
        document.removeEventListener('mouseup', this.boundOnDragEnd);
        document.removeEventListener('touchmove', this.boundOnDragMove);
        document.removeEventListener('touchend', this.boundOnDragEnd);
    }
    /**
     * Drag logic function to determine coordinates as a percentage.
     * @param posX
     * @param posY
     * @param pointer
     */
    updatePointerOnDrag(posX, posY, pointer) {
        const elem = pointer.parentElement;
        if (!elem) {
            return;
        }
        const rect = elem.getBoundingClientRect();
        const elemOffsetX = rect.left;
        const elemOffsetY = rect.top;
        const maxWidth = rect.width;
        const maxHeight = rect.height;
        // Set x and y as percentages of the gradient
        let updatedX = (posX - elemOffsetX) / maxWidth;
        let updatedY = (posY - elemOffsetY) / maxHeight;
        // Ensure pointer does not leave gradient bounds
        updatedX = Math.max(Math.min(updatedX, 1), 0);
        updatedY = Math.max(Math.min(updatedY, 1), 0);
        // utilize the %'s given for S & V (H decided by primary gradient)
        // S = x increasing
        // V = y decreasing
        // H = color (0-360) by %
        this.setPointerCoordinates({
            pointer,
            x: updatedX * 100,
            y: updatedY * 100,
        });
    }
    /**
     * Function handling updating pointer location based on provided coordinates.
     * The x and y values are percentages, from 0-100.
     * It then also updates the colors of the pointers.
     * @param {HTMLElement} options.pointer
     * @param {number} options.x
     * @param {number} options.y
     * @param {boolean} options.emitEvent
     * @param {string} options.colorType
     */
    setPointerCoordinates(options) {
        const { pointer, x, y = 50, emitEvent = true, colorType = '' } = options;
        const pointerOffset = pointer.offsetWidth / 2;
        pointer.style.left = `calc(${x}% - ${pointerOffset}px)`;
        // Updates the selected color of the targeted gradient
        if (pointer.id === PRIMARY_ID) {
            this.setPrimaryGradientColor(x / 100, emitEvent);
        }
        else if (pointer.id === SECONDARY_ID) {
            // only update this on secondary gradient
            pointer.style.top = `calc(${y}% - ${pointerOffset}px)`;
            this.setSecondaryGradientColor(x / 100, y / 100, emitEvent, colorType);
        }
    }
    /**
     * Sets primary pointer color.
     * Secondary gradient is updated to reflect new primary color.
     * @param x
     * @param emitEvent
     */
    setPrimaryGradientColor(x, emitEvent = true) {
        this.primaryHue = x * 360;
        this.primaryPointer.style.background = `hsl(${this.primaryHue}, 100%, 50%)`;
        this.updateSecondaryGradient(emitEvent);
    }
    /**
     * Sets secondary pointer color. If rgba is used, show that, otherwise default to hex values.
     * The value emitted from the gradient here, if emitEvent is true.
     * @param x
     * @param y
     * @param emitEvent
     * @param colorType
     */
    setSecondaryGradientColor(x, y, emitEvent = true, colorType = '') {
        const saturation = x * 100;
        const value = 100 - y * 100;
        let colorValue;
        let colorString;
        if (colorType === 'rgba') {
            colorValue = hsvToRgb(this.primaryHue, saturation, value);
            colorString = `rgb(${colorValue[0]}, ${colorValue[1]}, ${colorValue[2]})`;
        }
        else {
            // Defaults to hex value shown
            colorValue = hsvToHex(this.primaryHue, saturation, value);
            colorString = `#${colorValue.join('')}`;
        }
        this.secondaryPointer.style.background = colorString;
        this.secondaryPointerCoordinates = [x, y];
        if (emitEvent) {
            this.marketColorPickerGradientValueChange.emit({ value: colorString });
        }
    }
    /**
     * Updates the secondary gradient picker background, then updates secondary pointer.
     * @param emitEvent
     */
    updateSecondaryGradient(emitEvent = true) {
        const gradient = this.el.shadowRoot.querySelector('.secondary-gradient');
        gradient.style.background = `
      linear-gradient(to top, rgb(0, 0, 0), transparent),
      linear-gradient(to left, hsl(${this.primaryHue}, 100%, 50%), rgb(255, 255, 255))
    `;
        this.setSecondaryGradientColor(...this.secondaryPointerCoordinates, emitEvent);
    }
    /**
     * This value watcher attempts to convert the value into a valid color and updates the gradient pickers.
     * It returns a boolean based on whether this succeeded or not.
     * @returns boolean
     */
    updateGradientsByValue() {
        // Determine if color formatted as: hex, rgb, hsl
        // Convert it to hsv and update position based on hsv
        // Attempt to convert value
        const convertedColor = parseToHSVA(this.value);
        // If it converts successfully, values will exist. We also need the pointers to be initialized for this to work.
        if (convertedColor.values && this.primaryPointer && this.secondaryPointer) {
            const h = convertedColor.values[0];
            const s = convertedColor.values[1];
            const v = convertedColor.values[2];
            // Deconstruct to HSV values. h = primary, s = secondary x, v = secondary y (decreasing)
            const primaryX = (100 * h) / 360;
            const secondaryX = s;
            const secondaryY = 100 - v;
            const primaryOptions = {
                pointer: this.primaryPointer,
                x: primaryX,
                emitEvent: false,
            };
            const secondaryOptions = {
                pointer: this.secondaryPointer,
                x: secondaryX,
                y: secondaryY,
                colorType: convertedColor.colorType,
                emitEvent: false,
            };
            this.setPointerCoordinates(primaryOptions);
            this.setPointerCoordinates(secondaryOptions);
            return true;
        }
        return false;
    }
    /**
     * Sets necessary values for pointers to work if no valid value has been preset on load
     */
    setInitialPointers() {
        const pointers = [this.primaryPointer, this.secondaryPointer];
        const pointerCoordinates = [PRIMARY_COORDINATES, SECONDARY_COORDINATES];
        pointers.forEach((pointer, i) => {
            const pointerOptions = {
                pointer,
                x: pointerCoordinates[i][0],
                y: pointerCoordinates[i][1],
                emitEvent: false,
            };
            this.setPointerCoordinates(pointerOptions);
        });
    }
    componentDidLoad() {
        this.primaryPointer = this.el.shadowRoot.querySelector(`#${PRIMARY_ID}`);
        this.secondaryPointer = this.el.shadowRoot.querySelector(`#${SECONDARY_ID}`);
        const success = this.updateGradientsByValue();
        if (!success) {
            this.setInitialPointers();
        }
    }
    /* eslint-disable jsx-a11y/aria-role */
    render() {
        return (hAsync(Host, { key: '27b14b18a7e6c1035e8c062f8125918f7cc4a2c2', class: "market-color-picker-gradient" }, hAsync("slot", { key: '5abf8dc220282ff102cd8b5011849a35e79a4596' }), hAsync("div", { key: '036d0b665d8f536d8e89e9e44a11c0a323ebe648', class: "primary-gradient", role: "input", onMouseDown: (e) => this.onDragStart(e, this.primaryPointer), onTouchStart: (e) => this.onDragStart(e, this.primaryPointer) }, hAsync("div", { key: '96d5a6573888eb84d0c8833f493a4feb2869466c', id: PRIMARY_ID, class: "pointer" })), hAsync("div", { key: '825d8adfc5eb558d5114d540b9d054b8085967a5', class: "secondary-gradient", role: "input", onMouseDown: (e) => this.onDragStart(e, this.secondaryPointer), onTouchStart: (e) => this.onDragStart(e, this.secondaryPointer) }, hAsync("div", { key: '3b8b8955b967f45d3bac7b57b5904c52d71f1d34', id: SECONDARY_ID, class: "pointer" }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["updateGradientsByValue"]
    }; }
    static get style() { return MarketColorPickerGradientStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-color-picker-gradient",
        "$members$": {
            "value": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const pencilWritingIcon = () => (hAsync("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M17 4.17004C17.72 4.17004 18.45 4.45004 19 5.00004C20.1 6.10004 20.1 7.90004 19 9.00004L17 11L8 20H4V16L13 7.00004L15 5.00004C15.55 4.45004 16.28 4.17004 17 4.17004ZM17.01 6.17004C16.88 6.17004 16.63 6.20004 16.42 6.41004L15.84 7.01004L17.01 8.18004L17.6 7.59004C17.81 7.37004 17.84 7.13004 17.84 7.00004C17.84 6.87004 17.82 6.62004 17.6 6.41004C17.38 6.20004 17.14 6.17004 17.01 6.17004ZM6 18H7.17L15.58 9.59004L14.41 8.42004L6 16.83V18ZM12 18.0001H20V20.0001H12V18.0001Z" })));

const marketColorPickerInputCss = "/*!@:host*/.sc-market-color-picker-input-h{display:block}/*!@.market-color-swatch*/.market-color-swatch.sc-market-color-picker-input{vertical-align:middle;margin:var(--color-picker-input-icon-vertical-spacing, 12px) 0}/*!@.color-picker-input-icon*/.color-picker-input-icon.sc-market-color-picker-input{display:flex;justify-content:center;align-items:center;width:var(--color-picker-input-width, 40px);height:var(--color-picker-input-height, 40px);margin:12px 0;border-radius:var(--color-picker-icon-border-radius, calc(var(--core-radius-10) * 1px));background-color:var(--color-picker-icon-background-color, var(--core-fill-40-color))}/*!@.color-picker-input-icon svg path*/.color-picker-input-icon.sc-market-color-picker-input svg.sc-market-color-picker-input path.sc-market-color-picker-input{fill:var(--core-fill-10-color)}";
var MarketColorPickerInputStyle0 = marketColorPickerInputCss;

class MarketColorPickerInput {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketColorPickerInputValueChange = createEvent(this, "marketColorPickerInputValueChange", 7);
        this.value = undefined;
    }
    displayLeadingAccessory() {
        const MarketColorSwatchTagName = getNamespacedTagFor('market-color-swatch');
        const parsedValue = parseToHSVA(this.value);
        // If invalid, this will be null
        if (parsedValue.values) {
            return hAsync(MarketColorSwatchTagName, { value: this.value, disabled: true });
        }
        // otherwise return default icon
        return hAsync("div", { class: "color-picker-input-icon" }, pencilWritingIcon());
    }
    inputValueChange(event) {
        const { detail } = event;
        const prevValue = this.value;
        // Format for hexadecimal if required
        this.formatAndUpdateValue(detail.value);
        const { defaultPrevented } = this.marketColorPickerInputValueChange.emit({ prevValue, value: this.value });
        if (defaultPrevented) {
            this.value = prevValue;
        }
    }
    formatAndUpdateValue(value = this.value) {
        if (!value)
            return;
        let updatedValue = value;
        if (updatedValue[0] !== '#') {
            updatedValue = `#${updatedValue}`;
        }
        this.value = updatedValue;
    }
    componentWillLoad() {
        this.formatAndUpdateValue();
    }
    render() {
        const MarketInputTextTagName = getNamespacedTagFor('market-input-text');
        return (hAsync(Host, { key: '065ff7a8b9ec8a397dd945737ab77d7c465b996f', class: "market-color-picker-input" }, hAsync(MarketInputTextTagName, { key: '06608611fe126161506d8145d7a09de10b2dd02e', value: this.value, id: 'color-picker-input-text', maxlength: 7 }, hAsync("div", { key: '442ad70d982f86c5869004670b47132b670666a4', slot: "leading-accessory" }, this.displayLeadingAccessory()), hAsync("label", { key: '6e69242ce7ad59e3d099492a0898aa919dac643c', htmlFor: "color-picker-input-text" }, hAsync("slot", { key: '3fe01f07c3f4fadf32d5aef7809d46919a1f4b72', name: "label" }, "Hex")), hAsync("slot", { key: 'ebc1477530d21b20038b69557d5aabd9343d8d9f' }))));
    }
    static get style() { return MarketColorPickerInputStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-color-picker-input",
        "$members$": {
            "value": [1537]
        },
        "$listeners$": [[0, "marketInputValueChange", "inputValueChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"]]
    }; }
}

const marketColorSwatchCss = "/*!@:host*/.sc-market-color-swatch-h{position:relative;display:inline-block;width:40px;height:40px;border-radius:50%;background-color:var(--swatch-color);box-shadow:inset 0 0 0 1px rgb(0 0 0 / 15%);transition:box-shadow\n    var(--core-animation-enter-transition-moderate-speed-duration)\n    var(--core-animation-enter-transition-easing)}/*!@:host .inner-circle*/.sc-market-color-swatch-h .inner-circle.sc-market-color-swatch{position:absolute;top:50%;left:50%;width:0;height:0;border:0;border-radius:50%;background-color:white;box-shadow:0 0 0 0 rgb(0 0 0 / 15%);transition:width\n      var(--core-animation-enter-transition-moderate-speed-duration)\n      var(--core-animation-enter-transition-easing),\n      height\n      var(--core-animation-enter-transition-moderate-speed-duration)\n      var(--core-animation-enter-transition-easing),\n      box-shadow\n      var(--core-animation-enter-transition-moderate-speed-duration)\n      var(--core-animation-enter-transition-easing),\n      border\n      var(--core-animation-enter-transition-fast-speed-duration)\n      var(--core-animation-enter-transition-easing);transform:translate(-50%, -50%)}/*!@:host(:hover:not([disabled])) .inner-circle*/.sc-market-color-swatch-h:hover:not([disabled]) .inner-circle.sc-market-color-swatch{width:8px;height:8px;box-shadow:0 0 0 1px rgb(0 0 0 / 15%)}/*!@:host([selected])*/[selected].sc-market-color-swatch-h{box-shadow:inset 0 0 0 2px #006aff}/*!@:host([selected]) .inner-circle, :host([selected]:hover) .inner-circle*/[selected].sc-market-color-swatch-h .inner-circle.sc-market-color-swatch,[selected].sc-market-color-swatch-h:hover .inner-circle.sc-market-color-swatch{width:32px;height:32px;border:2px solid white;background-color:transparent;box-shadow:inset 0 0 0 1px rgb(0 0 0 / 15%)}/*!@:host(:active:not([disabled])) .inner-circle, :host([selected]:active) .inner-circle*/.sc-market-color-swatch-h:active:not([disabled]) .inner-circle.sc-market-color-swatch,[selected].sc-market-color-swatch-h:active .inner-circle.sc-market-color-swatch{width:16px;height:16px;border:0;background-color:white;box-shadow:0 0 0 1px rgb(0 0 0 / 15%)}/*!@:host(:hover:not([disabled])) .inner-circle, :host(:active:not([disabled])) .inner-circle*/.sc-market-color-swatch-h:hover:not([disabled]) .inner-circle.sc-market-color-swatch,.sc-market-color-swatch-h:active:not([disabled]) .inner-circle.sc-market-color-swatch{transition:width var(--core-animation-exit-transition-moderate-speed-duration),\n    height var(--core-animation-exit-transition-moderate-speed-duration),\n    box-shadow var(--core-animation-exit-transition-moderate-speed-duration),\n    border var(--core-animation-exit-transition-fast-speed-duration)}";
var MarketColorSwatchStyle0 = marketColorSwatchCss;

class MarketColorSwatch {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketColorSwatchSelectedChange = createEvent(this, "marketColorSwatchSelectedChange", 7);
        this.value = cjs.CORE_BLUE_FILL_COLOR;
        this.name = undefined;
        this.disabled = undefined;
        this.selected = false;
    }
    toggleSelection() {
        if (this.disabled) {
            return;
        }
        const newSelection = !this.selected;
        const swatchValue = { value: this.value, selected: newSelection };
        const { defaultPrevented } = this.marketColorSwatchSelectedChange.emit(swatchValue);
        if (!defaultPrevented) {
            this.selected = newSelection;
        }
    }
    render() {
        return (hAsync(Host, { key: 'cdffd64fba69827a9ddd35e01e9c01f1f05f130a', class: "market-color-swatch", role: "listitem", onClick: () => this.toggleSelection(), style: { '--swatch-color': this.value } }, hAsync("div", { key: 'e119468a948e2c977c84d3ade7040d6864e1f7ba', class: "inner-circle" })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketColorSwatchStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-color-swatch",
        "$members$": {
            "value": [513],
            "name": [513],
            "disabled": [516],
            "selected": [1540]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["name", "name"], ["disabled", "disabled"], ["selected", "selected"]]
    }; }
}

/**
 * Helper function to grab default Market color swatches formatted for market-color-picker
 * @returns { string } colorString
 */
function getDefaultMarketColorSwatches() {
    return [
        cjs.CORE_BURGUNDY_FILL_COLOR,
        cjs.CORE_RED_FILL_COLOR,
        cjs.CORE_ORANGE_FILL_COLOR,
        cjs.CORE_GOLD_FILL_COLOR,
        cjs.CORE_YELLOW_FILL_COLOR,
        cjs.CORE_TAUPE_FILL_COLOR,
        cjs.CORE_BROWN_FILL_COLOR,
        cjs.CORE_FOREST_FILL_COLOR,
        cjs.CORE_GREEN_FILL_COLOR,
        cjs.CORE_TEAL_FILL_COLOR,
        cjs.CORE_BLUE_FILL_COLOR,
        cjs.CORE_SKY_FILL_COLOR,
        cjs.CORE_PURPLE_FILL_COLOR,
        cjs.CORE_PINK_FILL_COLOR,
    ];
}

const marketColorSwatchListCss = "/*!@:host*/.sc-market-color-swatch-list-h{display:grid;grid-template-columns:repeat(auto-fill, var(--color-swatch-width, 40px));grid-gap:var(--color-swatch-list-spacing, 16px)}";
var MarketColorSwatchListStyle0 = marketColorSwatchListCss;

class MarketColorSwatchList {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketColorSwatchListValueChange = createEvent(this, "marketColorSwatchListValueChange", 7);
        this.value = undefined;
    }
    valueWatcher() {
        this.setSelectionFromValue();
    }
    /* Listen for the marketColorSwatchSelectedChange event which is emitted by slotted market-color-swatch elements
    when they are clicked */
    colorSwatchSelectedEventHandler(e) {
        this.handleItemSelectedEvent(e.detail);
    }
    handleItemSelectedEvent(eventInfo) {
        const selectedValue = eventInfo.selected ? eventInfo.value : '';
        if (this.value === selectedValue) {
            return;
        }
        const { defaultPrevented } = this.marketColorSwatchListValueChange.emit({
            value: selectedValue,
            prevValue: this.value,
        });
        if (!defaultPrevented) {
            this.value = selectedValue;
        }
    }
    // After selection, the swatches in the list update their selected state
    setSelectionFromValue() {
        // First check for slotted swatches, otherwise use default in shadow dom
        let items = [
            ...this.el.querySelectorAll(getNamespacedTagFor('market-color-swatch')),
        ];
        if (items.length === 0) {
            items = [
                ...this.el.shadowRoot.querySelectorAll(getNamespacedTagFor('market-color-swatch')),
            ];
        }
        items.forEach((item) => (item.selected = this.value === item.value));
    }
    handleSlotChange() {
        this.setSelectionFromValue();
    }
    render() {
        return (hAsync(Host, { key: 'ab0de23d5b4ba4357aafd8538968032feef9bb62', class: "market-color-swatch-list", role: "list" }, hAsync("slot", { key: 'e2e2430fcfa4b89fae3928cac368351c25d1fe61', onSlotchange: () => this.handleSlotChange() }, getDefaultMarketColorSwatches().map((swatchValue) => {
            return hAsync("market-color-swatch", { value: swatchValue });
        }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueWatcher"]
    }; }
    static get style() { return MarketColorSwatchListStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-color-swatch-list",
        "$members$": {
            "value": [1537]
        },
        "$listeners$": [[0, "marketColorSwatchSelectedChange", "colorSwatchSelectedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"]]
    }; }
}

const marketContentCardCss = "/*!@:host, ::slotted(*), **/.sc-market-content-card-h,.sc-market-content-card-s>*,*.sc-market-content-card{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-content-card-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-content-card-h *.sc-market-content-card,.sc-market-content-card-h[disabled].sc-market-content-card-s>*,.sc-market-content-card-h[disabled] .sc-market-content-card-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-content-card-h{display:block;padding:var(--content-card-padding-vertical-size) var(--content-card-padding-horizontal-size);border:var(--content-card-border-width) solid var(--content-card-border-color);border-radius:var(--content-card-border-radius);background-color:var(--content-card-background-color)}";
var MarketContentCardStyle0 = marketContentCardCss;

class MarketContentCard {
    constructor(hostRef) {
        registerInstance(this, hostRef);
    }
    render() {
        return (hAsync(Host, { key: 'd91376ddaea2a2b65b118b79866b90ffa2939abb', class: "market-content-card" }, hAsync("slot", { key: 'e16f374413a2b1088cefb99bb2611fad77383b1b' })));
    }
    static get style() { return MarketContentCardStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-content-card",
        "$members$": undefined,
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const marketContextCss = "/*!@:host, ::slotted(*), **/.sc-market-context-h,.sc-market-context-s>*,*.sc-market-context{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-context-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-context-h *.sc-market-context,.sc-market-context-h[disabled].sc-market-context-s>*,.sc-market-context-h[disabled] .sc-market-context-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-context-h{position:absolute;display:grid;justify-items:center;width:100vw;height:100%;animation:var(--core-animation-enter-transition-moderate-speed-duration)\n    market-fade-in\n    forwards\n    var(--core-animation-enter-transition-easing)}/*!@:host([hidden])*/[hidden].sc-market-context-h{opacity:0%;animation-name:market-fade-out;animation-duration:var(--core-animation-exit-transition-moderate-speed-duration);animation-timing-function:var(--core-animation-exit-transition-easing)}/*!@:host > **/.sc-market-context-h>*.sc-market-context{pointer-events:auto}/*!@:host(:not(.no-veil))*/.sc-market-context-h:not(.no-veil){background-color:var(--core-surface-overlay-color);opacity:100%;pointer-events:auto}/*!@:host(.no-veil)*/.no-veil.sc-market-context-h{pointer-events:none}@media screen and (min-width: 800px){/*!@::slotted(.market-modal-partial)*/.sc-market-context-s>.market-modal-partial{align-self:center;margin:var(--modal-partial-vertical-screen-buffer-size) var(--modal-partial-horizontal-screen-buffer-size)}}/*!@::slotted(.market-dialog)*/.sc-market-context-s>.market-dialog{align-self:center;width:calc(100% - (2 * var(--modal-dialog-horizontal-screen-buffer-size, 16px)))}";
var MarketContextStyle0 = marketContextCss;

class MarketContext {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketContextContentsChanged = createEvent(this, "marketContextContentsChanged", 7);
        this.marketContextEmptied = createEvent(this, "marketContextEmptied", 7);
        this.currentDialog = undefined;
        this.noVeil = false;
        this.hidden = false;
        this.animationEnterDuration = cjs.CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION;
        this.animationExitDuration = cjs.CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION;
        this.stack = [];
        this.totalCount = 0;
        this.dialogMeta = {};
    }
    currentDialogWatcher(newDialog) {
        this.stack.push(newDialog);
        this.stack = [...this.stack]; // Spread syntax ensures triggering the watcher
    }
    stackWatcher(newValue) {
        newValue.forEach((dialog) => {
            // increase the count of the type of dialog in the meta
            this.dialogMeta[dialog.type].count += 1;
            // Increase the total count of dialogs
            this.totalCount += 1;
        });
        // If there are no more dialogs opened, then emit an event indicating so
        if (newValue.length === 0) {
            this.hidden = true;
            setTimeout(() => {
                this.marketContextEmptied.emit();
            }, this.animationExitDuration);
        }
        this.setContextVeil();
    }
    doesStackContainDialogThatRequiresVeil(dialog) {
        const veiledDialogTagnames = Object.entries(DIALOGS_META)
            .filter(([, config]) => config.veil)
            .map(([type]) => getNamespacedTagFor(`market-${type}`));
        return veiledDialogTagnames.includes(dialog.tagName.toLowerCase());
    }
    setContextVeil() {
        // consumer use of noVeil prop overrides default behavior
        // veil shouldn't reset when stack is emptied
        if (this.el.hasAttribute('no-veil') || this.stack.length === 0) {
            return;
        }
        // context will turn off veil if no context in its stack requires one
        this.noVeil = !this.stack.some((dialog) => this.doesStackContainDialogThatRequiresVeil(dialog.el));
    }
    stackHasDialog(dialogEl) {
        return this.stack.some((dialog) => dialog.el === dialogEl);
    }
    modalLoadedEventHandler(e) {
        const dialog = e.detail.dialog;
        const type = e.detail.type;
        if (dialog.parentElement !== this.el) {
            // Ignore marketDialogLoaded events from dialogs which are not children of this
            // context.
            return;
        }
        else if (this.stackHasDialog(dialog)) {
            // Ignore marketDialogLoaded events from dialogs already contained in this
            // context's stack.
            return;
        }
        // Generate a new dialogID (ex. "modal-partial-2")
        const generatedDialogID = this.generateDialogID(type);
        // Set the dialogID for the dialog element (note: this maps to data-dialog-id
        // and not the native id attribute)
        dialog.dialogID = generatedDialogID;
        // Set the id prop if one does not exist
        // (we don't use this prop anymore, but since we were setting it to
        // generatedDialogID before, removing it would be a breaking change)
        dialog.id = dialog.id || generatedDialogID;
        // Build a new Dialog object and set the currentDialog
        this.currentDialog = {
            el: dialog,
            type,
            dialogID: dialog.dialogID,
            id: dialog.id,
            index: this.stack.length,
            indexOfType: this.dialogMeta[type].count + 1,
        };
        // Emit a nice marketContextContentsChanged event
        this.marketContextContentsChanged.emit({
            action: 'marketNewDialogOpened',
            currentDialog: this.currentDialog,
            stack: this.stack,
        });
    }
    // This event is emitted from market dialog components (Modal, Sheet, Blade, etc.)
    dialogDismissedEventHandler(event) {
        if (event.defaultPrevented) {
            return;
        }
        // only close direct children of this context
        if (event.target.parentElement === this.el) {
            this.close(event.detail.dialog.dialogID);
        }
    }
    generateDialogID(type) {
        // ex. "sheet-2"
        return `${type}-${this.dialogMeta[type].count + 1}`;
    }
    getDialogByID(dialogID) {
        return this.stack.find((dialog) => dialog.dialogID === dialogID);
    }
    /**
     * Adds the passed dialogTemplate to the stack and inserts it into the DOM
     */
    open(dialogTemplate) {
        if (this.stack.length === 0) {
            this.noVeil = !this.doesStackContainDialogThatRequiresVeil(dialogTemplate);
        }
        this.el.appendChild(dialogTemplate);
        return Promise.resolve();
    }
    /**
     * **Recommended for internal use only**
     * Removes the topmost dialog from the stack or the dialog matching the passed `dialogID`
     * Note that using this will not trigger the dialog to emit a marketDialogDismissed event.
     *
     * The recommended path for closing a dialog is to call its dismiss() method.
     */
    // TODO (breaking): consider renaming this method to `removeDialogElement`
    close(dialogID) {
        let dialog;
        const d = this.stack.indexOf(dialog);
        // If we want to close a specific dialog, then find that dialog in the stack
        if (dialogID) {
            dialog = this.stack.find((dialog) => dialog.dialogID === dialogID);
            // If there is no dialog with the passed id, log a helpful warning
            /* eslint-disable-next-line no-console */
            !dialog && console.warn(`Tried to close dialog with data-dialog-id "${dialogID}" but none were found`);
            // Otherwise we will close the current/most recently opened dialog
        }
        else {
            dialog = this.currentDialog;
        }
        if (dialog) {
            // currently, "persistent" is only implemented for market-dialog, bc it's
            // the only dialog type that doesn't programmatically insert a close button
            // when used w/ market-header
            if (dialog.type === 'dialog' && dialog.el.persistent) {
                return Promise.resolve();
            }
            // Remove the dialog node from the DOM
            setTimeout(() => {
                dialog.el.remove();
                // Remove the dialog from the stack. Reassign to trigger the watcher
                this.stack.splice(d, 1);
                this.stack = [...this.stack];
                // Emit a nice event
                this.marketContextContentsChanged.emit({
                    action: 'marketDialogClosed',
                    currentDialog: dialog,
                    stack: this.stack,
                });
            }, dialog.el.animationExitDuration);
        }
        return Promise.resolve();
    }
    /**
     * **Recommended for internal use only**
     * Removes the topmost dialog from the stack (just an alias for default .close() behavior)
     * Note that using this will not trigger the dialog to emit a marketDialogDismissed event.
     *
     * The recommended path for closing a dialog is to call its dismiss() method.
     */
    // TODO (breaking): consider removing this method in favor of encouraging consumers to close dialogs via dialog.dismiss();
    closeCurrent() {
        this.close();
        return Promise.resolve();
    }
    connectedCallback() {
        ALL_DIALOG_TYPES.forEach((dialogType) => {
            this.dialogMeta[dialogType] = { count: 0 };
        });
    }
    render() {
        return (hAsync(Host, { key: '2a0b56ee061c12442f50ceeaa8cb717817a0d1d5', class: `market-context ${this.noVeil ? 'no-veil' : ''}` }, hAsync("slot", { key: '12f97a955528ee801f1459cc9426f71b4a625025' })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "currentDialog": ["currentDialogWatcher"],
        "stack": ["stackWatcher"]
    }; }
    static get style() { return MarketContextStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-context",
        "$members$": {
            "currentDialog": [1040],
            "noVeil": [1040],
            "hidden": [1540],
            "animationEnterDuration": [2, "animation-enter-duration"],
            "animationExitDuration": [2, "animation-exit-duration"],
            "stack": [32],
            "totalCount": [32],
            "dialogMeta": [32],
            "open": [64],
            "close": [64],
            "closeCurrent": [64]
        },
        "$listeners$": [[0, "marketDialogLoaded", "modalLoadedEventHandler"], [0, "marketDialogDismissed", "dialogDismissedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"]]
    }; }
}

const marketContextManagerCss = "/*!@:host, ::slotted(*), **/.sc-market-context-manager-h,.sc-market-context-manager-s>*,*.sc-market-context-manager{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-context-manager-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-context-manager-h *.sc-market-context-manager,.sc-market-context-manager-h[disabled].sc-market-context-manager-s>*,.sc-market-context-manager-h[disabled] .sc-market-context-manager-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-context-manager-h{position:fixed;top:0;left:0;z-index:-1000;display:block;overflow:hidden;width:100vw;height:100%;opacity:0%}/*!@:host([active])*/[active].sc-market-context-manager-h{z-index:1000;opacity:100%;pointer-events:none}";
var MarketContextManagerStyle0 = marketContextManagerCss;

class MarketContextManager {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketContextManagerActivated = createEvent(this, "marketContextManagerActivated", 7);
        this.marketContextManagerDeactivated = createEvent(this, "marketContextManagerDeactivated", 7);
        this.active = false;
        this.currentContext = undefined;
        this.stack = [];
    }
    initChildListObserver() {
        if (this.childListObserver)
            return;
        const updateChildList = () => {
            this.stack = [...this.el.children];
            this.currentContext = this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
        };
        updateChildList();
        this.childListObserver = new MutationObserver(updateChildList);
        this.childListObserver.observe(this.el, { childList: true });
    }
    async getCurrentContext() {
        while (!this.currentContext) {
            await asyncRequestAnimationFrame();
        }
        return this.currentContext;
    }
    contextEmptiedEventHandler({ target: emptiedContext }) {
        // Remove the emptied context from the DOM
        emptiedContext.remove();
        // Remove the emptied context from the stack
        this.stack.splice(this.stack.indexOf(emptiedContext), 1);
        // Set the currentContext to the next highest context or null if this was the
        // only context in the stack
        if (this.stack.length === 0) {
            this.deactivate();
        }
    }
    windowKeydown(e) {
        var _a;
        if (e.key === 'Escape' || e.key === 'Esc') {
            (_a = this.currentContext) === null || _a === void 0 ? void 0 : _a.currentDialog.el.dismiss({ origin: this.el });
        }
    }
    /**
     * Adds the passed dialogEl to the DOM and creates a new context if necessary or according to
     * `shouldCreateNewContext` if it is passed
     */
    async open(dialogEl, shouldCreateNewContext) {
        let createNewContext = shouldCreateNewContext;
        if (!this.currentContext || dialogEl) {
            createNewContext = true;
        }
        // If we don't currently have a context, or we're opening certain types of
        // dialogs, then we should create a new context
        if (createNewContext) {
            this.createNewContext();
        }
        await this.currentContext.open(dialogEl);
    }
    /**
     * Closes the dialog with matching ID
     */
    close(dialogID) {
        this.currentContext.close(dialogID);
        return Promise.resolve();
    }
    /**
     * Adds a new market-context to the stack in the DOM and activates it
     */
    createNewContext() {
        this.activate();
        this.el.appendChild(document.createElement(getNamespacedTagFor('market-context')));
        this.currentContext = this.el.lastElementChild;
        return Promise.resolve();
    }
    /**
     * Hides the entire context manager
     */
    deactivate() {
        this.active = false;
        this.marketContextManagerDeactivated.emit();
        return Promise.resolve();
    }
    /**
     * Shows the context manager
     */
    activate() {
        if (!this.active) {
            this.active = true;
            this.marketContextManagerActivated.emit();
        }
        return Promise.resolve();
    }
    handleMouseEvents(e) {
        var _a, _b;
        // checking to make sure the click started and ended on a market-context
        // with a veil before dismissing the current dialog
        // (clicks pass through contexts w/o veil, currently only used w/ market-blade)
        if (e.type === 'mousedown') {
            this.mouseDownEl = e.target.tagName;
        }
        else if (e.type === 'mouseup') {
            const mouseUpEl = e.target.tagName;
            if (this.mouseDownEl === mouseUpEl &&
                e.target.tagName.toLowerCase() === getNamespacedTagFor('market-context') &&
                !e.target.classList.contains('no-veil')) {
                (_b = (_a = this.currentContext) === null || _a === void 0 ? void 0 : _a.currentDialog) === null || _b === void 0 ? void 0 : _b.el.dismiss({ origin: this.el });
            }
        }
    }
    componentDidLoad() {
        this.initChildListObserver();
    }
    render() {
        return (hAsync(Host, { key: '72a7dfd3862281d08036a4d1af846b8203e73893', class: "market-context-manager", onMouseDown: (e) => this.handleMouseEvents(e), onMouseUp: (e) => this.handleMouseEvents(e) }, hAsync("slot", { key: 'b7ef4e0031991376e48a559f2a026174667ff429' })));
    }
    disconnectedCallback() {
        var _a;
        (_a = this.childListObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    get el() { return getElement(this); }
    static get style() { return MarketContextManagerStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-context-manager",
        "$members$": {
            "active": [1540],
            "currentContext": [32],
            "stack": [32],
            "open": [64],
            "close": [64],
            "createNewContext": [64],
            "deactivate": [64],
            "activate": [64]
        },
        "$listeners$": [[0, "marketContextEmptied", "contextEmptiedEventHandler"], [8, "keydown", "windowKeydown"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"]]
    }; }
}

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      // eslint-disable-next-line no-console
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }
  var dayOfMonth = date.getDate();

  // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */

/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */
var millisecondsInMinute = 60000;

/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */
var millisecondsInHour = 3600000;

/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */
var millisecondsInSecond = 1000;

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the end of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = '0' + output;
  }
  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */
var formatters$2 = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    var signedYear = date.getUTCFullYear();
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();
      case 'aaa':
        return dayPeriodEnumValue;
      case 'aaaaa':
        return dayPeriodEnumValue[0];
      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var formatters$3 = formatters$2;

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B
      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ
      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }
    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

    // Two digit year
    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }

    // Ordinal number
    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    }

    // Padding
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);

    // Padding
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04
      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4
      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...
      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04
      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4
      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...
      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();
    switch (token) {
      case 'M':
      case 'MM':
        return formatters$3.M(date, token);
      // 1st, 2nd, ..., 12th
      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec
      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D
      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December
      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();
    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12
      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec
      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D
      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December
      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = getUTCWeek(date, options);
    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = getUTCISOWeek(date);
    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }
    return formatters$3.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T
      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu
      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday
      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value
      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });
      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T
      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu
      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday
      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value
      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });
      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T
      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu
      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday
      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02
      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue
      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T
      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu
      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday
      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });
      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();
      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });
      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }
    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });
      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();
      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });
      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });
      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });
      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }
    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }
    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;
    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;
    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }
    return formatters$3.m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }
    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return 'Z';
    }
    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long
      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long
      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters$1 = formatters;

var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });
    case 'PP':
      return formatLong.date({
        width: 'medium'
      });
    case 'PPP':
      return formatLong.date({
        width: 'long'
      });
    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};
var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });
    case 'pp':
      return formatLong.time({
        width: 'medium'
      });
    case 'ppp':
      return formatLong.time({
        width: 'long'
      });
    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;
    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;
    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;
    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }
  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};
var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }
  return result;
};
var formatDistance$1 = formatDistance;

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};
var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative$1 = formatRelative;

function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;
    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};
var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
    }
  }
  return number + 'th';
};
var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return undefined;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$1 = match;

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }
  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join('').match(formattingTokensRegExp$1).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }
    return substring;
  }).join('');
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}

function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}

/**
 * @name lastDayOfMonth
 * @category Month Helpers
 * @summary Return the last day of a month for the given date.
 *
 * @description
 * Return the last day of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of a month for 2 September 2014 11:55:00:
 * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|Number} date - the date that should be after the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck(this, Setter);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits(ValueSetter, _Setter);
  var _super = _createSuper(ValueSetter);
  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits(DateToSystemTimezoneSetter, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter);
  function DateToSystemTimezoneSetter() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter;
}(Setter);

var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck(this, Parser);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser;
}();

var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits(EraParser, _Parser);
  var _super = _createSuper(EraParser);
  function EraParser() {
    var _this;
    _classCallCheck(this, EraParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 140);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
    return _this;
  }
  _createClass(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B
        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ
        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser;
}(Parser);

var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59

  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999

  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
};

var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;
    case 'evening':
      return 17;
    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;
    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits(YearParser, _Parser);
  var _super = _createSuper(YearParser);
  function YearParser() {
    var _this;
    _classCallCheck(this, YearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };
      switch (token) {
        case 'y':
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case 'yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser;
}(Parser);

// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalWeekYearParser, _Parser);
  var _super = _createSuper(LocalWeekYearParser);
  function LocalWeekYearParser() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  _createClass(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };
      switch (token) {
        case 'Y':
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case 'Yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser;
}(Parser);

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOWeekYearParser, _Parser);
  var _super = _createSuper(ISOWeekYearParser);
  function ISOWeekYearParser() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser;
}(Parser);

var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(ExtendedYearParser, _Parser);
  var _super = _createSuper(ExtendedYearParser);
  function ExtendedYearParser() {
    var _this;
    _classCallCheck(this, ExtendedYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser;
}(Parser);

var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits(QuarterParser, _Parser);
  var _super = _createSuper(QuarterParser);
  function QuarterParser() {
    var _this;
    _classCallCheck(this, QuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...
        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser;
}(Parser);

var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneQuarterParser, _Parser);
  var _super = _createSuper(StandAloneQuarterParser);
  function StandAloneQuarterParser() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...
        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser;
}(Parser);

var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits(MonthParser, _Parser);
  var _super = _createSuper(MonthParser);
  function MonthParser() {
    var _this;
    _classCallCheck(this, MonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    return _this;
  }
  _createClass(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12
        case 'MM':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case 'Mo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec
        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D
        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December
        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser;
}(Parser);

var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneMonthParser, _Parser);
  var _super = _createSuper(StandAloneMonthParser);
  function StandAloneMonthParser() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12
        case 'LL':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case 'Lo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec
        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D
        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December
        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser;
}(Parser);

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalWeekParser, _Parser);
  var _super = _createSuper(LocalWeekParser);
  function LocalWeekParser() {
    var _this;
    _classCallCheck(this, LocalWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  _createClass(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, dateString);
        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser;
}(Parser);

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOWeekParser, _Parser);
  var _super = _createSuper(ISOWeekParser);
  function ISOWeekParser() {
    var _this;
    _classCallCheck(this, ISOWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, dateString);
        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser;
}(Parser);

var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// Day of the month
var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits(DateParser, _Parser);
  var _super = _createSuper(DateParser);
  function DateParser() {
    var _this;
    _classCallCheck(this, DateParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, dateString);
        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser;
}(Parser);

var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayOfYearParser, _Parser);
  var _super = _createSuper(DayOfYearParser);
  function DayOfYearParser() {
    var _this;
    _classCallCheck(this, DayOfYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser;
}(Parser);

function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayParser, _Parser);
  var _super = _createSuper(DayParser);
  function DayParser() {
    var _this;
    _classCallCheck(this, DayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T
        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday
        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser;
}(Parser);

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalDayParser, _Parser);
  var _super = _createSuper(LocalDayParser);
  function LocalDayParser() {
    var _this;
    _classCallCheck(this, LocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
    return _this;
  }
  _createClass(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd
        case 'eo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue
        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T
        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday
        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser;
}(Parser);

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneLocalDayParser, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser);
  function StandAloneLocalDayParser() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
    return _this;
  }
  _createClass(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd
        case 'co':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue
        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T
        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu
        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday
        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser;
}(Parser);

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISODayParser, _Parser);
  var _super = _createSuper(ISODayParser);
  function ISODayParser() {
    var _this;
    _classCallCheck(this, ISODayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, dateString);
        // 2nd
        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue
        case 'iii':
          return mapValue(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T
        case 'iiiii':
          return mapValue(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu
        case 'iiiiii':
          return mapValue(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday
        case 'iiii':
        default:
          return mapValue(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser;
}(Parser);

var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits(AMPMParser, _Parser);
  var _super = _createSuper(AMPMParser);
  function AMPMParser() {
    var _this;
    _classCallCheck(this, AMPMParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser;
}(Parser);

var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits(AMPMMidnightParser, _Parser);
  var _super = _createSuper(AMPMMidnightParser);
  function AMPMMidnightParser() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser;
}(Parser);

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayPeriodParser, _Parser);
  var _super = _createSuper(DayPeriodParser);
  function DayPeriodParser() {
    var _this;
    _classCallCheck(this, DayPeriodParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
    return _this;
  }
  _createClass(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser;
}(Parser);

var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour1to12Parser, _Parser);
  var _super = _createSuper(Hour1to12Parser);
  function Hour1to12Parser() {
    var _this;
    _classCallCheck(this, Hour1to12Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
    return _this;
  }
  _createClass(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser;
}(Parser);

var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour0to23Parser, _Parser);
  var _super = _createSuper(Hour0to23Parser);
  function Hour0to23Parser() {
    var _this;
    _classCallCheck(this, Hour0to23Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
    return _this;
  }
  _createClass(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser;
}(Parser);

var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour0To11Parser, _Parser);
  var _super = _createSuper(Hour0To11Parser);
  function Hour0To11Parser() {
    var _this;
    _classCallCheck(this, Hour0To11Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser;
}(Parser);

var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour1To24Parser, _Parser);
  var _super = _createSuper(Hour1To24Parser);
  function Hour1To24Parser() {
    var _this;
    _classCallCheck(this, Hour1To24Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
    return _this;
  }
  _createClass(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser;
}(Parser);

var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits(MinuteParser, _Parser);
  var _super = _createSuper(MinuteParser);
  function MinuteParser() {
    var _this;
    _classCallCheck(this, MinuteParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 60);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, dateString);
        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser;
}(Parser);

var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits(SecondParser, _Parser);
  var _super = _createSuper(SecondParser);
  function SecondParser() {
    var _this;
    _classCallCheck(this, SecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 50);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, dateString);
        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser;
}(Parser);

var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits(FractionOfSecondParser, _Parser);
  var _super = _createSuper(FractionOfSecondParser);
  function FractionOfSecondParser() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 30);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser;
}(Parser);

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOTimezoneWithZParser, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser);
  function ISOTimezoneWithZParser() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'x']);
    return _this;
  }
  _createClass(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser;
}(Parser);

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOTimezoneParser, _Parser);
  var _super = _createSuper(ISOTimezoneParser);
  function ISOTimezoneParser() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'X']);
    return _this;
  }
  _createClass(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser;
}(Parser);

var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampSecondsParser, _Parser);
  var _super = _createSuper(TimestampSecondsParser);
  function TimestampSecondsParser() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 40);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
    return _this;
  }
  _createClass(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser;
}(Parser);

var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser);
  function TimestampMillisecondsParser() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
    return _this;
  }
  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser;
}(Parser);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  };

  // If timezone isn't specified, it will be set to the system timezone
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters$1) {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens),
    _step;
  try {
    var _loop = function _loop() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        // Replace two single quote characters with one single quote character
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }

        // Cut token from string, or, if string doesn't match the token, return Invalid Date
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    }

    // Check if the remaining input contains something other than whitespace
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      // Result is tuple (date, flags)
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
        // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/**
 * @name lastDayOfYear
 * @category Year Helpers
 * @summary Return the last day of a year for the given date.
 *
 * @description
 * Return the last day of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of a year for 2 September 2014 11:55:00:
 * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 00:00:00
 */
function lastDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }
  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return {
    year: NaN,
    restDateString: ''
  };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);
  var captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @description
 * Return the start of yesterday.
 *
 * >  Please note that this function is not present in the FP submodule as
 * > it uses `new Date()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
function startOfYesterday() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
function subWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addWeeks(dirtyDate, -amount);
}

/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}

const marketDatePickerInputDateCss = "/*!@.input-row*/.input-row.sc-market-date-picker-input-date{display:flex;justify-content:space-around;margin-top:8px}/*!@.input-wrapper*/.input-wrapper.sc-market-date-picker-input-date{display:flex;flex:1;flex-direction:column;align-items:flex-start}/*!@.start-input:not(:last-child)*/.start-input.sc-market-date-picker-input-date:not(:last-child){margin-right:16px}/*!@.time-input, .date-input*/.time-input.sc-market-date-picker-input-date,.date-input.sc-market-date-picker-input-date{box-sizing:border-box;width:100%;margin-top:16px}/*!@.market-banner*/.market-banner.sc-market-date-picker-input-date{margin-top:16px}";
var MarketDatePickerInputDateStyle0 = marketDatePickerInputDateCss;

class MarketDateInputDate {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDatePickerInputDateSet = createEvent(this, "marketDatePickerInputDateSet", 7);
        this.marketDatePickerInputDateInvalidStateChanged = createEvent(this, "marketDatePickerInputDateInvalidStateChanged", 7);
        this.withTime = false;
        this.selectedStartDate = undefined;
        this.selectedEndDate = undefined;
        this.isDateDisabled = undefined;
        this.timeframe = 'present';
        this.range = false;
        this.isRangeInvalid = false;
    }
    emitInvalidStateEvent() {
        this.marketDatePickerInputDateInvalidStateChanged.emit({
            invalid: this.isRangeInvalid,
        });
    }
    formatDate(date, isTime = false) {
        if (!date)
            return '';
        const dateObj = new Date(date);
        if (!isValid(dateObj)) {
            return '';
        }
        const formatStr = isTime ? 'HH:mm' : 'yyyy-MM-dd';
        return format(dateObj, formatStr);
    }
    isInvalidDateForTimeframe(dateObj, today = new Date()) {
        const isFutureDate = this.timeframe === 'future' && isBefore(dateObj, today) && !isSameDay(dateObj, today);
        const isPastDate = this.timeframe === 'past' && isAfter(dateObj, today) && !isSameDay(dateObj, today);
        return isFutureDate || isPastDate;
    }
    updateInvalidState(start = this.selectedStartDate, end = this.selectedEndDate) {
        if (this.isDateInvalid(start) || this.isDateInvalid(end)) {
            this.isRangeInvalid = true;
            return;
        }
        // If end date is set, check if start date is after end date
        if (end) {
            this.isRangeInvalid = isAfter(new Date(start), new Date(end));
            return;
        }
        this.isRangeInvalid = false;
    }
    isDateInvalid(date) {
        if (!date)
            return false;
        const dateObj = parseISO(date);
        if (dateObj.toString() === 'Invalid Date')
            return true;
        if (this.isDateDisabled && this.isDateDisabled(dateObj)) {
            return true;
        }
        if (this.timeframe && this.isInvalidDateForTimeframe(dateObj)) {
            return true;
        }
        return false;
    }
    emitDateSetStart(ev) {
        this.emitDateSet(ev, 'start');
    }
    emitDateSetEnd(ev) {
        this.emitDateSet(ev, 'end');
    }
    emitDateSetStartTime(ev) {
        this.emitDateSet(ev, 'start', true);
    }
    emitDateSetEndTime(ev) {
        this.emitDateSet(ev, 'end', true);
    }
    emitDateSet(ev, input, timeInput = false) {
        ev.preventDefault();
        ev.stopPropagation();
        const { value } = ev.target;
        let valueToSubmit = value;
        // If time is set, add the time to the date
        if (this.withTime) {
            if (timeInput) {
                const date = this.formatDate(input === 'start' ? this.selectedStartDate : this.selectedEndDate);
                const time = value.slice(0, 5);
                valueToSubmit = `${date}T${time}`;
            }
            else {
                const time = this.formatDate(input === 'start' ? this.selectedStartDate : this.selectedEndDate, true);
                valueToSubmit = `${value}T${time}`;
            }
        }
        // Remove leading zeros
        const realLength = valueToSubmit.replace(/^0+/, '').length;
        // Only emit if length is (yyyy-mm-dd) or (yyyy-mm-ddThh:mm) and is valid
        if (realLength === 10 || realLength === 16) {
            this.marketDatePickerInputDateSet.emit({ date: valueToSubmit, input });
        }
    }
    componentWillRender() {
        this.updateInvalidState();
    }
    render() {
        const MarketInputTextTagName = getNamespacedTagFor('market-input-text');
        const MarketBannerTagName = getNamespacedTagFor('market-banner');
        const inputWrapper = (type) => (hAsync("div", { key: 'b21389daf44f3f7c01c99332c863b3694a5fe3ec', class: `input-wrapper ${type === 'start' ? 'start-input' : ''}` }, type === 'start' && dateInput('start'), type === 'start' && this.withTime && timeInput('start'), type === 'end' && dateInput('end'), type === 'end' && this.withTime && timeInput('end')));
        const dateInput = (type) => (hAsync(MarketInputTextTagName, { key: 'f425b7803c14bc28ba82f6ac33c84f2258d2a988', type: "date", class: `date-input`, name: `date-picker-date-${type}`, invalid: this.isRangeInvalid, value: this.formatDate(type === 'start' ? this.selectedStartDate : this.selectedEndDate), onInput: type === 'start' ? this.emitDateSetStart.bind(this) : this.emitDateSetEnd.bind(this) }, hAsync("label", { key: 'b9049334bb2a711c69327172411d07ba37c1aaaa', htmlFor: `date-picker-${type}` }, hAsync("slot", { key: '79396ea901c67d286f81dc132659f3967c8d7d9b', name: `${type}-date` }, this.range && (type === 'start' ? 'Start' : 'End'), " Date"))));
        const timeInput = (type) => (hAsync(MarketInputTextTagName, { key: '51b47dd0eaa7750109e65e870b028f940cce097b', type: "time", class: `time-input`, name: `date-picker-time-${type}`, invalid: this.isRangeInvalid, value: this.formatDate(type === 'start' ? this.selectedStartDate : this.selectedEndDate, true), onInput: type === 'start' ? this.emitDateSetStartTime.bind(this) : this.emitDateSetEndTime.bind(this) }, hAsync("label", { key: 'a0c76ff259384cbe05c43246c8e02219b728e958', htmlFor: `date-picker-time-${type}` }, hAsync("slot", { key: '542b72217fe71c460e650ae561151f54c66c331e', name: `${type}-time` }, this.range && (type === 'start' ? 'Start' : 'End'), " Time"))));
        return (hAsync(Host, { key: '97b4fde78831d10fb483c5ba14c5eb7d5a4ad6dc', class: "market-date-picker-input-date" }, this.range ? (hAsync("div", { class: "input-row" }, inputWrapper('start'), inputWrapper('end'))) : (hAsync("div", null, inputWrapper('start'))), this.isRangeInvalid && (hAsync(MarketBannerTagName, { key: 'e307642e971df21b7e52d49de81208537955275d', variant: "critical" }, hAsync("slot", { key: '573adb7b99baacc96011ba953f785e2fff879ca7', name: "range-error" }, "Enter a valid date range")))));
    }
    static get watchers() { return {
        "isRangeInvalid": ["emitInvalidStateEvent"]
    }; }
    static get style() { return MarketDatePickerInputDateStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-date-picker-input-date",
        "$members$": {
            "withTime": [4, "with-time"],
            "selectedStartDate": [1, "selected-start-date"],
            "selectedEndDate": [1, "selected-end-date"],
            "isDateDisabled": [16],
            "timeframe": [1],
            "range": [4],
            "isRangeInvalid": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

/**
 *  Enums for market-date-picker-menu slot names used to determine which row was selected
 */
var MENU_SLOT_NAMES;
(function (MENU_SLOT_NAMES) {
    MENU_SLOT_NAMES["TODAY"] = "today";
    MENU_SLOT_NAMES["YESTERDAY"] = "yesterday";
    MENU_SLOT_NAMES["THIS_WEEK"] = "this-week";
    MENU_SLOT_NAMES["LAST_WEEK"] = "last-week";
    MENU_SLOT_NAMES["THIS_MONTH"] = "this-month";
    MENU_SLOT_NAMES["LAST_MONTH"] = "last-month";
    MENU_SLOT_NAMES["THIS_YEAR"] = "this-year";
    MENU_SLOT_NAMES["LAST_YEAR"] = "last-year";
    MENU_SLOT_NAMES["CUSTOM"] = "custom";
})(MENU_SLOT_NAMES || (MENU_SLOT_NAMES = {}));

const marketDatePickerCss = "/*!@:host*/.sc-market-date-picker-h{display:flex}@media only screen and (max-width: 800px){/*!@:host([mobile-menu-position=\"top\"])*/[mobile-menu-position=\"top\"].sc-market-date-picker-h{flex-direction:column}/*!@:host([mobile-menu-position=\"top\"]) list-view*/[mobile-menu-position=\"top\"].sc-market-date-picker-h list-view.sc-market-date-picker{margin-bottom:var(--date-picker-menu-vertical-spacing)}/*!@:host([mobile-menu-position=\"bottom\"])*/[mobile-menu-position=\"bottom\"].sc-market-date-picker-h{flex-direction:column-reverse}/*!@:host([mobile-menu-position=\"bottom\"]) list-view*/[mobile-menu-position=\"bottom\"].sc-market-date-picker-h list-view.sc-market-date-picker{margin-top:var(--date-picker-menu-vertical-spacing)}}/*!@header*/header.sc-market-date-picker{height:var(--date-picker-header-minimum-height);margin-bottom:var(--date-picker-header-vertical-spacing)}/*!@nav*/nav.sc-market-date-picker{display:flex;justify-content:space-between;align-items:center}/*!@:host([year-view-active]) nav*/[year-view-active].sc-market-date-picker-h nav.sc-market-date-picker{justify-content:center}/*!@[id^=\"date-picker-label-\"]*/[id^=\"date-picker-label-\"].sc-market-date-picker{margin:0}/*!@.year-view-button*/.year-view-button.sc-market-date-picker{color:var(--date-picker-month-year-label-color, var(--core-text-10-color))}/*!@.year-view-button:hover, .year-view-button:active*/.year-view-button.sc-market-date-picker:hover,.year-view-button.sc-market-date-picker:active{background-color:transparent;color:var(--core-emphasis-text-color)}/*!@.caret*/.caret.sc-market-date-picker{margin-left:var(--date-picker-header-button-padding)}/*!@:host([year-view-active]) .caret*/[year-view-active].sc-market-date-picker-h .caret.sc-market-date-picker{transform:rotate(-180deg)}/*!@calendar*/calendar.sc-market-date-picker{min-width:var(--date-picker-minimum-width)}/*!@month-view*/month-view.sc-market-date-picker{display:grid;grid-template-rows:repeat(auto-fill, 1fr);grid-template-columns:repeat(7, 1fr);gap:var(--date-picker-grid-item-vertical-padding) var(--date-picker-grid-item-horizontal-padding);box-sizing:border-box}/*!@year-section*/year-section.sc-market-date-picker{display:flex;gap:var(--date-picker-grid-item-year-button-vertical-padding, 0)\n    var(--date-picker-grid-item-year-button-horizontal-padding, 12.5px);box-sizing:border-box}/*!@year-section .market-icon*/year-section.sc-market-date-picker .market-icon.sc-market-date-picker{width:var(--date-picker-grid-item-year-button-icon-size, var(--accessory-icon-variant-medium-size-height))}/*!@month-section*/month-section.sc-market-date-picker{display:grid;grid-template-rows:repeat(3, 1fr);grid-template-columns:repeat(4, 1fr);gap:var(--date-picker-grid-item-month-button-vertical-padding, 16px)\n    var(--date-picker-grid-item-month-button-horizontal-padding, 26.67px);box-sizing:border-box}";
var MarketDatePickerStyle0 = marketDatePickerCss;

/**
 * Object class to hold necessary date information when building out each market-date-picker-date for the calendar
 */
class Day {
    constructor() {
        this.date = '';
        this.month = null;
        this.year = null;
        // For market-date-picker-date props
        this.selected = false;
        this.selection = 'none';
        this.today = false;
        this.disabled = false;
    }
}
class MarketDatePicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDateRangeChanged = createEvent(this, "marketDateRangeChanged", 7);
        this.marketMenuSelectionChanged = createEvent(this, "marketMenuSelectionChanged", 7);
        /**
         * Current displayed months for the calendar year view. This can be updated with locale changes.
         */
        this.yearViewMonthList = [];
        this.selectionType = 'single';
        this.selectedStartDate = undefined;
        this.selectedEndDate = undefined;
        this.presetMenuOption = undefined;
        this.displayMenu = false;
        this.mobileMenuPosition = 'top';
        this.excludeMenuItems = '';
        this.timeframe = 'present';
        this.isDateDisabled = undefined;
        this.locale = navigator.language || 'en-US';
        this.displayedDate = undefined;
        this.withInputs = '';
        this.invalid = false;
        this.yearViewActive = false;
        this.displayedMonth = undefined;
        this.displayedWeekdays = [];
        this.yearViewYearsList = [];
        this.hoveredDate = undefined;
    }
    /**
     * Build out the weekday headers based on locale for the calendar view.
     */
    buildWeekdays() {
        this.displayedWeekdays = [];
        // Grab start of the week
        const weekday = startOfWeek(new Date(), { weekStartsOn: this.getLocaleFirstDayOfWeek() });
        let weekdayText;
        for (let d = 0; d < 7; d++) {
            weekdayText = weekday.toLocaleDateString(this.locale, { weekday: 'short' });
            // Shorten English based weekday headers by one
            if (this.locale.startsWith('en-')) {
                weekdayText = weekdayText.slice(0, -1);
            }
            this.displayedWeekdays.push(weekdayText);
            weekday.setDate(weekday.getDate() + 1);
        }
    }
    getLocaleFirstDayOfWeek() {
        var _a, _b, _c, _d, _e;
        const intl = new Intl.Locale(this.locale);
        // Chrome uses weekInfo as a property, Safari uses getWeekInfo() as a fn on the locale to get week info.
        // This is not yet supported in Firefox, so default to Sunday if no first day info is found.
        const firstDay = (_e = (_b = (_a = intl === null || intl === void 0 ? void 0 : intl.weekInfo) === null || _a === void 0 ? void 0 : _a.firstDay) !== null && _b !== void 0 ? _b : (_d = (_c = intl === null || intl === void 0 ? void 0 : intl.getWeekInfo) === null || _c === void 0 ? void 0 : _c.call(intl)) === null || _d === void 0 ? void 0 : _d.firstDay) !== null && _e !== void 0 ? _e : 0;
        // Translates the "Sunday" case, which weekInfo sets to 7
        return (firstDay % 7);
    }
    /**
     * Compares current hovered date to selected dates to determine correct styling for selection.
     */
    addHoveredDateRangeStyling(currentDate, datePickerDay) {
        if (!this.hoveredDate) {
            return;
        }
        const currentStartDate = new Date(this.selectedStartDate);
        // Set the day to be in the middle of a range when there is a start date and no end date,
        // and the day in question is between the start date and hovered date.
        if (this.selectedStartDate &&
            !this.selectedEndDate &&
            isBefore(currentDate, this.hoveredDate) &&
            isAfter(currentDate, currentStartDate)) {
            datePickerDay.selection = 'range-middle';
        }
        if (!isSameDay(this.hoveredDate, currentDate)) {
            return;
        }
        // If there's no start date, or a date range is selected, or the hovered date is before or the same as the start date,
        // the hovered button should be the start of a new range.
        if (!this.selectedStartDate ||
            (this.selectedStartDate && this.selectedEndDate) ||
            !isAfter(this.hoveredDate, currentStartDate)) {
            datePickerDay.selection = 'range-first';
        }
        else {
            datePickerDay.selection = 'range-last';
        }
    }
    /**
     * Helper function to add selection metadata to the date object being processed in buildCalendar.
     */
    addDateSelectionAttributes(day, calendarDate, currentStartDate, currentEndDate) {
        // Checks for start date comparison (for both single/range types)
        if (currentStartDate && isSameDay(calendarDate, currentStartDate)) {
            day.selected = true;
            day.selection = this.selectionType === 'single' ? 'single' : 'range-first';
        }
        // For range types only, check for dates within a selected range, or ends in a range
        if (this.selectionType === 'range') {
            this.addHoveredDateRangeStyling(calendarDate, day);
            if (currentStartDate &&
                currentEndDate &&
                isAfter(calendarDate, currentStartDate) &&
                isBefore(calendarDate, currentEndDate)) {
                day.selected = true;
                day.selection = 'range-middle';
            }
            if (currentEndDate && isSameDay(calendarDate, currentEndDate)) {
                day.selected = true;
                day.selection = 'range-last';
            }
        }
    }
    /**
     * The main chunk of this component is building out the calendar view.
     * Ensures correct styling and formatting is placed on each date component.
     * Adapted from: https://ionicframework.com/blog/building-with-stencil-calendar-component/
     */
    buildCalendar() {
        const today = new Date();
        const currentDisplayedDate = new Date(this.displayedDate);
        // Calendar used in iteration
        const calendar = new Date(currentDisplayedDate.getFullYear(), currentDisplayedDate.getMonth(), 1);
        // First day of month may not be first day of week
        // Roll back until first day of week
        // First day can either start at Sunday or Monday, so if it is Monday, subtract a day at the start of the calendar
        const firstDayOffset = this.getLocaleFirstDayOfWeek();
        // Handles edge case where a locale with Monday as the first day, starts on Sunday
        // This case builds the calendar with 6 blank squares in front of the first day (as expected)
        if (calendar.getDay() === 0 && firstDayOffset === 1) {
            calendar.setDate(calendar.getDate() - 6);
        }
        else {
            calendar.setDate(calendar.getDate() - (calendar.getDay() - firstDayOffset));
        }
        // Clear days to be rendered
        this.days = [];
        // Create date objects from selected dates if they exist
        const currentStartDate = this.selectedStartDate && new Date(this.selectedStartDate);
        const currentEndDate = this.selectedEndDate && new Date(this.selectedEndDate);
        for (let d = 0; d < 42; d++) {
            // Day to be rendered
            // Seed with current date in iteration
            const day = new Day();
            day.year = calendar.getFullYear();
            day.month = calendar.getMonth();
            // Populate day in month
            // Undefined date properties are not rendered
            if (calendar.getFullYear() === currentDisplayedDate.getFullYear() &&
                calendar.getMonth() === currentDisplayedDate.getMonth()) {
                day.date = calendar.getDate().toString();
            }
            // Check for today
            if (isSameDay(calendar, today)) {
                day.today = true;
            }
            // Check for selection types
            this.addDateSelectionAttributes(day, calendar, currentStartDate, currentEndDate);
            // Check for disabled dates
            if (day.date && this.isDateDisabled) {
                day.disabled = this.isDateDisabled(calendar);
            }
            if (this.timeframe === 'future' && isBefore(calendar, today) && !isSameDay(calendar, today)) {
                day.disabled = true;
            }
            if (this.timeframe === 'past' && isAfter(calendar, today) && !isSameDay(calendar, today)) {
                day.disabled = true;
            }
            // Add to days to be rendered
            this.days.push(day);
            // Move to next date
            calendar.setDate(calendar.getDate() + 1);
            // Do not render the last week
            // Depending on calendar layout
            // Some months require five weeks
            // Others six weeks (see May 2021)
            if (calendar.getDay() === 0 + firstDayOffset && calendar.getMonth() !== currentDisplayedDate.getMonth()) {
                break;
            }
        }
    }
    /**
     * Helper function to clear date selections.
     */
    clearDateSelections() {
        this.selectedStartDate = null;
        this.selectedEndDate = null;
    }
    /**
     * Used for the navigation arrows in the market-date-picker header, moves the calendar forward/backward by increment.
     * Currently only used for +1/-1 month.
     */
    navigateMonth(increment) {
        const currentDisplayedDate = new Date(this.displayedDate);
        this.displayedDate = new Date(currentDisplayedDate.getFullYear(), currentDisplayedDate.getMonth() + increment, 1).toISOString();
    }
    /**
     *  When ever an event changes the selected date, this updates the calendar view.
     *  The event receives a date string in the yyyy-mm-dd or yyy-mm-ddThh:mm format.
     *  this then checks what parts of the date have changed and only sends the changed parts to the
     * _selectDate function that receives (day, month, year)
     */
    dateInputDateSet({ detail: { date, input } }) {
        const [newDate, time] = date.split('T');
        const [newYear, newMonth, newDay] = newDate.split('-').map(Number);
        this.displayedDate = new Date(newYear, newMonth - 1, 1).toString();
        // fallback to undefined, to prevent overwriting if time was initialized but withTime is disabled.
        const [hour, minute] = this.withInputs === 'date-and-time' ? time.split(':').map(Number) : [];
        this._selectDate({
            day: newDay,
            month: newMonth - 1,
            year: newYear,
            hour,
            minute,
            input,
        });
    }
    /**
     * Whenever a market-date-picker-date is selected, this updates the selected date props, which then updates the calendar view.
     */
    selectDate({ detail: { date: dateElement } }) {
        if (dateElement.type !== 'day') {
            this.updateDisplayedHeader(dateElement.type, dateElement.day);
        }
        else {
            this._selectDate({ day: dateElement.day });
        }
    }
    /**
     * Whenever a market-date-picker-date is moused over or hovered, this updates the hovered date to update the calendar view.
     */
    hoverDate({ detail: { date: dateElement } }) {
        const currentDisplayedDate = new Date(this.displayedDate);
        this.hoveredDate = new Date(currentDisplayedDate.getFullYear(), currentDisplayedDate.getMonth(), dateElement.day);
    }
    /**
     * Whenever a market-date-picker-date is moused out, clear any hovering styling in the calendar view.
     */
    mousedOutDate() {
        this.hoveredDate = null;
    }
    /**
     * Whenever a market-row within market-date-picker-menu is selected, this ensures we move the current selected dates
     * to whichever option the user has selected.
     */
    selectMenuRow(e) {
        const menuOption = e.detail.menuSelection;
        if (!menuOption) {
            return;
        }
        this.marketMenuSelectionChanged.emit({
            menuSelection: menuOption,
        });
        const prevStartDate = this.selectedStartDate;
        const prevEndDate = this.selectedEndDate;
        this._setMenuRowOption(menuOption);
        if (menuOption !== MENU_SLOT_NAMES.CUSTOM) {
            this.marketDateRangeChanged.emit({
                prevStartDate,
                prevEndDate,
                startDate: this.selectedStartDate,
                endDate: this.selectedEndDate,
                menuSelection: menuOption,
            });
        }
    }
    /**
     * Updates invalid state of date picker based on date input selections
     */
    setInvalidState({ detail: { invalid } }) {
        this.invalid = invalid;
    }
    _setMenuRowOption(menuOption) {
        const today = new Date();
        switch (menuOption) {
            case MENU_SLOT_NAMES.TODAY:
                this.clearDateSelections();
                this.selectedStartDate = today.toISOString();
                break;
            case MENU_SLOT_NAMES.YESTERDAY:
                this.clearDateSelections();
                this.selectedStartDate = startOfYesterday().toISOString();
                break;
            case MENU_SLOT_NAMES.THIS_WEEK:
                this.selectedStartDate = startOfWeek(today).toISOString();
                if (this.selectionType === 'range') {
                    this.selectedEndDate = endOfWeek(today).toISOString();
                }
                break;
            case MENU_SLOT_NAMES.LAST_WEEK: {
                const lastWeekDate = subWeeks(today, 1);
                this.selectedStartDate = startOfWeek(lastWeekDate).toISOString();
                if (this.selectionType === 'range') {
                    this.selectedEndDate = endOfWeek(lastWeekDate).toISOString();
                }
                break;
            }
            case MENU_SLOT_NAMES.THIS_MONTH:
                this.selectedStartDate = startOfMonth(today).toISOString();
                if (this.selectionType === 'range') {
                    this.selectedEndDate = lastDayOfMonth(today).toISOString();
                }
                break;
            case MENU_SLOT_NAMES.LAST_MONTH: {
                const lastMonthDate = subMonths(today, 1);
                this.selectedStartDate = startOfMonth(lastMonthDate).toISOString();
                if (this.selectionType === 'range') {
                    this.selectedEndDate = lastDayOfMonth(lastMonthDate).toISOString();
                }
                break;
            }
            case MENU_SLOT_NAMES.THIS_YEAR:
                this.selectedStartDate = startOfYear(today).toISOString();
                if (this.selectionType === 'range') {
                    this.selectedEndDate = lastDayOfYear(today).toISOString();
                }
                break;
            case MENU_SLOT_NAMES.LAST_YEAR: {
                const lastYearDate = subYears(today, 1);
                this.selectedStartDate = startOfYear(lastYearDate).toISOString();
                if (this.selectionType === 'range') {
                    this.selectedEndDate = lastDayOfYear(lastYearDate).toISOString();
                }
                break;
            }
        }
        // Update displayed date to selected date
        if (menuOption !== MENU_SLOT_NAMES.CUSTOM) {
            this.displayedDate = this.selectedStartDate;
        }
    }
    _selectDate(options) {
        var _a;
        const prevStartDate = this.selectedStartDate;
        const prevEndDate = this.selectedEndDate;
        const currentDisplayedDate = new Date(this.displayedDate);
        // Handles case where month is January, represented by 0
        const checkedMonth = (_a = options.month) !== null && _a !== void 0 ? _a : currentDisplayedDate.getMonth();
        const day = new Date(options.year || currentDisplayedDate.getFullYear(), checkedMonth, options.day || currentDisplayedDate.getDate(), options.hour || currentDisplayedDate.getHours(), options.minute || currentDisplayedDate.getMinutes()).toISOString();
        if (this.displayMenu && !isSameDay(new Date(this.selectedStartDate), new Date(day))) {
            // Select custom menu row if it exists when calendar is updated
            const menu = this.el.shadowRoot.querySelector(getNamespacedTagFor('market-date-picker-menu'));
            menu._selectCustomRow();
        }
        if (this.selectionType === 'single') {
            this.clearDateSelections();
            this.selectedStartDate = day;
        }
        else {
            // Date range logic
            if (this.selectedStartDate && !this.selectedEndDate && day >= this.selectedStartDate) {
                // if new day is equal or after selected start date, and end date isn't set, update end date.
                this.selectedEndDate = day;
            }
            else {
                if (options.input) {
                    if (options.input === 'start')
                        this.selectedStartDate = day;
                    if (options.input === 'end')
                        this.selectedEndDate = day;
                }
                else {
                    this.clearDateSelections();
                    this.selectedStartDate = day;
                }
            }
        }
        this.marketDateRangeChanged.emit({
            prevStartDate,
            prevEndDate,
            startDate: this.selectedStartDate,
            endDate: this.selectedEndDate,
            menuSelection: MENU_SLOT_NAMES.CUSTOM,
        });
    }
    // MONTH & YEAR VIEW FUNCTIONS
    toggleCaret() {
        this.yearViewActive = !this.yearViewActive;
    }
    validateDisplayedDate(date) {
        // Handles invalid dates passed in to displayed date
        if (new Date(date).toString() === 'Invalid Date') {
            this.displayedDate = new Date().toISOString();
        }
    }
    buildInitialYearView() {
        this.validateDisplayedDate(this.displayedDate);
        const currentDisplayedDate = new Date(this.displayedDate);
        const currentYear = currentDisplayedDate.getFullYear();
        this.yearViewYearsList = [(currentYear - 1).toString(), currentYear.toString(), (currentYear + 1).toString()];
        for (let i = 0; i < 12; i++) {
            const monthName = new Date(2024, i).toLocaleDateString(this.locale, { month: 'short' });
            this.yearViewMonthList.push(monthName);
        }
    }
    updateDisplayedYearList(increment) {
        this.yearViewYearsList = this.yearViewYearsList.map((year) => {
            return (Number(year) + increment).toString();
        });
    }
    updateDisplayedHeader(type, value) {
        var _a;
        let updatedDate;
        if (type === 'year') {
            updatedDate = { year: value };
        }
        if (type === 'month') {
            const monthDate = new Date(`${value} 1`);
            const monthValue = monthDate.toLocaleDateString(this.locale, { month: 'numeric' });
            updatedDate = { month: Number(monthValue) - 1 };
            // Close the year view if month is selected
            this.toggleCaret();
        }
        const currentDisplayedDate = new Date(this.displayedDate);
        // Handles case where month is January, represented by 0
        const checkedMonth = (_a = updatedDate === null || updatedDate === void 0 ? void 0 : updatedDate.month) !== null && _a !== void 0 ? _a : currentDisplayedDate.getMonth();
        const day = new Date(updatedDate.year || currentDisplayedDate.getFullYear(), checkedMonth, 1).toISOString();
        this.displayedDate = day;
    }
    componentWillLoad() {
        if (this.presetMenuOption) {
            this._setMenuRowOption(this.presetMenuOption);
        }
        this.buildInitialYearView();
        this.datePickerLabel = `date-picker-label-${v4()}`;
    }
    /**
     * Core function called whenever props or states are changed to update the calendar view.
     */
    componentWillRender() {
        this.validateDisplayedDate(this.displayedDate);
        this.displayedMonth = new Date(this.displayedDate).toLocaleString(this.locale, { month: 'short', year: 'numeric' });
        this.buildWeekdays();
        this.buildCalendar();
    }
    render() {
        const MarketDatePickerMenuTagName = getNamespacedTagFor('market-date-picker-menu');
        const MarketDatePickerDateTagName = getNamespacedTagFor('market-date-picker-date');
        const MarketDatePickerInputDateTagName = getNamespacedTagFor('market-date-picker-input-date');
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        const MarketDividerTagName = getNamespacedTagFor('market-divider');
        // TODO: remove when design tokens are added (UI-6454)
        const DATE_PICKER_BUTTON_PREVIOUS_YEAR_ICON_ASSET = 'chevron-left';
        const DATE_PICKER_BUTTON_NEXT_YEAR_ICON_ASSET = 'chevron-right';
        const DATE_PICKER_BUTTON_PREVIOUS_MONTH_ICON_ASSET = 'arrow-left';
        const DATE_PICKER_BUTTON_NEXT_MONTH_ICON_ASSET = 'arrow-right';
        return (hAsync(Host, { key: 'c78a7b05df332b7aa06423aed1ed30275e618bc0', class: "market-date-picker" }, this.displayMenu && (hAsync("list-view", { key: 'ac0a38b70c298576e139cf9d276424b8d31ab7af' }, hAsync(MarketDatePickerMenuTagName, { key: 'f95cc5ab86f56d1a414553371fbfa16c8d37c0af', timeframe: this.timeframe, excludeMenuItems: this.excludeMenuItems, presetMenuOption: this.presetMenuOption }, hAsync("slot", { key: '3cc5b7756b2b5a5e1d79a0f630c9b9c5fb61dba5', name: MENU_SLOT_NAMES.TODAY, slot: MENU_SLOT_NAMES.TODAY }, "Today"), hAsync("slot", { key: 'dcd99d9668b7f6ecfed93e37a3074208ce33f6d1', name: MENU_SLOT_NAMES.YESTERDAY, slot: MENU_SLOT_NAMES.YESTERDAY }, "Yesterday"), hAsync("slot", { key: '01b404c3d5ed89bb69e3e5ede661308d1937d6ef', name: MENU_SLOT_NAMES.THIS_WEEK, slot: MENU_SLOT_NAMES.THIS_WEEK }, "This week"), hAsync("slot", { key: '1037a8b6ed5b53ff442fe33c22a038551cfb7666', name: MENU_SLOT_NAMES.LAST_WEEK, slot: MENU_SLOT_NAMES.LAST_WEEK }, "Last week"), hAsync("slot", { key: '1ae37f2beab8500d77bc9047249f2818c8679df9', name: MENU_SLOT_NAMES.THIS_MONTH, slot: MENU_SLOT_NAMES.THIS_MONTH }, "This month"), hAsync("slot", { key: '5aa7900479c4f236ca93614e1d992c147f5adf4c', name: MENU_SLOT_NAMES.LAST_MONTH, slot: MENU_SLOT_NAMES.LAST_MONTH }, "Last month"), hAsync("slot", { key: 'd64f498efa100bcf1375c1754a396fa90d8f33a4', name: MENU_SLOT_NAMES.THIS_YEAR, slot: MENU_SLOT_NAMES.THIS_YEAR }, "This year"), hAsync("slot", { key: 'a265f8265ab43a52080a0fee70d86eaf1faf7cb0', name: MENU_SLOT_NAMES.LAST_YEAR, slot: MENU_SLOT_NAMES.LAST_YEAR }, "Last year"), hAsync("slot", { key: 'a8f9eab3bf9fcc47932e3298f01fa3b623d781c7', name: MENU_SLOT_NAMES.CUSTOM, slot: MENU_SLOT_NAMES.CUSTOM }, "Custom")))), hAsync("calendar", { key: '74306dc7f74bf8ab987aa8bcfd052ca0cf218b5a' }, hAsync("header", { key: '4bde0079d12ac3c1290260eb9526e30b3ac30710' }, hAsync("nav", { key: '33a1fe6d6a15b50d461241106c2b2d035be49529' }, !this.yearViewActive && (hAsync(MarketButtonTagName, { key: 'ba20533947d6c6dee2a3069fef4bf9e3600471dd', class: "left-nav", size: "small", "aria-label": "Previous month", onClick: () => this.navigateMonth(-1) }, hAsync(MarketIconTagName, { key: 'ca3ecb61171ff64efce990de4353fa6be2b4e398', slot: "icon", name: DATE_PICKER_BUTTON_PREVIOUS_MONTH_ICON_ASSET }))), hAsync(MarketButtonTagName, { key: '60a7f627185b9c0d6bf3af21eb8467be6ea8570d', class: "year-view-button", "aria-label": 'Toggle year view', onClick: () => this.toggleCaret(), caret: this.yearViewActive ? 'up' : 'down', rank: "tertiary" }, hAsync("h2", { key: '09150c4c973668a250052523c621bd3bc0de9c44', id: this.datePickerLabel }, this.displayedMonth)), !this.yearViewActive && (hAsync(MarketButtonTagName, { key: '93f69cba83dee974a878176b9a38b39b37f3212d', size: "small", "aria-label": "Next month", onClick: () => this.navigateMonth(1) }, hAsync(MarketIconTagName, { key: '4f4a71fac7f937b7786331b23b05d5d24a68bf58', slot: "icon", name: DATE_PICKER_BUTTON_NEXT_MONTH_ICON_ASSET }))))), !this.yearViewActive && (hAsync("month-view", { key: 'fc0709e315caf71fb7674aa1954d8e51102d16c6', role: "grid", "aria-labelledby": this.datePickerLabel }, 
        // Set the weekdays header for the date picker calendar
        this.displayedWeekdays.map((text) => (hAsync(MarketDatePickerDateTagName, { class: 'weekday-header', disabled: true, day: text }))), 
        // Set the available dates
        this.days.map((day) => (hAsync(MarketDatePickerDateTagName, { disabled: day.disabled, selection: day.selection, today: day.today, selected: day.selected, day: day.date || null, type: "day" }))))), this.yearViewActive && (hAsync("year-view", { key: '6cdd043108fedfd459815f538c693d0bd4e8f75b', "aria-labelledby": this.datePickerLabel }, hAsync("year-section", { key: '80534d9d3973be8708d224efde75a84ed167f9a7' }, hAsync(MarketButtonTagName, { key: '6724cb67424c6c25df2fd43a098bd7a065112f78', size: "small", rank: "tertiary", "aria-label": "Previous year", onClick: () => this.updateDisplayedYearList(-1) }, hAsync(MarketIconTagName, { key: 'f06c2e8ae425af9690325352dadece71761059cb', slot: "icon", name: DATE_PICKER_BUTTON_PREVIOUS_YEAR_ICON_ASSET })), this.yearViewYearsList.map((year) => (hAsync(MarketDatePickerDateTagName, { day: year, type: "year" }))), hAsync(MarketButtonTagName, { key: '47818e59632afab8f514f691b6df885ac27dcad0', size: "small", rank: "tertiary", "aria-label": "Next year", onClick: () => this.updateDisplayedYearList(1) }, hAsync(MarketIconTagName, { key: '6a5d4cc241a1fccc5276a719cb30a03478fa6884', slot: "icon", name: DATE_PICKER_BUTTON_NEXT_YEAR_ICON_ASSET }))), hAsync(MarketDividerTagName, { key: 'a2532c37506458317c88f2e1a134a7adaa9104d5', size: "thin" }), hAsync("month-section", { key: 'f48b27b6528a2ff1f53e78b31f9cf8383f9fe7bf', role: "grid" }, this.yearViewMonthList.map((monthName) => (hAsync(MarketDatePickerDateTagName, { day: monthName, type: "month" })))))), this.withInputs && (hAsync(MarketDatePickerInputDateTagName, { key: '57aed426810970887e893dd8d60c28bda6b02663', class: "date-input-top-margin", range: this.selectionType === 'range', isDateDisabled: this.isDateDisabled, selectedStartDate: this.selectedStartDate, selectedEndDate: this.selectedEndDate, withTime: this.withInputs === 'date-and-time', timeframe: this.timeframe }, hAsync("slot", { key: '304e7f7e99bf489c7853cd9f623fc9399f508c45', name: "start-date", slot: "start-date" }, this.selectionType === 'range' ? 'Start ' : '', "Date"), hAsync("slot", { key: '5a738f898bdca337206719367b81288c5b20f991', name: "end-date", slot: "end-date" }, "End Date"), hAsync("slot", { key: '2a0606961a10798604f47e0bb0a31237187bd2f1', name: "start-time", slot: "start-time" }, this.selectionType === 'range' ? 'Start ' : '', "Time"), hAsync("slot", { key: '3027c801069e38f923baa0ac2d91d83b0d74d3a2', name: "end-time", slot: "end-time" }, "End Time"), hAsync("slot", { key: '21026dbc719cafd2109f3c31b9553628ada54480', name: "range-error", slot: "range-error" }, "Enter a valid date range"))))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketDatePickerStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-date-picker",
        "$members$": {
            "selectionType": [1, "selection-type"],
            "selectedStartDate": [1537, "selected-start-date"],
            "selectedEndDate": [1537, "selected-end-date"],
            "presetMenuOption": [1, "preset-menu-option"],
            "displayMenu": [4, "display-menu"],
            "mobileMenuPosition": [513, "mobile-menu-position"],
            "excludeMenuItems": [1, "exclude-menu-items"],
            "timeframe": [1],
            "isDateDisabled": [16],
            "locale": [1],
            "displayedDate": [1025, "displayed-date"],
            "withInputs": [1537, "with-inputs"],
            "invalid": [1540],
            "yearViewActive": [1540, "year-view-active"],
            "displayedMonth": [32],
            "displayedWeekdays": [32],
            "yearViewYearsList": [32],
            "hoveredDate": [32]
        },
        "$listeners$": [[0, "marketDatePickerInputDateSet", "dateInputDateSet"], [0, "marketDatePickerDateSelected", "selectDate"], [0, "marketDatePickerDateMousedOver", "hoverDate"], [0, "marketDatePickerDateMousedOut", "mousedOutDate"], [0, "marketDatePickerMenuSelectionChanged", "selectMenuRow"], [0, "marketDatePickerInputDateInvalidStateChanged", "setInvalidState"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selectedStartDate", "selected-start-date"], ["selectedEndDate", "selected-end-date"], ["mobileMenuPosition", "mobile-menu-position"], ["withInputs", "with-inputs"], ["invalid", "invalid"], ["yearViewActive", "year-view-active"]]
    }; }
}

const marketDatePickerDateCss = "/*!@:host(:not([day]))*/.sc-market-date-picker-date-h:not([day]){border-width:0 !important;border-radius:0 !important;background-color:rgb(0 0 0 / 0%) !important;color:rgb(0 0 0 / 0%) !important;pointer-events:none !important}/*!@:host*/.sc-market-date-picker-date-h{display:inline-flex;flex-direction:row;justify-content:center;align-items:center;width:100%;min-width:var(--date-picker-grid-item-width);height:var(--date-picker-grid-item-height);padding:0;font-size:var(--date-picker-weekdays-font-size);line-height:var(--date-picker-weekdays-font-leading);text-align:center}/*!@:host([disabled])*/[disabled].sc-market-date-picker-date-h{color:var(--date-picker-date-text-unselected-selection-disabled-state-color);cursor:not-allowed}/*!@:host(.weekday-header)*/.weekday-header.sc-market-date-picker-date-h{color:var(--date-picker-weekdays-color-color);cursor:auto}/*!@:host(:not([selection='range-middle']:not([today])))*/(.sc-market-date-picker-date-h:not([selection='range-middle']:not([today]))){border-radius:var(--date-picker-date-border-radius)}/*!@:host([selection='none']:not([disabled]))*/[selection='none'].sc-market-date-picker-date-h:not([disabled]){color:var(--date-picker-date-text-unselected-selection-normal-state-color)}/*!@:host([selection='single'][selected]), :host([selection='range-first'][selected]), :host([selection='range-last'][selected])*/[selection='single'][selected].sc-market-date-picker-date-h,[selection='range-first'][selected].sc-market-date-picker-date-h,[selection='range-last'][selected].sc-market-date-picker-date-h{background-color:var(--date-picker-date-background-single-selection-normal-state-color);color:var(--date-picker-date-text-single-selection-disabled-state-color)}/*!@:host([selection='single'][disabled][selected]), :host([selection='range-first'][disabled][selected]), :host([selection='range-last'][disabled][selected])*/[selection='single'][disabled][selected].sc-market-date-picker-date-h,[selection='range-first'][disabled][selected].sc-market-date-picker-date-h,[selection='range-last'][disabled][selected].sc-market-date-picker-date-h{background-color:var(--date-picker-date-background-single-selection-disabled-state-color);color:var(--date-picker-date-text-single-selection-disabled-state-color)}/*!@:host(:hover[selection='range-first']:not([selected]):not([today])), :host(:active[selection='range-first']:not([selected]):not([today]))*/.sc-market-date-picker-date-h:hover[selection='range-first']:not([selected]):not([today]),.sc-market-date-picker-date-h:active[selection='range-first']:not([selected]):not([today]){--date-picker-date-range-first-selection-border-radius-top-left:var(--date-picker-date-border-radius);--date-picker-date-range-first-selection-border-radius-top-right:0;--date-picker-date-range-first-selection-border-radius-bottom-right:0;--date-picker-date-range-first-selection-border-radius-bottom-left:var(--date-picker-date-border-radius);border-radius:var(--date-picker-date-range-first-selection-border-radius-top-left)\n      var(--date-picker-date-range-first-selection-border-radius-top-right)\n      var(--date-picker-date-range-first-selection-border-radius-bottom-right)\n      var(--date-picker-date-range-first-selection-border-radius-bottom-left)}/*!@:host([selection='range-middle']:not([disabled]))*/[selection='range-middle'].sc-market-date-picker-date-h:not([disabled]){background-color:var(--date-picker-date-background-range-middle-selection-hover-state-color);color:var(--date-picker-date-text-range-middle-selection-hover-state-color)}/*!@:host([selection='range-middle'][selected])*/[selection='range-middle'][selected].sc-market-date-picker-date-h{background-color:var(--date-picker-date-background-range-middle-selection-normal-state-color)}/*!@:host([selection='range-middle'][disabled][today])*/[selection='range-middle'][disabled][today].sc-market-date-picker-date-h{border-color:var(--date-picker-date-border-disabled-state-color-color)}/*!@:host(:hover[selection='range-last']:not([selected]):not([today])), :host(:active[selection='range-last']:not([selected]):not([today]))*/.sc-market-date-picker-date-h:hover[selection='range-last']:not([selected]):not([today]),.sc-market-date-picker-date-h:active[selection='range-last']:not([selected]):not([today]){--date-picker-date-range-last-selection-border-radius-top-left:0;--date-picker-date-range-last-selection-border-radius-top-right:var(--date-picker-date-border-radius);--date-picker-date-range-last-selection-border-radius-bottom-right:var(--date-picker-date-border-radius);--date-picker-date-range-last-selection-border-radius-bottom-left:0;border-radius:var(--date-picker-date-range-last-selection-border-radius-top-left)\n      var(--date-picker-date-range-last-selection-border-radius-top-right)\n      var(--date-picker-date-range-last-selection-border-radius-bottom-right)\n      var(--date-picker-date-range-last-selection-border-radius-bottom-left)}/*!@:host([today])*/[today].sc-market-date-picker-date-h{box-sizing:border-box;border-width:calc(var(--date-picker-today-border-width) * 1px);border-style:solid;border-radius:var(--date-picker-date-border-radius);font-weight:var(--date-picker-today-font-weight)}/*!@:host([today]:not([disabled]))*/[today].sc-market-date-picker-date-h:not([disabled]){border-color:var(--date-picker-today-border-color-color)}/*!@:host([today][disabled])*/[today][disabled].sc-market-date-picker-date-h{color:var(--date-picker-today-label-disabled-state-color-color)}/*!@:host(:hover:not([disabled]))*/.sc-market-date-picker-date-h:hover:not([disabled]){cursor:pointer}/*!@:host(:hover:not([disabled]):not([selected]))*/.sc-market-date-picker-date-h:hover:not([disabled]):not([selected]){background-color:var(--date-picker-date-background-unselected-selection-hover-state-color);color:var(--date-picker-date-text-unselected-selection-hover-state-color)}/*!@:host(:active:not([disabled]):not([selected]))*/.sc-market-date-picker-date-h:active:not([disabled]):not([selected]){background-color:var(--date-picker-date-background-unselected-selection-pressed-state-color);color:var(--date-picker-date-text-unselected-selection-pressed-state-color)}";
var MarketDatePickerDateStyle0 = marketDatePickerDateCss;

class MarketDatePickerDate {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDatePickerDateSelected = createEvent(this, "marketDatePickerDateSelected", 7);
        this.marketDatePickerDateMousedOver = createEvent(this, "marketDatePickerDateMousedOver", 7);
        this.marketDatePickerDateMousedOut = createEvent(this, "marketDatePickerDateMousedOut", 7);
        this.disabled = false;
        this.selection = 'none';
        this.today = false;
        this.selected = false;
        this.day = undefined;
        this.type = undefined;
    }
    /**
     * Interaction handler that passes events back to the market-date-picker component
     */
    handleInteraction(e) {
        var _a;
        if (this.disabled || ((_a = this.day) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            e.stopImmediatePropagation();
            return;
        }
        const isKeyboardEnter = e instanceof KeyboardEvent && e.type === 'keydown' && e.key === 'Enter';
        if (e.type === 'click' || isKeyboardEnter) {
            this.marketDatePickerDateSelected.emit({ date: this.el });
        }
        if (e.type === 'mouseover') {
            this.marketDatePickerDateMousedOver.emit({ date: this.el });
        }
        if (e.type === 'mouseout') {
            this.marketDatePickerDateMousedOut.emit();
        }
    }
    render() {
        return (hAsync(Host, { key: '4a7621e744a0ecf6b77dc02b8d73fec0f311c51a', class: "market-date-picker-date", role: this.disabled || !this.day ? undefined : 'button', tabindex: this.disabled || !this.day ? -1 : 0, "aria-disabled": this.disabled, onClick: (e) => {
                this.handleInteraction(e);
            }, onmouseover: (e) => {
                this.handleInteraction(e);
            }, onmouseout: (e) => {
                this.handleInteraction(e);
            }, onkeydown: (e) => {
                this.handleInteraction(e);
            } }, this.day));
    }
    get el() { return getElement(this); }
    static get style() { return MarketDatePickerDateStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-date-picker-date",
        "$members$": {
            "disabled": [516],
            "selection": [513],
            "today": [516],
            "selected": [516],
            "day": [513],
            "type": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["selection", "selection"], ["today", "today"], ["selected", "selected"], ["day", "day"], ["type", "type"]]
    }; }
}

const marketDatePickerMenuCss = "/*!@:host*/.sc-market-date-picker-menu-h{display:block;margin-right:var(--date-picker-menu-horizontal-spacing);font-weight:var(--date-picker-menu-text-weight);font-size:var(--date-picker-menu-text-size);line-height:var(--date-picker-menu-text-leading)}/*!@:host > .market-list > .market-row*/.sc-market-date-picker-menu-h>.market-list.sc-market-date-picker-menu>.market-row.sc-market-date-picker-menu{min-height:var(--date-picker-menu-row-height);padding:0 12px}/*!@:host > .market-list > .market-row::before*/.sc-market-date-picker-menu-h>.market-list.sc-market-date-picker-menu>.market-row.sc-market-date-picker-menu::before{content:none}/*!@:host > .market-list > .market-row::part(container)*/.sc-market-date-picker-menu-h>.market-list.sc-market-date-picker-menu>.market-row.sc-market-date-picker-menu::part(container){padding-right:0;padding-left:0}/*!@:host > .market-list > .market-row[selected]*/.sc-market-date-picker-menu-h>.market-list.sc-market-date-picker-menu>.market-row[selected].sc-market-date-picker-menu{color:var(--date-picker-menu-row-label-selected-state-text-color)}@media only screen and (max-width: 800px){/*!@:host*/.sc-market-date-picker-menu-h{margin-right:0}/*!@:host > .market-list > .market-row*/.sc-market-date-picker-menu-h>.market-list.sc-market-date-picker-menu>.market-row.sc-market-date-picker-menu{width:inherit}}";
var MarketDatePickerMenuStyle0 = marketDatePickerMenuCss;

/**
 * @slot 'today' - slot for market date picker menu today option;
 * @slot 'yesterday' - slot for market date picker menu yesterday option;
 * @slot 'this-week' - slot for market date picker menu this week option;
 * @slot 'last-week' - slot for market date picker menu last week option;
 * @slot 'this-month' - slot for market date picker menu this month option;
 * @slot 'last-month' - slot for market date picker menu last month option;
 * @slot 'this-year' - slot for market date picker menu this year option;
 * @slot 'last-year' - slot for market date picker menu last year option;
 * @slot 'custom' - slot for market date picker menu custom option;
 */
class MarketDatePickerMenu {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDatePickerMenuSelectionChanged = createEvent(this, "marketDatePickerMenuSelectionChanged", 7);
        this.timeframe = 'present';
        this.excludeMenuItems = '';
        this.presetMenuOption = undefined;
    }
    handleMarketListSelectionsDidChange(e) {
        e.stopPropagation();
        this.marketDatePickerMenuSelectionChanged.emit({
            menuSelection: e.detail.newSelectionValue,
        });
    }
    /**
     * Method to visually select Custom row for use by the date picker component
     * (internal use only)
     */
    _selectCustomRow() {
        const MarketRowTagName = getNamespacedTagFor('market-row');
        this.el.shadowRoot.querySelectorAll(MarketRowTagName).forEach((row) => {
            if (row.querySelector('slot').name === MENU_SLOT_NAMES.CUSTOM) {
                row.click();
            }
        });
        return Promise.resolve();
    }
    render() {
        const MarketListTagName = getNamespacedTagFor('market-list');
        const MarketRowTagName = getNamespacedTagFor('market-row');
        const excludedItems = this.excludeMenuItems.split(',');
        return (hAsync(Host, { key: '6090ec920f710ad17233bc061600f108bc13fff6', class: "market-date-picker-menu" }, hAsync(MarketListTagName, { key: '3473a573abe914accc731ff4d97cfe166248087c', interactive: true }, this.timeframe !== 'past' && !excludedItems.includes(MENU_SLOT_NAMES.TODAY) && (hAsync(MarketRowTagName, { key: 'eedc051737dc15a743af020751cef2c37271bff7', value: MENU_SLOT_NAMES.TODAY, selected: this.presetMenuOption === MENU_SLOT_NAMES.TODAY }, hAsync("slot", { key: 'd782a493549f936b7a71c9ecd39ff67ad1c88d70', name: MENU_SLOT_NAMES.TODAY }, "Today"))), this.timeframe !== 'future' && !excludedItems.includes(MENU_SLOT_NAMES.YESTERDAY) && (hAsync(MarketRowTagName, { key: '72521a7e96473e55de174166ff6afa46fd383f2f', value: MENU_SLOT_NAMES.YESTERDAY, selected: this.presetMenuOption === MENU_SLOT_NAMES.YESTERDAY }, hAsync("slot", { key: 'db259f0d8269deb3fad87b4b2bcad6cd9867034c', name: MENU_SLOT_NAMES.YESTERDAY }, "Yesterday"))), this.timeframe !== 'past' && !excludedItems.includes(MENU_SLOT_NAMES.THIS_WEEK) && (hAsync(MarketRowTagName, { key: '8660bc56922d1e2bcd14269659bd462749eba341', value: MENU_SLOT_NAMES.THIS_WEEK, selected: this.presetMenuOption === MENU_SLOT_NAMES.THIS_WEEK }, hAsync("slot", { key: 'dfeb980290086dcc8d8f7201502239bbd51fa260', name: MENU_SLOT_NAMES.THIS_WEEK }, "This week"))), this.timeframe !== 'future' && !excludedItems.includes(MENU_SLOT_NAMES.LAST_WEEK) && (hAsync(MarketRowTagName, { key: '776ed0ad2290ec60c57a55f9ae4010754c8c4acb', value: MENU_SLOT_NAMES.LAST_WEEK, selected: this.presetMenuOption === MENU_SLOT_NAMES.LAST_WEEK }, hAsync("slot", { key: '9409f941203c9c46135301df12375494b3f3f28d', name: MENU_SLOT_NAMES.LAST_WEEK }, "Last week"))), this.timeframe !== 'past' && !excludedItems.includes(MENU_SLOT_NAMES.THIS_MONTH) && (hAsync(MarketRowTagName, { key: 'fc732ad76d322f0ad329880e6603132917deb408', value: MENU_SLOT_NAMES.THIS_MONTH, selected: this.presetMenuOption === MENU_SLOT_NAMES.THIS_MONTH }, hAsync("slot", { key: '43ffecd94558b942b89c55876591e0cbe2f66d86', name: MENU_SLOT_NAMES.THIS_MONTH }, "This month"))), this.timeframe !== 'future' && !excludedItems.includes(MENU_SLOT_NAMES.LAST_MONTH) && (hAsync(MarketRowTagName, { key: 'e0ee3686874390121ac5d869eb0c913845ee4ad7', value: MENU_SLOT_NAMES.LAST_MONTH, selected: this.presetMenuOption === MENU_SLOT_NAMES.LAST_MONTH }, hAsync("slot", { key: 'b1f4ebffed7e3c4e7a7694b092d6e9aac358d81b', name: MENU_SLOT_NAMES.LAST_MONTH }, "Last month"))), this.timeframe !== 'past' && !excludedItems.includes(MENU_SLOT_NAMES.THIS_YEAR) && (hAsync(MarketRowTagName, { key: 'cfadc74f7f5dc2e690069586e32741b0cf0cccfe', value: MENU_SLOT_NAMES.THIS_YEAR, selected: this.presetMenuOption === MENU_SLOT_NAMES.THIS_YEAR }, hAsync("slot", { key: 'bfc37f3ddc5714a1f3712659f84bac997e6e342b', name: MENU_SLOT_NAMES.THIS_YEAR }, "This year"))), this.timeframe !== 'future' && !excludedItems.includes(MENU_SLOT_NAMES.LAST_YEAR) && (hAsync(MarketRowTagName, { key: 'e78f7a5172c0bfb5981a7406b4c72f97ea982fea', value: MENU_SLOT_NAMES.LAST_YEAR, selected: this.presetMenuOption === MENU_SLOT_NAMES.LAST_YEAR }, hAsync("slot", { key: 'ef34c7825b2caff5958fb3555bb2f7acd9345876', name: MENU_SLOT_NAMES.LAST_YEAR }, "Last year"))), !excludedItems.includes(MENU_SLOT_NAMES.CUSTOM) && (hAsync(MarketRowTagName, { key: 'b21974f32253bf276e7338a6cfabcdcbdfbe0c88', value: MENU_SLOT_NAMES.CUSTOM, selected: this.presetMenuOption === MENU_SLOT_NAMES.CUSTOM }, hAsync("slot", { key: '4c6281b3a79f0d24d278b023fe52449b459bac11', name: MENU_SLOT_NAMES.CUSTOM }, "Custom"))))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketDatePickerMenuStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-date-picker-menu",
        "$members$": {
            "timeframe": [513],
            "excludeMenuItems": [1, "exclude-menu-items"],
            "presetMenuOption": [1, "preset-menu-option"],
            "_selectCustomRow": [64]
        },
        "$listeners$": [[0, "marketListSelectionsDidChange", "handleMarketListSelectionsDidChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["timeframe", "timeframe"]]
    }; }
}

const marketDialogCss = "/*!@:host, ::slotted(*), **/.sc-market-dialog-h,.sc-market-dialog-s>*,*.sc-market-dialog{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-dialog-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-dialog-h *.sc-market-dialog,.sc-market-dialog-h[disabled].sc-market-dialog-s>*,.sc-market-dialog-h[disabled] .sc-market-dialog-s>*{cursor:not-allowed !important;pointer-events:none !important}@keyframes market-popup{from{opacity:0%;transform:scale(0.9, 0.9)}to{opacity:100%;transform:scale(1, 1)}}@keyframes market-popdown{from{opacity:100%;transform:scale(1, 1)}to{opacity:0%;transform:scale(0.9, 0.9)}}@keyframes market-slideup{from{opacity:0%;transform:translateY(80vh)}to{opacity:100%;transform:translateY(0)}}@keyframes market-slidedown{from{opacity:100%;transform:translateY(0)}to{opacity:0%;transform:translateY(80vh)}}@keyframes market-slide-left-enter{from{transform:translateX(100%)}to{transform:translateX(0)}}@keyframes market-slide-left-exit{from{transform:translateX(0)}to{transform:translateX(100%)}}@keyframes market-fade-in{from{opacity:0%}to{opacity:100%}}@keyframes market-fade-out{from{opacity:100%}to{opacity:0%}}@keyframes market-input-autofill-start{from{}to{}}@keyframes market-input-autofill-cancel{from{}to{}}@keyframes market-input-search-compact-enter{from{}to{}}@keyframes market-input-search-compact-exit{from{}to{}}/*!@:host*/.sc-market-dialog-h{display:flex;flex-direction:column;justify-content:stretch;overflow:hidden}/*!@:host ::slotted(main), :host ::slotted(.main)*/.sc-market-dialog-h .sc-market-dialog-s>main,.sc-market-dialog-h.sc-market-dialog-s>.main,.sc-market-dialog-h .sc-market-dialog-s>.main{flex:0 1 100%;overflow-y:auto;height:100%}/*!@:host ::slotted(.market-header)*/.sc-market-dialog-h .sc-market-dialog-s>.market-header{margin-bottom:var(--core-metrics-spacing-300);padding-top:0}/*!@:host ::slotted(.market-footer)*/.sc-market-dialog-h .sc-market-dialog-s>.market-footer{padding-bottom:0}/*!@:host*/.sc-market-dialog-h{--modal-dialog-width:var(--modal-dialog-maximum-width-size);--modal-dialog-horizontal-padding-size:var(--modal-dialog-compact-horizontal-size-class-horizontal-padding);--modal-dialog-vertical-padding-size:var(--modal-dialog-compact-vertical-size-class-vertical-padding);width:var(--modal-dialog-width);max-width:var(--modal-dialog-width);padding:var(--modal-dialog-vertical-padding-size)\n    var(--modal-dialog-horizontal-padding-size);border-radius:var(--modal-dialog-border-radius);background-color:var(--modal-dialog-background-color);animation:var(--modal-dialog-animation-enter-transition-duration)\n    market-popup\n    forwards\n    var(--modal-dialog-animation-enter-transition-easing)}/*!@:host([hidden])*/[hidden].sc-market-dialog-h{animation-name:market-popdown;animation-duration:var(--modal-dialog-animation-exit-transition-duration);animation-timing-function:var(--modal-dialog-animation-exit-transition-easing)}/*!@:host([value=\"loadingMode\"])*/[value=\"loadingMode\"].sc-market-dialog-h{display:flex;flex-direction:column}/*!@::slotted(.market-footer)*/.sc-market-dialog-s>.market-footer{padding-top:var(--modal-dialog-regular-vertical-size-class-vertical-padding)}/*!@.market-activity-indicator*/.market-activity-indicator.sc-market-dialog{align-self:flex-start;margin-bottom:var(--core-metrics-spacing-200)}@media only screen and (min-width: 600px){/*!@:host*/.sc-market-dialog-h{--modal-dialog-horizontal-padding-size:var(--modal-dialog-regular-horizontal-size-class-horizontal-padding);--modal-dialog-vertical-padding-size:var(--modal-dialog-regular-vertical-size-class-vertical-padding)}}@media only screen and (min-width: 1200px){/*!@:host*/.sc-market-dialog-h{--modal-dialog-horizontal-padding-size:var(--modal-dialog-wide-horizontal-size-class-horizontal-padding);--modal-dialog-vertical-padding-size:var(--modal-dialog-wide-vertical-size-class-vertical-padding, 32px)}}";
var MarketDialogStyle0 = marketDialogCss;

/**
 * @slot - The main content of the dialog. Use `<section class="main">` tag.
 */
class MarketDialog {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDialogLoaded = createEvent(this, "marketDialogLoaded", 7);
        this.marketDialogDismissed = createEvent(this, "marketDialogDismissed", 7);
        this.marketDialogDidDismiss = createEvent(this, "marketDialogDidDismiss", 7);
        this.type = 'dialog';
        this.hidden = false;
        this.dialogID = undefined;
        this.index = undefined;
        this.isLoading = false;
        this.persistent = false;
        this.trapFocus = false;
        this.animationEnterDuration = cjs.MODAL_DIALOG_ANIMATION_ENTER_TRANSITION_DURATION;
        this.animationExitDuration = cjs.MODAL_DIALOG_ANIMATION_EXIT_TRANSITION_DURATION;
    }
    /**
     * Emits the dismiss event
     * The parent context will handle actually removing elements from the DOM,
     * All the dialog needs to do it emit an event so actually closing it can be
     * some other elements problem
     */
    dismiss(dismissOptions) {
        if (!this.persistent) {
            const { defaultPrevented } = this.marketDialogDismissed.emit({
                dialog: this.el,
                type: this.type,
                origin: (dismissOptions === null || dismissOptions === void 0 ? void 0 : dismissOptions.origin) || this.el,
            });
            if (!defaultPrevented) {
                this.hidden = true;
                /**
                 * Emit a marketDialogDidDismiss event when modal gets fully dismissed (after animation).
                 */
                setTimeout(() => {
                    this.marketDialogDidDismiss.emit({
                        dialog: this.el,
                        type: this.type,
                        origin: this.el,
                    });
                }, this.animationExitDuration);
            }
        }
        return Promise.resolve();
    }
    onTrapFocusChanged(newValue, oldValue) {
        // only activate/deactivate when the `trapFocus` prop value changes
        if (newValue !== oldValue) {
            if (newValue) {
                this.activateFocusTrap();
            }
            else {
                this.deactivateFocusTrap();
            }
        }
    }
    /**
     * Activates the focus trap
     *
     * See [`focus-trap.ts`](../../utils/focus-trap.ts) for default options
     *
     * @param {Object} [options] [focus-trap create options](https://github.com/focus-trap/focus-trap#createoptions)
     * @param {Object} [activateOptions] set options for [onActivate, onPostActivate, and checkCanFocusTrap](https://github.com/focus-trap/focus-trap#trapactivate)
     */
    activateFocusTrap(options, activateOptions) {
        if (this.focusTrap) {
            this.focusTrap.activate(activateOptions !== null && activateOptions !== void 0 ? activateOptions : {});
            if (!this.trapFocus) {
                this.trapFocus = true;
            }
        }
        else {
            this.focusTrap = createAndActivateFocusTrap({
                activateOptions,
                el: this.el,
                options,
            });
        }
        return Promise.resolve();
    }
    /**
     * Deactivates the focus trap
     *
     * @param {FocusTrapDeactivateOptions} [deactivateOptions] set options for [onDeactivate, onPostDeactivate, and checkCanReturnFocus](https://github.com/focus-trap/focus-trap#trapdeactivate)
     */
    deactivateFocusTrap(deactivateOptions) {
        if (this.focusTrap) {
            this.focusTrap.deactivate(Object.assign({ returnFocus: true, checkCanReturnFocus: (trigger) => new Promise((resolve) => {
                    if (typeof (trigger === null || trigger === void 0 ? void 0 : trigger.setFocus) === 'function') {
                        trigger.setFocus();
                    }
                    else {
                        resolve(); // node.focus(); will be called by focus-trap
                    }
                }) }, deactivateOptions));
            this.focusTrap = undefined;
        }
        return Promise.resolve();
    }
    removeTopMarginOfFirstHeading() {
        const headings = this.el.querySelectorAll('h1, h2, h3, h4, h5, h6');
        if (headings.length > 0) {
            headings[0].style.marginTop = '0';
        }
    }
    handleSlotchange() {
        this.removeTopMarginOfFirstHeading();
    }
    connectedCallback() {
        this.connectedCallbackTimeout = setTimeout(() => {
            /**
             * Emit a marketDialogLoaded event when the component connects. Need this so
             * the context manager isn't rummaging around it's DOM to try and find the
             * dialog that was just appended
             */
            this.marketDialogLoaded.emit({
                dialog: this.el,
                type: this.type,
            });
            if (this.trapFocus) {
                this.activateFocusTrap();
            }
        }, this.animationEnterDuration);
        this.handleSlotchange();
    }
    disconnectedCallback() {
        this.deactivateFocusTrap();
        /**
         * Prevents error caused by race conditions during rapid mounting and
         * unmounting of component by clearing the setTimeout from connectedCallback
         * if it gets called after disconnectedCallback.
         */
        clearTimeout(this.connectedCallbackTimeout);
    }
    render() {
        const MarketActivityIndicatorTagName = getNamespacedTagFor('market-activity-indicator');
        return (hAsync(Host, { key: '7da7425983b6355851687256e2dc66d205f316ed', class: "market-dialog", role: "dialog" }, this.isLoading && hAsync(MarketActivityIndicatorTagName, { key: '474cdfa415c07cf3c9e0cff7a0d0584f4b837386' }), hAsync("slot", { key: 'f26ca73aa2034db72a0c075051f89c7e95dcfeea', onSlotchange: this.handleSlotchange.bind(this) })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "trapFocus": ["onTrapFocusChanged"]
    }; }
    static get style() { return MarketDialogStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-dialog",
        "$members$": {
            "hidden": [1540],
            "dialogID": [513, "data-dialog-id"],
            "index": [514, "data-dialog-index"],
            "isLoading": [4, "is-loading"],
            "persistent": [516],
            "trapFocus": [1028, "trap-focus"],
            "animationEnterDuration": [2, "animation-enter-duration"],
            "animationExitDuration": [2, "animation-exit-duration"],
            "dismiss": [64],
            "activateFocusTrap": [64],
            "deactivateFocusTrap": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"], ["dialogID", "data-dialog-id"], ["index", "data-dialog-index"], ["persistent", "persistent"]]
    }; }
}

const marketDividerCss = "/*!@:host*/.sc-market-divider-h{--divider-thin-variant-height:1px;display:block;flex:none;height:var(--divider-height);border-radius:var(--divider-radius);background-color:var(--divider-fill-color)}/*!@:host([margin=\"large\"])*/[margin=\"large\"].sc-market-divider-h{margin:var(--divider-large-variant-vertical-padding) 0}/*!@:host([margin=\"medium\"])*/[margin=\"medium\"].sc-market-divider-h{margin:var(--divider-medium-variant-vertical-padding) 0}/*!@:host([margin=\"small\"])*/[margin=\"small\"].sc-market-divider-h{margin:var(--divider-small-variant-vertical-padding) 0}/*!@:host([size=\"thin\"])*/[size=\"thin\"].sc-market-divider-h{height:var(--divider-thin-variant-height)}";
var MarketDividerStyle0 = marketDividerCss;

class MarketDivider {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.margin = 'medium';
        this.size = 'thick';
    }
    render() {
        return hAsync(Host, { key: 'b585eb868ec3ea219f031f101198924340befc6c', class: "market-divider" });
    }
    static get style() { return MarketDividerStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-divider",
        "$members$": {
            "margin": [513],
            "size": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["margin", "margin"], ["size", "size"]]
    }; }
}

const marketDragHandleCss = "/*!@:host*/.sc-market-drag-handle-h{cursor:grab}/*!@:host(:active)*/.sc-market-drag-handle-h:active{cursor:grabbing}/*!@svg*/svg.sc-market-drag-handle{display:block;fill:var(--drag-handle-normal-state-color, var(--core-fill-20-color))}/*!@:host(:hover) svg*/.sc-market-drag-handle-h:hover svg.sc-market-drag-handle{fill:var(--drag-handle-hover-state-color, var(--core-fill-10-color))}";
var MarketDragHandleStyle0 = marketDragHandleCss;

class MarketDragHandle {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDragHandleDragStart = createEvent(this, "marketDragHandleDragStart", 7);
        this.marketDragHandleDragMove = createEvent(this, "marketDragHandleDragMove", 7);
        this.marketDragHandleDragEnd = createEvent(this, "marketDragHandleDragEnd", 7);
        // These bound func refs are so we can remove them later
        this.boundOnDragMove = this.onDragMove.bind(this);
        this.boundOnDragEnd = this.onDragEnd.bind(this);
    }
    onDragStart(e) {
        e.preventDefault();
        e.stopPropagation();
        // only start drag on touch events or left mouse clicks
        if (!isTouchEvent(e) && e.button !== 0)
            return;
        const { marketDragHandleDragStart, boundOnDragMove, boundOnDragEnd } = this;
        const coords = getCoordsFromEvent(e);
        const { defaultPrevented } = marketDragHandleDragStart.emit(coords);
        if (defaultPrevented)
            return;
        document.addEventListener('mousemove', boundOnDragMove);
        document.addEventListener('mouseup', boundOnDragEnd);
        // don't use passive touch event listeners so we can call preventDefault()
        document.addEventListener('touchmove', boundOnDragMove, { passive: false });
        document.addEventListener('touchend', boundOnDragEnd, { passive: false });
    }
    onDragMove(e) {
        e.preventDefault();
        const { marketDragHandleDragMove, boundOnDragMove, boundOnDragEnd } = this;
        const coords = getCoordsFromEvent(e);
        const { defaultPrevented } = marketDragHandleDragMove.emit(coords);
        if (defaultPrevented) {
            // cancel the drag
            document.removeEventListener('mousemove', boundOnDragMove);
            document.removeEventListener('mouseup', boundOnDragEnd);
            document.removeEventListener('touchmove', boundOnDragMove);
            document.removeEventListener('touchend', boundOnDragEnd);
        }
    }
    onDragEnd(e) {
        e.preventDefault();
        const { marketDragHandleDragEnd, boundOnDragMove, boundOnDragEnd } = this;
        const coords = getCoordsFromEvent(e);
        const { defaultPrevented } = marketDragHandleDragEnd.emit(coords);
        if (defaultPrevented)
            return;
        document.removeEventListener('mousemove', boundOnDragMove);
        document.removeEventListener('mouseup', boundOnDragEnd);
        document.removeEventListener('touchmove', boundOnDragMove);
        document.removeEventListener('touchend', boundOnDragEnd);
    }
    render() {
        return (hAsync(Host, { key: 'dda02c9d494ab1adf9b5304fe869186c88edec39', class: "market-drag-handle", onMouseDown: (e) => this.onDragStart(e), onTouchStart: (e) => this.onDragStart(e), "aria-hidden": "true" }, hAsync("svg", { key: 'f9f774fcfd26b698663a8b6cb00762ddc223021d', width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '970919adbe5cac235679d2a74d2320f0016dd1d0', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M15 8C16.1046 8 17 7.10457 17 6C17 4.89543 16.1046 4 15 4C13.8954 4 13 4.89543 13 6C13 7.10457 13.8954 8 15 8ZM15 14C16.1046 14 17 13.1046 17 12C17 10.8954 16.1046 10 15 10C13.8954 10 13 10.8954 13 12C13 13.1046 13.8954 14 15 14ZM11 18C11 19.1046 10.1046 20 9 20C7.89543 20 7 19.1046 7 18C7 16.8954 7.89543 16 9 16C10.1046 16 11 16.8954 11 18ZM17 18C17 19.1046 16.1046 20 15 20C13.8954 20 13 19.1046 13 18C13 16.8954 13.8954 16 15 16C16.1046 16 17 16.8954 17 18ZM11 12C11 13.1046 10.1046 14 9 14C7.89543 14 7 13.1046 7 12C7 10.8954 7.89543 10 9 10C10.1046 10 11 10.8954 11 12ZM11 6C11 7.10457 10.1046 8 9 8C7.89543 8 7 7.10457 7 6C7 4.89543 7.89543 4 9 4C10.1046 4 11 4.89543 11 6Z" }))));
    }
    static get style() { return MarketDragHandleStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-drag-handle",
        "$members$": undefined,
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements$1 = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName$1(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow$1(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement$1(node) {
  var OwnElement = getWindow$1(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement$1(node) {
  var OwnElement = getWindow$1(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot$1(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

var max$1 = Math.max;
var min$1 = Math.min;
var round$1 = Math.round;

function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement$1(element) ? getWindow$1(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect$1(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot$1(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}

function isTableElement$1(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName$1(element)) >= 0;
}

function getDocumentElement$1(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode$1(element) {
  if (getNodeName$1(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot$1(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement$1(element) // fallback

  );
}

function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock$1(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement$1(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle$2(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode$1(element);

  if (isShadowRoot$1(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement$1(currentNode) && ['html', 'body'].indexOf(getNodeName$1(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent$1(element) {
  var window = getWindow$1(element);
  var offsetParent = getTrueOffsetParent$1(element);

  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }

  if (offsetParent && (getNodeName$1(offsetParent) === 'html' || getNodeName$1(offsetParent) === 'body' && getComputedStyle$2(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock$1(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function within(min, value, max) {
  return max$1(min, min$1(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow$1(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent$1(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$2 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow$1,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getVariation(placement) {
  return placement.split('-')[1];
}

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent$1(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow$1(popper)) {
      offsetParent = getDocumentElement$1(popper);

      if (getComputedStyle$2(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow$1(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow$1(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX$1(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect$1(element, strategy) {
  var win = getWindow$1(element);
  var html = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX$1(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect$1(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement$1(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle$2(body || html).direction === 'rtl') {
    x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$2(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent$1(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName$1(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement$1(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent$1(getParentNode$1(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent$1(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode$1(target)));
}

function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect$1(element, strategy) {
  var rect = getBoundingClientRect$1(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect$1(getViewportRect$1(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect$1(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;

  if (!isElement$1(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect$1(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow$1(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect$1(isElement$1(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements$1 : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow$1(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip$1(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow$1(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement$1(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement$1(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$2 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip$1,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets$1(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped$1(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide$1(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow$1(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow$1(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$2 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide$1
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset$2(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements$1.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$3 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset$2
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow$1(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$1(min, tetherMin) : min, offset, tether ? max$1(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll$1(node) {
  if (node === getWindow$1(node) || !isHTMLElement$1(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce$1(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent$1(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$3, flip$2, preventOverflow$1, arrow$2, hide$2];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

const marketDropdownCss = "/*!@:host*/.sc-market-dropdown-h{display:inline-block}/*!@:host ::slotted([slot=\"trigger\"])*/.sc-market-dropdown-h .sc-market-dropdown-s>[slot=\"trigger\"]{cursor:pointer !important}/*!@:host ::slotted([slot=\"popover\"])*/.sc-market-dropdown-h .sc-market-dropdown-s>[slot=\"popover\"]{z-index:99999;opacity:0%;visibility:hidden;pointer-events:none}/*!@:host([expanded]) ::slotted([slot=\"popover\"])*/.sc-market-dropdown-h[expanded] .sc-market-dropdown-s>[slot=\"popover\"]{opacity:100%;visibility:visible;pointer-events:auto}/*!@:host([expanded]) .*/[expanded].sc-market-dropdown-h ..sc-market-dropdown{visibility:hidden}@media (min-width: 600px){/*!@:host ::slotted(.market-popover)*/.sc-market-dropdown-h .sc-market-dropdown-s>.market-popover{max-width:400px}}";
var MarketDropdownStyle0 = marketDropdownCss;

/**
 * @slot trigger - Content slotted here will serve as the "trigger" for user
 * interaction that opens the element in the "content" slot. If it is a
 * `<market-button>`, `<market-filter-button>`, or `<market-link>`,
 * the dropdown will manage their disabled state.
 * @slot popover - Content slotted here will become visible when the slotted
 * trigger content is interacted with. Only tested with `<market-popover>`.
 *
 * To tweak popover position relative to the trigger, you can use the props
 * `popoverPlacement`, popoverSkidding`, and `popoverDistance`.
 */
class MarketDropdown {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDropdownOpened = createEvent(this, "marketDropdownOpened", 7);
        this.marketDropdownClosed = createEvent(this, "marketDropdownClosed", 7);
        /**
         * Popper instance
         */
        this.popperInstance = null;
        this.onMutationObserved = (ariaAttributes) => {
            this.ariaAttributes = ariaAttributes;
        };
        this.interaction = 'click';
        this.disabled = false;
        this.expanded = false;
        this.popoverPlacement = 'bottom';
        this.popoverStrategy = 'absolute';
        this.popoverSkidding = undefined;
        this.popoverDistance = 8;
        this.ariaAttributes = undefined;
    }
    /**
     * Clicks outside of the dropdown component will close the popover. This means
     * that only one dropdown can be open on screen at a time.
     */
    windowClick(e) {
        // https://lamplightdev.com/blog/2021/04/10/how-to-detect-clicks-outside-of-a-web-component
        if (this.expanded && !e.composedPath().includes(this.el)) {
            this.closeDropdown();
        }
    }
    /**
     * Toggles the dropdown
     */
    onExpandedChange(newValue, oldValue) {
        if (newValue === oldValue) {
            return;
        }
        if (this.expanded) {
            this.openDropdown();
        }
        else {
            this.closeDropdown();
        }
    }
    syncDisabledState() {
        // this only covers elements slotted directly into market-dropdown, aka in the light DOM
        const slottedTriggerElements = this.el.querySelectorAll(supportedDropdownTriggers.map((elName) => getNamespacedTagFor(elName)).join(','));
        slottedTriggerElements.forEach((element) => {
            element.disabled = this.disabled;
        });
    }
    /**
     * Toggles the dropdown opened or closed
     */
    toggleDropdown() {
        if (this.expanded) {
            return this.closeDropdown();
        }
        else {
            return this.openDropdown();
        }
    }
    /**
     * Opens the dropdown
     */
    openDropdown() {
        if (this.expanded) {
            return Promise.resolve();
        }
        const { defaultPrevented } = this.marketDropdownOpened.emit();
        if (!defaultPrevented && !this.expanded) {
            this.expanded = true;
        }
        return Promise.resolve();
    }
    /**
     * Closes the dropdown
     */
    closeDropdown() {
        if (!this.expanded) {
            return Promise.resolve();
        }
        const { defaultPrevented } = this.marketDropdownClosed.emit();
        if (!defaultPrevented && this.expanded) {
            this.expanded = false;
        }
        return Promise.resolve();
    }
    /**
     * Updates the popper's tooltip location
     * https://popper.js.org/docs/v2/lifecycle/#manual-update
     */
    async updateDropdownPosition() {
        var _a;
        await ((_a = this.popperInstance) === null || _a === void 0 ? void 0 : _a.update());
        return Promise.resolve();
    }
    async handleInteraction(e) {
        if (this.disabled || this.interaction === 'none') {
            return;
        }
        // default behavior (interaction = 'click') is that the popover toggles
        // open/closed when any part of the element is clicked (trigger or popover)
        if (this.interaction === 'click' && e.type === 'click') {
            this.toggleDropdown();
        }
        // when interaction = 'hover', mousing over the trigger opens the popover
        // and mousing out of the trigger OR popover closes the popover
        if (this.interaction === 'hover' && e.type === 'mouseover') {
            this.openDropdown();
        }
        if (this.interaction === 'hover' && e.type === 'mouseout') {
            this.closeDropdown();
        }
        if (e instanceof KeyboardEvent && e.key === 'Enter') {
            this.toggleDropdown();
        }
        // when interaction = 'persistent', the popover can only be toggled
        // open/closed with clicks to the trigger element
        const trigger = this.el.querySelector('[slot="trigger"]');
        if (this.interaction === 'persistent' && e.type === 'click' && e.composedPath().includes(trigger)) {
            this.toggleDropdown();
        }
        // since slotted content is not visible until this.expanded is true,
        // we need to tell popper.js to more accurately calculate its position once
        // it becomes visible
        if (this.popperInstance) {
            await this.popperInstance.update();
        }
    }
    initializePopper() {
        const { el, popperInstance, popoverPlacement: placement, popoverStrategy: strategy, popoverSkidding: skidding, popoverDistance: distance, } = this;
        if (popperInstance) {
            popperInstance.destroy();
            this.popperInstance = null;
        }
        const trigger = el;
        const popover = el.querySelector('[slot="popover"]');
        if (popover === null) {
            return;
        }
        this.popperInstance = createPopper(trigger, popover, {
            // https://popper.js.org/docs/v2/constructors/#options
            placement,
            strategy,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [skidding, distance],
                    },
                },
            ],
        });
    }
    updatePopoverConfig() {
        const { popperInstance, popoverSkidding: skidding, popoverDistance: distance } = this;
        popperInstance.setOptions({
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [skidding, distance],
                    },
                },
            ],
        });
    }
    connectedCallback() {
        // It's possible for connectedCallback to fire when the element is not connected \_()_/
        // https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks
        if (!this.el.isConnected) {
            return;
        }
        // If this is the initial connection, the popover slot may not exist yet. In that case we'll initialize Popper via
        // the slotchange event handler. If this is a reconnect, we need to reinitialize Popper since it will have been
        // destroyed by disconnectedCallback.
        this.initializePopper();
    }
    disconnectedCallback() {
        // It's possible for disconnectedCallback to fire when the element is still connected \_()_/
        // https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks
        if (this.el.isConnected) {
            return;
        }
        if (this.popperInstance) {
            // Destroying Popper on disconnect prevents memory leaks
            this.popperInstance.destroy();
            this.popperInstance = null;
        }
    }
    registerTrigger() {
        this.slottedTriggerEl = this.el.querySelector(supportedDropdownTriggers.join(','));
        this.syncDisabledState();
    }
    componentWillLoad() {
        this.mutationObserver = observeAriaAttributes(this.el, this.onMutationObserved);
    }
    componentWillRender() {
        if (this.slottedTriggerEl) {
            const popover = this.el.querySelector('[slot="popover"]');
            if (!popover.id) {
                popover.id = `popover-${v4()}`;
            }
            applyExpandableAriaControls(this.slottedTriggerEl, {
                expanded: this.expanded.toString(),
                popoverId: popover.id,
            });
        }
    }
    render() {
        return (hAsync(Host, { key: '8f536e224e90a942948d1d8f1c2618e8c3c1d70d', class: "market-dropdown", expanded: this.expanded, onClick: (e) => {
                this.handleInteraction(e);
            }, onmouseover: (e) => {
                this.handleInteraction(e);
            }, onmouseout: (e) => {
                this.handleInteraction(e);
            }, onKeyDown: (e) => {
                this.handleInteraction(e);
            } }, hAsync("slot", { key: '70de16830a447a9ae2fb1b92f88d03a01a315b2e', name: "trigger", onSlotchange: () => this.registerTrigger() }), hAsync("slot", { key: '027a7018a99e24b1fa18b484368752a892180d09', name: "popover", onSlotchange: () => this.initializePopper() })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "expanded": ["onExpandedChange"],
        "disabled": ["syncDisabledState"],
        "popoverSkidding": ["updatePopoverConfig"],
        "popoverDistance": ["updatePopoverConfig"]
    }; }
    static get style() { return MarketDropdownStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-dropdown",
        "$members$": {
            "interaction": [1],
            "disabled": [516],
            "expanded": [1540],
            "popoverPlacement": [1, "popover-placement"],
            "popoverStrategy": [1, "popover-strategy"],
            "popoverSkidding": [2, "popover-skidding"],
            "popoverDistance": [2, "popover-distance"],
            "ariaAttributes": [32],
            "toggleDropdown": [64],
            "openDropdown": [64],
            "closeDropdown": [64],
            "updateDropdownPosition": [64]
        },
        "$listeners$": [[8, "click", "windowClick"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["expanded", "expanded"]]
    }; }
}

const marketEmptyStateCss = "/*!@:host, ::slotted(*), **/.sc-market-empty-state-h,.sc-market-empty-state-s>*,*.sc-market-empty-state{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-empty-state-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-empty-state-h *.sc-market-empty-state,.sc-market-empty-state-h[disabled].sc-market-empty-state-s>*,.sc-market-empty-state-h[disabled] .sc-market-empty-state-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-empty-state-h{display:flex;flex-direction:column;gap:var(--empty-state-button-group-vertical-spacing);justify-content:center;align-items:center;width:100%;padding:var(--empty-state-vertical-padding) var(--empty-state-horizontal-padding);border-width:calc(var(--empty-state-border-width) * 1px);border-style:solid;border-color:var(--core-fill-40-color);border-radius:var(--empty-state-border-radius);background-color:var(--empty-state-background-color)}/*!@.text*/.text.sc-market-empty-state{display:flex;flex-direction:column;gap:var(--empty-state-paragraph-vertical-spacing);width:100%;max-width:var(--empty-state-text-maximum-width, 600px);margin:0 auto;text-align:center}/*!@.text ::slotted([slot=\"primary-text\"]), .text ::slotted([slot=\"secondary-text\"])*/.text .sc-market-empty-state-s>[slot=\"primary-text\"],.text.sc-market-empty-state-s>[slot=\"secondary-text\"],.text .sc-market-empty-state-s>[slot=\"secondary-text\"]{margin:0;font-family:inherit}/*!@.text ::slotted([slot=\"primary-text\"])*/.text .sc-market-empty-state-s>[slot=\"primary-text\"]{color:var(--empty-state-heading-color);font-weight:var(--empty-state-heading-text-weight);font-size:var(--empty-state-heading-text-size);line-height:var(--empty-state-heading-text-leading)}/*!@.text ::slotted([slot=\"secondary-text\"])*/.text.sc-market-empty-state-s>[slot=\"secondary-text\"],.text .sc-market-empty-state-s>[slot=\"secondary-text\"]{color:var(--empty-state-paragraph-color);font-weight:var(--empty-state-paragraph-text-weight);font-size:var(--empty-state-paragraph-text-size);line-height:var(--empty-state-paragraph-text-leading)}/*!@.actions*/.actions.sc-market-empty-state{display:flex;flex-direction:row;gap:var(--empty-state-actions-spacing, var(--core-metrics-spacing-200))}";
var MarketEmptyStateStyle0 = marketEmptyStateCss;

/**
 * @slot primary-text - Primary text; `<h3>` element is recommended
 * @slot secondary-text - Secondary text; `<p>` element is recommended
 * @slot media - Media that appears above the primary text
 * @slot actions - Action elements; `<market-button>` is recommended
 * @slot - default slot is available for slotting non-text content and will appear above all other slots
 */
class MarketEmptyState {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Whether or not `.actions` will be displayed (if `actions` slot is provided)
         */
        this.showActions = false;
    }
    handleSlottedContent() {
        this.showActions = Boolean(this.el.querySelector('[slot="actions"]'));
    }
    componentWillRender() {
        this.handleSlottedContent();
    }
    render() {
        return (hAsync(Host, { key: '54e7233386056a887b6bf5ddd92e3c807ccc1a0b', class: "market-empty-state" }, hAsync("slot", { key: '853617bbee38b7d377c76ab6825001578adc2dc8' }), hAsync("slot", { key: '6a4c5d3c4237b40f41469805c4bb87c278106f45', name: "media" }), hAsync("div", { key: 'f0855c32819b9987229b443ea6300643339d8a05', class: "text" }, hAsync("slot", { key: '5b8cb78b638507654b8bca5784805b67f355141b', name: "primary-text" }), hAsync("slot", { key: '1752a55ddc654a3ad72ee5ba000b115b712bbaa3', name: "secondary-text" })), this.showActions && (hAsync("div", { key: '8fe597e76e04a8814c16e2c3958ddf1e3d7faa6b', class: "actions" }, hAsync("slot", { key: '6f05692706f359bd5b604f347ee2e98db1a98be8', name: "actions" })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketEmptyStateStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-empty-state",
        "$members$": undefined,
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const marketFieldCss = "/*!@:host, ::slotted(*), **/.sc-market-field-h,.sc-market-field-s>*,*.sc-market-field{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-field-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-field-h *.sc-market-field,.sc-market-field-h[disabled].sc-market-field-s>*,.sc-market-field-h[disabled] .sc-market-field-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-field-h{--error-icon-height:16px;--error-icon-width:16px;--error-icon-offset:calc(calc(var(--field-error-message-text-leading) - var(--error-icon-height)) / 2);display:block;text-align:start}/*!@::slotted([slot])*/.sc-market-field-s>[slot]{margin-top:4px}/*!@::slotted([slot=\"error\"])*/.sc-market-field-s>[slot=\"error\"]{display:block;color:var(--field-error-message-text-color);font-weight:var(--field-error-message-text-weight);font-size:var(--field-error-message-text-size);line-height:var(--field-error-message-text-leading);letter-spacing:var(--field-error-message-text-tracking)}/*!@::slotted([slot=\"error\"])::before*/.sc-market-field-s>[slot=\"error\"]::before{content:\"\";display:inline-block;vertical-align:calc(-1 * var(--error-icon-offset));width:var(--error-icon-width);height:var(--error-icon-height);margin-right:calc(\n        var(--field-error-message-icon-padding, 2px) +\n        var(--field-error-message-icon-margin-right, 4px)\n      );margin-left:var(--field-error-message-icon-padding, 2px);background-color:var(--field-error-message-text-color);-webkit-mask:url(\"data:image/svg+xml;utf8,<svg width='16' height='16' viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg'><path fill-rule='evenodd' clip-rule='evenodd' d='M8 15.5C12.1333 15.5 15.5 12.1333 15.5 8C15.5 3.86667 12.1333 0.5 8 0.5C3.86667 0.5 0.5 3.86667 0.5 8C0.5 12.1333 3.86667 15.5 8 15.5ZM8 2.16667C11.2167 2.16667 13.8333 4.78333 13.8333 8C13.8333 11.2167 11.2167 13.8333 8 13.8333C4.78333 13.8333 2.16667 11.2167 2.16667 8C2.16667 4.78333 4.78333 2.16667 8 2.16667ZM8 12.1667C8.5753 12.1667 9.04167 11.7003 9.04167 11.125C9.04167 10.5497 8.5753 10.0833 8 10.0833C7.4247 10.0833 6.95833 10.5497 6.95833 11.125C6.95833 11.7003 7.4247 12.1667 8 12.1667ZM7.16667 3.83333H8.83333V9.25H7.16667V3.83333Z'/></svg>\");mask:url(\"data:image/svg+xml;utf8,<svg width='16' height='16' viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg'><path fill-rule='evenodd' clip-rule='evenodd' d='M8 15.5C12.1333 15.5 15.5 12.1333 15.5 8C15.5 3.86667 12.1333 0.5 8 0.5C3.86667 0.5 0.5 3.86667 0.5 8C0.5 12.1333 3.86667 15.5 8 15.5ZM8 2.16667C11.2167 2.16667 13.8333 4.78333 13.8333 8C13.8333 11.2167 11.2167 13.8333 8 13.8333C4.78333 13.8333 2.16667 11.2167 2.16667 8C2.16667 4.78333 4.78333 2.16667 8 2.16667ZM8 12.1667C8.5753 12.1667 9.04167 11.7003 9.04167 11.125C9.04167 10.5497 8.5753 10.0833 8 10.0833C7.4247 10.0833 6.95833 10.5497 6.95833 11.125C6.95833 11.7003 7.4247 12.1667 8 12.1667ZM7.16667 3.83333H8.83333V9.25H7.16667V3.83333Z'/></svg>\");-webkit-mask-size:cover;mask-size:cover}/*!@::slotted([slot=\"bottom-accessory\"])*/.sc-market-field-s>[slot=\"bottom-accessory\"]{display:block;margin:var(--field-helper-text-vertical-spacing) var(--field-helper-text-horizontal-spacing);color:var(--field-helper-text-text-color);font-weight:var(--field-helper-text-weight);font-size:var(--field-helper-text-size);line-height:var(--field-helper-text-leading);letter-spacing:var(--field-helper-text-tracking)}/*!@::slotted([slot=\"action\"])*/.sc-market-field-s>[slot=\"action\"]{display:block;padding:var(--field-action-vertical-padding-size) 0;color:var(--field-action-text-color);font-weight:var(--field-action-text-weight);font-size:var(--field-action-text-size);line-height:var(--field-action-text-leading);letter-spacing:var(--field-action-text-tracking);text-decoration:none;cursor:pointer}/*!@::slotted(button[slot=\"action\"])*/.sc-market-field-s>button[slot=\"action\"]{padding:0;border:none;background-color:transparent;outline:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}";
var MarketFieldStyle0 = marketFieldCss;

/**
 * @slot - The form input, ex. market-input-text.
 * @slot error - Optional error text for the block, displayed below the input when invalid.
 * @slot bottom-accessory - Optional content for the block, displayed below the input.
 * @slot action - Optional action component for the block, displayed below the input.
 */
class MarketField {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.errorSlotId = v4();
        this.name = undefined;
        this.readonly = false;
        this.disabled = false;
        this.invalid = false;
    }
    getSlottedInputs() {
        const supportedInputTags = [
            getNamespacedTagFor('market-input-text'),
            getNamespacedTagFor('market-input-password'),
            getNamespacedTagFor('market-select'),
            getNamespacedTagFor('market-textarea'),
            getNamespacedTagFor('market-code-input'),
        ];
        // create flattened array of slotted supported input elements based on tag name
        const slottedInputElements = supportedInputTags.flatMap((tag) => {
            return [
                ...this.el.getElementsByTagName(tag),
            ];
        });
        return slottedInputElements;
    }
    getErrorSlot() {
        return this.el.querySelector('[slot="error"]');
    }
    getBottomAccessorySlot() {
        return this.el.querySelector('[slot="bottom-accessory"]');
    }
    getInputElAriaDescribedby() {
        const describedBy = [];
        if (this.getErrorSlot()) {
            describedBy.push(`${this.errorSlotId}-error`);
        }
        if (this.getBottomAccessorySlot()) {
            describedBy.push(`${this.errorSlotId}-bottom-accessory`);
        }
        return describedBy.join(' ');
    }
    handleErrorAttributes() {
        const errorSlotEl = this.getErrorSlot();
        if (errorSlotEl) {
            errorSlotEl.setAttribute('role', 'alert');
            errorSlotEl.setAttribute('id', `${this.errorSlotId}-error`);
        }
    }
    handleBottomAccessoryAttributes() {
        const bottomAccessorySlotEl = this.getBottomAccessorySlot();
        if (bottomAccessorySlotEl) {
            bottomAccessorySlotEl.setAttribute('id', `${this.errorSlotId}-bottom-accessory`);
        }
    }
    render() {
        // check for slotted supported market inputs and pass properties down
        this.getSlottedInputs().forEach((input) => {
            input.name = this.name;
            input.disabled = this.disabled;
            input.invalid = this.invalid;
            input.readonly = this.readonly;
            const inputElAriaDescribedby = this.getInputElAriaDescribedby();
            if (inputElAriaDescribedby) {
                input.setAttribute('aria-describedby', inputElAriaDescribedby);
            }
        });
        return (hAsync(Host, { key: '7abe30582756b2b385dcb2a11fb8027a4b3fe9e9', class: "market-field" }, hAsync("slot", { key: 'eaa6676be67540025cce0721382111d9149fe7ea' }), this.invalid && !this.disabled && (
        // slot relocation broke in @stencil/core@1.13.0
        // wrapping a slot in a shadowless div as a workaround
        // this should be fixed in 2.1.1
        hAsync("div", { key: '736cbd69cbce0bb6aa2bc345c078082d6dc04ce4' }, hAsync("slot", { key: '902c9a1ddff740365332f129d1935966d4c082a0', name: "error", onSlotchange: () => this.handleErrorAttributes() }))), hAsync("slot", { key: 'ea8a27036ae7d823703b534e4b8c0bd21dab50ce', name: "bottom-accessory", onSlotchange: () => this.handleBottomAccessoryAttributes() }), hAsync("slot", { key: '40922f28c8231b3e13fae355a90585f5635d01e9', name: "action" })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketFieldStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-field",
        "$members$": {
            "name": [513],
            "readonly": [516],
            "disabled": [516],
            "invalid": [516]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["name", "name"], ["readonly", "readonly"], ["disabled", "disabled"], ["invalid", "invalid"]]
    }; }
}

/**
 * Returns byte size as a human-readable string.
 * Cribbed from https://stackoverflow.com/a/18650828
 *
 * @param bytes File size in bytes
 * @param decimals Decimal precision
 */
const getReadableFilesize = (bytes, decimals = 2) => {
    if (!Number(bytes))
        return '0 bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['bytes', 'kB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${Number.parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
};

const marketFileUploadCss = "/*!@:host, ::slotted(*), **/.sc-market-file-upload-h,.sc-market-file-upload-s>*,*.sc-market-file-upload{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-file-upload-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-file-upload-h *.sc-market-file-upload,.sc-market-file-upload-h[disabled].sc-market-file-upload-s>*,.sc-market-file-upload-h[disabled] .sc-market-file-upload-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@button, .market-button, ::slotted(button), ::slotted(.market-button), ::slotted(.market-link)*/button.sc-market-file-upload,.market-button.sc-market-file-upload,.sc-market-file-upload-s>button,.sc-market-file-upload-s>.market-button,.sc-market-file-upload-s>.market-link{font-weight:var(--core-type-semibold-30-weight);font-size:var(--core-type-semibold-30-size);font-family:var(--core-type-semibold-30-font-family);line-height:var(--core-type-semibold-30-leading);letter-spacing:var(--core-type-semibold-30-tracking);text-transform:var(--core-type-semibold-30-case)}/*!@.label-container*/.label-container.sc-market-file-upload{border-width:var(--file-upload-border-width, 1px);border-style:var(--file-upload-normal-state-border-style, dashed);border-color:var(--file-upload-normal-state-border-color, var(--core-fill-30-color));border-radius:var(--file-upload-border-radius, 6px);transition:background-color border-color 0.2s}/*!@.label-container > label*/.label-container.sc-market-file-upload>label.sc-market-file-upload{display:flex;flex-direction:column;justify-content:center;align-items:center;padding:var(--file-upload-dropzone-vertical-padding, var(--core-metrics-spacing-400))\n      var(--file-upload-dropzone-horizontal-padding, var(--core-metrics-spacing-400));text-align:center;cursor:pointer}/*!@.label-container > label .market-icon*/.label-container.sc-market-file-upload>label.sc-market-file-upload .market-icon.sc-market-file-upload{color:var(--file-upload-label-fill-color, var(--core-text-10-color))}/*!@.label-container > .market-row*/.label-container.sc-market-file-upload>.market-row.sc-market-file-upload{margin:0}/*!@button, .market-button, ::slotted(button), ::slotted(.market-button), ::slotted(.market-link)*/button.sc-market-file-upload,.market-button.sc-market-file-upload,.sc-market-file-upload-s>button,.sc-market-file-upload-s>.market-button,.sc-market-file-upload-s>.market-link{padding:0}/*!@slot:not([name=\"compact\"]) button, slot:not([name=\"compact\"]) .market-button, slot:not([name=\"compact\"]) ::slotted(button), slot:not([name=\"compact\"]) ::slotted(.market-button), slot:not([name=\"compact\"]) ::slotted(.market-link)*/slot.sc-market-file-upload:not([name=\"compact\"]) button.sc-market-file-upload,slot.sc-market-file-upload:not([name=\"compact\"]) .market-button.sc-market-file-upload,slot:not([name=\"compact\"]).sc-market-file-upload-s>button,slot:not([name=\"compact\"]) .sc-market-file-upload-s>button,slot:not([name=\"compact\"]).sc-market-file-upload-s>.market-button,slot:not([name=\"compact\"]) .sc-market-file-upload-s>.market-button,slot:not([name=\"compact\"]).sc-market-file-upload-s>.market-link,slot:not([name=\"compact\"]) .sc-market-file-upload-s>.market-link{border:none;background-color:inherit;color:var(--file-upload-button-label-color, var(--button-normal-variant-tertiary-rank-normal-state-label-color));font-family:inherit;text-align:right;cursor:pointer}/*!@.has-file-selected*/.has-file-selected.sc-market-file-upload{border-style:var(--file-upload-file-selected-state-border-style, solid) !important;border-color:var(--file-upload-file-selected-state-border-color, var(--core-fill-30-color))}@media (hover: hover){/*!@:host(:hover) .label-container*/.sc-market-file-upload-h:hover .label-container.sc-market-file-upload{border-style:var(--file-upload-hover-state-border-style, dashed);border-color:var(--file-upload-hover-state-border-color, var(--core-emphasis-fill-color));background-color:var(--file-upload-hover-state-background-color, var(--core-emphasis-40-color))}}/*!@:host(:active) .label-container, :host(:active) .is-dragging-over*/.sc-market-file-upload-h:active .label-container.sc-market-file-upload,.sc-market-file-upload-h:active .is-dragging-over.sc-market-file-upload{border-style:var(--file-upload-active-state-border-style, dashed);border-color:var(--file-upload-active-state-border-color, var(--core-emphasis-fill-color));background-color:var(--file-upload-active-state-background-color, var(--core-emphasis-30-color))}/*!@:host([disabled]) .label-container*/[disabled].sc-market-file-upload-h .label-container.sc-market-file-upload{border-style:var(--file-upload-disabled-state-border-style, dashed);border-color:var(--file-upload-disabled-state-border-color, var(--field-disabled-state-border-color));background-color:var(--file-upload-disabled-state-background-color, var(--field-disabled-state-background-color));color:var(--file-upload-disabled-state-label-color, var(--field-disabled-state-empty-phase-label-color))}/*!@:host([disabled]) button, :host([disabled]) ::slotted(button), :host([disabled]) ::slotted(.market-button), :host([disabled]) ::slotted(.market-icon), :host([disabled]) ::slotted(.market-link), :host([disabled]) label .market-icon, :host([disabled]) label ::slotted(.market-icon)*/[disabled].sc-market-file-upload-h button.sc-market-file-upload,.sc-market-file-upload-h[disabled].sc-market-file-upload-s>button,.sc-market-file-upload-h[disabled] .sc-market-file-upload-s>button,.sc-market-file-upload-h[disabled].sc-market-file-upload-s>.market-button,.sc-market-file-upload-h[disabled] .sc-market-file-upload-s>.market-button,.sc-market-file-upload-h[disabled].sc-market-file-upload-s>.market-icon,.sc-market-file-upload-h[disabled] .sc-market-file-upload-s>.market-icon,.sc-market-file-upload-h[disabled].sc-market-file-upload-s>.market-link,.sc-market-file-upload-h[disabled] .sc-market-file-upload-s>.market-link,[disabled].sc-market-file-upload-h label.sc-market-file-upload .market-icon.sc-market-file-upload,.sc-market-file-upload-h[disabled] label.sc-market-file-upload-s>.market-icon,.sc-market-file-upload-h[disabled] label .sc-market-file-upload-s>.market-icon{opacity:30%}/*!@slot[name=\"compact-action\"]*/slot[name=\"compact-action\"].sc-market-file-upload{display:none}/*!@:host([compact]) slot[name=\"compact-action\"]*/[compact].sc-market-file-upload-h slot[name=\"compact-action\"].sc-market-file-upload{display:block;width:100%}/*!@:host([compact]) slot:not([name=\"compact-action\"])*/[compact].sc-market-file-upload-h slot.sc-market-file-upload:not([name=\"compact-action\"]){display:none}/*!@:host([compact]) .label-container*/[compact].sc-market-file-upload-h .label-container.sc-market-file-upload{border-style:unset;border-color:unset;background-color:unset}/*!@:host([compact]) .label-container > label*/[compact].sc-market-file-upload-h .label-container.sc-market-file-upload>label.sc-market-file-upload{padding:0}/*!@:host([compact]) .market-button, :host([compact]) .market-link, :host([compact]) ::slotted(.market-button), :host([compact]) ::slotted(.market-link)*/[compact].sc-market-file-upload-h .market-button.sc-market-file-upload,[compact].sc-market-file-upload-h .market-link.sc-market-file-upload,.sc-market-file-upload-h[compact].sc-market-file-upload-s>.market-button,.sc-market-file-upload-h[compact] .sc-market-file-upload-s>.market-button,.sc-market-file-upload-h[compact].sc-market-file-upload-s>.market-link,.sc-market-file-upload-h[compact] .sc-market-file-upload-s>.market-link{width:100%}/*!@.market-list*/.market-list.sc-market-file-upload{margin-top:var(--file-upload-dropzone-vertical-margin, var(--core-metrics-spacing-100))}/*!@.market-accessory[slot=\"leading-accessory\"]*/.market-accessory[slot=\"leading-accessory\"].sc-market-file-upload{border-radius:var(--file-upload-border-radius, 6px);background-color:var(--file-upload-leading-accessory-background-color, var(--core-fill-40-color))}/*!@.market-accessory[slot=\"trailing-accessory\"]*/.market-accessory[slot=\"trailing-accessory\"].sc-market-file-upload{cursor:pointer}/*!@.market-accessory[slot=\"trailing-accessory\"] .market-icon*/.market-accessory[slot=\"trailing-accessory\"].sc-market-file-upload .market-icon.sc-market-file-upload{color:var(--file-upload-delete-fill-color, var(--core-fill-20-color))}/*!@[data-status]:not([data-status=\"\"]) .market-accessory[slot=\"leading-accessory\"]*/[data-status].sc-market-file-upload:not([data-status=\"\"]) .market-accessory[slot=\"leading-accessory\"].sc-market-file-upload{background-color:unset}/*!@[data-status=\"error\"] [slot=\"subtext\"], [data-status=\"error\"] .market-accessory[slot=\"leading-accessory\"]*/[data-status=\"error\"].sc-market-file-upload [slot=\"subtext\"].sc-market-file-upload,[data-status=\"error\"].sc-market-file-upload .market-accessory[slot=\"leading-accessory\"].sc-market-file-upload{color:var(--file-upload-leading-accessory-error-color, var(--core-critical-fill-color))}/*!@:host([disabled]) [data-status=\"error\"] [slot=\"subtext\"]*/[disabled].sc-market-file-upload-h [data-status=\"error\"].sc-market-file-upload [slot=\"subtext\"].sc-market-file-upload{opacity:30%}/*!@[data-status=\"success\"] .market-accessory[slot=\"leading-accessory\"]*/[data-status=\"success\"].sc-market-file-upload .market-accessory[slot=\"leading-accessory\"].sc-market-file-upload{color:var(--file-upload-leading-accessory-success-color, var(--core-success-fill-color))}/*!@[data-status=\"loading\"] .market-accessory[slot=\"leading-accessory\"]*/[data-status=\"loading\"].sc-market-file-upload .market-accessory[slot=\"leading-accessory\"].sc-market-file-upload{animation:market-file-upload-loading-rotation 1s infinite linear}@keyframes market-file-upload-loading-rotation{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}/*!@:host([invalid]) .label-container*/[invalid].sc-market-file-upload-h .label-container.sc-market-file-upload{border-color:var(--field-normal-state-invalid-validity-border-color)}/*!@::slotted([slot=\"bottom-accessory\"])*/.sc-market-file-upload-s>[slot=\"bottom-accessory\"]{color:var(--core-text-20-color)}";
var MarketFileUploadStyle0 = marketFileUploadCss;

/**
 * @slot - Used for drop zone content. Intended for an icon (optional), main text, and secondary text (optional).
 * @slot compact-action - Used for "compact" mode content. Intended for use with a `market-button` or `market-link`. When this
 * slot is used, default slot content must also be provided. Visible when `compact` is true.
 * @slot bottom-accessory - DEPRECATED: Used for the bottom accessory text. We recommend using the default slot
 * to add secondary text to the drop zone content instead.
 * @slot error - DEPRECATED: Used for input-level error text. We recommend using the fileMetadata prop to set error
 * status and messages on the file level instead.
 */
class MarketFileUpload {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketFileUploadValueChange = createEvent(this, "marketFileUploadValueChange", 7);
        this.accept = '';
        this.value = [];
        this.disabled = false;
        this.invalid = false;
        this.multiple = false;
        this.compact = false;
        this.fileSubtext = undefined;
        this.fileMetadata = undefined;
        this.deleteButtonAriaLabel = 'Delete';
        this.isDraggingOver = false;
        this.files = undefined;
    }
    watchValueHandler(newValue) {
        if (Array.isArray(newValue)) {
            this.files = this.multiple ? [...newValue] : [newValue[0]];
        }
    }
    watchDisabledHandler() {
        this.slottedCompactButtons.forEach((el) => (el.disabled = this.disabled));
    }
    /**
     * We want to disable certain functions if multiple is false and a file has been selected
     */
    get hasSingleFileSelected() {
        return !this.multiple && this.files.length === 1;
    }
    /* returns `market-button` or `market-link` elements in the "compact" slot */
    get slottedCompactButtons() {
        const interactiveElementTagnames = new Set([
            getNamespacedTagFor('market-button'),
            getNamespacedTagFor('market-link'),
        ]);
        return [...this.el.querySelector('[slot="compact-action"]').children].filter((el) => interactiveElementTagnames.has(el.tagName.toLowerCase()));
    }
    draggingOver(e) {
        if (this.disabled || this.hasSingleFileSelected) {
            return;
        }
        this.isDraggingOver = true;
        e.preventDefault();
    }
    endDrag(e) {
        e.preventDefault();
        if (this.disabled || this.hasSingleFileSelected) {
            return;
        }
        this.isDraggingOver = false;
        if (e.type === 'drop' && e.dataTransfer) {
            this.addFiles(e.dataTransfer.files);
        }
    }
    handleButtonClick() {
        this.fileInputElement.click();
    }
    handleDeleteKeydown(e, index) {
        if (e.key === 'Enter' && !this.disabled) {
            this.removeFile(index);
        }
    }
    removeFile(index) {
        this.files.splice(index, 1);
        this.files = [...this.files];
        this.emitFileChange();
    }
    labelContainerClassNames() {
        const classNames = [];
        if (this.isDraggingOver) {
            classNames.push('is-dragging-over');
        }
        if (this.hasSingleFileSelected) {
            classNames.push('has-file-selected');
        }
        return classNames;
    }
    onInputChange(e) {
        this.addFiles(e.target.files);
        // unset the file input value so that we can re-add files
        // if they are removed by the user
        this.fileInputElement.value = '';
    }
    addFiles(files) {
        if (files) {
            if (!this.multiple) {
                this.files = [files[0]];
            }
            else {
                this.files = [...files, ...this.files];
            }
        }
        this.emitFileChange();
    }
    emitFileChange() {
        this.marketFileUploadValueChange.emit({ value: this.files });
    }
    handleCompactSlotChange() {
        this.slottedCompactButtons.forEach((el) => {
            el.removeEventListener('click', this.handleButtonClick.bind(this));
            if (!this.disabled) {
                el.addEventListener('click', this.handleButtonClick.bind(this));
            }
            el.disabled = this.disabled;
        });
    }
    componentWillLoad() {
        if (this.value) {
            this.files = [...this.value];
        }
        else {
            this.files = [];
        }
    }
    componentDidLoad() {
        this.handleCompactSlotChange();
    }
    renderFilesAsMarketRows() {
        const MarketRowTagName = getNamespacedTagFor('market-row');
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        return this.files.map((file, index) => {
            var _a;
            const rowConfig = (_a = this.fileMetadata) === null || _a === void 0 ? void 0 : _a.find((row) => row.filename === file.name);
            // set default icons
            let leadingIcon = file.type.startsWith('image/') ? 'picture' : 'file';
            let trailingIcon = 'delete';
            // set default secondary text
            let secondaryText;
            switch (this.fileSubtext) {
                case 'size':
                    secondaryText = getReadableFilesize(file[this.fileSubtext]);
                    break;
                case 'type':
                    secondaryText = file[this.fileSubtext];
                    break;
            }
            // row config status overrides default row appearance
            switch (rowConfig === null || rowConfig === void 0 ? void 0 : rowConfig.status) {
                case 'error':
                    leadingIcon = 'warning';
                    trailingIcon = 'clear';
                    // message only displayed if status = error
                    secondaryText = rowConfig === null || rowConfig === void 0 ? void 0 : rowConfig.message;
                    break;
                case 'loading':
                    leadingIcon = 'loading';
                    trailingIcon = 'clear';
                    break;
                case 'success':
                    leadingIcon = 'success';
                    break;
            }
            // row config custom icon overrides previously set leading icon
            leadingIcon = (rowConfig === null || rowConfig === void 0 ? void 0 : rowConfig.leadingIconName) || leadingIcon;
            return (hAsync(MarketRowTagName, { disabled: this.disabled, interactive: true, transient: true, "data-index": index, "data-status": rowConfig === null || rowConfig === void 0 ? void 0 : rowConfig.status }, hAsync("label", { slot: "label" }, file.name), secondaryText && hAsync("p", { slot: "subtext" }, secondaryText), hAsync(MarketAccessoryTagName, { slot: "leading-accessory", size: "image" }, hAsync(MarketIconTagName, { name: leadingIcon, fidelity: 24 })), hAsync(MarketAccessoryTagName, { slot: "trailing-accessory", size: "icon", tabindex: this.disabled ? -1 : 0, role: "button", "aria-label": this.deleteButtonAriaLabel, onKeyDown: (e) => this.handleDeleteKeydown(e, index), onClick: () => this.removeFile(index) }, hAsync(MarketIconTagName, { name: trailingIcon, fidelity: 24 }))));
        });
    }
    render() {
        const MarketListTagName = getNamespacedTagFor('market-list');
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        const MarketFieldTagName = getNamespacedTagFor('market-field');
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        const fileMarketRows = this.renderFilesAsMarketRows();
        const showUploadLabel = this.multiple || fileMarketRows.length === 0;
        const showList = this.multiple && fileMarketRows.length > 0;
        return (hAsync(Host, { key: 'a6387bad3723b23579e4803bc809802dc05bbe80', class: "market-file-upload", ondragenter: (e) => this.draggingOver(e), ondragover: (e) => this.draggingOver(e), ondragleave: (e) => this.endDrag(e), ondrop: (e) => this.endDrag(e) }, hAsync(MarketFieldTagName, { key: '9ddf6b3ef0cc37b4fe171ffde6b1db2dc25a5880', disabled: this.disabled, invalid: this.invalid }, hAsync("div", { key: '5db42c4af01b94ee691e4bfc8c3695f4ff5cfde1', class: `label-container ${this.labelContainerClassNames()}` }, !showUploadLabel && fileMarketRows[0], showUploadLabel && (
        // the input is correctly wrapped inside its label, but eslint gets confused by label > span > slot > text
        // eslint-disable-next-line jsx-a11y/label-has-associated-control
        hAsync("label", { key: '6a0554081de2392295a706c220aec4ff890c6581' }, hAsync("slot", { key: 'f8dda6a2fc67c2d25b61ceca30eee030cbdace99' }, hAsync(MarketAccessoryTagName, { key: '01fa720e37c0e4e9a9d3c131c9724ebb0c67db66', size: "image" }, hAsync(MarketIconTagName, { key: '3c00d32e418d48998a82b6659b0e712f02435e27', name: "file", fidelity: 24 })), hAsync("span", { key: 'fd67c239b8a5f91429b36053ece843bfff65c998' }, hAsync("button", { key: '85d595f5a16f5f59e879dadc361e7426d4160fc2', onClick: () => this.handleButtonClick() }, "Choose a file"), " or drag and drop it here")), hAsync("slot", { key: 'c415fc3cc17a5387d4ec8b4353603ae2eb877221', name: "compact-action", onSlotchange: () => this.handleCompactSlotChange() }, hAsync(MarketButtonTagName, { key: '98b94fc6b3a7438d88da13a2cc8cd073d33359c4', rank: "primary", disabled: this.disabled, onClick: () => this.handleButtonClick() }, "Upload file")), hAsync("input", { key: '48c717f8ae9f8846fadf12ff4e0ee7522ba27e90', ref: (el) => (this.fileInputElement = el), onChange: (e) => this.onInputChange(e), type: "file", name: "files[]", multiple: this.multiple, accept: this.accept, hidden: true })))), hAsync("slot", { key: 'e9d47e3973faf4525b19cbfcdd3d75ada36d4fc3', name: "bottom-accessory" }, hAsync("small", { key: '832c55e6dcc9502fb1684455726b9b38040c8311', slot: "bottom-accessory" })), hAsync("slot", { key: 'a11420e7a810512140165124aa659f8e952de3e9', name: "error" }, hAsync("small", { key: '3ac344c99721274c2493afeec18f42c224375a28', slot: "error" }))), showList && (hAsync(MarketListTagName, { key: '542ed5f8cabf72bcf2a61db1875d3b26c9b6373a', interactive: true, transient: true }, fileMarketRows))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["watchValueHandler"],
        "disabled": ["watchDisabledHandler"]
    }; }
    static get style() { return MarketFileUploadStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-file-upload",
        "$members$": {
            "accept": [1],
            "value": [16],
            "disabled": [516],
            "invalid": [516],
            "multiple": [516],
            "compact": [516],
            "fileSubtext": [1, "file-subtext"],
            "fileMetadata": [16],
            "deleteButtonAriaLabel": [513, "delete-button-aria-label"],
            "isDraggingOver": [32],
            "files": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["invalid", "invalid"], ["multiple", "multiple"], ["compact", "compact"], ["deleteButtonAriaLabel", "delete-button-aria-label"]]
    }; }
}

var ListItemSelectableType;
(function (ListItemSelectableType) {
    ListItemSelectableType[ListItemSelectableType["RADIO"] = 0] = "RADIO";
    ListItemSelectableType[ListItemSelectableType["CHECKBOX"] = 1] = "CHECKBOX";
    ListItemSelectableType[ListItemSelectableType["SWITCH"] = 2] = "SWITCH";
    ListItemSelectableType[ListItemSelectableType["SELECTABLE_WITHOUT_CONTROL"] = 3] = "SELECTABLE_WITHOUT_CONTROL";
})(ListItemSelectableType || (ListItemSelectableType = {}));

/**
 * Check if the value is considered empty
 * @param {unknown} value
 */
function isValueEmpty$1(value) {
    // Note: we don't check for 0 here because it's a valid value, so _.isEmpty() is not used
    return value === '' || value === null || value === undefined || (Array.isArray(value) && value.length === 0);
}
/**
 * Check if the slotted control in <market-row slot="control-row> is a valid control row input
 * @param {unknown} control
 */
function isValidControl(control) {
    var _a;
    if (!control) {
        return false;
    }
    const tagName = (_a = control.tagName) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
    const validControlTags = [
        getNamespacedTagFor('market-checkbox').toLocaleLowerCase(),
        getNamespacedTagFor('market-radio').toLocaleLowerCase(),
        getNamespacedTagFor('market-toggle').toLocaleLowerCase(),
    ];
    return validControlTags.includes(tagName);
}
function getRowSelectableType(row) {
    if (!row.interactive || row.variant === 'drill' || Boolean(row.href) || (row.interactive && row.transient)) {
        return undefined;
    }
    const slottedControl = row.querySelector('[slot="control"]');
    if (!slottedControl) {
        return ListItemSelectableType.SELECTABLE_WITHOUT_CONTROL;
    }
    if (isElementWithTagName(slottedControl, 'market-checkbox')) {
        return ListItemSelectableType.CHECKBOX;
    }
    if (isElementWithTagName(slottedControl, 'market-radio')) {
        return ListItemSelectableType.RADIO;
    }
    if (isElementWithTagName(slottedControl, 'market-toggle')) {
        return ListItemSelectableType.SWITCH;
    }
    return undefined;
}
/**
 * Get the selectable type (radio, checkbox, etc.) from a list item, which is either a market-row or market-action-card
 * @param {TMarketListItem} item
 */
function getItemSelectableType(item) {
    if (isElementWithTagName(item, 'market-action-card')) {
        const innerRow = item.querySelector(getNamespacedTagFor('market-row'));
        if (innerRow) {
            return getRowSelectableType(innerRow);
        }
        return ListItemSelectableType.SELECTABLE_WITHOUT_CONTROL;
    }
    if (isElementWithTagName(item, 'market-row')) {
        return getRowSelectableType(item);
    }
    return undefined;
}

const marketFilterCss = "/*!@:host, ::slotted(*), **/.sc-market-filter-h,.sc-market-filter-s>*,*.sc-market-filter{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-filter-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-filter-h *.sc-market-filter,.sc-market-filter-h[disabled].sc-market-filter-s>*,.sc-market-filter-h[disabled] .sc-market-filter-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-filter-h{display:inline-block}/*!@.dropdown, .dropdown > .filter-button*/.dropdown.sc-market-filter,.dropdown.sc-market-filter>.filter-button.sc-market-filter{width:100%}/*!@.date-popover*/.date-popover.sc-market-filter{max-width:unset;max-height:unset}";
var MarketFilterStyle0 = marketFilterCss;

/**
 * @slot label - Filter label, using `<label>`
 * @slot display-value - Overwrites the displayed value or feedback
 * @slot - The `<market-list>` or `<market-date-picker>` element
 */
class MarketFilter {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketFilterClosed = createEvent(this, "marketFilterClosed", 7);
        this.marketFilterOpened = createEvent(this, "marketFilterOpened", 7);
        this.marketFilterExpandedChanged = createEvent(this, "marketFilterExpandedChanged", 7);
        this.marketFilterValueDidChange = createEvent(this, "marketFilterValueDidChange", 7);
        this.name = undefined;
        this.disabled = undefined;
        this.focused = false;
        this.size = 'medium';
        this.expanded = false;
        this.dropdownInteraction = undefined;
        this.popoverPlacement = 'bottom-start';
        this.popoverStrategy = 'absolute';
        this.selectedDisplayValue = undefined;
    }
    /**
     * **INTERNAL [do not use directly]**
     *
     * Get the filter type
     */
    async getFilterType() {
        return Promise.resolve(this.filterType);
    }
    /**
     * Toggle focus on the filter button
     * @param {boolean} [value=true] whether or not focus will be applied or removed
     * @returns {Promise<boolean>} whether or not the filter was focused or blurred
     */
    async setFocus(value = true) {
        this.focused = await this.filterButtonEl.setFocus(value);
        return Promise.resolve(this.focused);
    }
    /**
     * @private
     * *INTERNAL*: Used by `market-filter-dropdown-menu` to reemit events from the cloned datepicker inside the dropdown.
     *
     * Sets the value of the list and emits `marketFilterValueDidChange`.
     *
     * @param value - The value to set for the market filter.
     * @returns A promise that resolves when the value is set.
     */
    async __setAndEmitListValue(value) {
        var _a;
        if (!this.listEl) {
            return Promise.reject(new Error('No list found.'));
        }
        const prevValue = (_a = this.listEl) === null || _a === void 0 ? void 0 : _a.value;
        this.listEl.value = value;
        this.marketFilterValueDidChange.emit({
            name: this.name,
            prevValue: prevValue || null,
            value,
        });
        this.setDisplayValueFromSlottedElement();
        return Promise.resolve();
    }
    /**
     * @private
     * *INTERNAL*: Used by `market-filter-dropdown-menu` to reemit events from the cloned datepicker inside the dropdown.
     *
     * Sets the value of the date picker emits `marketFilterValueDidChange`.
     *
     * @param value - The new value for the date picker.
     * @returns A promise that resolves when the value is set.
     */
    async __setAndEmitDatePickerValue(value) {
        if (!this.datePickerEl) {
            return Promise.reject(new Error('No date picker found.'));
        }
        const prevStartDate = this.datePickerEl.selectedStartDate;
        const prevEndDate = this.datePickerEl.selectedEndDate;
        const startDate = value === null || value === void 0 ? void 0 : value.startDate;
        const endDate = value === null || value === void 0 ? void 0 : value.endDate;
        this.datePickerEl.selectedStartDate = startDate;
        this.datePickerEl.selectedEndDate = endDate;
        this.marketFilterValueDidChange.emit({
            name: this.name,
            prevValue: {
                startDate: prevStartDate,
                endDate: prevEndDate,
            },
            value: {
                startDate,
                endDate,
            },
        });
        this.setDisplayValueFromSlottedElement();
        return Promise.resolve();
    }
    /**
     * Handle `marketListSelectionsDidChange` emitted by `<market-list>`
     */
    handleListSelectionChange({ detail }) {
        var _a;
        this.setDisplayValueFromListEvent(detail);
        const prevValue = detail.prevSelectionValues.length > 1 ? detail.prevSelectionValues : detail.prevSelectionValues[0];
        const value = (() => {
            if (detail.currentSelectionValues.length === 0) {
                return null;
            }
            else if (detail.currentSelectionValues.length === 1) {
                return detail.currentSelectionValues[0];
            }
            return detail.currentSelectionValues;
        })();
        this.rawValue = value;
        this.marketFilterValueDidChange.emit({
            name: this.name,
            prevValue: prevValue || null,
            value,
        });
        /**
         * If the `<market-list>` is mutliselect, prevent the dropdown from collapsing after a selection.
         * Also prevent from closing when `dropdownInteraction` is provided.
         */
        if (!((_a = this.listEl) === null || _a === void 0 ? void 0 : _a.multiselect) && !this.dropdownInteraction) {
            this.expanded = false;
        }
    }
    /**
     * Handle `marketDateRangeChanged` emitted by `<market-date-picker>`
     */
    handleDateRangeChange(e) {
        const { startDate, endDate, prevStartDate, prevEndDate } = e.detail;
        this.setDisplayValueFromDateEvent(e);
        this.marketFilterValueDidChange.emit({
            name: this.name,
            prevValue: {
                startDate: prevStartDate,
                endDate: prevEndDate,
            },
            value: {
                startDate,
                endDate,
            },
        });
    }
    /**
     * Handle `marketDropdownOpened` emitted by `<market-dropdown>`
     */
    handleDropdownOpened(e) {
        if (e.target !== this.el)
            return;
        const { defaultPrevented } = this.marketFilterExpandedChanged.emit(true);
        if (defaultPrevented) {
            e.preventDefault();
            return;
        }
        // temporary handler for deprecated event
        if (this.marketFilterOpened.emit().defaultPrevented) {
            e.preventDefault();
            return;
        }
        if (!this.dropdownInteraction) {
            this.expanded = true;
        }
    }
    /**
     * Handle `marketDropdownClosed` emitted by `<market-dropdown>`
     */
    handleDropdownClosed(e) {
        if (e.target !== this.el)
            return;
        const { defaultPrevented } = this.marketFilterExpandedChanged.emit(false);
        if (defaultPrevented) {
            e.preventDefault();
            return;
        }
        // temporary handler for deprecated event
        if (this.marketFilterClosed.emit().defaultPrevented) {
            e.preventDefault();
            return;
        }
        if (!this.dropdownInteraction) {
            this.expanded = false;
        }
    }
    /**
     * Handle default slot changes
     */
    handleDefaultSlotChange() {
        this.datePickerEl = this.el.querySelector(getNamespacedTagFor('market-date-picker'));
        this.listEl = this.el.querySelector(getNamespacedTagFor('market-list'));
        const autoId = `popover-${v4()}`;
        if (this.datePickerEl) {
            if (!this.datePickerEl.id) {
                this.datePickerEl.id = autoId;
                this.popoverId = autoId;
            }
            else {
                this.popoverId = this.datePickerEl.id;
            }
            this.filterType = 'date';
            this.setDisplayValueFromSlottedElement();
        }
        else if (this.listEl) {
            // make sure that the list is interactive
            if (!this.listEl.interactive) {
                this.listEl.interactive = true;
            }
            if (!this.listEl.id) {
                this.listEl.id = autoId;
                this.popoverId = autoId;
            }
            else {
                this.popoverId = this.listEl.id;
            }
            this.filterType = 'list';
            this.setDisplayValueFromSlottedElement();
        }
    }
    /**
     * Listens to changes in row content to ensure that if the selected row's content
     * is dynamically updated, those changes will be reflected to `selectedDisplayValue`.
     */
    initRowObservers() {
        /**
         * Since onSlotchange only fires on changes to the slotted node itself,
         * we need to use mutation observers to listen to changes to market-list's
         * slotted market-rows: https://github.com/ionic-team/stencil/issues/232#issuecomment-397871813
         */
        const syncRowContent = (row) => {
            if (typeof this.rawValue === 'string' && row.value === this.rawValue) {
                this.selectedDisplayValue = this.getTextContentOfRowWithValue(row.value);
            }
        };
        const rows = this.el.querySelectorAll(`${getNamespacedTagFor('market-list')} ${getNamespacedTagFor('market-row')}`);
        rows.forEach((row) => {
            const observer = new MutationObserver(() => syncRowContent(row));
            observer.observe(row, { characterData: true, subtree: true });
        });
    }
    /**
     * Gets the `.textContent` of the `<market-row>` with the provided `value`.
     * This is only used for list types.
     */
    getTextContentOfRowWithValue(value) {
        const marketRowTag = getNamespacedTagFor('market-row');
        const labelEl = this.listEl.querySelector(`${marketRowTag}[value="${value}"] [slot="label"]`);
        return labelEl === null || labelEl === void 0 ? void 0 : labelEl.textContent;
    }
    /**
     * Infers the value from the <market-list> or <market-date-picker>
     */
    setDisplayValueFromSlottedElement() {
        const displayValueEl = this.el.querySelector('[slot="display-value"]');
        const hasDisplayValue = Boolean(displayValueEl);
        if (hasDisplayValue) {
            this.selectedDisplayValue = displayValueEl.textContent;
            return;
        }
        if (this.listEl) {
            if (!this.listEl.value) {
                this.selectedDisplayValue = undefined;
                return;
            }
            this.rawValue = this.listEl.value;
            if (this.listEl.multiselect) {
                // if there's more than 1 value selected, get the count of selected values
                const valueCount = (() => {
                    if (typeof this.listEl.value === 'string') {
                        return this.listEl.value.split(',').length;
                    }
                    else if (Array.isArray(this.listEl.value)) {
                        return this.listEl.value.length;
                    }
                    return undefined; // this will skip the check below and print the raw `value` instead
                })();
                if (valueCount > 1) {
                    this.selectedDisplayValue = `${valueCount}`;
                    return;
                }
            }
            // get the selected row's label textContent and set that as the display value
            this.selectedDisplayValue = this.getTextContentOfRowWithValue(this.listEl.value);
        }
        else if (this.datePickerEl) {
            this.selectedDisplayValue = this.formatDate({
                startDate: this.datePickerEl.selectedStartDate,
                endDate: this.datePickerEl.selectedEndDate,
            });
        }
    }
    formatDate({ startDate, endDate }) {
        var _a, _b;
        const start = startDate ? new Date(startDate) : undefined;
        const end = endDate ? new Date(endDate) : undefined;
        if (!start && !end) {
            return '';
        }
        const locale = this.datePickerEl.locale;
        // If both dates exists and have the same year, show the year only on the end of the range.
        const startAndEndInTheSameYear = Boolean(start && end && start.getFullYear() === end.getFullYear());
        const startDateString = (_a = start === null || start === void 0 ? void 0 : start.toLocaleDateString(locale, startAndEndInTheSameYear && end ? { day: 'numeric', month: 'numeric' } : { dateStyle: 'short' })) !== null && _a !== void 0 ? _a : '';
        const endDateString = (_b = end === null || end === void 0 ? void 0 : end.toLocaleDateString(locale, { dateStyle: 'short' })) !== null && _b !== void 0 ? _b : '';
        return `${startDateString}${endDateString ? `${endDateString}` : ''}`;
    }
    /**
     * Calculate the display value from the `marketDateRangeChanged` event of `<market-list>`
     * Formatting is based on design guidelines:
     * https://www.notion.so/marketdesignsystem/Filters-78885543b16446f49d5cfa98c6a56648#bb6aac7e29e04f98890ba32042ddae05
     */
    setDisplayValueFromDateEvent(e) {
        var _a, _b, _c, _d;
        const { menuSelection } = e.detail;
        if (menuSelection === MENU_SLOT_NAMES.CUSTOM) {
            this.selectedDisplayValue = this.formatDate(e.detail);
        }
        else if (menuSelection) {
            // get the textContent of the menu item
            const presetMenuTextContent = (_d = (_c = (_b = (_a = this.datePickerEl) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector(`${getNamespacedTagFor('market-date-picker-menu')} slot[name="${menuSelection}"]`)) === null || _c === void 0 ? void 0 : _c.textContent) === null || _d === void 0 ? void 0 : _d.trim();
            this.selectedDisplayValue = presetMenuTextContent;
        }
    }
    /**
     * Calculate the display value from the `marketListSelectionsDidChange` event of `<market-list>`
     */
    setDisplayValueFromListEvent({ currentSelectionValues, currentSelections, }) {
        const displayValueEl = this.el.querySelector('[slot="display-value"]');
        const hasDisplayValue = Boolean(displayValueEl);
        if (hasDisplayValue) {
            this.selectedDisplayValue = displayValueEl.textContent;
            return;
        }
        if (!(currentSelectionValues === null || currentSelectionValues === void 0 ? void 0 : currentSelectionValues.length)) {
            // no selection
            this.selectedDisplayValue = undefined;
        }
        else if (currentSelectionValues.length > 1) {
            // multiple selections: display the count
            this.selectedDisplayValue = `${currentSelectionValues.length}`;
        }
        else {
            // single selection: display the selected row's label contents
            const labelEl = currentSelections[0].querySelector('[slot="label"]');
            this.selectedDisplayValue = labelEl.textContent;
        }
    }
    connectedCallback() {
        this.initRowObservers();
        this.handleDefaultSlotChange();
    }
    render() {
        var _a;
        const { datePickerEl, disabled, dropdownInteraction, expanded, handleDefaultSlotChange, listEl, popoverId, popoverPlacement, popoverStrategy, selectedDisplayValue, size, } = this;
        /**
         * Dropdown interaction will be set as 'persistent' by default if:
         * - `dropdownInteraction` is not defined; or
         * - `<market-list>` is provided and is `multiselect`; or
         * - `<market-date-picker>` is provided
         */
        const isMultiselectList = (_a = listEl === null || listEl === void 0 ? void 0 : listEl.multiselect) !== null && _a !== void 0 ? _a : false;
        const hasDatePicker = Boolean(datePickerEl);
        const interaction = dropdownInteraction !== null && dropdownInteraction !== void 0 ? dropdownInteraction : (hasDatePicker || isMultiselectList ? 'persistent' : undefined);
        const MarketDropdownTagName = getNamespacedTagFor('market-dropdown');
        const MarketPopoverTagName = getNamespacedTagFor('market-popover');
        const MarketFilterButtonTagName = getNamespacedTagFor('market-filter-button');
        return (hAsync(Host, { key: '232446ed830e3feb776c691d0c77a27a13730e07', class: "market-filter" }, hAsync(MarketDropdownTagName, { key: 'eeb8a4bfe3a2d0a2c8ecf73787e0de2105137ca2', class: "dropdown", disabled: disabled, expanded: expanded, interaction: interaction, popoverPlacement: popoverPlacement, popoverStrategy: popoverStrategy }, hAsync(MarketFilterButtonTagName, { key: '7f34007cbf900c11b76d70d4b8ca5a341b0c69b7', active: expanded, class: "filter-button", disabled: disabled, ref: (el) => (this.filterButtonEl = el), slot: "trigger", size: size, popoverId: popoverId }, hAsync("slot", { key: 'd69a920b6ece024223e9b41f938ded48d7581cd9', name: "label" }), !isValueEmpty$1(selectedDisplayValue) && (hAsync("span", { key: 'b780be1b15399455522269be98a395af03f64c8b', slot: "feedback" }, hAsync("slot", { key: '92193310039dd4006cb34d945403f2f62aca4349', name: "display-value" }, selectedDisplayValue)))), hAsync(MarketPopoverTagName, { key: '8e1d32d1b6782be2fc9ddc3e09dec981adce7613', class: classNames({ 'date-popover': hasDatePicker }), slot: "popover", id: popoverId }, hAsync("slot", { key: '41b3895ba903e29b90063a3085a60ab0aa16bb75', onSlotchange: handleDefaultSlotChange.bind(this) }), hAsync("slot", { key: '08001b6b66a5bbc79e9e8c9ad51f285baa19ecd3', name: "list", onSlotchange: handleDefaultSlotChange.bind(this) })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketFilterStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-filter",
        "$members$": {
            "name": [1],
            "disabled": [4],
            "focused": [1540],
            "size": [1],
            "expanded": [1540],
            "dropdownInteraction": [1, "dropdown-interaction"],
            "popoverPlacement": [1, "popover-placement"],
            "popoverStrategy": [1, "popover-strategy"],
            "selectedDisplayValue": [32],
            "getFilterType": [64],
            "setFocus": [64],
            "__setAndEmitListValue": [64],
            "__setAndEmitDatePickerValue": [64]
        },
        "$listeners$": [[0, "marketListSelectionsDidChange", "handleListSelectionChange"], [0, "marketDateRangeChanged", "handleDateRangeChange"], [0, "marketDropdownOpened", "handleDropdownOpened"], [0, "marketDropdownClosed", "handleDropdownClosed"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["focused", "focused"], ["expanded", "expanded"]]
    }; }
}

const marketFilterButtonCss = "/*!@:host, ::slotted(*), **/.sc-market-filter-button-h,.sc-market-filter-button-s>*,*.sc-market-filter-button{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-filter-button-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-filter-button-h *.sc-market-filter-button,.sc-market-filter-button-h[disabled].sc-market-filter-button-s>*,.sc-market-filter-button-h[disabled] .sc-market-filter-button-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-filter-button-h{--filter-button-normal-state-icon-color:var(--filter-button-normal-state-label-color);--filter-button-hover-state-icon-color:var(--filter-button-hover-state-label-color);--filter-button-pressed-state-icon-color:var(--filter-button-pressed-state-label-color);--filter-button-disabled-state-icon-color:var(--filter-button-disabled-state-label-color);display:inline-block;white-space:nowrap}/*!@button*/button.sc-market-filter-button{display:inline-flex;gap:var(--filter-button-label-content-spacing);justify-content:center;align-items:center;width:100%;border:none;border-radius:var(--filter-button-border-radius);background-color:var(--filter-button-normal-state-background-color);color:var(--filter-button-normal-state-label-color);box-shadow:var(--filter-button-normal-state-border-color) 0 0 0 var(--filter-button-border-size) inset;font-family:inherit;white-space:nowrap;cursor:pointer}/*!@button:focus*/button.sc-market-filter-button:focus{outline:none}/*!@button ::slotted([slot])*/button .sc-market-filter-button-s>[slot]{cursor:inherit}/*!@button ::slotted([slot=\"feedback\"])*/button .sc-market-filter-button-s>[slot=\"feedback\"]{color:var(--filter-button-normal-state-feedback-color);white-space:nowrap}/*!@button svg*/button.sc-market-filter-button svg.sc-market-filter-button{display:none;fill:var(--filter-button-normal-state-icon-color)}/*!@:host([icon-only]) .label*/[icon-only].sc-market-filter-button-h .label.sc-market-filter-button{display:none}/*!@:host([icon-only]) svg*/[icon-only].sc-market-filter-button-h svg.sc-market-filter-button{display:block}/*!@:host([size=\"medium\"]) button*/[size=\"medium\"].sc-market-filter-button-h button.sc-market-filter-button{min-height:var(--filter-button-medium-size-minimum-height);padding:var(--filter-button-medium-size-label-vertical-padding)\n      var(--filter-button-medium-size-label-horizontal-padding);font-weight:var(--filter-button-medium-size-label-text-weight);font-size:var(--filter-button-medium-size-label-text-size);line-height:var(--filter-button-medium-size-label-text-leading);letter-spacing:var(--filter-button-medium-size-label-text-tracking);text-transform:var(--filter-button-medium-size-label-text-case)}/*!@:host([size=\"medium\"]) ::slotted([slot=\"feedback\"])*/.sc-market-filter-button-h[size=\"medium\"] .sc-market-filter-button-s>[slot=\"feedback\"]{font-weight:var(--filter-button-medium-size-feedback-text-weight);font-size:var(--filter-button-medium-size-feedback-text-size);line-height:var(--filter-button-medium-size-feedback-text-leading);letter-spacing:var(--filter-button-medium-size-feedback-text-tracking);text-transform:var(--filter-button-medium-size-feedback-text-case)}/*!@:host([size=\"small\"]) button*/[size=\"small\"].sc-market-filter-button-h button.sc-market-filter-button{min-height:var(--filter-button-small-size-minimum-height);padding:var(--filter-button-small-size-label-vertical-padding)\n      var(--filter-button-small-size-label-horizontal-padding);font-weight:var(--filter-button-small-size-label-text-weight);font-size:var(--filter-button-small-size-label-text-size);line-height:var(--filter-button-small-size-label-text-leading);letter-spacing:var(--filter-button-small-size-label-text-tracking);text-transform:var(--filter-button-small-size-label-text-case)}/*!@:host([size=\"small\"]) ::slotted([slot=\"feedback\"])*/.sc-market-filter-button-h[size=\"small\"] .sc-market-filter-button-s>[slot=\"feedback\"]{font-weight:var(--filter-button-small-size-feedback-text-weight);font-size:var(--filter-button-small-size-feedback-text-size);line-height:var(--filter-button-small-size-feedback-text-leading);letter-spacing:var(--filter-button-small-size-feedback-text-tracking);text-transform:var(--filter-button-small-size-feedback-text-case)}/*!@:host(:hover) button, :host(:focus) button*/.sc-market-filter-button-h:hover button.sc-market-filter-button,.sc-market-filter-button-h:focus button.sc-market-filter-button{background-color:var(--filter-button-hover-state-background-color);color:var(--filter-button-hover-state-label-color);box-shadow:var(--filter-button-hover-state-border-color) 0 0 0 var(--filter-button-border-size) inset}/*!@:host(:hover) ::slotted([slot=\"feedback\"]), :host(:focus) ::slotted([slot=\"feedback\"])*/.sc-market-filter-button-h:hover .sc-market-filter-button-s>[slot=\"feedback\"],.sc-market-filter-button-h:focus.sc-market-filter-button-s>[slot=\"feedback\"],.sc-market-filter-button-h:focus .sc-market-filter-button-s>[slot=\"feedback\"]{color:var(--filter-button-hover-state-feedback-color)}/*!@:host(:hover) svg, :host(:focus) svg*/.sc-market-filter-button-h:hover svg.sc-market-filter-button,.sc-market-filter-button-h:focus svg.sc-market-filter-button{fill:var(--filter-button-hover-state-icon-color)}/*!@:host([active]) button, :host(:active) button*/[active].sc-market-filter-button-h button.sc-market-filter-button,.sc-market-filter-button-h:active button.sc-market-filter-button{background-color:var(--filter-button-pressed-state-background-color);color:var(--filter-button-pressed-state-label-color);box-shadow:var(--filter-button-pressed-state-border-color) 0 0 0 var(--filter-button-border-size) inset}/*!@:host([active]) ::slotted([slot=\"feedback\"]), :host(:active) ::slotted([slot=\"feedback\"])*/.sc-market-filter-button-h[active] .sc-market-filter-button-s>[slot=\"feedback\"],.sc-market-filter-button-h:active.sc-market-filter-button-s>[slot=\"feedback\"],.sc-market-filter-button-h:active .sc-market-filter-button-s>[slot=\"feedback\"]{color:var(--filter-button-pressed-state-feedback-color)}/*!@:host([active]) svg, :host(:active) svg*/[active].sc-market-filter-button-h svg.sc-market-filter-button,.sc-market-filter-button-h:active svg.sc-market-filter-button{fill:var(--filter-button-pressed-state-icon-color)}/*!@:host([disabled]) button*/[disabled].sc-market-filter-button-h button.sc-market-filter-button{background-color:var(--filter-button-disabled-state-background-color);color:var(--filter-button-disabled-state-label-color);box-shadow:var(--filter-button-disabled-state-border-color) 0 0 0 var(--filter-button-border-size) inset}/*!@:host([disabled]) ::slotted([slot=\"feedback\"])*/.sc-market-filter-button-h[disabled] .sc-market-filter-button-s>[slot=\"feedback\"]{color:var(--filter-button-disabled-state-feedback-color)}/*!@:host([disabled]) svg*/[disabled].sc-market-filter-button-h svg.sc-market-filter-button{fill:var(--filter-button-disabled-state-icon-color)}";
var MarketFilterButtonStyle0 = marketFilterButtonCss;

/**
 * @slot - The text used for the filter button label
 * @slot feedback - The text to indicate currently applied filters
 */
class MarketFilterButton {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.size = 'medium';
        this.disabled = false;
        this.focused = false;
        this.iconOnly = false;
        this.active = false;
        this.popoverId = undefined;
        this.ariaAttributes = undefined;
    }
    handleClick(event) {
        if (this.disabled) {
            event.stopImmediatePropagation();
        }
    }
    handleDisabledChange(newValue) {
        if (newValue && this.focused) {
            this.focused = false;
        }
    }
    /**
     * Toggle focus on the filter button
     * @param {boolean} [value=true] whether or not focus will be applied or removed
     * @returns {Promise<boolean>} whether or not the button was focused or blurred
     */
    async setFocus(value = true) {
        if (this.disabled) {
            return Promise.resolve(false);
        }
        this.focused = value;
        if (this.focused) {
            this.buttonEl.focus();
        }
        else {
            this.buttonEl.blur();
        }
        return Promise.resolve(this.focused);
    }
    render() {
        return (hAsync(Host, { key: '752fd8ad8a381d5f89cf0e177d11ba9bb4d74a2c', class: "market-filter-button" }, hAsync("button", { key: '42ad2cc1f2f0ab15177812c029be00a2c76bbe04', "aria-disabled": this.disabled, disabled: this.disabled, ref: (el) => (this.buttonEl = el), "aria-expanded": this.active.toString(), "aria-controls": this.popoverId, type: "button" }, hAsync("svg", { key: '2fe6ab99cf28e8502042eebd33466849206357d9', width: "18", height: "12", viewBox: "0 0 18 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: 'a083550a7a9e99b2d609adfc231104bff2dd89d1', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0 0H18V2H0V0ZM15 5H3V7H15V5ZM12 10H6V12H12V10Z" })), hAsync("span", { key: '9220d6f2bfa3c6640773aae7b0b0e10fe3c0bf8f', class: "label" }, hAsync("slot", { key: '78a1dff60c4b0cf87141a94ed4cbecdf62d9f213' })), hAsync("slot", { key: '4e28fde3d40ce59ed21759070255a094ba42bf9d', name: "feedback" }))));
    }
    static get watchers() { return {
        "disabled": ["handleDisabledChange"]
    }; }
    static get style() { return MarketFilterButtonStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-filter-button",
        "$members$": {
            "size": [513],
            "disabled": [516],
            "focused": [1540],
            "iconOnly": [516, "icon-only"],
            "active": [516],
            "popoverId": [1, "popover-id"],
            "ariaAttributes": [32],
            "setFocus": [64]
        },
        "$listeners$": [[2, "click", "handleClick"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["size", "size"], ["disabled", "disabled"], ["focused", "focused"], ["iconOnly", "icon-only"], ["active", "active"]]
    }; }
}

const marketFilterDropdownMenuCss = "/*!@:host, ::slotted(*), **/.sc-market-filter-dropdown-menu-h,.sc-market-filter-dropdown-menu-s>*,*.sc-market-filter-dropdown-menu{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-filter-dropdown-menu-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-filter-dropdown-menu-h *.sc-market-filter-dropdown-menu,.sc-market-filter-dropdown-menu-h[disabled].sc-market-filter-dropdown-menu-s>*,.sc-market-filter-dropdown-menu-h[disabled] .sc-market-filter-dropdown-menu-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@::slotted([slot=\"filter-title\"])*/.sc-market-filter-dropdown-menu-s>[slot=\"filter-title\"]{font-weight:var(--core-type-heading-20-weight);font-size:var(--core-type-heading-20-size);font-family:var(--core-type-heading-20-font-family);line-height:var(--core-type-heading-20-leading);letter-spacing:var(--core-type-heading-20-tracking);text-transform:var(--core-type-heading-20-case)}/*!@.overflow-filters*/.overflow-filters.sc-market-filter-dropdown-menu{overflow:hidden;height:0}/*!@.popover*/.popover.sc-market-filter-dropdown-menu{display:flex;flex-direction:column}/*!@.selection-header::part(heading)*/.selection-header.sc-market-filter-dropdown-menu::part(heading){--filter-overflow-heading-margin-top-size:var(--core-metrics-spacing-200);margin-top:var(--filter-overflow-heading-margin-top-size)}/*!@.filter-options-container*/.filter-options-container.sc-market-filter-dropdown-menu{--filter-overflow-filter-options-container-margin-top-size:var(--core-metrics-spacing-100);display:flex;flex:1;overflow-y:auto;width:calc(\n      100% +\n      var(--modal-popover-wide-viewport-padding-left-size) +\n      var(--modal-popover-wide-viewport-padding-right-size)\n    );margin:var(--filter-overflow-filter-options-container-margin-top-size)\n    calc(var(--modal-popover-wide-viewport-padding-right-size) * -1)\n    calc(var(--modal-popover-wide-viewport-padding-bottom-size) * -1)\n    calc(var(--modal-popover-wide-viewport-padding-left-size) * -1);padding-left:var(--modal-popover-wide-viewport-padding-left-size)}/*!@.filter-options-container ::slotted(.market-list[slot=\"filter-options\"])*/.filter-options-container .sc-market-filter-dropdown-menu-s>.market-list[slot=\"filter-options\"]{width:calc(100% - var(--modal-popover-wide-viewport-padding-right-size))}/*!@.filter-options-container ::slotted(.market-list[slot=\"filter-options\"])::after*/.filter-options-container .sc-market-filter-dropdown-menu-s>.market-list[slot=\"filter-options\"]::after{content:\"\";display:block;width:100%;height:var(--core-metrics-spacing-100)}/*!@.filter-options-container ::slotted(.market-date-picker[slot=\"filter-options\"])*/.filter-options-container .sc-market-filter-dropdown-menu-s>.market-date-picker[slot=\"filter-options\"]{width:auto;min-width:var(--date-picker-minimum-width);padding-right:var(--modal-popover-wide-viewport-padding-right-size)}/*!@.filter-options-container ::slotted(.market-date-picker[slot=\"filter-options\"])::after*/.filter-options-container .sc-market-filter-dropdown-menu-s>.market-date-picker[slot=\"filter-options\"]::after{content:\"\";display:block;width:100%;height:var(--core-metrics-spacing-300)}/*!@.filter-options-container ::slotted(.market-date-picker[slot=\"filter-options\"][display-menu])*/.filter-options-container .sc-market-filter-dropdown-menu-s>.market-date-picker[slot=\"filter-options\"][display-menu]{height:calc(100%)}";
var MarketFilterDropdownMenuStyle0 = marketFilterDropdownMenuCss;

/**
 * @slot search - Search input, using `<market-input-search>`
 * @slot filters - Filters, using `<market-filter>`
 * @slot settings - Filter settings, using `<market-filter>`
 * @slot visible-filters - INTERNAL ONLY: Used by `<market-filter-group>` when programmatically arranging visible vs overflow
 * buttons based on available space.
 */
class MarketFilterDropdownMenu {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.size = 'medium';
        this.filtersWithSelectedValue = undefined;
        this.hasSelectedFilter = undefined;
        this.isDropdownActive = undefined;
    }
    /**
     * Handle `marketDropdownOpened` emitted by `<market-dropdown>`
     */
    handleDropdownOpened(e) {
        if (e.target !== this.el)
            return;
        this.deselectFilter();
        this.isDropdownActive = true;
    }
    /**
     * Handle `marketDropdownClosed` emitted by `<market-dropdown>`
     */
    handleDropdownClosed(e) {
        if (e.target !== this.el)
            return;
        this.isDropdownActive = false;
    }
    /**
     * Handle `marketHeaderNavigate` emitted by `<market-button>` when clicking the back button
     */
    handleHeaderNavigate() {
        this.deselectFilter();
    }
    /**
     * Deselect filter
     */
    deselectFilter() {
        this.hasSelectedFilter = false;
    }
    /**
     * Handle overflow-filters slot change
     */
    handleOverflowFiltersSlotChange() {
        this.filterEls = this.el
            .querySelector('[slot="overflow-filters"]')
            .assignedNodes();
        // create <market-row>s; and calculate how many filters have set `values`
        this.createRowsFromFilters();
        this.calculateFiltersWithSelectedValue();
    }
    /**
     * Create rows from filter slots
     */
    createRowsFromFilters() {
        var _a, _b, _c, _d;
        // no more filters, remove rows if they exist
        if (!((_a = this.filterEls) === null || _a === void 0 ? void 0 : _a.length)) {
            (_b = this.filterRowEls) === null || _b === void 0 ? void 0 : _b.forEach((filterRowEl) => {
                filterRowEl.remove();
            });
            return;
        }
        const filterRowElsByValue = ((_c = this.filterRowEls) !== null && _c !== void 0 ? _c : []).reduce((result, rowEl) => {
            result[rowEl.value] = rowEl;
            return result;
        }, {});
        const filterNames = new Set();
        const rowsByName = {};
        this.filterEls.forEach((filterEl) => {
            var _a;
            const name = filterEl.name;
            filterNames.add(name);
            const currentRowEl = filterRowElsByValue[name];
            if (currentRowEl) {
                // recycle filter row with the same name if it exists
                rowsByName[name] = currentRowEl;
            }
            else {
                // create new row element
                const newRowEl = document.createElement(getNamespacedTagFor('market-row'));
                newRowEl.variant = 'drill';
                newRowEl.interactive = true;
                newRowEl.transient = true;
                newRowEl.value = name;
                newRowEl.size = this.size;
                newRowEl.addEventListener('click', async () => {
                    await this.handleFilterSelection(newRowEl);
                });
                rowsByName[name] = newRowEl;
            }
            // create the row label
            const label = (_a = rowsByName[name]) === null || _a === void 0 ? void 0 : _a.querySelector('label');
            label === null || label === void 0 ? void 0 : label.remove();
            const filterLabelEl = filterEl.querySelector('label');
            if (filterLabelEl) {
                rowsByName[name].appendChild(filterLabelEl.cloneNode(true));
            }
            // disable the row if the filter is disabled
            if (filterEl.disabled) {
                rowsByName[name].disabled = true;
            }
            // assign the slot
            rowsByName[name].setAttribute('slot', 'filter-row');
        });
        // remove rows that should not exist anymore
        (_d = this.filterRowEls) === null || _d === void 0 ? void 0 : _d.forEach((filterRowEl) => {
            if (!filterNames.has(filterRowEl.value)) {
                filterRowEl.remove();
            }
        });
        // add the new rows to the DOM
        this.filterRowEls = [...this.filterEls].map(({ name }) => rowsByName[name]);
        this.filterRowEls.forEach((filterRowEl) => {
            filterRowEl.setAttribute('slot', 'filter-rows');
            this.el.appendChild(filterRowEl);
        });
    }
    /**
     * When a filter is selected, the popover content will show
     * the selected filter's title and list selection
     */
    async handleFilterSelection(rowEl) {
        var _a, _b, _c;
        const value = rowEl.value;
        this.hasSelectedFilter = true;
        const filterEl = this.filterEls.find((filterEl) => filterEl.name === value);
        // clone the label
        const labelEl = filterEl.querySelector('label');
        const clonedLabelEl = labelEl.cloneNode(true);
        clonedLabelEl.setAttribute('slot', 'filter-title');
        (_a = this.el.querySelector('[slot="filter-title"]')) === null || _a === void 0 ? void 0 : _a.remove();
        this.el.appendChild(clonedLabelEl);
        switch (await filterEl.getFilterType()) {
            case 'date': {
                // clone the date picker
                const datePickerEl = filterEl.querySelector(getNamespacedTagFor('market-date-picker'));
                const clonedDatePickerEl = datePickerEl.cloneNode(true);
                clonedDatePickerEl.setAttribute('slot', 'filter-options');
                clonedDatePickerEl.addEventListener('marketDateRangeChanged', (e) => {
                    this.handleDatePickerFilterSelection(e, filterEl);
                });
                (_b = this.el.querySelector('[slot="filter-options"]')) === null || _b === void 0 ? void 0 : _b.remove();
                this.el.appendChild(clonedDatePickerEl);
                break;
            }
            case 'list': {
                // clone the list
                const listEl = filterEl.querySelector(getNamespacedTagFor('market-list'));
                const clonedListEl = listEl.cloneNode(true);
                clonedListEl.setAttribute('slot', 'filter-options');
                clonedListEl.addEventListener('marketListSelectionsDidChange', (e) => {
                    this.handleListFilterSelection(e, filterEl, listEl);
                });
                clonedListEl.setAttribute('interactive', '');
                listEl.multiselect && clonedLabelEl.setAttribute('multiselect', '');
                (_c = this.el.querySelector('[slot="filter-options"]')) === null || _c === void 0 ? void 0 : _c.remove();
                this.el.appendChild(clonedListEl);
                break;
            }
        }
    }
    async handleDatePickerFilterSelection(e, filterEl) {
        const { startDate, endDate } = e.detail;
        await filterEl.__setAndEmitDatePickerValue({ startDate, endDate });
        // after selecting, recalculate what we display as feedback
        this.calculateFiltersWithSelectedValue();
    }
    async handleListFilterSelection(e, filterEl, listEl) {
        // set the filter value, then automatically deselect if the list is not multiselect
        const { currentSelectionValues } = e.detail;
        await filterEl.__setAndEmitListValue(currentSelectionValues);
        if (!listEl.multiselect) {
            this.deselectFilter();
        }
        // after selecting, recalculate what we display as feedback
        this.calculateFiltersWithSelectedValue();
    }
    /**
     * Count how many filters with selected value
     * and that count is displayed as feedback.
     */
    calculateFiltersWithSelectedValue() {
        this.filtersWithSelectedValue = [...(this.filterEls || [])].reduce((count, filterEl) => {
            const list = filterEl.querySelector(getNamespacedTagFor('market-list'));
            if (!isValueEmpty$1(list === null || list === void 0 ? void 0 : list.value)) {
                return count + 1;
            }
            const datePicker = filterEl.querySelector(getNamespacedTagFor('market-date-picker'));
            if (datePicker === null || datePicker === void 0 ? void 0 : datePicker.selectedStartDate) {
                return count + 1;
            }
            return count;
        }, 0);
    }
    componentDidLoad() {
        this.handleOverflowFiltersSlotChange();
    }
    render() {
        const { filtersWithSelectedValue, handleOverflowFiltersSlotChange, hasSelectedFilter, isDropdownActive, size } = this;
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        const MarketDropdownTagName = getNamespacedTagFor('market-dropdown');
        const MarketFilterButtonTagName = getNamespacedTagFor('market-filter-button');
        const MarketHeaderTagName = getNamespacedTagFor('market-header');
        const MarketListTagName = getNamespacedTagFor('market-list');
        const MarketPopoverTagName = getNamespacedTagFor('market-popover');
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        return (hAsync(Host, { key: 'a0855f0de2eacc84c813febeb342ca93632969c4', class: classNames('market-filter-dropdown-menu', { 'show-options': hasSelectedFilter }) }, hAsync(MarketDropdownTagName, { key: 'fff9d200c45bad3f954435486c01877af984c7aa', interaction: "persistent", popoverPlacement: "bottom-end" }, hAsync(MarketFilterButtonTagName, { key: '704fa58e50c9d254387e0765ae0b5d07830255c1', active: isDropdownActive, iconOnly: true, size: size, slot: "trigger" }, filtersWithSelectedValue && hAsync("span", { key: '62cc860fe5084000ed4effbb64faf1e78de6e613', slot: "feedback" }, filtersWithSelectedValue)), hAsync(MarketPopoverTagName, { key: '5c8149b85ffcca282d261f21480af60940ac081d', class: "popover", slot: "popover" }, !hasSelectedFilter ? (hAsync(MarketListTagName, { class: "filter-list", interactive: true }, hAsync("slot", { name: "filter-rows" }))) : (hAsync(Fragment, null, hAsync(MarketHeaderTagName, { class: "selection-header" }, hAsync(MarketButtonTagName, { rank: "secondary", size: "small", slot: "navigation" }, hAsync(MarketAccessoryTagName, { slot: "icon" }, hAsync("svg", { width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M4.29289 11.293C3.90237 11.6835 3.90237 12.3167 4.29289 12.7072L11.2929 19.7072L12.7071 18.293L7.41421 13.0001L19 13.0001V11.0001L7.41421 11.0001L12.7071 5.70718L11.2929 4.29297L4.29289 11.293Z" })))), hAsync("slot", { name: "filter-title" })), hAsync("div", { class: "filter-options-container" }, hAsync("slot", { name: "filter-options" })))))), hAsync("div", { key: '8d07e768be4265b1dc9fddcb830ca9d788a3da80', class: "overflow-filters" }, hAsync("slot", { key: '4e9b383b6a4b36fc5665fd072965bfcf86c194ac', name: "overflow-filters", onSlotchange: handleOverflowFiltersSlotChange.bind(this) }))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketFilterDropdownMenuStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-filter-dropdown-menu",
        "$members$": {
            "size": [513],
            "filtersWithSelectedValue": [32],
            "hasSelectedFilter": [32],
            "isDropdownActive": [32]
        },
        "$listeners$": [[0, "marketDropdownOpened", "handleDropdownOpened"], [0, "marketDropdownClosed", "handleDropdownClosed"], [0, "marketHeaderNavigate", "handleHeaderNavigate"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["size", "size"]]
    }; }
}

const marketFilterGroupCss = "/*!@:host, ::slotted(*), **/.sc-market-filter-group-h,.sc-market-filter-group-s>*,*.sc-market-filter-group{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-filter-group-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-filter-group-h *.sc-market-filter-group,.sc-market-filter-group-h[disabled].sc-market-filter-group-s>*,.sc-market-filter-group-h[disabled] .sc-market-filter-group-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-filter-group-h{--filter-group-margin:var(--core-metrics-spacing-200);--filter-group-search-width:280px;display:flex;margin:var(--filter-group-margin)}/*!@.content*/.content.sc-market-filter-group{--filter-group-button-spacing:var(--core-metrics-spacing-100);display:flex;flex:1;flex-flow:row nowrap;gap:var(--filter-group-button-spacing, var(--core-metrics-spacing-100))}/*!@::slotted([slot=\"search\"])*/.sc-market-filter-group-s>[slot=\"search\"]{max-width:var(--filter-group-search-width)}/*!@::slotted([slot=\"search\"]:not([compact]))*/.sc-market-filter-group-s>[slot=\"search\"]:not([compact]){min-width:var(--filter-group-search-width)}/*!@::slotted([slot=\"search\"][focused])*/.sc-market-filter-group-s>[slot=\"search\"][focused]{flex:1 1 var(--filter-group-search-width)}@media (max-width: 599px){/*!@.content*/.content.sc-market-filter-group{justify-content:space-between}/*!@::slotted([slot=\"search\"])*/.sc-market-filter-group-s>[slot=\"search\"]{max-width:unset}/*!@::slotted([slot=\"search\"][focused])*/.sc-market-filter-group-s>[slot=\"search\"][focused]{flex:1}/*!@::slotted([slot=\"filters\"])*/.sc-market-filter-group-s>[slot=\"filters\"]{display:inline-flex;flex:1}}";
var MarketFilterGroupStyle0 = marketFilterGroupCss;

const MAX_VISIBLE_FILTERS = 3;
const FILTER_GROUP_GAP = 8;
const FILTER_BUTTON_WIDTH = 50;
const FILTER_BUTTON_FEEDBACK_GAP = 8;
const RESIZE_DEBOUNCE_DURATION$2 = 16; // 60fps
/**
 * @slot search - Search input, using `<market-input-search>`
 * @slot filters - Filters, using `<market-filter>`
 */
class MarketFilterGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Used to hide filters when on compact mode
         */
        this._isSearchActive = false;
        /**
         * Used to focus on the first filter when 'Tab' is pressed on the input search
         */
        this._willFocusOnFirstFilter = false;
        /**
         * Used to delay the overflow dropdown menu from opening
         */
        this._willDelayDropdownOpen = false;
        /**
         * Observers
         */
        this._observers = {};
        this.throttledHandleResize = throttle(this.handleResize.bind(this), RESIZE_DEBOUNCE_DURATION$2);
        this.maxVisibleFilters = 3;
        this._sortedFilterEls = {
            overflow: [],
            visible: [],
        };
    }
    maxVisibleFiltersWatcher() {
        this.handleResize();
    }
    /**
     * Search is active when it's focused
     */
    marketInputSearchFocusHandler({ detail }) {
        this._isSearchActive = detail;
    }
    /**
     * For every search animation event, we either show or hide filters
     */
    async marketInternalInputSearchCompactAnimationHandler(e) {
        e.stopPropagation();
        await this.handleResize();
        await asyncRequestAnimationFrame();
        /**
         * 'animationstart' means that search is expanded from its compact state.
         * So when the dropdown menu is clicked, we defer the popover from opening
         * right away to prevent jittery animations while elements are getting settled.
         * (See `marketDropdownOpenedHandler` for the delay logic)
         */
        this._willDelayDropdownOpen = e.detail === 'animationstart';
    }
    /**
     * Handle dropdown menu's `marketDropdownOpened` event
     * TODO: There is no `market-dropdown` in this template below.
     * This event is bubbling up from `market-filter-dropdown-menu`.
     * We should refactor this to use a custom event from that instead,
     * but that component does not yet emit custom open/close events.
     */
    marketDropdownOpenedHandler(e) {
        if (!this._willDelayDropdownOpen) {
            return;
        }
        this._willDelayDropdownOpen = false;
        e.preventDefault();
        /**
         * Delay `marketDropdownOpened` and manually open the dropdown later.
         * A little extra time (1.25x) has to be added in case the browser rendering
         * is a bit slow. FAST x 1.25 looks like the sweet spot for now.
         */
        setTimeout(async () => {
            var _a, _b, _c, _d, _e, _f;
            await asyncRequestAnimationFrame();
            await ((_c = (_b = (_a = this._dropdownMenuEl) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector(getNamespacedTagFor('market-dropdown'))) === null || _c === void 0 ? void 0 : _c.updateDropdownPosition());
            (_f = (_e = (_d = this._dropdownMenuEl) === null || _d === void 0 ? void 0 : _d.shadowRoot) === null || _e === void 0 ? void 0 : _e.querySelector(getNamespacedTagFor('market-dropdown'))) === null || _f === void 0 ? void 0 : _f.openDropdown();
        }, cjs.CORE_ANIMATION_EXIT_TRANSITION_FAST_SPEED_DURATION * 1.25);
    }
    /**
     * The overflow feedback's text length is based on filters that have value.
     * Basically, the button's structure is: `[ <icon> <gap> <feedback> ]`
     */
    calculateOverflowButtonWidth(filterEls) {
        // if there are no filters, the overflow button will be hidden
        if (!(filterEls === null || filterEls === void 0 ? void 0 : filterEls.length)) {
            return 0;
        }
        const hasValueCount = filterEls.reduce((result, filterEl) => {
            const listEl = filterEl.querySelector(getNamespacedTagFor('market-list'));
            if (listEl === null || listEl === void 0 ? void 0 : listEl.value) {
                return result + 1;
            }
            const datePickerEl = filterEl.querySelector(getNamespacedTagFor('market-date-picker'));
            if (datePickerEl === null || datePickerEl === void 0 ? void 0 : datePickerEl.selectedStartDate) {
                return result + 1;
            }
            return result;
        }, 0);
        // feedback omitted when there's no selection
        if (hasValueCount === 0) {
            return FILTER_BUTTON_WIDTH;
        }
        // render the text in some canvas and calculate its width
        const canvasEl = document.createElement('canvas');
        const context = canvasEl.getContext('2d');
        // assume that the first filter's size is the same size as the rest
        if (filterEls[0].size === 'small') {
            context.font = `${cjs.CORE_TYPE_PARAGRAPH_20_SIZE}px ${cjs.CORE_TYPE_PARAGRAPH_20_FONT_FAMILY}`;
        }
        else {
            context.font = `${cjs.CORE_TYPE_PARAGRAPH_30_SIZE}px ${cjs.CORE_TYPE_PARAGRAPH_30_FONT_FAMILY}`;
        }
        const feedbackTextWidth = context.measureText(`${hasValueCount}`).width;
        canvasEl.remove(); // cleanup
        return FILTER_BUTTON_WIDTH + FILTER_BUTTON_FEEDBACK_GAP + feedbackTextWidth;
    }
    getComputedWidth(el) {
        return Number.parseFloat(window.getComputedStyle(el).width);
    }
    /**
     * Find out where the cutoff will happen.
     * Main chunk of the overflow logic happens here
     */
    async findFilterCutoffIndex() {
        var _a, _b;
        if (((_a = this.maxVisibleFilters) !== null && _a !== void 0 ? _a : MAX_VISIBLE_FILTERS) <= 0) {
            return 0;
        }
        const isNarrowBreakpoint = (window === null || window === void 0 ? void 0 : window.innerWidth) <= cjs.CORE_BREAKPOINT_NARROW_MAX_WIDTH;
        if (isNarrowBreakpoint && !this._isSearchActive) {
            return 1; // show 1 filter max on narrow breakpoints
        }
        else if (this._isSearchActive) {
            return 0; // search is active so no filters should be shown
        }
        /**
         * Get the widths of all the other components (group, search)
         * where `FILTER_GROUP_GAP` is the gap between elements
         */
        const filterGroupWidth = this.getComputedWidth(this.el);
        const searchWidth = this._slottedInputSearchEl
            ? this.getComputedWidth(this._slottedInputSearchEl) + FILTER_GROUP_GAP
            : 0;
        /**
         * Temporary container where we can measure filter widths
         * https://dev.to/sstraatemans/calculate-html-element-width-before-render-4ii7
         */
        const tempEl = document.createElement('div');
        tempEl.style.width = 'auto';
        tempEl.style.position = 'absolute';
        tempEl.style.visibility = 'hidden';
        this.el.shadowRoot.appendChild(tempEl);
        let index = 0;
        let filterWidths = 0;
        for (const filterEl of this._filterEls) {
            if (index === ((_b = this.maxVisibleFilters) !== null && _b !== void 0 ? _b : MAX_VISIBLE_FILTERS)) {
                break;
            }
            /**
             * Presuming that all the remaining filters (**excluding** the current one, i.e. `filterEl`)
             * will be overflowed, calculate the potential dropdown menu button width.
             * If this is the last filter, it will not be followed by a `market-filter-dropdown-menu`.
             */
            const dropdownMenuButtonWidth = index + 1 === this._filterEls.length // is this the last one?
                ? 0
                : FILTER_GROUP_GAP + this.calculateOverflowButtonWidth(this._filterEls.slice(index));
            // measure the filter's width in the temporary container
            const clonedFilterEl = filterEl.cloneNode(true);
            clonedFilterEl.style.display = 'block';
            tempEl.appendChild(clonedFilterEl);
            // let the shadow DOM render within the temp container first before measuring its width
            await asyncRequestAnimationFrame();
            const filterElWidth = this.getComputedWidth(tempEl);
            tempEl.removeChild(clonedFilterEl);
            // width of all the filters so far; gap is only added for filters after the first
            filterWidths += (index > 0 ? FILTER_GROUP_GAP : 0) + filterElWidth;
            // check if filter can fit
            const potentialWidth = searchWidth + filterWidths + dropdownMenuButtonWidth;
            if (potentialWidth >= filterGroupWidth) {
                // it won't fit; breaking the loop sets the cutoff
                break;
            }
            ++index;
        }
        // cleanup
        this.el.shadowRoot.removeChild(tempEl);
        tempEl.remove();
        return index;
    }
    /**
     * Sort filters:
     * - split by `this._filterCutoffIndex`
     * - visible filters: set attr `[slot="filters"]`; remove `display: none;`
     * - overflow filters: set attr `[slot="overflow-filters"]`; add `display: none;`
     */
    sortVisibleAndOverflowFilters() {
        this._sortedFilterEls = {
            visible: this._filterEls.slice(0, this._filterCutoffIndex),
            overflow: this._filterEls.slice(this._filterCutoffIndex),
        };
        this._sortedFilterEls.visible.forEach((filterEl) => {
            if (filterEl.style.display) {
                filterEl.style.removeProperty('display');
            }
            if (filterEl.getAttribute('slot') !== 'filters') {
                filterEl.setAttribute('slot', 'filters');
            }
        });
        this._sortedFilterEls.overflow.forEach((filterEl) => {
            if (filterEl.style.display !== 'none') {
                filterEl.style.display = 'none';
            }
            if (filterEl.getAttribute('slot') !== 'overflow-filters') {
                filterEl.setAttribute('slot', 'overflow-filters');
            }
        });
    }
    /**
     * Handle screen / component resize
     */
    async handleResize() {
        if (!this.getComputedWidth(this.el)) {
            // element isn't fully rendered yet
            return;
        }
        const index = await this.findFilterCutoffIndex();
        const isFilterCutoffUpdated = index !== this._filterCutoffIndex;
        if (isFilterCutoffUpdated) {
            this._filterCutoffIndex = index;
            await asyncRequestAnimationFrame();
            this.sortVisibleAndOverflowFilters();
            // collapse dropdown if it's expanded
            if (this._dropdownMenuEl) {
                const dropdownEl = this._dropdownMenuEl.querySelector(getNamespacedTagFor('market-dropdown'));
                if (dropdownEl === null || dropdownEl === void 0 ? void 0 : dropdownEl.expanded) {
                    dropdownEl === null || dropdownEl === void 0 ? void 0 : dropdownEl.closeDropdown();
                }
            }
        }
        this.checkIfSearchShouldBeCompact();
    }
    /**
     * Toggle search's compact mode, if present and not focused
     */
    async checkIfSearchShouldBeCompact() {
        var _a, _b;
        if (!this._slottedInputSearchEl || this._slottedInputSearchEl.hasAttribute('focused')) {
            return;
        }
        const isNarrowBreakpoint = (window === null || window === void 0 ? void 0 : window.innerWidth) <= cjs.CORE_BREAKPOINT_NARROW_MAX_WIDTH;
        const hasFilters = Boolean((_a = this._filterEls) === null || _a === void 0 ? void 0 : _a.length);
        const hasMoreThanMaxFilters = this._filterEls.length > ((_b = this.maxVisibleFilters) !== null && _b !== void 0 ? _b : MAX_VISIBLE_FILTERS);
        const searchShouldBeCompact = hasFilters && (isNarrowBreakpoint || hasMoreThanMaxFilters);
        // only toggle `compact` when value is new
        if (searchShouldBeCompact !== this._slottedInputSearchEl.hasAttribute('compact')) {
            if (this._slottedInputSearchEl.getAttribute('focused')) {
                await this._slottedInputSearchEl.setFocus(false);
            }
            if (searchShouldBeCompact) {
                this._slottedInputSearchEl.setAttribute('compact', '');
            }
            else {
                this._slottedInputSearchEl.removeAttribute('compact');
            }
        }
    }
    /**
     * When tabbing from the search input and into the first filter,
     */
    handleInputSearchTabKeydown(e) {
        var _a;
        if (e.key === 'Tab' && !e.shiftKey && ((_a = this._filterEls) === null || _a === void 0 ? void 0 : _a.length)) {
            e.preventDefault();
            this._slottedInputSearchEl.blur();
            this._willFocusOnFirstFilter = true;
        }
    }
    /**
     * When input search is focused, make sure that dropdown menu is closed
     */
    handleInputSearchFocus() {
        var _a, _b;
        const dropdownEl = (_b = (_a = this._dropdownMenuEl) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector(getNamespacedTagFor('market-dropdown'));
        if (dropdownEl === null || dropdownEl === void 0 ? void 0 : dropdownEl.hasAttribute('expanded')) {
            dropdownEl.closeDropdown();
        }
    }
    registerSlottedInputSearch() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        (_b = (_a = this._slottedInputSearchEl) === null || _a === void 0 ? void 0 : _a.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, 'keydown', this.handleInputSearchTabKeydown);
        (_d = (_c = this._slottedInputSearchEl) === null || _c === void 0 ? void 0 : _c.removeEventListener) === null || _d === void 0 ? void 0 : _d.call(_c, 'focus', this.handleInputSearchFocus);
        this._slottedInputSearchEl = this.el.querySelector('[slot="search"]');
        (_f = (_e = this._slottedInputSearchEl) === null || _e === void 0 ? void 0 : _e.addEventListener) === null || _f === void 0 ? void 0 : _f.call(_e, 'keydown', this.handleInputSearchTabKeydown.bind(this));
        (_h = (_g = this._slottedInputSearchEl) === null || _g === void 0 ? void 0 : _g.addEventListener) === null || _h === void 0 ? void 0 : _h.call(_g, 'focus', this.handleInputSearchFocus.bind(this));
        this.checkIfSearchShouldBeCompact();
    }
    registerSlottedFilters() {
        this._filterEls = [...this.el.children].filter((el) => isElementWithTagName(el, 'market-filter'));
    }
    observeContent(el) {
        if (!this._observers.content) {
            this._observers.content = new ResizeObserver(this.throttledHandleResize);
            this._observers.content.observe(el);
        }
    }
    filtersOnSlotChangeHandler() {
        this.registerSlottedFilters();
        this.handleResize();
    }
    connectedCallback() {
        if (!this._observers.host) {
            this._observers.host = new ResizeObserver(this.throttledHandleResize);
            this._observers.host.observe(this.el);
        }
    }
    componentWillLoad() {
        this.registerSlottedFilters();
        this.registerSlottedInputSearch();
        this.handleResize();
    }
    componentWillRender() {
        var _a, _b, _c;
        // if 'Tab' was pressed (see `handleInputSearchTabKeydown`), attempt to focus on the first filter
        if (this._willFocusOnFirstFilter) {
            (_c = (_b = (_a = this._filterEls) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.setFocus) === null || _c === void 0 ? void 0 : _c.call(_b);
            this._willFocusOnFirstFilter = false;
        }
    }
    disconnectedCallback() {
        Object.entries(this._observers).forEach(([key, observer]) => {
            if (observer) {
                observer.disconnect();
                this._observers[key] = undefined;
            }
        });
    }
    render() {
        var _a, _b;
        /**
         * The dropdown menu button will follow the size of the first filter;
         * basically assuming that the rest of the filters follow the same size.
         */
        const dropdownMenuButtonSize = (_b = (_a = this._filterEls) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.size;
        const MarketFilterDropdownMenuTagName = getNamespacedTagFor('market-filter-dropdown-menu');
        return (hAsync(Host, { key: 'bcebdf2c66d61a3bdf5b7e68b049ae8aef8d592b', class: "market-filter-group" }, hAsync("div", { key: '54f3edb35faf0ebabc85d5564f15d144aa8405d2', class: "content", ref: (el) => this.observeContent(el) }, hAsync("slot", { key: '0f0f1052cf9714fbf3dd9d134fb509979bd8f03a', name: "search", onSlotchange: () => this.registerSlottedInputSearch() }), hAsync("slot", { key: '30813cd9185d3cf5728e7fe20e90e3cda4bb3388', name: "filters", onSlotchange: () => this.filtersOnSlotChangeHandler() }), this._sortedFilterEls.overflow.length > 0 && (hAsync(MarketFilterDropdownMenuTagName, { key: '7db61ce101fcd40d802ccfb58f238c61312b857a', class: "dropdown-menu", size: dropdownMenuButtonSize, ref: (el) => (this._dropdownMenuEl = el) }, hAsync("slot", { key: '6f0d43ea458edc1181a046ab7d261aabd4f0b5f8', name: "overflow-filters", slot: "overflow-filters" }))))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "maxVisibleFilters": ["maxVisibleFiltersWatcher"]
    }; }
    static get style() { return MarketFilterGroupStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-filter-group",
        "$members$": {
            "maxVisibleFilters": [2, "max-visible-filters"],
            "_sortedFilterEls": [32]
        },
        "$listeners$": [[0, "marketInputSearchFocus", "marketInputSearchFocusHandler"], [0, "marketInternalInputSearchCompactAnimation", "marketInternalInputSearchCompactAnimationHandler"], [0, "marketDropdownOpened", "marketDropdownOpenedHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const marketFooterCss = "/*!@:host, ::slotted(*), **/.sc-market-footer-h,.sc-market-footer-s>*,*.sc-market-footer{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-footer-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-footer-h *.sc-market-footer,.sc-market-footer-h[disabled].sc-market-footer-s>*,.sc-market-footer-h[disabled] .sc-market-footer-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-footer-h{display:flex;flex-wrap:wrap;justify-content:space-between;width:100%;padding:var(--footer-vertical-padding-size) 0}/*!@:host ::slotted(.market-button-group)*/.sc-market-footer-h .sc-market-footer-s>.market-button-group{width:100%}";
var MarketFooterStyle0 = marketFooterCss;

/**
 * @slot - The content of the footer, ex button(s), text
 */
class MarketFooter {
    constructor(hostRef) {
        registerInstance(this, hostRef);
    }
    render() {
        return (hAsync(Host, { key: '99d6e49edf0d6d563f09d8e95f4f4f3a04cbd8a3', class: "market-footer" }, hAsync("slot", { key: '65b517c3bbc7a9bc55637ee1d21f738546d70832' })));
    }
    static get style() { return MarketFooterStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-footer",
        "$members$": undefined,
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const marketHeaderCss = "/*!@:host, ::slotted(*), **/.sc-market-header-h,.sc-market-header-s>*,*.sc-market-header{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-header-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-header-h *.sc-market-header,.sc-market-header-h[disabled].sc-market-header-s>*,.sc-market-header-h[disabled] .sc-market-header-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@::slotted(.wayfinding), ::slotted([slot=\"wayfinding\"]), ::slotted(.subheading), ::slotted([slot=\"subheading\"])*/.sc-market-header-s>.wayfinding,.sc-market-header-s>[slot=\"wayfinding\"],.sc-market-header-s>.subheading,.sc-market-header-s>[slot=\"subheading\"]{font-weight:var(--core-type-paragraph-20-weight);font-size:var(--core-type-paragraph-20-size);font-family:var(--core-type-paragraph-20-font-family);line-height:var(--core-type-paragraph-20-leading);letter-spacing:var(--core-type-paragraph-20-tracking);text-transform:var(--core-type-paragraph-20-case)}/*!@::slotted(.wayfinding) b, ::slotted(.wayfinding) strong, ::slotted([slot=\"wayfinding\"]) b, ::slotted([slot=\"wayfinding\"]) strong, ::slotted(.subheading) b, ::slotted(.subheading) strong, ::slotted([slot=\"subheading\"]) b, ::slotted([slot=\"subheading\"]) strong*/.sc-market-header-s>.wayfinding b,.sc-market-header-s>.wayfinding strong,.sc-market-header-s>[slot=\"wayfinding\"] b,.sc-market-header-s>[slot=\"wayfinding\"] strong,.sc-market-header-s>.subheading b,.sc-market-header-s>.subheading strong,.sc-market-header-s>[slot=\"subheading\"] b,.sc-market-header-s>[slot=\"subheading\"] strong{font-weight:var(--core-type-semibold-20-weight)}/*!@:host*/.sc-market-header-h{--header-animation-duration:0.2s;display:block}/*!@::slotted(*)*/.sc-market-header-s>*{margin:0}/*!@::slotted(.wayfinding), ::slotted([slot=\"wayfinding\"])*/.sc-market-header-s>.wayfinding,.sc-market-header-s>[slot=\"wayfinding\"]{display:block;margin-bottom:var(--header-sub-text-spacing-bottom-size);color:var(--header-sub-text-text-color)}/*!@::slotted(.subheading), ::slotted([slot=\"subheading\"])*/.sc-market-header-s>.subheading,.sc-market-header-s>[slot=\"subheading\"]{display:block;margin-top:var(--header-sub-text-spacing-bottom-size);color:var(--header-sub-text-text-color)}/*!@:host([show-navigation]) ::slotted([slot=\"compact\"]:not(.wayfinding):not(.subheading))*/.sc-market-header-h[show-navigation] .sc-market-header-s>[slot=\"compact\"]:not(.wayfinding):not(.subheading){font-weight:var(--core-type-heading-20-weight);font-size:var(--core-type-heading-20-size);font-family:var(--core-type-heading-20-font-family);line-height:var(--core-type-heading-20-leading);letter-spacing:var(--core-type-heading-20-tracking);text-transform:var(--core-type-heading-20-case)}/*!@nav*/nav.sc-market-header{padding-right:var(--header-main-text-horizontal-spacing)}/*!@menu*/menu.sc-market-header{display:none;grid-auto-flow:column;align-items:start;margin:0;padding-left:var(--header-main-text-horizontal-spacing);-moz-column-gap:var(--button-group-spacing);column-gap:var(--button-group-spacing)}/*!@:host([show-actions]) menu*/[show-actions].sc-market-header-h menu.sc-market-header{display:grid}/*!@.grid*/.grid.sc-market-header{display:none}/*!@:host([show-actions]) .grid*/[show-actions].sc-market-header-h .grid.sc-market-header{display:grid;grid-template-columns:auto minmax(max-content, 1fr)}/*!@:host([show-navigation]) .grid*/[show-navigation].sc-market-header-h .grid.sc-market-header{display:grid;grid-template-columns:minmax(max-content, 1fr) auto minmax(max-content, 1fr)}/*!@.navigation*/.navigation.sc-market-header{display:none}/*!@:host([show-navigation]) .navigation*/[show-navigation].sc-market-header-h .navigation.sc-market-header{display:flex}/*!@.actions*/.actions.sc-market-header{display:flex;place-content:flex-end}/*!@.compact*/.compact.sc-market-header{display:flex;flex-direction:column;place-content:center}/*!@::slotted(p)*/.sc-market-header-s>p{margin-top:var(--header-bottom-padding-size)}/*!@::slotted(p[slot=\"compact\"])*/.sc-market-header-s>p[slot=\"compact\"]{display:none}/*!@:host([show-navigation]) .compact*/[show-navigation].sc-market-header-h .compact.sc-market-header{overflow:hidden;text-align:center;opacity:0%;visibility:hidden;transition:opacity var(--header-animation-duration) ease-in-out,\n    visibility 0s linear var(--header-animation-duration)}/*!@:host([show-navigation]) .compact ::slotted([slot=\"compact\"])*/.sc-market-header-h[show-navigation] .compact .sc-market-header-s>[slot=\"compact\"]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}/*!@.heading*/.heading.sc-market-header{display:block;transition:opacity var(--header-animation-duration) ease-in-out, visibility 0s}/*!@:host([show-navigation]) .heading*/[show-navigation].sc-market-header-h .heading.sc-market-header{margin-top:var(--header-nav-icon-button-spacing-buttom-size)}/*!@:host([show-actions]:not([show-navigation])) .heading*/[show-actions].sc-market-header-h:not([show-navigation]) .heading.sc-market-header{display:none}/*!@:host([show-navigation][compact]) .compact*/[show-navigation][compact].sc-market-header-h .compact.sc-market-header{opacity:100%;visibility:visible;transition:opacity var(--header-animation-duration) ease-in-out, visibility 0s}/*!@:host([show-navigation][compact]) .heading*/[show-navigation][compact].sc-market-header-h .heading.sc-market-header{opacity:0%;visibility:hidden;transition:opacity var(--header-animation-duration) ease-in-out,\n      visibility 0s linear var(--header-animation-duration)}/*!@:host(.regular) .heading*/.regular.sc-market-header-h .heading.sc-market-header{max-width:var(--modal-full-fixed-layout-width);margin-right:auto;margin-left:auto}/*!@:host(.wide) .heading*/.wide.sc-market-header-h .heading.sc-market-header{max-width:1200px;margin-right:auto;margin-left:auto}";
var MarketHeaderStyle0 = marketHeaderCss;

/**
 * @slot - The title. The position of the title varies based on the presence of other slots
 * @slot navigation - navigation buttons, ex close, back, forward, on the left side of the header
 * @slot wayfinding - the smaller "eyebrow" text displayed above the title, e.g. "Step 1 of 2"
 * @slot actions - for button(s) to perform actions, on the right side of the header
 * @slot subheading - Secondary text for the row
 * @part heading - the heading area where the default, wayfinding, and subheading slot is contained in
 */
class MarketHeader {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketHeaderNavigate = createEvent(this, "marketHeaderNavigate", 7);
        this.showNavigation = null;
        this.closeButtonAriaLabel = 'Close';
        this.disableCloseButton = false;
        this.compact = false;
        this.showActions = false;
    }
    handleCompact() {
        if (this.compact) {
            const compact = this.el.shadowRoot.querySelector('.grid .compact');
            const minHeight = Number.parseInt(getComputedStyle(compact).height, 10);
            this.el.style.height = minHeight !== undefined ? `${minHeight}px` : '';
        }
        else {
            this.el.style.height = '';
        }
    }
    handleSlottedNavigation() {
        // If there is custom navigation passed in, we need to
        // attach event handlers to the slotted elements manually
        const customNavEl = this.el.querySelector('[slot="navigation"]');
        if (customNavEl) {
            this.showNavigation = true;
            customNavEl.addEventListener('click', this.handleSlottedNavClick.bind(this));
        }
    }
    handleSlottedActions() {
        const actions = this.el.querySelector('[slot="actions"]');
        this.showActions = actions ? true : false;
    }
    handleCloseButtonClick(event) {
        this.marketHeaderNavigate.emit({
            event,
            action: 'close',
        });
    }
    handleSlottedNavClick(event) {
        this.marketHeaderNavigate.emit({
            event,
            action: 'custom',
        });
    }
    componentWillLoad() {
        this.checkForNavigation();
        this.cloneDefaultHeadingToCompactHeading();
        // watch for changes in slotted children content
        const observer = new MutationObserver(this.handleMutation.bind(this));
        observer.observe(this.el, { childList: true, characterData: true, subtree: true });
    }
    componentDidRender() {
        // this function requires layout computation,
        // so we need to wait until render to call.
        this.handleCompact();
    }
    handleMutation(mutationList) {
        // We don't want to re-clone the default slot content if
        // the mutation was already the result of the cloning
        // because then we would get into an infinite loop!
        // So we have to look at the mutation data to check if a
        // compact slotted element was added to prevent re-cloning.
        let shouldClone = true;
        mutationList.forEach((mutation) => {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach((node) => {
                    if (node.slot === 'compact') {
                        shouldClone = false;
                    }
                });
            }
        });
        if (shouldClone) {
            this.cloneDefaultHeadingToCompactHeading();
        }
    }
    checkForNavigation() {
        // We want to force the header to be navigable when slotted in modals
        const hasModalParent = this.el.closest(`
      ${getNamespacedTagFor('market-modal-full')},
      ${getNamespacedTagFor('market-modal-partial')}
    `);
        // The same if custom navigation is slotted in
        const hasCustomNavigation = this.el.querySelector('[slot="navigation"]');
        // Only set this if the prop hasn't been passed in manually
        if (this.showNavigation === null) {
            this.showNavigation = hasModalParent || hasCustomNavigation ? true : false;
        }
    }
    cloneDefaultHeadingToCompactHeading() {
        // clear existing compact slotted content
        const compactSlottedContent = this.el.querySelectorAll('[slot="compact"]');
        for (const node of compactSlottedContent) {
            this.el.removeChild(node);
        }
        // clone the wayfinding or subheading slot into compact slot
        const wayfindingEl = this.el.querySelector('[slot="wayfinding"]');
        const subheadingEl = this.el.querySelector('[slot="subheading"]');
        if (wayfindingEl) {
            const clone = wayfindingEl.cloneNode(true);
            clone.slot = 'compact';
            clone.classList.add('wayfinding');
            this.el.appendChild(clone);
        }
        // clone the rest of the default slot content into compact slot
        const defaultSlotContent = [...this.el.children].filter((el) => !el.getAttribute('slot'));
        for (const node of defaultSlotContent) {
            const clone = node.cloneNode(true);
            clone.slot = 'compact';
            this.el.appendChild(clone);
        }
        if (!wayfindingEl && subheadingEl) {
            const clone = subheadingEl.cloneNode(true);
            clone.slot = 'compact';
            clone.classList.add('subheading');
            this.el.appendChild(clone);
        }
    }
    renderDefaultNavigation() {
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        return (hAsync(MarketButtonTagName, { rank: "secondary", slot: "navigation", "aria-label": this.closeButtonAriaLabel, disabled: this.disableCloseButton, onClick: (event) => this.handleCloseButtonClick(event) }, hAsync(MarketIconTagName, { slot: "icon", name: cjs.HEADER_CLOSE_BUTTON_ICON_ASSET })));
    }
    render() {
        return (hAsync(Host, { key: '7deecc774073b8dbae2a706c36b0970ec4670fd0', class: "market-header", "show-actions": this.showActions }, hAsync("div", { key: '949def9a4ec1fc238649852bce2dda05e79b01bf', class: "grid" }, hAsync("div", { key: '48daf39e6b4e01e7d5ee2f046d14b70c05d5ca06', class: "navigation" }, hAsync("nav", { key: 'bd1b1d181e8e9b681764ab57e1eabfa644913d3f' }, hAsync("slot", { key: 'a9c8c33eea02ad025010c14a589dcf4928ea2888', name: "navigation", onSlotchange: () => this.handleSlottedNavigation() }, this.renderDefaultNavigation()))), hAsync("div", { key: '87fe12de9b587f9f08eb883ab786afa118ebd2cd', class: "compact" }, hAsync("slot", { key: '39d20daa0da037b878be425fc588a3e02fe73f14', name: "compact" })), hAsync("div", { key: 'd5857c0e116b22270b5cd3f7b67239c19328117d', class: "actions" }, hAsync("menu", { key: '12fc1cd1ed8570357a2e5888cb2e9ff523e8f760' }, hAsync("slot", { key: 'ea3684f5a6bffe85330a873232d88961bd4f5efe', name: "actions", onSlotchange: () => this.handleSlottedActions() })))), hAsync("div", { key: 'd209001247f0319930036590e609351026b684b6', class: "heading", part: "heading" }, hAsync("slot", { key: 'f29115e8addad7b8989a786bf0bfd9c44752db54', name: "wayfinding" }), hAsync("slot", { key: '39258aa88e9374c5c3d55544b4cab1b8d0402d7e' }), hAsync("slot", { key: '90c57b59dca1f4fcfd6326170e39beb9b9ea6182', name: "subheading" }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "compact": ["handleCompact"]
    }; }
    static get style() { return MarketHeaderStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-header",
        "$members$": {
            "showNavigation": [1540, "show-navigation"],
            "closeButtonAriaLabel": [513, "close-button-aria-label"],
            "disableCloseButton": [4, "disable-close-button"],
            "compact": [516],
            "showActions": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["showNavigation", "show-navigation"], ["closeButtonAriaLabel", "close-button-aria-label"], ["compact", "compact"]]
    }; }
}

const core = {
	icon: {
		expand: {
			"fidelity:16": {
				"default": true,
				asset: "chevron-down",
				size: 16,
				width: 16,
				height: 16,
				tintable: true
			}
		},
		collapse: {
			"fidelity:16": {
				"default": true,
				asset: "chevron-up",
				size: 16,
				width: 16,
				height: 16,
				tintable: true
			}
		},
		"continue": {
			"fidelity:16": {
				"default": true,
				asset: "chevron-right",
				size: 16,
				width: 16,
				height: 16,
				tintable: true
			}
		},
		"return": {
			"fidelity:16": {
				"default": true,
				asset: "chevron-left",
				size: 16,
				width: 16,
				height: 16,
				tintable: true
			}
		},
		clear: {
			"fidelity:24": {
				"default": true,
				asset: "x",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		close: {
			"fidelity:24": {
				"default": true,
				asset: "x",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		add: {
			"fidelity:24": {
				"default": true,
				asset: "plus",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		remove: {
			"fidelity:24": {
				"default": true,
				asset: "minus",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		back: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-left",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		previous: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-left",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		forward: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-right",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		next: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-right",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		ascend: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-up",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		descend: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-down",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		more: {
			"fidelity:24": {
				"default": true,
				asset: "ellipsis-horizontal",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		menu: {
			"fidelity:24": {
				"default": true,
				asset: "hamburger-lines",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		loading: {
			"fidelity:24": {
				"default": true,
				asset: "radial-spinner",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		search: {
			"fidelity:24": {
				"default": true,
				asset: "magnifying-glass",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		drag: {
			"fidelity:24": {
				"default": true,
				asset: "grip-dots-vertical",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		warn: {
			"fidelity:24": {
				"default": true,
				asset: "exclamation-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		warning: {
			"fidelity:24": {
				"default": true,
				asset: "exclamation-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		alert: {
			"fidelity:24": {
				"default": true,
				asset: "exclamation-triangle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		attention: {
			"fidelity:24": {
				"default": true,
				asset: "exclamation-triangle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		succeed: {
			"fidelity:24": {
				"default": true,
				asset: "checkmark-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		success: {
			"fidelity:24": {
				"default": true,
				asset: "checkmark-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		inform: {
			"fidelity:24": {
				"default": true,
				asset: "i-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		info: {
			"fidelity:24": {
				"default": true,
				asset: "i-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		deny: {
			"fidelity:24": {
				"default": true,
				asset: "no-entry-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		denied: {
			"fidelity:24": {
				"default": true,
				asset: "no-entry-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		cancel: {
			"fidelity:24": {
				"default": true,
				asset: "x-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		cancelled: {
			"fidelity:24": {
				"default": true,
				asset: "x-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		recommend: {
			"fidelity:24": {
				"default": true,
				asset: "lightning-bolt",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		recommendation: {
			"fidelity:24": {
				"default": true,
				asset: "lightning-bolt",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		refresh: {
			"fidelity:24": {
				"default": true,
				asset: "dual-rotating-arrows",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		cycle: {
			"fidelity:24": {
				"default": true,
				asset: "dual-rotating-arrows",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		"delete": {
			"fidelity:24": {
				"default": true,
				asset: "trashcan",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		checkmark: {
			"fidelity:24": {
				asset: "checkmark",
				size: 24,
				width: 20,
				height: 20,
				tintable: true
			},
			"fidelity:20": {
				"default": true,
				asset: "checkmark",
				size: 20,
				width: 20,
				height: 20,
				tintable: true
			}
		},
		indeterminate: {
			"fidelity:20": {
				"default": true,
				asset: "indeterminate-mark",
				size: 20,
				width: 20,
				height: 20,
				tintable: true
			}
		},
		help: {
			"fidelity:24": {
				"default": true,
				asset: "question-mark-circle",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		show: {
			"fidelity:24": {
				"default": true,
				asset: "eye",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		hide: {
			"fidelity:24": {
				"default": true,
				asset: "eye-slash",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		filter: {
			"fidelity:24": {
				"default": true,
				asset: "filter",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		file: {
			"fidelity:24": {
				"default": true,
				asset: "dogeared-paper",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		look: {
			"fidelity:24": {
				"default": true,
				asset: "binoculars",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		ascending: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-up",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		descending: {
			"fidelity:24": {
				"default": true,
				asset: "arrow-down",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		unsorted: {
			"fidelity:24": {
				"default": true,
				asset: "up-down",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		settings: {
			"fidelity:24": {
				"default": true,
				asset: "sliders-horizontal",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		undo: {
			"fidelity:24": {
				"default": true,
				asset: "cycle-backward",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		redo: {
			"fidelity:24": {
				"default": true,
				asset: "cycle-forward",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		edit: {
			"fidelity:24": {
				"default": true,
				asset: "pencil-writing",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		},
		picture: {
			"fidelity:24": {
				"default": true,
				asset: "image",
				size: 24,
				width: 24,
				height: 24,
				tintable: true
			}
		}
	}
};
var tokens = {
	core: core
};

var marketSVGSprite = `<svg id="market-icon-sprite"><defs/><symbol id="market-icon-chevron-down-fidelity-16" viewBox="0 0 16 16" data-fidelity="16" data-name="chevron-down" data-default-fidelity="true" data-tintable="true" data-width="16" data-height="16">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.70715 11.7071C8.31663 12.0976 7.68346 12.0976 7.29294 11.7071L1.29294 5.7071L2.70715 4.29289L8.00005 9.58578L13.2929 4.29289L14.7072 5.70711L8.70715 11.7071Z" fill="currentColor"/>
</symbol><symbol id="market-icon-chevron-up-fidelity-16" viewBox="0 0 16 16" data-fidelity="16" data-name="chevron-up" data-default-fidelity="true" data-tintable="true" data-width="16" data-height="16">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.29285 4.29289C7.68337 3.90237 8.31654 3.90237 8.70706 4.29289L14.7071 10.2929L13.2928 11.7071L7.99995 6.41421L2.70706 11.7071L1.29285 10.2929L7.29285 4.29289Z" fill="currentColor"/>
</symbol><symbol id="market-icon-chevron-right-fidelity-16" viewBox="0 0 16 16" data-fidelity="16" data-name="chevron-right" data-default-fidelity="true" data-tintable="true" data-width="16" data-height="16">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.7071 7.29291C12.0976 7.68343 12.0976 8.3166 11.7071 8.70712L5.70711 14.7071L4.29289 13.2929L9.58579 8.00001L4.29289 2.70712L5.70711 1.29291L11.7071 7.29291Z" fill="currentColor"/>
</symbol><symbol id="market-icon-chevron-left-fidelity-16" viewBox="0 0 16 16" data-fidelity="16" data-name="chevron-left" data-default-fidelity="true" data-tintable="true" data-width="16" data-height="16">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.29289 7.29291C3.90237 7.68343 3.90237 8.3166 4.29289 8.70712L10.2929 14.7071L11.7071 13.2929L6.41421 8.00001L11.7071 2.70712L10.2929 1.29291L4.29289 7.29291Z" fill="currentColor"/>
</symbol><symbol id="market-icon-x-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="x" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M6.71004 18.71L12 13.41L17.29 18.71L18.71 17.29L13.41 12L18.71 6.71004L17.29 5.29004L12 10.59L6.71004 5.29004L5.29004 6.71004L10.59 12L5.29004 17.29L6.71004 18.71Z" fill="currentColor"/>
</symbol><symbol id="market-icon-plus-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="plus" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M13 19V13H19V11H13V5H11V11H5V13H11V19H13Z" fill="currentColor"/>
</symbol><symbol id="market-icon-minus-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="minus" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M19 11H5V13H19V11Z" fill="currentColor"/>
</symbol><symbol id="market-icon-arrow-left-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="arrow-left" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.29289 11.2929C3.90237 11.6834 3.90237 12.3166 4.29289 12.7071L11.2929 19.7071L12.7071 18.2929L7.41421 13L19 13V11H7.41421L12.7071 5.70712L11.2929 4.29291L4.29289 11.2929Z" fill="currentColor"/>
</symbol><symbol id="market-icon-arrow-right-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="arrow-right" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.7071 11.2929C20.0976 11.6834 20.0976 12.3166 19.7071 12.7071L12.7071 19.7071L11.2929 18.2929L16.5858 13L5 13L5 11H16.5858L11.2929 5.70712L12.7071 4.29291L19.7071 11.2929Z" fill="currentColor"/>
</symbol><symbol id="market-icon-arrow-up-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="arrow-up" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.2928 4.29289C11.6834 3.90237 12.3165 3.90237 12.7071 4.29289L19.7071 11.2929L18.2928 12.7071L13 7.41421L13 19H11L11 7.41421L5.70706 12.7071L4.29285 11.2929L11.2928 4.29289Z" fill="currentColor"/>
</symbol><symbol id="market-icon-arrow-down-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="arrow-down" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.7071 19.7071C12.3165 20.0976 11.6834 20.0976 11.2928 19.7071L4.29285 12.7071L5.70706 11.2929L11 16.5858V5L13 5L13 16.5858L18.2928 11.2929L19.7071 12.7071L12.7071 19.7071Z" fill="currentColor"/>
</symbol><symbol id="market-icon-ellipsis-horizontal-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="ellipsis-horizontal" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 12C8 13.1046 7.10457 14 6 14C4.89543 14 4 13.1046 4 12C4 10.8954 4.89543 10 6 10C7.10457 10 8 10.8954 8 12ZM12 14C13.1046 14 14 13.1046 14 12C14 10.8954 13.1046 10 12 10C10.8954 10 10 10.8954 10 12C10 13.1046 10.8954 14 12 14ZM18 14C19.1046 14 20 13.1046 20 12C20 10.8954 19.1046 10 18 10C16.8954 10 16 10.8954 16 12C16 13.1046 16.8954 14 18 14Z" fill="currentColor"/>
</symbol><symbol id="market-icon-hamburger-lines-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="hamburger-lines" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 6H21V8H3V6ZM21 11H3V13H21V11ZM21 16H3V18H21V16Z" fill="currentColor"/>
</symbol><symbol id="market-icon-radial-spinner-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="radial-spinner" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19 12C19 8.13401 15.866 5 12 5V3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12H5C5 15.866 8.13401 19 12 19C15.866 19 19 15.866 19 12Z" fill="currentColor"/>
</symbol><symbol id="market-icon-magnifying-glass-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="magnifying-glass" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M10.5 17.4998C12.07 17.4998 13.52 16.9698 14.68 16.0998L18.79 20.2098L20.2 18.7998L16.09 14.6898C16.97 13.5198 17.49 12.0798 17.49 10.5098C17.49 6.64983 14.35 3.50983 10.49 3.50983C6.62999 3.50983 3.48999 6.64983 3.48999 10.5098C3.48999 14.3698 6.63999 17.4998 10.5 17.4998ZM10.5 5.49983C13.26 5.49983 15.5 7.73983 15.5 10.4998C15.5 13.2598 13.26 15.4998 10.5 15.4998C7.73999 15.4998 5.49999 13.2598 5.49999 10.4998C5.49999 7.73983 7.73999 5.49983 10.5 5.49983Z" fill="currentColor"/>
</symbol><symbol id="market-icon-grip-dots-vertical-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="grip-dots-vertical" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 8C16.1046 8 17 7.10457 17 6C17 4.89543 16.1046 4 15 4C13.8954 4 13 4.89543 13 6C13 7.10457 13.8954 8 15 8ZM15 14C16.1046 14 17 13.1046 17 12C17 10.8954 16.1046 10 15 10C13.8954 10 13 10.8954 13 12C13 13.1046 13.8954 14 15 14ZM11 18C11 19.1046 10.1046 20 9 20C7.89543 20 7 19.1046 7 18C7 16.8954 7.89543 16 9 16C10.1046 16 11 16.8954 11 18ZM17 18C17 19.1046 16.1046 20 15 20C13.8954 20 13 19.1046 13 18C13 16.8954 13.8954 16 15 16C16.1046 16 17 16.8954 17 18ZM11 12C11 13.1046 10.1046 14 9 14C7.89543 14 7 13.1046 7 12C7 10.8954 7.89543 10 9 10C10.1046 10 11 10.8954 11 12ZM11 6C11 7.10457 10.1046 8 9 8C7.89543 8 7 7.10457 7 6C7 4.89543 7.89543 4 9 4C10.1046 4 11 4.89543 11 6Z" fill="currentColor"/>
</symbol><symbol id="market-icon-exclamation-circle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="exclamation-circle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21ZM12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5ZM12 17C12.6904 17 13.25 16.4404 13.25 15.75C13.25 15.0596 12.6904 14.5 12 14.5C11.3096 14.5 10.75 15.0596 10.75 15.75C10.75 16.4404 11.3096 17 12 17ZM11 7H13V13.5H11V7Z" fill="currentColor"/>
</symbol><symbol id="market-icon-exclamation-triangle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="exclamation-triangle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M11 9.00005H13V14.5H11V9.00005Z" fill="currentColor"/>
<path d="M12 18C12.6904 18 13.25 17.4404 13.25 16.75C13.25 16.0596 12.6904 15.5 12 15.5C11.3096 15.5 10.75 16.0596 10.75 16.75C10.75 17.4404 11.3096 18 12 18Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.866 2.17944C12.6874 1.87004 12.3573 1.67944 12 1.67944C11.6427 1.67944 11.3126 1.87004 11.134 2.17944L1.13397 19.5C0.955342 19.8094 0.955342 20.1905 1.13397 20.5C1.31261 20.8094 1.64273 21 2 21H22C22.3573 21 22.6874 20.8094 22.866 20.5C23.0447 20.1905 23.0447 19.8094 22.866 19.5L12.866 2.17944ZM12 4.67944L20.268 19H3.73205L12 4.67944Z" fill="currentColor"/>
</symbol><symbol id="market-icon-checkmark-circle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="checkmark-circle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 12C3 7.03 7.03 3 12 3C16.97 3 21 7.03 21 12C21 16.97 16.97 21 12 21C7.03 21 3 16.97 3 12ZM5 12C5 15.86 8.14 19 12 19C15.86 19 19 15.86 19 12C19 8.14 15.86 5 12 5C8.14 5 5 8.14 5 12ZM8.71005 10.8L11 13.09L15.3101 8.80005L16.72 10.21L11.72 15.21C11.52 15.4 11.27 15.5 11.01 15.5C10.75 15.5 10.5 15.41 10.3 15.21L7.30005 12.21L8.71005 10.8Z" fill="currentColor"/>
</symbol><symbol id="market-icon-i-circle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="i-circle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3ZM12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19ZM11 10.5V17H13V10.5H11ZM13.25 8.25C13.25 8.94036 12.6904 9.5 12 9.5C11.3096 9.5 10.75 8.94036 10.75 8.25C10.75 7.55964 11.3096 7 12 7C12.6904 7 13.25 7.55964 13.25 8.25Z" fill="currentColor"/>
</symbol><symbol id="market-icon-no-entry-circle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="no-entry-circle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3ZM19 12C19 13.57 18.47 15.02 17.6 16.18L7.82 6.4C8.98 5.53 10.43 5 12 5C15.86 5 19 8.14 19 12ZM5 12C5 10.43 5.53 8.98 6.4 7.82L16.18 17.6C15.02 18.47 13.57 19 12 19C8.14 19 5 15.86 5 12Z" fill="currentColor"/>
</symbol><symbol id="market-icon-x-circle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="x-circle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 12C3 7.03 7.03 3 12 3C16.97 3 21 7.03 21 12C21 16.97 16.97 21 12 21C7.03 21 3 16.97 3 12ZM5 12C5 15.86 8.14 19 12 19C15.86 19 19 15.86 19 12C19 8.14 15.86 5 12 5C8.14 5 5 8.14 5 12ZM12 10.59L14.29 8.29004L15.71 9.71004L13.41 12L15.71 14.29L14.29 15.71L12 13.42L9.71004 15.71L8.29004 14.29L10.59 12L8.29004 9.71004L9.71004 8.29004L12 10.59Z" fill="currentColor"/>
</symbol><symbol id="market-icon-lightning-bolt-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="lightning-bolt" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M11 23.1701V15.0001H3.07996L13 0.830078V9.00008H20.92L11 23.1701ZM6.91996 13.0001H13V16.8301L17.08 11.0001H11V7.17008L6.91996 13.0001Z" fill="currentColor"/>
</symbol><symbol id="market-icon-dual-rotating-arrows-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="dual-rotating-arrows" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M5.77 17.01C5.81 16.97 5.84 16.92 5.88 16.88L7.19 15.57C6.42 14.54 6 13.31 6 12C6 8.68998 8.69 5.99998 12 5.99998H13.59L12.3 7.28998L13.71 8.69998L16.71 5.69998C17.1 5.30998 17.1 4.67998 16.71 4.28998L13.71 1.28998L12.3 2.69998L13.59 3.99998H12C7.59 3.99998 4 7.58998 4 12C4 13.85 4.62 15.6 5.77 17.01Z" fill="currentColor"/>
<path d="M18 12C18 15.31 15.31 18 12 18H10.41L11.7 16.71L10.29 15.3L7.29 18.3C6.9 18.69 6.9 19.32 7.29 19.71L10.29 22.71L11.7 21.3L10.41 20H12C16.41 20 20 16.41 20 12C20 10.15 19.38 8.39998 18.23 6.98998C18.19 7.02998 18.16 7.07998 18.12 7.11998L16.81 8.42998C17.58 9.45998 18 10.69 18 12Z" fill="currentColor"/>
</symbol><symbol id="market-icon-trashcan-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="trashcan" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M21 5H19H17H15C15 3.35 13.65 2 12 2C10.35 2 9 3.35 9 5H7H5H3V7H5V18.75C5 20.54 6.66 22 8.7 22H15.3C17.34 22 19 20.54 19 18.75V7H21V5ZM12 4C12.55 4 13 4.45 13 5H11C11 4.45 11.45 4 12 4ZM17 18.75C17 19.43 16.22 20 15.3 20H8.7C7.78 20 7 19.43 7 18.75V7H17V18.75ZM15 9H13V18H15V9ZM9 9H11V18H9V9Z" fill="currentColor"/>
</symbol><symbol id="market-icon-checkmark-fidelity-24" viewBox="0 0 20 20" data-fidelity="24" data-name="checkmark" data-tintable="true" data-width="20" data-height="20">
<path d="M5 10L8.75 13.5L15 6.5" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
</symbol><symbol id="market-icon-indeterminate-mark-fidelity-20" viewBox="0 0 20 20" data-fidelity="20" data-name="indeterminate-mark" data-default-fidelity="true" data-tintable="true" data-width="20" data-height="20">
<path d="M6 10H14" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
</symbol><symbol id="market-icon-question-mark-circle-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="question-mark-circle" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3ZM12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19ZM12 17C12.6904 17 13.25 16.4404 13.25 15.75C13.25 15.0596 12.6904 14.5 12 14.5C11.3096 14.5 10.75 15.0596 10.75 15.75C10.75 16.4404 11.3096 17 12 17ZM9 9.75C9 8.23 10.35 7 12 7C13.65 7 15 8.23 15 9.75C15 10.86 14.34 11.52 13.81 12.04C13.28 12.57 13 12.87 13 13.5H11C11 12.0198 11.7993 11.2206 12.3883 10.6317L12.4 10.62C12.84 10.19 13 10.01 13 9.75C13 9.34 12.54 9 12 9C11.46 9 11 9.34 11 9.75H9Z" fill="currentColor"/>
</symbol><symbol id="market-icon-eye-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="eye" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.09 11.58C3.97 7.52 7.77 5 12 5C16.23 5 20.03 7.52 21.91 11.58C22.03 11.84 22.03 12.15 21.91 12.42C20.03 16.48 16.23 19 12 19C7.77 19 3.97 16.48 2.09 12.42C1.97 12.16 1.97 11.85 2.09 11.58ZM4.11 12C5.72 15.1 8.71 17 12 17C15.29 17 18.28 15.1 19.89 12C18.28 8.9 15.29 7 12 7C8.71 7 5.72 8.9 4.11 12ZM8 12C8 9.79 9.79 8 12 8C14.21 8 16 9.79 16 12C16 14.21 14.21 16 12 16C9.79 16 8 14.21 8 12ZM10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10C10.9 10 10 10.9 10 12Z" fill="currentColor"/>
</symbol><symbol id="market-icon-eye-slash-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="eye-slash" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.5481 17.9609L16.55 17.96L19.3 20.71L20.71 19.3L18.31 16.9C19.81 15.78 21.06 14.27 21.91 12.43C22.03 12.16 22.03 11.85 21.91 11.59C20.03 7.52004 16.23 5.00004 12 5.00004C10.39 5.00004 8.85 5.37004 7.45 6.04004L4.71 3.29004L3.29361 4.70643L14.0183 15.4311L14.02 15.43L15.01 16.42L15.008 16.4208L16.5481 17.9609ZM11.49 10.07L13.93 12.51C13.97 12.35 14 12.18 14 12C14 10.9 13.1 10 12 10C11.82 10 11.65 10.03 11.49 10.07ZM15.43 14.02L16.86 15.45C18.09 14.6 19.14 13.43 19.89 12C18.28 8.90004 15.29 7.00004 12 7.00004C10.95 7.00004 9.94 7.21004 8.99 7.58004L9.98 8.57004C10.57 8.22004 11.26 8.00004 12 8.00004C14.21 8.00004 16 9.79004 16 12C16 12.74 15.79 13.43 15.43 14.02Z" fill="currentColor"/>
<path d="M11.7512 15.9924L8.0076 12.2488C8.13092 14.2606 9.73948 15.8691 11.7512 15.9924Z" fill="currentColor"/>
<path d="M5.61696 9.8582C5.03307 10.4841 4.52321 11.2015 4.11 12C5.72 15.1 8.71 17 12 17C12.244 17 12.4859 16.9887 12.7254 16.9666L14.4639 18.7052C13.6686 18.8984 12.8439 19 12 19C7.77 19 3.97 16.48 2.09 12.42C1.97 12.16 1.97 11.85 2.09 11.58C2.63958 10.3904 3.35638 9.33864 4.19985 8.44109L5.61696 9.8582Z" fill="currentColor"/>
</symbol><symbol id="market-icon-filter-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="filter" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 6H21V8H3V6ZM18 11H6V13H18V11ZM15 16H9V18H15V16Z" fill="currentColor"/>
</symbol><symbol id="market-icon-dogeared-paper-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="dogeared-paper" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M13 2H11H8C6.34 2 5 3.34 5 5V19C5 20.66 6.34 22 8 22H16C17.66 22 19 20.66 19 19V10V8L13 2ZM16.17 8H13V4.83L16.17 8ZM17 19C17 19.55 16.55 20 16 20H8C7.45 20 7 19.55 7 19V5C7 4.45 7.45 4 8 4H11V8V10H13H17V19Z" fill="currentColor"/>
</symbol><symbol id="market-icon-binoculars-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="binoculars" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M20.68 10.32L16.86 6.5H16C16 5.67 15.33 5 14.5 5C13.67 5 13 5.67 13 6.5H11C11 5.67 10.33 5 9.5 5C8.67 5 8 5.67 8 6.5H7.14L3.32 10.32C2.47 11.17 2 12.3 2 13.5C2 15.98 4.02 18 6.5 18C8.88 18 10.81 16.14 10.97 13.81C11.29 13.93 11.64 14 12 14C12.36 14 12.71 13.93 13.03 13.81C13.19 16.14 15.12 18 17.5 18C19.98 18 22 15.98 22 13.5C22 12.3 21.53 11.17 20.68 10.32ZM6.5 16C5.12 16 4 14.88 4 13.5C4 12.83 4.26 12.2 4.73 11.73C5.2 11.26 5.83 11 6.5 11C7.88 11 9 12.12 9 13.5C9 14.88 7.88 16 6.5 16ZM9.21 9.93C8.68 9.53 8.06 9.23 7.38 9.09L7.96 8.5H10.34C9.83 8.84 9.43 9.34 9.21 9.93ZM12 12C11.45 12 11 11.55 11 11C11 10.45 11.45 10 12 10C12.55 10 13 10.45 13 11C13 11.55 12.55 12 12 12ZM13.65 8.5H16.03L16.62 9.09C15.94 9.23 15.32 9.53 14.79 9.93C14.57 9.34 14.17 8.84 13.65 8.5ZM17.5 16C16.12 16 15 14.88 15 13.5C15 12.12 16.12 11 17.5 11C18.17 11 18.8 11.26 19.27 11.73C19.74 12.2 20 12.83 20 13.5C20 14.88 18.88 16 17.5 16Z" fill="currentColor"/>
</symbol><symbol id="market-icon-up-down-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="up-down" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.295 20.7149L12.295 16.7149L13.715 15.3049L16.005 17.5949L16.005 4.00485L18.005 4.00485L18.005 17.5949L20.295 15.3049L21.705 16.7149L17.705 20.7149C17.315 21.1049 16.685 21.1049 16.295 20.7149ZM3.70502 8.70488L2.29502 7.29488L6.29502 3.29488C6.68502 2.90488 7.31502 2.90488 7.70502 3.29488L11.705 7.29488L10.295 8.70488L8.00502 6.41488L8.00502 20.0049L6.00502 20.0049L6.00502 6.41488L3.70502 8.70488Z" fill="currentColor"/>
</symbol><symbol id="market-icon-sliders-horizontal-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="sliders-horizontal" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 3C8.3 3 9.4 3.84 9.82 5H22V7H9.82C9.4 8.16 8.3 9 7 9C5.7 9 4.6 8.16 4.18 7H2V5H4.18C4.6 3.84 5.7 3 7 3ZM6 6C6 6.55 6.45 7 7 7C7.55 7 8 6.55 8 6C8 5.45 7.55 5 7 5C6.45 5 6 5.45 6 6ZM17 9C15.7 9 14.6 9.84 14.18 11H2V13H14.18C14.59 14.16 15.69 15 17 15C18.31 15 19.4 14.16 19.82 13H22V11H19.82C19.4 9.84 18.3 9 17 9ZM17 13C16.45 13 16 12.55 16 12C16 11.45 16.45 11 17 11C17.55 11 18 11.45 18 12C18 12.55 17.55 13 17 13ZM7 15C5.7 15 4.6 15.84 4.18 17H2V19H4.18C4.6 20.16 5.7 21 7 21C8.3 21 9.4 20.16 9.82 19H22V17H9.82C9.4 15.84 8.3 15 7 15ZM7 19C6.45 19 6 18.55 6 18C6 17.45 6.45 17 7 17C7.55 17 8 17.45 8 18C8 18.55 7.55 19 7 19Z" fill="currentColor"/>
</symbol><symbol id="market-icon-cycle-backward-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="cycle-backward" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M15.0001 8.0499H6.41006L8.70006 5.7599L7.29006 4.3399L3.29006 8.3399C2.90006 8.7299 2.90006 9.3599 3.29006 9.7499L7.29006 13.7499L8.70006 12.3399L6.41006 10.0499H15.0001C17.2101 10.0499 19.0001 11.8399 19.0001 14.0499C19.0001 16.2599 17.2101 18.0499 15.0001 18.0499H6.00006V20.0499H15.0001C18.3101 20.0499 21.0001 17.3599 21.0001 14.0499C21.0001 10.7399 18.3101 8.0499 15.0001 8.0499Z" fill="currentColor"/>
</symbol><symbol id="market-icon-cycle-forward-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="cycle-forward" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M8.99756 7.66007H17.5876L15.2976 5.37007L16.7076 3.95007L20.7076 7.95007C21.0976 8.34007 21.0976 8.97007 20.7076 9.36007L16.7076 13.3601L15.2976 11.9501L17.5876 9.66007H8.99756C6.78756 9.66007 4.99756 11.4501 4.99756 13.6601C4.99756 15.8701 6.78756 17.6601 8.99756 17.6601H17.9976V19.6601H8.99756C5.68756 19.6601 2.99756 16.9701 2.99756 13.6601C2.99756 10.3501 5.68756 7.66007 8.99756 7.66007Z" fill="currentColor"/>
</symbol><symbol id="market-icon-pencil-writing-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="pencil-writing" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17 4.17004C17.72 4.17004 18.45 4.45004 19 5.00004C20.1 6.10004 20.1 7.90004 19 9.00004L17 11L8 20H4V16L13 7.00004L15 5.00004C15.55 4.45004 16.28 4.17004 17 4.17004ZM17.01 6.17004C16.88 6.17004 16.63 6.20004 16.42 6.41004L15.84 7.01004L17.01 8.18004L17.6 7.59004C17.81 7.37004 17.84 7.13004 17.84 7.00004C17.84 6.87004 17.82 6.62004 17.6 6.41004C17.38 6.20004 17.14 6.17004 17.01 6.17004ZM6 18H7.17L15.58 9.59004L14.41 8.42004L6 16.83V18ZM12 18.0001H20V20.0001H12V18.0001Z" fill="currentColor"/>
</symbol><symbol id="market-icon-image-fidelity-24" viewBox="0 0 24 24" data-fidelity="24" data-name="image" data-default-fidelity="true" data-tintable="true" data-width="24" data-height="24">
<path d="M12 9C12 10.1046 11.1046 11 10 11C8.89543 11 8 10.1046 8 9C8 7.89543 8.89543 7 10 7C11.1046 7 12 7.89543 12 9Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 2C3.34315 2 2 3.34315 2 5V19C2 20.6569 3.34315 22 5 22H19C20.6569 22 22 20.6569 22 19V5C22 3.34315 20.6569 2 19 2H5ZM19 4H5C4.44771 4 4 4.44772 4 5V16.5858L8 12.5858L10.5 15.0858L16 9.58578L20 13.5858V5C20 4.44771 19.5523 4 19 4ZM20 16.4142L16 12.4142L10.5 17.9142L8 15.4142L4.0633 19.3509C4.20542 19.7301 4.57119 20 5 20H19C19.5523 20 20 19.5523 20 19V16.4142Z" fill="currentColor"/>
</symbol></svg>
`;

function getDefaultIconFidelity(icon) {
    const defaultFidelity = Object.keys(icon)
        .filter((key) => key.includes('fidelity'))
        .find((fidelity) => {
        return icon[fidelity].default ? icon[fidelity].size : null;
    });
    return icon[defaultFidelity].size;
}
function getFidelityToken(fidelity, icon) {
    return icon[`fidelity:${fidelity}`];
}
function isValidTokenFidelity(fidelity, icon) {
    return Boolean(getFidelityToken(fidelity, icon));
}
function getMarketIconSVGSymbol(asset, fidelity) {
    // Return the SVG asset matching the asset name and the fidelity provided. Of no fidelity provided, return the first match.
    return fidelity
        ? document.querySelector(`[data-name="${asset}"][data-fidelity="${fidelity}"]`)
        : document.querySelector(`[data-name="${asset}"]`);
}
function isValidSpriteFidelity(asset, fidelity) {
    return Boolean(getMarketIconSVGSymbol(asset, fidelity));
}

const marketIconCss = "@property --icon-width{syntax:\"<length>\";inherits:false;initial-value:24px}@property --icon-height{syntax:\"<length>\";inherits:false;initial-value:24px}/*!@:host*/.sc-market-icon-h{display:inline-block;width:var(--icon-width);height:var(--icon-height);color:inherit}/*!@:host([tintable]) ::slotted(svg)*/.sc-market-icon-h[tintable] .sc-market-icon-s>svg{fill:currentcolor}/*!@:host([tintable]) ::slotted(svg) path, :host([tintable]) ::slotted(svg) circle, :host([tintable]) ::slotted(svg) rect, :host([tintable]) ::slotted(svg) polygon, :host([tintable]) ::slotted(svg) ellipse, :host([tintable]) ::slotted(svg) line, :host([tintable]) ::slotted(svg) polyline*/.sc-market-icon-h[tintable] .sc-market-icon-s>svg path,.sc-market-icon-h[tintable].sc-market-icon-s>svg circle,.sc-market-icon-h[tintable] .sc-market-icon-s>svg circle,.sc-market-icon-h[tintable].sc-market-icon-s>svg rect,.sc-market-icon-h[tintable] .sc-market-icon-s>svg rect,.sc-market-icon-h[tintable].sc-market-icon-s>svg polygon,.sc-market-icon-h[tintable] .sc-market-icon-s>svg polygon,.sc-market-icon-h[tintable].sc-market-icon-s>svg ellipse,.sc-market-icon-h[tintable] .sc-market-icon-s>svg ellipse,.sc-market-icon-h[tintable].sc-market-icon-s>svg line,.sc-market-icon-h[tintable] .sc-market-icon-s>svg line,.sc-market-icon-h[tintable].sc-market-icon-s>svg polyline,.sc-market-icon-h[tintable] .sc-market-icon-s>svg polyline{fill:inherit}/*!@::slotted(svg)*/.sc-market-icon-s>svg{display:block;width:100%;height:100%}";
var MarketIconStyle0 = marketIconCss;

const marketIconSVGSpriteID = '#market-icon-sprite';
class MarketIcon {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Whether or not the icon can change color (is monotone).
         * */
        this.tintable = true;
        this.name = undefined;
        this.fidelity = undefined;
    }
    cloneSymbol(symbol, assetName, width, height) {
        // Remove any existing SVG child elements so we don't duplicate them
        this.el.querySelectorAll('svg').forEach((svg) => svg.remove());
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
        svg.dataset.name = assetName;
        svg.setAttribute('viewBox', symbol === null || symbol === void 0 ? void 0 : symbol.getAttribute('viewBox'));
        width && svg.setAttribute('width', `${width}`);
        height && svg.setAttribute('height', `${height}`);
        svg.innerHTML = symbol.innerHTML;
        this.el.appendChild(svg);
    }
    getDimensions(symbol, fidelityToken, currentFidelity) {
        var _a, _b, _c, _d;
        // Get the dimensions from the symbol's viewBox attribute
        const dimensions = (symbol === null || symbol === void 0 ? void 0 : symbol.getAttribute('viewBox').split(/\s/).map((d) => Number.parseInt(d, 10))) || [];
        /* Set the dimensions based on the following:
        1. Passed width/height param
        2. Width & Height as read from the tokens
        3. The numbers from the matching SVG symbol's viewBox attribute
        4. Whatever the currentFidelity is set to (assumes square dimensions)
        */
        const width = (_b = (_a = fidelityToken === null || fidelityToken === void 0 ? void 0 : fidelityToken.width) !== null && _a !== void 0 ? _a : dimensions[2]) !== null && _b !== void 0 ? _b : currentFidelity;
        const height = (_d = (_c = fidelityToken === null || fidelityToken === void 0 ? void 0 : fidelityToken.height) !== null && _c !== void 0 ? _c : dimensions[3]) !== null && _d !== void 0 ? _d : currentFidelity;
        return { width, height };
    }
    componentWillLoad() {
        var _a;
        let assetName, currentFidelity, defaultFidelity, fidelityToken, symbol;
        // Find the market SVG sprite if it is on the page
        const documentSVGSprite = document.querySelector(marketIconSVGSpriteID);
        /* If we can't find a symbol or a root level SVG sprite, that means we need to add the default one
        to the page */
        if (!documentSVGSprite) {
            /* This feels sort of icky, but using innerHTML apparently the best way to convert the string
            that gets loaded from importing marketSVGSprite into an actual DOM element */
            const template = document.createElement('div');
            template.innerHTML = marketSVGSprite;
            const sprite = template.querySelector(marketIconSVGSpriteID);
            sprite.style.display = 'none';
            document.body.append(sprite);
            template.remove();
        }
        // Get the full icon object as well as the object at the correct fidelity key if passed.
        const iconToken = tokens.core.icon[this.name];
        // If we have passed a semantic name
        if (iconToken) {
            // Determine the default fidelity from the tokens.
            defaultFidelity = getDefaultIconFidelity(iconToken);
            // Current fidelity is either the fidelity that is passed if it is valid, or the default fidelity
            currentFidelity = isValidTokenFidelity(this.fidelity, iconToken) ? this.fidelity : defaultFidelity;
            // Get the JSON object of the token values for this icon for this icon
            fidelityToken = getFidelityToken(currentFidelity, iconToken);
            // Find the asset name for this semantic icon
            assetName = fidelityToken === null || fidelityToken === void 0 ? void 0 : fidelityToken.asset;
            // Otherwise we've passed a descriptive name
        }
        else {
            // The name passed is assumed to be the asset name
            assetName = this.name;
            // If fidelity here is null or invalid, then this will be an approximate selection of the symbol
            // But we need to surmise some default fidelity and current fidelity from something and since we
            // dont have tokens, the SVG markup is the only thing we have more or less.
            symbol = getMarketIconSVGSymbol(assetName, this.fidelity);
            // Approximate a default fidelity from the matching SVG symbol in the sprite
            defaultFidelity = Number.parseInt(symbol === null || symbol === void 0 ? void 0 : symbol.dataset.fidelity, 10);
            // Current fidelity is either the fidelity that is passed if it is valid, or the default fidelity
            currentFidelity = isValidSpriteFidelity(assetName, this.fidelity) ? this.fidelity : defaultFidelity;
        }
        /* Even if we already have a symbol, we want to run this function again in case the symbol
        assignment on line 120 was assigned based on a non-existent or invalid fidelity */
        symbol = getMarketIconSVGSymbol(assetName, currentFidelity);
        const { width, height } = this.getDimensions(symbol, fidelityToken, currentFidelity);
        if (symbol) {
            // Append the symbol to the component's template
            this.cloneSymbol(symbol, assetName, width, height);
        }
        // set props needed for render
        this.width = width;
        this.height = height;
        this.tintable = (_a = fidelityToken === null || fidelityToken === void 0 ? void 0 : fidelityToken.tintable) !== null && _a !== void 0 ? _a : true;
    }
    render() {
        return (hAsync(Host, { key: 'c8e658a53c2c5af0b32b3f123b124df008f0b499', class: "market-icon", tintable: this.tintable, style: {
                '--icon-width': `${this.width}px`,
                '--icon-height': `${this.height}px`,
            } }, hAsync("slot", { key: '573037cc01b84ffac5e425ac25d9422aca7ae7ab' })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketIconStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-icon",
        "$members$": {
            "name": [513],
            "fidelity": [514]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["name", "name"], ["fidelity", "fidelity"]]
    }; }
}

const marketInlineSectionHeaderCss = "/*!@:host, ::slotted(*), **/.sc-market-inline-section-header-h,.sc-market-inline-section-header-s>*,*.sc-market-inline-section-header{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-inline-section-header-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-inline-section-header-h *.sc-market-inline-section-header,.sc-market-inline-section-header-h[disabled].sc-market-inline-section-header-s>*,.sc-market-inline-section-header-h[disabled] .sc-market-inline-section-header-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-inline-section-header-h{display:flex;justify-content:space-between;align-items:center}";
var MarketInlineSectionHeaderStyle0 = marketInlineSectionHeaderCss;

/**
 * @slot - Heading tag with text, ex. h2, h3, h4, h5, h6.
 * @slot trailing-accessory - Accessory to display at the end of the header line.
 */
class MarketInlineSectionHeader {
    constructor(hostRef) {
        registerInstance(this, hostRef);
    }
    render() {
        return (hAsync(Host, { key: '1e021e90353a3773683597d5b1509918652ed000' }, hAsync("slot", { key: '9b822f33cb4a646ad27a0e9131cd98ee83b6cea6' }), hAsync("slot", { key: '9395fdc855ced7754ce4cdc03023998de4b7c3b0', name: "trailing-accessory" })));
    }
    static get style() { return MarketInlineSectionHeaderStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-inline-section-header",
        "$members$": undefined,
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const getSuccessIcon = () => (hAsync("svg", { class: "icon", width: "20", height: "20", viewBox: "-2 -2 26 26", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M3 12C3 7.03 7.03 3 12 3C16.97 3 21 7.03 21 12C21 16.97 16.97 21 12 21C7.03 21 3 16.97 3 12ZM5 12C5 15.86 8.14 19 12 19C15.86 19 19 15.86 19 12C19 8.14 15.86 5 12 5C8.14 5 5 8.14 5 12ZM8.71005 10.8L11 13.09L15.3101 8.80005L16.72 10.21L11.72 15.21C11.52 15.4 11.27 15.5 11.01 15.5C10.75 15.5 10.5 15.41 10.3 15.21L7.30005 12.21L8.71005 10.8Z" })));
const getInfoIcon = () => (hAsync("svg", { class: "icon", width: "20", height: "20", viewBox: "-2 -2 26 26", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3ZM12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19ZM11 10.5V17H13V10.5H11ZM13.25 8.25C13.25 8.94036 12.6904 9.5 12 9.5C11.3096 9.5 10.75 8.94036 10.75 8.25C10.75 7.55964 11.3096 7 12 7C12.6904 7 13.25 7.55964 13.25 8.25Z" })));
const getWarningIcon = () => (hAsync("svg", { class: "icon", width: "20", height: "20", viewBox: "-2 -2 26 26", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { d: "M11 9.00005H13V14.5H11V9.00005Z" }),
    hAsync("path", { d: "M12 18C12.6904 18 13.25 17.4404 13.25 16.75C13.25 16.0596 12.6904 15.5 12 15.5C11.3096 15.5 10.75 16.0596 10.75 16.75C10.75 17.4404 11.3096 18 12 18Z" }),
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12.866 2.17944C12.6874 1.87004 12.3573 1.67944 12 1.67944C11.6427 1.67944 11.3126 1.87004 11.134 2.17944L1.13397 19.5C0.955342 19.8094 0.955342 20.1905 1.13397 20.5C1.31261 20.8094 1.64273 21 2 21H22C22.3573 21 22.6874 20.8094 22.866 20.5C23.0447 20.1905 23.0447 19.8094 22.866 19.5L12.866 2.17944ZM12 4.67944L20.268 19H3.73205L12 4.67944Z" })));
const getCriticalIcon = () => (hAsync("svg", { class: "icon", width: "20", height: "20", viewBox: "-2 -2 26 26", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12 21C16.96 21 21 16.96 21 12C21 7.04 16.96 3 12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21ZM12 5C15.86 5 19 8.14 19 12C19 15.86 15.86 19 12 19C8.14 19 5 15.86 5 12C5 8.14 8.14 5 12 5ZM12 17C12.6904 17 13.25 16.4404 13.25 15.75C13.25 15.0596 12.6904 14.5 12 14.5C11.3096 14.5 10.75 15.0596 10.75 15.75C10.75 16.4404 11.3096 17 12 17ZM11 7H13V13.5H11V7Z" })));

const marketInlineStatusCss = "/*!@:host*/.sc-market-inline-status-h{display:flex;align-items:flex-start;font-weight:var(--inline-status-normal-size-text-weight);font-size:var(--inline-status-normal-size-text-size);font-family:var(--inline-status-normal-size-text-font-family);line-height:var(--inline-status-normal-size-text-leading);letter-spacing:var(--inline-status-normal-size-text-tracking);text-transform:var(--inline-status-normal-size-text-case)}/*!@:host .icon, :host ::slotted([slot=\"icon\"])*/.sc-market-inline-status-h .icon.sc-market-inline-status,.sc-market-inline-status-h.sc-market-inline-status-s>[slot=\"icon\"],.sc-market-inline-status-h .sc-market-inline-status-s>[slot=\"icon\"]{flex-shrink:0;margin-right:var(--inline-status-normal-size-spacing-horizontal)}/*!@:host([variant=\"info\"])*/[variant=\"info\"].sc-market-inline-status-h{color:var(--core-text-20-color)}/*!@:host([variant=\"info\"]) .icon, :host([variant=\"info\"]) ::slotted([slot=\"icon\"])*/[variant=\"info\"].sc-market-inline-status-h .icon.sc-market-inline-status,.sc-market-inline-status-h[variant=\"info\"].sc-market-inline-status-s>[slot=\"icon\"],.sc-market-inline-status-h[variant=\"info\"] .sc-market-inline-status-s>[slot=\"icon\"]{fill:var(--core-fill-20-color)}/*!@:host([variant=\"critical\"])*/[variant=\"critical\"].sc-market-inline-status-h{color:var(--inline-status-error-variant-icon-color)}/*!@:host([variant=\"critical\"]) .icon, :host([variant=\"critical\"]) ::slotted([slot=\"icon\"])*/[variant=\"critical\"].sc-market-inline-status-h .icon.sc-market-inline-status,.sc-market-inline-status-h[variant=\"critical\"].sc-market-inline-status-s>[slot=\"icon\"],.sc-market-inline-status-h[variant=\"critical\"] .sc-market-inline-status-s>[slot=\"icon\"]{fill:var(--inline-status-error-variant-text-color)}/*!@:host([variant=\"success\"])*/[variant=\"success\"].sc-market-inline-status-h{color:var(--inline-status-success-variant-icon-color)}/*!@:host([variant=\"success\"]) .icon, :host([variant=\"success\"]) ::slotted([slot=\"icon\"])*/[variant=\"success\"].sc-market-inline-status-h .icon.sc-market-inline-status,.sc-market-inline-status-h[variant=\"success\"].sc-market-inline-status-s>[slot=\"icon\"],.sc-market-inline-status-h[variant=\"success\"] .sc-market-inline-status-s>[slot=\"icon\"]{fill:var(--inline-status-success-variant-text-color)}/*!@:host([variant=\"warning\"])*/[variant=\"warning\"].sc-market-inline-status-h{color:var(--inline-status-warning-variant-icon-color)}/*!@:host([variant=\"warning\"]) .icon, :host([variant=\"warning\"]) ::slotted([slot=\"icon\"])*/[variant=\"warning\"].sc-market-inline-status-h .icon.sc-market-inline-status,.sc-market-inline-status-h[variant=\"warning\"].sc-market-inline-status-s>[slot=\"icon\"],.sc-market-inline-status-h[variant=\"warning\"] .sc-market-inline-status-s>[slot=\"icon\"]{fill:var(--inline-status-warning-variant-icon-color)}";
var MarketInlineStatusStyle0 = marketInlineStatusCss;

/**
 * @slot - The text for market-inline-status
 * @slot icon - Optional, for use with a custom icon
 */
class MarketInlineStatus {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.variant = 'info';
    }
    render() {
        return (hAsync(Host, { key: 'ce4428f0523ed96deb0f6167b96f87ed34bd64d1', class: "market-inline-status" }, hAsync("slot", { key: 'd03865e2931b958cfb05f1224af729cd41eb095c', name: "icon" }, this.variant === 'info' && getInfoIcon(), this.variant === 'success' && getSuccessIcon(), this.variant === 'warning' && getWarningIcon(), this.variant === 'critical' && getCriticalIcon()), hAsync("slot", { key: 'b830ce20c7ce9c407e5a14d46f97b80024b14168' })));
    }
    static get style() { return MarketInlineStatusStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-inline-status",
        "$members$": {
            "variant": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["variant", "variant"]]
    }; }
}

const marketInputPasswordCss = "/*!@:host, ::slotted(*), **/.sc-market-input-password-h,.sc-market-input-password-s>*,*.sc-market-input-password{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-input-password-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-input-password-h *.sc-market-input-password,.sc-market-input-password-h[disabled].sc-market-input-password-s>*,.sc-market-input-password-h[disabled] .sc-market-input-password-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-input-password-h{--focus-ring-color:color-mix(in srgb, var(--core-focus-ring-color) 100%, transparent);display:block}/*!@.toggle*/.toggle.sc-market-input-password{display:flex;flex-shrink:0;justify-content:center;align-items:center;width:100%;height:100%;margin:0;border:none;background:transparent;outline:none;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.toggle svg*/.toggle.sc-market-input-password svg.sc-market-input-password{display:block;fill:var(--core-text-20-color)}/*!@.toggle:focus-visible*/.toggle.sc-market-input-password:focus-visible{border-radius:var(--core-radius-10);outline:var(--core-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:calc(var(--core-focus-ring-border-size) * -1)}";
var MarketInputPasswordStyle0 = marketInputPasswordCss;

/**
 * @slot - The label for the input.
 *
 * @slot input - Can be used to slot your own HTML input, if needed (ex. if supporting browser
 * autofill)
 */
class MarketInputPassword {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.inputId = undefined;
        this.name = undefined;
        this.value = undefined;
        this.placeholder = undefined;
        this.maxlength = undefined;
        this.minlength = undefined;
        this.size = 'large';
        this.readonly = undefined;
        this.required = undefined;
        this.disabled = undefined;
        this.focused = undefined;
        this.invalid = undefined;
        this.autocomplete = undefined;
        this.inputmode = undefined;
        this.type = 'password';
    }
    /**
     * Sets focus styling on `<market-input-password>`. Toggles focus on the inner `<input>` if true, and blurs focus if false.
     */
    async setFocus(value = true) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.focused = value;
        await this.marketInputText.setFocus(value);
    }
    registerSlottedInput() {
        // We need to pass in the slotted input here since it's inside market-input-password's
        // light DOM, and market-input-text is unable to find it.
        this.slottedInput = this.el.querySelector('input[slot=input]');
        if (this.slottedInput) {
            this.marketInputText.registerSlottedInput(this.slottedInput);
        }
    }
    togglePasswordVisibility(e) {
        this.type = this.type === 'password' ? 'text' : 'password';
        e.stopPropagation();
    }
    handleKeyDown(e) {
        if (e.key === 'Enter') {
            submitFormImplicitly(this.el);
        }
    }
    renderSvgHidden() {
        return (hAsync("svg", { width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M16.5481 17.9609L16.55 17.96L19.3 20.71L20.71 19.3L18.31 16.9C19.81 15.78 21.06 14.27 21.91 12.43C22.03 12.16 22.03 11.85 21.91 11.59C20.03 7.52004 16.23 5.00004 12 5.00004C10.39 5.00004 8.85 5.37004 7.45 6.04004L4.71 3.29004L3.29361 4.70643L14.0183 15.4311L14.02 15.43L15.01 16.42L15.008 16.4208L16.5481 17.9609ZM11.49 10.07L13.93 12.51C13.97 12.35 14 12.18 14 12C14 10.9 13.1 10 12 10C11.82 10 11.65 10.03 11.49 10.07ZM15.43 14.02L16.86 15.45C18.09 14.6 19.14 13.43 19.89 12C18.28 8.90004 15.29 7.00004 12 7.00004C10.95 7.00004 9.94 7.21004 8.99 7.58004L9.98 8.57004C10.57 8.22004 11.26 8.00004 12 8.00004C14.21 8.00004 16 9.79004 16 12C16 12.74 15.79 13.43 15.43 14.02Z" }), hAsync("path", { d: "M11.7512 15.9924L8.0076 12.2488C8.13092 14.2606 9.73948 15.8691 11.7512 15.9924Z" }), hAsync("path", { d: "M5.61696 9.8582C5.03307 10.4841 4.52321 11.2015 4.11 12C5.72 15.1 8.71 17 12 17C12.244 17 12.4859 16.9887 12.7254 16.9666L14.4639 18.7052C13.6686 18.8984 12.8439 19 12 19C7.77 19 3.97 16.48 2.09 12.42C1.97 12.16 1.97 11.85 2.09 11.58C2.63958 10.3904 3.35638 9.33864 4.19985 8.44109L5.61696 9.8582Z" })));
    }
    renderSvgVisible() {
        return (hAsync("svg", { width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.09 11.58C3.97 7.52 7.77 5 12 5C16.23 5 20.03 7.52 21.91 11.58C22.03 11.84 22.03 12.15 21.91 12.42C20.03 16.48 16.23 19 12 19C7.77 19 3.97 16.48 2.09 12.42C1.97 12.16 1.97 11.85 2.09 11.58ZM4.11 12C5.72 15.1 8.71 17 12 17C15.29 17 18.28 15.1 19.89 12C18.28 8.9 15.29 7 12 7C8.71 7 5.72 8.9 4.11 12ZM8 12C8 9.79 9.79 8 12 8C14.21 8 16 9.79 16 12C16 14.21 14.21 16 12 16C9.79 16 8 14.21 8 12ZM10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10C10.9 10 10 10.9 10 12Z" })));
    }
    render() {
        const MarketInputTextTagName = getNamespacedTagFor('market-input-text');
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        return (hAsync(Host, { key: '0d9ee78c234098738dd4a3d788d02ad27e1b3d9b', class: "market-input-password", onKeyDown: (e) => {
                this.handleKeyDown(e);
            } }, hAsync(MarketInputTextTagName, { key: '6c17f320cbb9cfcf309a1c066ce7ea1abacde3e3', type: this.type, ref: (el) => (this.marketInputText = el), onBlur: () => { }, onClick: () => { }, onFocus: () => { }, inputId: this.inputId, name: this.name, placeholder: this.placeholder, maxlength: this.maxlength, minlength: this.minlength, size: this.size, value: this.value, readonly: this.readonly, required: this.required, disabled: this.disabled, invalid: this.invalid, autocomplete: this.autocomplete, inputmode: this.inputmode }, hAsync("slot", { key: 'afe629c1b01a8c020fdc5fac660c6af169c1c07b' }), hAsync("slot", { key: 'b98af81fa7cf0b6eaabe7f6e42be7a51cb6977c8', name: "input", onSlotchange: () => this.registerSlottedInput(),
            // if there is a slotted input, assign it to market-input-text's "input" slot
            slot: this.slottedInput ? 'input' : '' }), hAsync(MarketAccessoryTagName, { key: 'e6828fe01ded7e6d69fee864efdd13bd22a7681d', slot: "trailing-accessory", size: "image" }, hAsync("button", { key: '8febe33735908d2a0a2df804b927331dd3470353', class: "toggle", onClick: (e) => {
                this.togglePasswordVisibility(e);
            }, onKeyDown: (e) => {
                // don't submit a form if enter is pressed when the toggle is focused
                e.stopPropagation();
            } }, this.type === 'password' && this.renderSvgHidden(), this.type === 'text' && this.renderSvgVisible())))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketInputPasswordStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-input-password",
        "$members$": {
            "inputId": [1, "input-id"],
            "name": [1],
            "value": [1],
            "placeholder": [1],
            "maxlength": [2],
            "minlength": [2],
            "size": [513],
            "readonly": [4],
            "required": [4],
            "disabled": [4],
            "focused": [1028],
            "invalid": [4],
            "autocomplete": [8],
            "inputmode": [1],
            "type": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["size", "size"]]
    }; }
}

const marketLinkCss = "/*!@:host, ::slotted(*), **/.sc-market-link-h,.sc-market-link-s>*,*.sc-market-link{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-link-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-link-h *.sc-market-link,.sc-market-link-h[disabled].sc-market-link-s>*,.sc-market-link-h[disabled] .sc-market-link-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@a, button*/a.sc-market-link,button.sc-market-link{--text-link-focus-ring-border-size:var(--button-focus-ring-border-size);--text-link-focus-ring-buffer-size:var(--button-focus-ring-buffer-size);--text-link-focus-ring-color:var(--button-focus-ring-color);--focus-ring-color:color-mix(in srgb, var(--text-link-focus-ring-color) 100%, transparent)}/*!@a:focus-visible, button:focus-visible*/a.sc-market-link:focus-visible,button.sc-market-link:focus-visible{border-radius:1px;outline:var(--text-link-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--text-link-focus-ring-buffer-size)}/*!@:host*/.sc-market-link-h{--transition-duration:0.2s;color:var(--text-link-normal-variant-color);font-weight:var(--text-link-medium-size-text-weight);font-size:inherit;line-height:inherit;letter-spacing:var(--text-link-medium-size-text-tracking);cursor:pointer}/*!@:host a, :host a:link, :host a:visited, :host a:hover, :host a:active, :host button*/.sc-market-link-h a.sc-market-link,.sc-market-link-h a.sc-market-link:link,.sc-market-link-h a.sc-market-link:visited,.sc-market-link-h a.sc-market-link:hover,.sc-market-link-h a.sc-market-link:active,.sc-market-link-h button.sc-market-link{color:inherit;font-family:inherit;text-decoration:none;transition:color var(--transition-duration)}/*!@:host a, :host a:link, :host a:visited, :host button*/.sc-market-link-h a.sc-market-link,.sc-market-link-h a.sc-market-link:link,.sc-market-link-h a.sc-market-link:visited,.sc-market-link-h button.sc-market-link{opacity:var(--text-link-normal-state-opacity)}/*!@:host a:hover, :host button:hover, :host a:focus, :host button:focus*/.sc-market-link-h a.sc-market-link:hover,.sc-market-link-h button.sc-market-link:hover,.sc-market-link-h a.sc-market-link:focus,.sc-market-link-h button.sc-market-link:focus{color:var(--core-blue-20-color);text-decoration:underline}/*!@:host a:active, :host button:active*/.sc-market-link-h a.sc-market-link:active,.sc-market-link-h button.sc-market-link:active{color:var(--core-blue-10-color)}/*!@:host([highlight=\"underline\"]) a, :host([highlight=\"underline\"]) button*/[highlight=\"underline\"].sc-market-link-h a.sc-market-link,[highlight=\"underline\"].sc-market-link-h button.sc-market-link{display:inline-block;text-decoration:underline}/*!@:host([highlight=\"underline\"]) a:hover, :host([highlight=\"underline\"]) a:focus, :host([highlight=\"underline\"]) button:hover, :host([highlight=\"underline\"]) button:focus*/[highlight=\"underline\"].sc-market-link-h a.sc-market-link:hover,[highlight=\"underline\"].sc-market-link-h a.sc-market-link:focus,[highlight=\"underline\"].sc-market-link-h button.sc-market-link:hover,[highlight=\"underline\"].sc-market-link-h button.sc-market-link:focus{color:var(--core-blue-20-color);text-decoration:none}/*!@:host([aria-disabled]) a, :host([aria-disabled]) button*/[aria-disabled].sc-market-link-h a.sc-market-link,[aria-disabled].sc-market-link-h button.sc-market-link{opacity:var(--text-link-disabled-state-opacity)}/*!@:host([destructive])*/[destructive].sc-market-link-h{color:var(--text-link-destructive-variant-color)}/*!@:host button*/.sc-market-link-h button.sc-market-link{padding:0;border:none;background:none;font:inherit;text-align:inherit;cursor:pointer}";
var MarketLinkStyle0 = marketLinkCss;

/**
 * @slot - The text used for the link.
 */
class MarketLink {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.onMutationObserved = (ariaAttributes) => {
            this.ariaAttributes = ariaAttributes;
        };
        this.href = undefined;
        this.target = undefined;
        this.rel = undefined;
        this.destructive = false;
        this.disabled = false;
        this.download = undefined;
        this.highlight = undefined;
        this.ariaAttributes = undefined;
    }
    componentWillLoad() {
        this.mutationObserver = observeAriaAttributes(this.el, this.onMutationObserved);
    }
    handleClick(e) {
        if (this.disabled) {
            e.preventDefault();
            e.stopPropagation();
        }
    }
    render() {
        const { disabled, handleClick, href, target, ariaAttributes, rel, download } = this;
        const TagType = href !== undefined ? 'a' : 'button';
        const TagTypeAttrs = TagType === 'a' ? { href, target, rel, download } : { disabled };
        return (hAsync(Host, { key: '1ff15b453af9a9fc80263474f7415d669b4d158f', class: "market-link", onClick: handleClick, onKeyDown: handleClick }, hAsync(TagType, Object.assign({ key: '9c680a5363b028c6dcece71a5e6d3efc7f131190' }, TagTypeAttrs, ariaAttributes, { "aria-disabled": disabled ? 'true' : null, tabindex: disabled ? '-1' : null }), hAsync("slot", { key: 'ca9afe137bd74a21bfe944a4af0afc3d241d0015' }))));
    }
    disconnectedCallback() {
        var _a;
        (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    get el() { return getElement(this); }
    static get style() { return MarketLinkStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-link",
        "$members$": {
            "href": [1],
            "target": [1],
            "rel": [1],
            "destructive": [516],
            "disabled": [516],
            "download": [1],
            "highlight": [520],
            "ariaAttributes": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["destructive", "destructive"], ["disabled", "disabled"], ["highlight", "highlight"]]
    }; }
}

// adapted from https://bobbyhadz.com/blog/javascript-find-highest-z-index-on-page
function getMaxZIndex(container) {
    return Math.max(...[...container.querySelectorAll('*')]
        .map((el) => Number.parseFloat(window.getComputedStyle(el).zIndex))
        .filter((zIndex) => !Number.isNaN(zIndex)), 0);
}

// This function sets CSS styles on an element and returns a promise.
// The promise is resolved after any CSS transitions complete on the changed styles.
// It's smart enough to resolve immediately if there is no transition on the style.
// However, this is intended to be used with transitions that are set in CSS files.
//
// Example usage:
// await transitionToPromise(element, {
//   top: '100px',
//   height: '100px',
//   transform: 'scale(2)',
// });
//
// adapted from https://gist.github.com/davej/44e3bbec414ed4665220
async function transitionToPromise(el, styles) {
    const computedStyle = getComputedStyle(el);
    const { transitionProperty } = computedStyle;
    const properties = transitionProperty.split(', ');
    return Promise.all(Object.keys(styles).map((property) => {
        const value = styles[property];
        return new Promise((resolve) => {
            // if no value to set, resolve
            if (!value)
                resolve();
            // if same value, resolve
            if (value === el.style[property])
                resolve();
            // if no transition on this property, set it and resolve
            if (!properties.includes(property)) {
                el.style[property] = value;
                resolve();
            }
            // otherwise, set up a listener for transitionend
            const transitionEnded = (e) => {
                if (e.propertyName !== property)
                    return;
                el.removeEventListener('transitionend', transitionEnded);
                resolve();
            };
            el.addEventListener('transitionend', transitionEnded);
            el.style[property] = value;
        });
    }));
}

function isMarketTableV2Row(value) {
    const tagName = value === null || value === void 0 ? void 0 : value.tagName.toLowerCase();
    return Boolean(value && tagName === getNamespacedTagFor('market-table-v2-row'));
}

function isMarketTableV2Group(value) {
    const tagName = value === null || value === void 0 ? void 0 : value.tagName.toLowerCase();
    return Boolean(value && tagName === getNamespacedTagFor('market-table-v2-group'));
}

function isDraggable(value) {
    return Boolean(value && value.dragEnabled !== undefined);
}
const SCROLL_DELAY = Math.min(1000 / 60); // shoot for ~60 fps
const SCROLL_STEP_MAX = 24; // max scroll 24px at a time
const MarketTableV2GroupTag = getNamespacedTagFor('market-table-v2-group');
/*
  This util class abstracts & encapsulates drag & drop functionality for a component.

  When wired up to a component, it does the following:
  - adds a .market-drag-placeholder class to the original dragged element
  - clones the dragged element with a class of .market-drag-clone
  - visually tracks the drag move with the cloned element via CSS transform
  - fires custom events on the dragged element:
    - marketDragStart: fires on drag start
    - marketDragEnd: fires on drag end
    - marketDragComplete: fires when the dragged element's transition completes
  - fires custom events on the drag target:
    - marketDragEnter: fires when the dragged element enters a new target
    - marketDragMove: fires when the dragged element moves over a target
    - marketDragLeave: fires when the dragged element leaves a target
    - marketDragDrop: fires when the dragged element is dropped on a target
  - adds a .market-drag-released class to transition the clone back to the placeholder

  Intended to be wired up via events fired by <market-drag-handle> like so:

  ```html
  <Host
    onMarketDragHandleDragStart={(e: CustomEvent<TMarketDragCoords>) => this.onDragStart(e)}
    onMarketDragHandleDragMove={(e: CustomEvent<TMarketDragCoords>) => this.onDragMove(e)}
    onMarketDragHandleDragEnd={(e: CustomEvent<TMarketDragCoords> => this.onDragEnd(e)}
  >
    <market-drag-handle></market-drag-handle>
  </Host>
  ```

  ```js
  async onDragStart(e: CustomEvent<TMarketDragCoords>) {
    const coords: TMarketDragCoords = e.detail;
    this.drag = new Draggable(this.el, { anchor: 'right' });
    await this.drag.start(coords);
  }
  onDragMove(e: CustomEvent<TMarketDragCoords>) {
    const coords: TMarketDragCoords = e.detail;
    this.drag.move(coords);
  }
  async onDragEnd(e: CustomEvent<TMarketDragCoords>) {
    const coords: TMarketDragCoords = e.detail;
    await this.drag.end(coords);
    this.drag.destroy();
  }
  ```

  ```css
  // the original element stays in place and gets this class.
  // use it to add placeholder styles, e.g. a grayed out row, etc.
  :host(.market-drag-placeholder) {
    color: gray;
    background: gray;
  }

  // the cloned element follows the drag via CSS transform and gets this class.
  // to add styles for the dragged element, do it here. for example:
  // - you want to size the dragged element with a width and/or height
  // - you want to transition from the starting size & position
  // - you want to transition in a drop-shadow (see below)
  :host(.market-drag-clone) {
    min-width: 200px;
    transition-timing-function: ease;
    transition-duration: 200ms;
    transition-property: top, width, height;

    // pro tip: transitioning the opacity of a pseudo with a
    // box-shadow is hardware accelerated and more performant
    // than transitioning the box-shadow property directly
    &::after {
      box-shadow: 0 4px 32px 0 rgba(0, 0, 0, 0.1);
      opacity: var(--market-drag-clone-shadow-opacity, 0); // set by draggable
      transition: 200ns opacity ease;
    }
  }

  // the cloned element gets this class when released.
  // use it to transition clone back to the placeholder.
  :host(.market-drag-released) {
    transition-timing-function: ease;
    transition-duration: 200ms;
    transition-property: top, width, height, transform;
  }
  ```
*/
class Draggable {
    // Init the class with the element to be dragged
    constructor(el, opts) {
        this.el = el;
        this.anchor = (opts === null || opts === void 0 ? void 0 : opts.anchor) || 'none';
    }
    // Start a drag movement on the element:
    // - adds a .market-drag-placeholder class to the dragged element
    // - clones the dragged element with a class of .market-drag-clone
    // - fires marketDragStart custom event on the dragged element
    async start(coords) {
        this.canceled = false;
        const { x, y } = coords;
        this.startCoords = this.previousCoords = coords;
        const { el, anchor } = this;
        // find and measure a reference element
        // special case: if el is a table group, reference its parent row
        const referenceElement = isMarketTableV2Group(el) ? el.querySelector('[slot="parent"]') : el;
        const { top: startTop, right: startRight, left: startLeft, width: startWidth, height: startHeight, } = measureElement(referenceElement);
        // get the drag source
        const source = el.parentElement;
        // get the drag target
        const target = document.elementsFromPoint(x, y)[0];
        // clone the reference element to visually track the drag movement
        const clone = referenceElement.cloneNode(true);
        clone.classList.add('market-drag-clone', 'market-drag-transitioning');
        // save references
        this.source = source;
        this.target = target;
        this.clone = clone;
        // fire start event
        const defaultPrevented = !el.dispatchEvent(new CustomEvent('marketDragStart', {
            bubbles: true,
            cancelable: true,
            detail: Object.assign(Object.assign({}, coords), { el,
                source,
                target,
                clone }),
        }));
        if (defaultPrevented) {
            this.canceled = true;
            return;
        }
        // get nearest scrollable parent
        this.scrollParent = getScrollParent(el);
        // the original element becomes a placeholder when it's dragged
        el.classList.add('market-drag-placeholder');
        // append and measure the clone's final size
        // - if desired, dragged dimensions should be specified in CSS
        Object.assign(clone.style, {
            position: 'fixed',
            opacity: 0, // hidden while we measure it
            transitionProperty: 'none', // turn transitions off
        });
        document.body.append(clone);
        await asyncRequestAnimationFrame();
        const { width: finalWidth, height: finalHeight } = measureElement(clone);
        // set the clone's initial position to match the reference element
        Object.assign(clone.style, {
            opacity: '', // visible now that we've measured it
            width: `${startWidth}px`,
            height: `${startHeight}px`,
            top: `${startTop}px`,
            left: anchor !== 'right' ? `${startLeft}px` : 'auto',
            right: anchor !== 'left' ? `${window.innerWidth - startRight}px` : 'auto',
            zIndex: `${getMaxZIndex(document.body) + 1}`,
        });
        await asyncRequestAnimationFrame();
        // eslint-disable-next-line require-atomic-updates
        clone.style.transitionProperty = ''; // turn transitions back on
        // special case: if clone is a table row, add class to style the first cell
        if (isMarketTableV2Row(clone)) {
            clone.querySelector('market-table-v2-cell').classList.add('market-drag-clone-first-cell');
        }
        // add optional drop shadow opacity (custom CSS property)
        clone.style.setProperty('--market-drag-clone-shadow-opacity', '1');
        // transition clone to dragged size and position
        transitionToPromise(clone, {
            top: `${startTop + (startHeight - finalHeight) / 2}px`,
            height: `${finalHeight}px`,
            width: anchor === 'none' ? `${startWidth}px` : `${finalWidth}px`,
        }).then(() => {
            clone.classList.remove('market-drag-transitioning');
        });
    }
    // Continues a drag movement on the element:
    // - visually tracks the drag move with the cloned element via CSS transform
    // - fires marketDragEnter, marketDragMove, & marketDragLeave custom events on drag targets
    move(coords) {
        const { el, clone, source, target, startCoords, previousCoords, canceled } = this;
        const { x, y } = coords;
        // if the drag has already been canceled, return early
        if (canceled)
            return;
        // if for some reason we have no clone, return early
        if (!clone)
            return;
        // if the drag coords haven't changed, return early
        if (x === previousCoords.x && y === previousCoords.y)
            return;
        // save the current coords
        this.previousCoords = coords;
        // get the first drag target that is not the clone or its descendants
        const newTarget = [...document.elementsFromPoint(x, y)].find((target) => {
            return !clone.contains(target);
        });
        // if drag target is new
        if (newTarget !== target) {
            // fire leave on current target
            target === null || target === void 0 ? void 0 : target.dispatchEvent(new CustomEvent('marketDragLeave', {
                bubbles: true,
                detail: {
                    x,
                    y,
                    el,
                    source,
                    target,
                    clone,
                },
            }));
            // fire enter on new target
            newTarget === null || newTarget === void 0 ? void 0 : newTarget.dispatchEvent(new CustomEvent('marketDragEnter', {
                bubbles: true,
                detail: {
                    x,
                    y,
                    el,
                    source,
                    target: newTarget,
                    clone,
                },
            }));
            // update current drag target
            this.target = newTarget;
        }
        // fire drag move on new target
        newTarget === null || newTarget === void 0 ? void 0 : newTarget.dispatchEvent(new CustomEvent('marketDragMove', {
            bubbles: true,
            detail: {
                x,
                y,
                el,
                source,
                target: newTarget,
                clone,
            },
        }));
        // move the clone with the drag move
        const deltaX = x - startCoords.x;
        const deltaY = y - startCoords.y;
        Object.assign(clone.style, {
            transform: `translate(${deltaX}px, ${deltaY}px)`,
        });
        // scroll the scrollParent if need be
        this.scroll();
    }
    // Ends a drag movement on the element:
    // - fires marketDragEnd custom event on the dragged element
    // - fires marketDragDrop custom event on drag target
    // - removes the cloned element after transitioning it back to the placeholder
    // - removes the .market-drag-placeholder class from the dragged element
    async end(coords) {
        if (this.canceled)
            return;
        const { el, source, clone, anchor, scrollInterval } = this;
        const { x, y } = coords;
        // stop any current scrolling
        clearInterval(scrollInterval);
        // if for some reason we have no clone, return early
        if (!clone)
            return;
        // get the first drag target that is not the clone or its descendants
        const target = [...document.elementsFromPoint(x, y)].find((target) => {
            return !clone.contains(target);
        });
        // fire end event on dragged element
        const defaultPrevented = !el.dispatchEvent(new CustomEvent('marketDragEnd', {
            bubbles: true,
            cancelable: true,
            detail: {
                x,
                y,
                el,
                source,
                target,
                clone,
            },
        }));
        // fire drop event on target
        if (!defaultPrevented) {
            target === null || target === void 0 ? void 0 : target.dispatchEvent(new CustomEvent('marketDragDrop', {
                bubbles: true,
                cancelable: false,
                detail: {
                    x,
                    y,
                    el,
                    source,
                    target,
                    clone,
                },
            }));
        }
        // find the reference element, w/ some special logic for table groups
        const collapsedTableGroup = farthest(el, `${MarketTableV2GroupTag}[collapsed]`);
        const draggedIntoCollapsedGroup = collapsedTableGroup && collapsedTableGroup !== el;
        const referenceElement = draggedIntoCollapsedGroup
            ? collapsedTableGroup.querySelector('[slot="parent"]')
            : isMarketTableV2Group(el)
                ? el.querySelector('[slot="parent"]')
                : el;
        // measure the elements
        await asyncRequestAnimationFrame();
        const { top: finalTop, right: finalRight, left: finalLeft, width: finalWidth, height: finalHeight, } = measureElement(referenceElement);
        const { top: startTop, right: startRight, left: startLeft, width: startWidth, height: startHeight, } = measureElement(clone);
        const deltaX = anchor === 'left' ? startLeft - finalLeft : startRight - finalRight;
        const deltaY = startTop - finalTop;
        // update the clone position so that its top & left origin
        // is the same as the dragged element (which may have been moved!)
        // delta transform will result in the clone appearing in the same spot
        Object.assign(clone.style, {
            pointerEvents: 'none', // disable mouse events
            transitionProperty: 'none', // turn transitions off
            top: `${finalTop}px`,
            left: anchor !== 'right' ? `${finalLeft}px` : 'auto',
            right: anchor !== 'left' ? `${window.innerWidth - finalRight}px` : 'auto',
            width: `${startWidth}px`,
            height: `${startHeight}px`,
            transform: `translate(${deltaX}px, ${deltaY}px)`,
        });
        await asyncRequestAnimationFrame();
        // eslint-disable-next-line require-atomic-updates
        clone.style.transitionProperty = ''; // turn transitions back on
        // special case: if clone is a table row, remove styling from the first cell
        if (isMarketTableV2Row(clone) && isMarketTableV2Row(referenceElement)) {
            clone.querySelector('market-table-v2-cell').classList.remove('market-drag-clone-first-cell');
        }
        // remove the transform to transition clone back to the placeholder.
        clone.classList.add('market-drag-released', 'market-drag-transitioning');
        if (draggedIntoCollapsedGroup)
            clone.classList.add('market-drag-into-collapsed-group');
        clone.style.removeProperty('--market-drag-clone-shadow-opacity');
        await asyncRequestAnimationFrame();
        await transitionToPromise(clone, {
            width: `${finalWidth}px`,
            height: `${finalHeight}px`,
            transform: deltaX || deltaY ? 'translate(0, 0)' : null,
        });
        // cleanup
        el.classList.remove('market-drag-placeholder');
        clone.remove();
        // fire event on dragged element when its transition completes
        el === null || el === void 0 ? void 0 : el.dispatchEvent(new CustomEvent('marketDragComplete', {
            bubbles: true,
            cancelable: false,
            detail: {
                x,
                y,
                el,
                source,
                target,
                clone,
            },
        }));
    }
    scroll() {
        const { clone, scrollParent, scrollInterval } = this;
        // stop any current scrolling
        clearInterval(scrollInterval);
        // measure the clone position
        const { bottom: cloneBottom, top: cloneTop, right: cloneRight, left: cloneLeft } = measureElement(clone);
        // measure the scroll parent position
        const { bottom: scrollParentBottom, top: scrollParentTop, right: scrollParentRight, left: scrollParentLeft, } = getScrollParentRect(scrollParent);
        // scroll vertically if clone is over a vertical edge
        const deltaBottom = cloneBottom - scrollParentBottom;
        const deltaTop = cloneTop - scrollParentTop;
        const top = deltaBottom > 0
            ? Math.min(deltaBottom / 4, SCROLL_STEP_MAX)
            : deltaTop < 0
                ? Math.max(deltaTop / 4, -SCROLL_STEP_MAX)
                : 0;
        // scroll horizontally if clone is over a horizontal edge
        const deltaRight = cloneRight - scrollParentRight;
        const deltaLeft = cloneLeft - scrollParentLeft;
        const left = deltaRight > 0
            ? Math.min(deltaRight / 4, SCROLL_STEP_MAX)
            : deltaLeft < 0
                ? Math.max(deltaLeft / 4, -SCROLL_STEP_MAX)
                : 0;
        if (top !== 0 || left !== 0) {
            this.scrollInterval = setInterval(() => {
                scrollParent.scrollBy({ top, left });
            }, SCROLL_DELAY);
        }
    }
    // clean up var refs
    destroy() {
        this.el = null;
        this.clone = null;
        this.source = null;
        this.target = null;
        this.startCoords = null;
        this.canceled = null;
        this.scrollParent = null;
        this.scrollInterval = null;
        this.anchor = null;
    }
}
// Finds the nearest scrollable ancestor element.
// Looks for scrolling in both X and Y directions. Returns the document if no element is found.
// Works for now for our purposes, but may eventually need to take into account other display/position types.
function getScrollParent(element) {
    let parent = element.parentElement;
    while (parent !== document.documentElement) {
        const { overflowY, overflowX } = getComputedStyle(parent);
        const scrollableY = /(auto|scroll)/.test(overflowY) && parent.scrollHeight > parent.offsetHeight;
        const scrollableX = /(auto|scroll)/.test(overflowX) && parent.scrollWidth > parent.offsetWidth;
        if (scrollableY || scrollableX)
            return parent;
        parent = parent.parentElement;
    }
    return document.documentElement;
}
// Basically getBoundingClientRect() but handles an edge case
// where the scrollable parent could be the document itself
function getScrollParentRect(element) {
    const { top, right, bottom, left } = measureElement(element);
    if (element === document.documentElement) {
        // we actually want the window size in this case
        const top = 0;
        const right = window.innerWidth;
        const bottom = window.innerHeight;
        const left = 0;
        return { top, right, bottom, left };
    }
    return { top, right, bottom, left };
}
// This does the opposite of element.closest(selector).
// That is, it finds the outermost ancestor element that matches the selector.
function farthest(el, selector) {
    let farthest;
    let pointer = el;
    while (pointer !== document.body) {
        const nextClosest = pointer.closest(selector);
        if (nextClosest)
            farthest = nextClosest;
        pointer = pointer.parentElement;
    }
    return farthest;
}
// Basically getBoundingClientRect() but rounded
function measureElement(el) {
    const rect = el.getBoundingClientRect();
    return {
        top: Math.round(rect.top),
        right: Math.round(rect.right),
        bottom: Math.round(rect.bottom),
        left: Math.round(rect.left),
        width: Math.round(rect.width),
        height: Math.round(rect.height),
    };
}

var _a;
function isReorderable(value) {
    return Boolean(value && ['internal', 'external'].includes(value.reorderable));
}
const TABLE_GROUP_EXPAND_TIMEOUT_DURATION = 300;
/*
  This util class abstracts & encapsulates reorderable functionality for a component.

  In the constructor:
  - `el` is the component element to apply reordering functionality to
  - `accepts` is an array of CSS selectors that are valid draggable elements
  - `event` is the stencil EventEmitter to fire when a reorder event occurs

  Intended to be wired up via drag events fired by a dragged object like so:
  
  ```html
  <Host
    onMarketDragMove={(e: CustomEvent<TMarketDragEventDetail>) => this.onDragMove(e)}
    onMarketDragLeave={() => this.onDragLeave()}
    onMarketDragEnd={(e: CustomEvent<TMarketDragEventDetail>) => this.onDragEnd(e)}
    onMarketDragDrop={(e: CustomEvent<TMarketDragEventDetail>) => this.onDragDrop(e)}
  >
    ...
  </Host>
  ```

  ```js
  this.reorder = new Reorderable({
    el: this.el,
    accepts: ['market-row'],
    event: marketListItemsReordered,
  });
  onDragMove(e: CustomEvent<TMarketDragEventDetail>) {
    this.reorder.dragMove(e);
  }
  onDragLeave() {
    this.reorder.dragLeave();
  }
  onDragEnd(e: CustomEvent<TMarketDragEventDetail>) {
    this.reorder.dragEnd(e);
  }
  onDragDrop(e: CustomEvent<TMarketDragEventDetail>) {
    this.reorder.dragDrop(e);
  }
  ```

  ```css
  // the drag cursor inserted to show current drop location
  ::slotted(.market-drag-cursor) { ... }
  ```
*/
class Reorderable {
    static createCursor() {
        const cursor = document.createElement('div');
        cursor.classList.add('market-drag-cursor');
        return cursor;
    }
    constructor({ el, accepts, event, mode, }) {
        this.el = el;
        this.accepts = accepts;
        this.event = event;
        this.mode = mode;
    }
    isValidDrag(dragged, source, target) {
        const { el, accepts } = this;
        const reorderableSource = source === null || source === void 0 ? void 0 : source.closest('[reorderable="internal"], [reorderable="external"]');
        const reorderableTarget = target === null || target === void 0 ? void 0 : target.closest('[reorderable="internal"], [reorderable="external"]');
        // begin with type checks...
        if (!isDraggable(dragged))
            return false;
        if (!isReorderable(reorderableSource))
            return false;
        if (!isReorderable(reorderableTarget))
            return false;
        // is this an accepted draggable item?
        if (dragged.closest(accepts.join(',')) !== dragged)
            return false;
        // is this element either the source or destination?
        if (el !== reorderableSource && el !== reorderableTarget)
            return false;
        // if source & destination elements are different...
        if (reorderableSource !== reorderableTarget) {
            // are they both reorderable externally?
            const bothExternal = reorderableSource.reorderable === 'external' && reorderableTarget.reorderable === 'external';
            // or do they have a common reorderable ancestor?
            const closestReorderable = getCommonAncestor(reorderableSource, reorderableTarget).closest('[reorderable="internal"], [reorderable="external"]');
            if (!bothExternal && !closestReorderable)
                return false;
        }
        // looks like we're good!
        return true;
    }
    /**
     * Fired on a target element when an item is dragged over the target.
     */
    dragMove(e) {
        var _b, _c;
        const { el, accepts, tableGroupExpandTimeout } = this;
        const { y, el: dragged, source, target } = e.detail;
        const { cursor } = _a;
        // check drag validity
        if (!this.isValidDrag(dragged, source, target))
            return;
        // clear the table group timeout
        clearTimeout(tableGroupExpandTimeout);
        // remove cursor parent class
        (_b = cursor.parentElement) === null || _b === void 0 ? void 0 : _b.classList.remove('market-drag-cursor-parent');
        // if this element is the drag target itself (not another child)
        if (target === el) {
            el.append(cursor);
            el.classList.add('market-drag-cursor-parent');
            return;
        }
        // otherwise, find the nearest child item target
        const targetSibling = target.closest(accepts.join(','));
        // do nothing if no target sibling
        if (!targetSibling)
            return;
        // do nothing if the target sibling is the placeholder
        if (targetSibling === dragged)
            return;
        // determine where to insert cursor based on mouse position
        if (isMarketTableV2Group(targetSibling)) {
            // special case for table groups; look at the parent row
            const parent = [...targetSibling.children].find((el) => isMarketTableV2Row(el) && el.slot === 'parent');
            const { top, height } = parent.getBoundingClientRect();
            if (targetSibling.collapsible && targetSibling.collapsed) {
                const oneThird = Math.round(top + height / 3);
                const twoThirds = Math.round(top + (height * 2) / 3);
                if (y < oneThird) {
                    // insert cursor before the group
                    targetSibling.before(cursor);
                }
                else if (y > twoThirds) {
                    // insert cursor after the group
                    targetSibling.after(cursor);
                }
                else {
                    // insert cursor inside the group after the parent
                    parent.after(cursor);
                    const children = [...targetSibling.children].filter((el) => (isMarketTableV2Row(el) || isMarketTableV2Group(el)) && !el.slot);
                    // set a timeout to expand the group if hovered
                    if (children.length > 0) {
                        this.tableGroupExpandTimeout = setTimeout(async () => {
                            await targetSibling.setCollapsed(false);
                            await asyncRequestAnimationFrame();
                            parent.after(cursor);
                        }, TABLE_GROUP_EXPAND_TIMEOUT_DURATION);
                    }
                }
            }
            else {
                const halfway = Math.round(top + height / 2);
                if (y < halfway) {
                    // insert cursor before the group
                    targetSibling.before(cursor);
                }
                else {
                    // insert cursor inside the group after the parent
                    parent.after(cursor);
                }
            }
        }
        else {
            const { top, height } = targetSibling.getBoundingClientRect();
            const halfway = Math.round(top + height / 2);
            if (y < halfway) {
                targetSibling.before(cursor);
            }
            else {
                targetSibling.after(cursor);
            }
        }
        // mark the cursor's parent
        (_c = cursor.parentElement) === null || _c === void 0 ? void 0 : _c.classList.add('market-drag-cursor-parent');
    }
    /**
     * Fired on a target element when a dragged item leaves the target
     */
    dragLeave() {
        var _b;
        const { tableGroupExpandTimeout } = this;
        const { cursor } = _a;
        // remove the cursor and parent class
        (_b = cursor.parentElement) === null || _b === void 0 ? void 0 : _b.classList.remove('market-drag-cursor-parent');
        cursor.remove();
        // clear the table group timeout
        clearTimeout(tableGroupExpandTimeout);
    }
    /**
     * Fired on a dragged item when it is released.
     * Useful to determine if an item was dropped externally.
     */
    dragEnd(e) {
        const { el, accepts, event, tableGroupExpandTimeout } = this;
        const { el: dragged, source } = e.detail;
        const { cursor } = _a;
        // clear the table group timeout
        clearTimeout(tableGroupExpandTimeout);
        // instead of using target from the event detail, use cursor's parent
        const target = cursor.parentElement;
        // check for drag validity
        if (!this.isValidDrag(dragged, source, target))
            return;
        // do nothing if the source and target are the same reorderable
        const reorderableSource = source === null || source === void 0 ? void 0 : source.closest('[reorderable="internal"], [reorderable="external"]');
        const reorderableTarget = target === null || target === void 0 ? void 0 : target.closest('[reorderable="internal"], [reorderable="external"]');
        if (reorderableSource === reorderableTarget)
            return;
        // we now know the element is being dragged out of its reorderable parent,
        // so we stop propagation on original event so reorder event isn't duped.
        e.stopImmediatePropagation();
        // note: dragging externally means new index = -1
        const items = getReorderableItems(el, accepts);
        const oldIndex = items.indexOf(dragged);
        const newIndex = -1;
        // emit the reorder event and check for prevent default
        const { defaultPrevented } = event.emit({
            item: dragged,
            oldIndex,
            newIndex,
        });
        // if reorder event was prevented, prevent the drop event
        if (defaultPrevented) {
            e.preventDefault();
            cursor.remove();
        }
    }
    /**
     * Fired on a target element when a dragged item is released over the target.
     */
    async dragDrop(e) {
        const { el, accepts, event, mode, tableGroupExpandTimeout } = this;
        const { el: dragged, source } = e.detail;
        const { cursor } = _a;
        // clear the table group timeout
        clearTimeout(tableGroupExpandTimeout);
        // if this is not the cursor's parent, do nothing and let the event bubble up
        const reorderableTarget = cursor.parentElement;
        if (el !== reorderableTarget)
            return;
        // check for drag validity
        if (!this.isValidDrag(dragged, source, reorderableTarget))
            return;
        // prevent the event from further bubbling up
        e.stopImmediatePropagation();
        // remove cursor parent class
        reorderableTarget === null || reorderableTarget === void 0 ? void 0 : reorderableTarget.classList.remove('market-drag-cursor-parent');
        // if the cursor is a sibling of the dragged element, do nothing
        if ([cursor.previousElementSibling, cursor.nextElementSibling].includes(dragged)) {
            cursor.remove();
            return;
        }
        // note: if item is external, then old index is -1
        const items = getReorderableItems(reorderableTarget, accepts);
        const oldIndex = items.indexOf(dragged);
        // find new index
        const itemsWithoutDraggedEl = [...items];
        if (oldIndex >= 0) {
            itemsWithoutDraggedEl.splice(oldIndex, 1);
        }
        const newIndex = itemsWithoutDraggedEl.indexOf(cursor.previousElementSibling) + 1;
        // same index means no reorder event
        if (newIndex === oldIndex) {
            cursor.remove();
            return;
        }
        // create a temp div to hold the element's original position
        const originalPosition = document.createElement('div');
        // insert the dragged element at the cursor's position
        dragged.replaceWith(originalPosition);
        cursor.replaceWith(dragged);
        // await the drop completion event
        await new Promise((resolve) => dragged.addEventListener('marketDragComplete', resolve, { once: true }));
        // in framework mode, restore the original position before firing event
        if (mode === 'framework')
            originalPosition.replaceWith(dragged);
        // fire the reorder event and check for prevent default
        const { defaultPrevented } = event.emit({
            item: dragged,
            oldIndex,
            newIndex,
        });
        // in default mode, restore the original position if event was prevented
        if (defaultPrevented && mode === 'default')
            originalPosition.replaceWith(dragged);
        // cleanup: remove the original position if still in DOM
        originalPosition.remove();
    }
    // clean up var refs
    destroy() {
        _a.cursor.remove();
        clearTimeout(this.tableGroupExpandTimeout);
        this.el = null;
        this.accepts = null;
        this.event = null;
        this.mode = null;
        this.tableGroupExpandTimeout = null;
    }
}
_a = Reorderable;
// static instance var means only one cursor shared across all Reorderable instances
Reorderable.cursor = _a.createCursor();
function getReorderableItems(el, accepts) {
    const items = [];
    const scopedSelectors = accepts.map((selector) => `:scope > ${selector}`);
    el.querySelectorAll(scopedSelectors.join(',')).forEach((item) => {
        if (isDraggable(item))
            items.push(item);
    });
    return items;
}
function getCommonAncestor(node1, node2) {
    let node = node1;
    while (node) {
        if (node.contains(node2)) {
            return node;
        }
        node = node.parentElement;
    }
    return null;
}

const marketListCss = "/*!@:host, ::slotted(*), **/.sc-market-list-h,.sc-market-list-s>*,*.sc-market-list{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-list-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-list-h *.sc-market-list,.sc-market-list-h[disabled].sc-market-list-s>*,.sc-market-list-h[disabled] .sc-market-list-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-list-h{display:block}/*!@::slotted(.market-action-card)*/.sc-market-list-s>.market-action-card{margin-bottom:var(--action-card-spacing)}/*!@::slotted(.market-input-search)*/.sc-market-list-s>.market-input-search{margin-bottom:var(--core-metrics-spacing-100)}/*!@.hidden, ::slotted(.hidden)*/.hidden.sc-market-list,.sc-market-list-s>.hidden{display:none}/*!@::slotted(.market-row.hide-bottom-border)::before*/.sc-market-list-s>.market-row.hide-bottom-border::before{display:none}/*!@.market-empty-state, ::slotted(.market-empty-state)*/.market-empty-state.sc-market-list,.sc-market-list-s>.market-empty-state{padding-right:0;padding-left:0;border:0}/*!@::slotted(.market-drag-cursor)*/.sc-market-list-s>.market-drag-cursor{--drag-cursor-height:4px;display:block;height:0;outline:calc(var(--drag-cursor-height) / 2) solid var(--core-emphasis-fill-color);pointer-events:none}";
var MarketListStyle0 = marketListCss;

/* If Stencil supported extending built-in elements, I would much prefer to extend the <li>
element instead of creating a completely different one here, but unlike buttons and anchors,
the default <li> tag doesn't provide a whole lot over a custom element aside from semantics */
/**
 * @slot control-row - Intended for use with interactive multiselect lists. When used with a
 * `<market-row>` containing a slotted control (such as `<market-checkbox>`), toggling this row
 * will select/deselect all list options.
 * @slot search - Intended for use with `<market-input-search>`
 * @slot empty-state - Intended for use with `<market-empty-state>`; shown when filtering items
 * via `<market-input-search>` and there are no search results.
 * @slot - Intended for use with `<market-row>` or `<market-action-card>`.
 */
class MarketList {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketListSelectionsDidChange = createEvent(this, "marketListSelectionsDidChange", 7);
        this.marketListSlotChange = createEvent(this, "marketListSlotChange", 7);
        this.marketListItemsReordered = createEvent(this, "marketListItemsReordered", 3);
        this.marketListItemsFiltered = createEvent(this, "marketListItemsFiltered", 7);
        this.observers = {};
        this.value = '';
        this.interactive = false;
        this.transient = false;
        this.multiselect = false;
        this.name = undefined;
        this.filterStrategy = 'textcontent';
        this.reorderable = 'off';
        this.reorderMode = 'default';
        this.hideSelectableCount = false;
        this.hasSearch = false;
        this.items = undefined;
        this.selections = new Set();
        this.filteredItems = undefined;
    }
    reorderableWatcher() {
        this.setReorderable();
    }
    valueWatcher() {
        this.setSelectionsFromValue();
    }
    hideSelectableCountWatcher() {
        this.injectCountOnControlRow();
    }
    /* Listen for the marketRowSelected event which is emitted by slotted market-row elements
    when they are clicked */
    rowSelectedEventHandler(e) {
        this.handleItemSelectedEvent(e.target);
    }
    /* Listen for the marketRowDeselected event which is emitted by slotted market-row elements
    when they are clicked */
    rowDeselectedEventHandler(e) {
        this.handleItemDeselectedEvent(e.target);
    }
    /* Listen for the marketCardSelected event which is emitted by slotted market-action-card elements
    when they are clicked */
    cardSelectedEventHandler(e) {
        this.handleItemSelectedEvent(e.target);
    }
    /* Listen for the marketCardDeselected event which is emitted by slotted market-action-card elements
    when they are clicked */
    cardDeselectedEventHandler(e) {
        this.handleItemDeselectedEvent(e.target);
    }
    /**
     * Listen for `marketInputSearchValueChange` which is emitted by the slotted `market-input-search`
     */
    marketInputSearchValueChangeEventHander({ detail }) {
        this.filterItems(detail.value);
    }
    getEventSelectionDetails() {
        const prevSelectionValues = (() => {
            if (typeof this.value === 'string') {
                return this.value ? this.value.split(',').filter((value) => !isValueEmpty$1(value)) : [];
            }
            else if (Array.isArray(this.value)) {
                return this.value.filter((value) => !isValueEmpty$1(value));
            }
            return this.value;
        })();
        const currentSelections = uniqBy([...this.selections].filter((item) => item !== this.controlRow), (item) => item.value);
        const currentSelectionValues = currentSelections.reduce((items, item) => {
            if (!isValueEmpty$1(item.value)) {
                items.push(item.value);
            }
            return items;
        }, []);
        return { currentSelections, currentSelectionValues, prevSelectionValues };
    }
    handleItemSelectedEvent(selectedItem) {
        if (selectedItem === this.controlRow) {
            this.selectAllItems();
        }
        else {
            this.selectItem(selectedItem);
        }
        const { currentSelections, currentSelectionValues, prevSelectionValues } = this.getEventSelectionDetails();
        this.value = currentSelectionValues.join(','); // reflect to DOM
        this.marketListSelectionsDidChange.emit({
            newSelection: selectedItem,
            newSelectionValue: selectedItem.value,
            newDeselection: null,
            newDeselectionValue: null,
            currentSelections,
            currentSelectionValues,
            prevSelectionValues,
        });
    }
    handleItemDeselectedEvent(deselectedItem) {
        // We check to see if the element is in our selections, since we may have
        // already manually deselected it due to another element being clicked.
        // We only want the code in the block to fire when `marketRowDeselected` is being
        // emitted due to a merchant actually clicking to deselect an element.
        if (!this.selections.has(deselectedItem)) {
            return;
        }
        if (deselectedItem === this.controlRow) {
            /**
             * special case: when the only remaining selected items are disabled,
             * the control row's checkbox will be indeterminate (expected UI behavior).
             * when normally, clicking a row with an indeterminate checkbox selects all,
             * in this case, we want it to select all (non-disabled items) instead.
             */
            const shouldSelectAll = (() => {
                var _a, _b;
                const items = ((_b = (_a = this.filteredItems) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : this.items).filter((item) => item !== this.controlRow);
                const nonDisabledItems = items.filter((item) => !item.disabled);
                return nonDisabledItems.every((item) => !item.selected);
            })();
            if (shouldSelectAll) {
                this.selectAllItems();
            }
            else {
                this.deselectAllItems();
            }
        }
        else {
            this.deselectItem(deselectedItem);
        }
        const { currentSelections, currentSelectionValues, prevSelectionValues } = this.getEventSelectionDetails();
        this.value = currentSelectionValues.join(','); // reflect to DOM
        this.marketListSelectionsDidChange.emit({
            newSelection: null,
            newSelectionValue: null,
            newDeselection: deselectedItem,
            newDeselectionValue: deselectedItem.value,
            currentSelections,
            currentSelectionValues,
            prevSelectionValues,
        });
    }
    /**
     * Selects a given option from the list. Also handles deselecting
     * all other elements when not in multiselect mode.
     */
    selectItem(selectedItem) {
        /* Only if this list is interactive and *doesn't* allow multiple selections,
        deselect all the options except the one that was just selected */
        if (this.interactive) {
            if (!this.multiselect) {
                this.deselectItems([selectedItem]);
                this.selections = new Set([selectedItem]);
            }
            else {
                this.selections.add(selectedItem);
            }
        }
    }
    /**
     * Selects all multiselect list options.
     */
    selectAllItems() {
        var _a;
        if (!this.items || !this.interactive || !this.multiselect) {
            return;
        }
        // if items are being filtered, "Select all" only applies to visible items
        // and then filter all non-disabled items to already selected items (might include disabled items)
        const selectableItems = (((_a = this.filteredItems) === null || _a === void 0 ? void 0 : _a.visible) || this.items).filter((item) => !item.disabled);
        this.selections = new Set([...this.selections.values(), ...selectableItems]);
    }
    /**
     * Deselects a given option from the list.
     */
    deselectItem(deselectedItem) {
        this.selections.delete(deselectedItem);
    }
    /**
     * Deselects all other items other than the ones that were just selected.
     */
    deselectItems(selectedItems) {
        if (!this.items) {
            return;
        }
        this.items.forEach((item) => {
            /* Check to make sure the item isn't in the list of
              selected items (likely only the one that was just
              selected and triggered the callback) */
            if (!selectedItems.includes(item) && item.selected) {
                item.deselect();
            }
        });
    }
    /**
     * Deselects all list options.
     */
    deselectAllItems() {
        var _a, _b;
        if (!this.selections || !this.interactive) {
            return;
        }
        /**
         * If items are being filtered, only deselect visible items.
         * Disabled items will not be deselected.
         */
        const visibleItemsSet = new Set((_b = (_a = this.filteredItems) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : this.items);
        const selectedItemsToKeep = [...this.selections].filter((selectedItem) => {
            return selectedItem.disabled || !visibleItemsSet.has(selectedItem);
        });
        this.selections = new Set(selectedItemsToKeep);
    }
    /**
     * If passed or updates interactive, ensure list itself is set to interactive mode.
     */
    syncListInteractiveWithItems() {
        if (this.items.length > 0 &&
            (this.items[0].tagName === getNamespacedTagFor('market-action-card').toUpperCase() ||
                (this.items[0].tagName === getNamespacedTagFor('market-row').toUpperCase() &&
                    this.items[0].interactive === true)) &&
            !this.interactive) {
            // force list to be interactive if items are interactive rows
            // (i.e. when they contain slotted controls), or
            // items are action cards (which are always interactive)
            this.interactive = true;
        }
    }
    /**
     * Processes interactive, transient, and multiselect props and propagates these props
     * to children components whenever these props are updated.
     */
    processItems() {
        this.items.forEach((item) => {
            if (item.tagName === getNamespacedTagFor('market-action-card').toUpperCase()) {
                item.transient = this.transient;
                const cardRow = item.querySelector(getNamespacedTagFor('market-row'));
                if (cardRow) {
                    this.setRowProperties(cardRow);
                }
            }
            else {
                this.setRowProperties(item);
            }
        });
    }
    getCurrentSelectionValues() {
        if (Array.isArray(this.value)) {
            return new Set(this.value);
        }
        return new Set(this.multiselect ? this.value.split(',') : [this.value]);
    }
    setRowProperties(row) {
        row.interactive = this.interactive;
        row.transient = this.transient;
        // We don't want subsequent clicks to deselect rows for single select lists
        row.togglable = this.multiselect;
    }
    /**
     * Select item that corresponds to passed value, or clear all values if value is empty string.
     */
    setSelectionsFromValue() {
        var _a;
        if (this.value || this.value === '') {
            const values = this.getCurrentSelectionValues();
            (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
                if (item === this.controlRow) {
                    // control row selection happens in syncControlRowWithSelections
                    return;
                }
                if (!isValueEmpty$1(this.value) && values.has(item.value)) {
                    item.silentlySelect();
                    this.selectItem(item);
                }
                else {
                    // value is '', so deselect all items
                    item.silentlyDeselect();
                    this.deselectItem(item);
                }
            });
        }
    }
    /**
     * Find any list items with the `selected` property and add to `selections`.
     */
    setSelectionsFromRowAttributes() {
        const initialSelections = new Set();
        this.items.forEach((item) => {
            if (item.selected) {
                /* TODO: Maybe figure out how to handle the case where the
                 * list is not multiselect, but more than one market-row has the
                 * [selected] attribute */
                initialSelections.add(item);
            }
        });
        this.selections = initialSelections;
    }
    setListAndItemsRoles() {
        const itemSelectableTypes = this.items.map((item) => getItemSelectableType(item));
        const allItemsHaveSameSelectableType = itemSelectableTypes.every((type) => type === ListItemSelectableType.CHECKBOX) ||
            itemSelectableTypes.every((type) => type === ListItemSelectableType.RADIO) ||
            itemSelectableTypes.every((type) => type === ListItemSelectableType.SWITCH) ||
            itemSelectableTypes.every((type) => type === ListItemSelectableType.SELECTABLE_WITHOUT_CONTROL);
        if (allItemsHaveSameSelectableType) {
            this.el.setAttribute('role', 'listbox');
            this.items.forEach((item) => {
                item.setAttribute('role', 'option');
            });
            this.el.setAttribute('aria-multiselectable', this.multiselect ? 'true' : 'false');
        }
        else {
            this.el.setAttribute('role', 'list');
            this.items.forEach((item) => {
                item.setAttribute('role', 'listitem');
            });
        }
        if (this.value) {
            this.setSelectionsFromValue();
        }
        else {
            this.setSelectionsFromRowAttributes();
        }
    }
    /**
     * Sets the initial state of the list by updating and propagating props and setting
     * default value.
     */
    setInternalState() {
        this.items = [
            ...this.el.querySelectorAll(`:scope > ${getNamespacedTagFor('market-row')}, :scope > ${getNamespacedTagFor('market-action-card')}`),
        ];
        if (this.items.length === 0) {
            return;
        }
        this.syncListInteractiveWithItems();
        this.processItems();
        this.setListAndItemsRoles();
        if (this.value) {
            this.setSelectionsFromValue();
        }
        else {
            this.setSelectionsFromRowAttributes();
        }
    }
    /**
     * Syncs the state of the slotted control row with list selections (e.g. all selected, none
     * selected, some selected).
     */
    async syncControlRowWithSelections() {
        var _a, _b;
        if (!this.controlRow) {
            return;
        }
        const slottedControl = this.controlRow.querySelector('[slot="control"]');
        const isCheckbox = slottedControl.tagName.toLowerCase() === getNamespacedTagFor('market-checkbox');
        const items = ((_b = (_a = this.filteredItems) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : this.items).filter((item) => item !== this.controlRow);
        const controlRowStatus = (() => {
            if (items.every((item) => item.selected)) {
                // all non-disabled items are selected
                return 'checked';
            }
            else if (items.some((item) => item.selected)) {
                // at least one is selected (regardless if it's disabled or not)
                return 'indeterminate';
            }
            else {
                return 'unchecked';
            }
        })();
        switch (controlRowStatus) {
            case 'unchecked':
                // no options selected, deselect control row
                this.deselectItem(this.controlRow);
                await this.controlRow.silentlyDeselect();
                await asyncRequestAnimationFrame(); // prevents flash where it goes from indeterminate -> checked -> unchecked
                slottedControl.removeAttribute('indeterminate');
                break;
            case 'checked':
                // all options selected, select control row
                await this.controlRow.silentlySelect();
                this.selectItem(this.controlRow);
                slottedControl.removeAttribute('indeterminate');
                break;
            case 'indeterminate':
                // some options selected
                if (isCheckbox) {
                    // control row gets selected, checkbox set to indeterminate
                    await this.controlRow.silentlySelect();
                    this.selectItem(this.controlRow);
                    await asyncRequestAnimationFrame(); // prevents bug where checkbox becomes checked but not indeterminate
                    slottedControl.setAttribute('indeterminate', '');
                }
                else {
                    // control row gets deselected
                    await this.controlRow.silentlyDeselect();
                    this.deselectItem(this.controlRow);
                }
                break;
        }
        this.injectCountOnControlRow();
    }
    /**
     * Injects an accessory to the control row that displays the number of items;
     * or edit that accessory's text content if the element already exists.
     *
     * Disabled items are not included in the count.
     *
     * Count is only rendered when `hideSelectableCount` is `false`, which it is by default.
     */
    injectCountOnControlRow() {
        if (!this.controlRow) {
            return;
        }
        const countAccessoryEl = this.controlRow.querySelector('.count[slot="trailing-accessory"]');
        if (this.hideSelectableCount) {
            if (countAccessoryEl) {
                this.controlRow.removeChild(countAccessoryEl);
            }
            return;
        }
        const count = this.filteredItems.visible.filter((item) => !item.disabled).length;
        if (countAccessoryEl) {
            countAccessoryEl.textContent = `${count}`;
        }
        else {
            const newEl = document.createElement('span');
            newEl.classList.add('count');
            newEl.setAttribute('slot', 'trailing-accessory');
            newEl.textContent = `${count}`;
            this.controlRow.appendChild(newEl);
        }
    }
    /**
     * Filters items based on search query inputted in slotted `market-input-search`
     */
    filterItems(query) {
        var _a;
        const filteredItems = this.items.reduce((filteredItems, item) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            if (item.getAttribute('slot') === 'control-row') {
                // filteredItems will not contain the control row as it isn't needed for logic purposes
                return filteredItems;
            }
            else if (!query) {
                // if there's no search query, all items are visible
                filteredItems.visible.push(item);
                return filteredItems;
            }
            else if (typeof this.filterStrategy === 'function') {
                // attempts to call the provided function
                const callbackResult = this.filterStrategy({
                    item,
                    label: (_a = item.querySelector('[slot="label"]')) === null || _a === void 0 ? void 0 : _a.textContent,
                    query,
                    textContent: item.textContent,
                    value: item.value,
                });
                if (callbackResult) {
                    filteredItems.visible.push(item);
                    return filteredItems;
                }
            }
            else if (((_c = (_b = this.filterStrategy) === null || _b === void 0 ? void 0 : _b.toLocaleLowerCase) === null || _c === void 0 ? void 0 : _c.call(_b)) === 'textcontent') {
                // search through the entire item's textContent
                const isFound = ((_d = item === null || item === void 0 ? void 0 : item.textContent) === null || _d === void 0 ? void 0 : _d.search(new RegExp(query, 'i'))) >= 0;
                if (isFound) {
                    filteredItems.visible.push(item);
                    return filteredItems;
                }
            }
            else if (((_f = (_e = this.filterStrategy) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase) === null || _f === void 0 ? void 0 : _f.call(_e)) === 'label') {
                // only works if there's a slotted label
                const labelEl = item.querySelector('[slot="label"]');
                const isFound = ((_g = labelEl === null || labelEl === void 0 ? void 0 : labelEl.textContent) === null || _g === void 0 ? void 0 : _g.search(new RegExp(query, 'i'))) >= 0;
                if (isFound) {
                    filteredItems.visible.push(item);
                    return filteredItems;
                }
            }
            else if (((_j = (_h = this.filterStrategy) === null || _h === void 0 ? void 0 : _h.toLocaleLowerCase) === null || _j === void 0 ? void 0 : _j.call(_h)) === 'value') {
                // if the item's value isn't a string, it may not work well UX-wise
                const value = String(item.value);
                const isFound = value.search(new RegExp(query)) >= 0;
                if (isFound) {
                    filteredItems.visible.push(item);
                    return filteredItems;
                }
            }
            // item didn't pass any of the conditions / filter strategies above
            filteredItems.hidden.push(item);
            return filteredItems;
        }, {
            visible: [],
            hidden: [],
            visibleSelected: [],
            selected: [],
        });
        // DOM manipulation
        requestAnimationFrame(() => {
            var _a;
            // make sure that visible items are visible, hidden items are hidden
            filteredItems.visible.forEach((item) => item.classList.remove('hidden'));
            filteredItems.hidden.forEach((item) => item.classList.add('hidden'));
            // hide last visible item's bottom border
            this.items.forEach((item) => item.classList.remove('hide-bottom-border'));
            if (filteredItems.visible.length > 0) {
                const lastVisibleItem = filteredItems.visible[filteredItems.visible.length - 1];
                lastVisibleItem.classList.add('hide-bottom-border');
            }
            // hide control row if there are no search results
            (_a = this.controlRow) === null || _a === void 0 ? void 0 : _a.classList.toggle('hidden', filteredItems.visible.length === 0);
        });
        // will not emit when the list is initially rendered without a search query
        if (this.filteredItems || (!this.filteredItems && query)) {
            this.marketListItemsFiltered.emit({
                items: filteredItems.visible,
                prevItems: (_a = this.filteredItems) === null || _a === void 0 ? void 0 : _a.visible,
            });
        }
        // this triggers a re-render since `this.filteredItems` is a `@State`
        this.filteredItems = filteredItems;
        this.updateSelectedItemsInFilteredItems();
    }
    updateSelectedItemsInFilteredItems() {
        if (!this.filteredItems) {
            return;
        }
        this.filteredItems.selected = this.items.filter((item) => item.getAttribute('slot') !== 'control-row' && item.selected);
        this.filteredItems.visibleSelected = this.filteredItems.visible.filter((item) => item.getAttribute('slot') !== 'control-row' && item.selected);
    }
    /* SLOTCHANGE HANDLERS */
    handleSearchSlotchange() {
        var _a;
        this.inputSearchEl = this.el.querySelector('[slot="search"]');
        this.hasSearch = Boolean(this.inputSearchEl);
        this.filterItems((_a = this.inputSearchEl) === null || _a === void 0 ? void 0 : _a.value);
    }
    defaultSlotchangeHandler() {
        var _a;
        this.setInternalState();
        this.filterItems((_a = this.inputSearchEl) === null || _a === void 0 ? void 0 : _a.value);
        this.setReorderable();
        this.marketListSlotChange.emit();
    }
    /**
     * Rows slotted into the "control-row" slot only function as such if the list is interactive and
     * multiselect and the row contains a valid slotted control (checkbox or toggle).
     */
    controlRowSlotchangeHandler() {
        if (!this.interactive || !this.multiselect) {
            return;
        }
        const slottedRow = this.el.querySelector('[slot="control-row"]');
        const slottedControl = slottedRow === null || slottedRow === void 0 ? void 0 : slottedRow.querySelector('[slot="control"]');
        this.controlRow = isValidControl(slottedControl) ? slottedRow : undefined;
    }
    /**
     * Show empty state if:
     * - list isn't empty, but
     * - there is a search query, and
     * - there are no search results
     */
    setEmptyStateVisibility() {
        var _a, _b;
        const emptyStateEl = this.el.querySelector('[slot="empty-state"]') ||
            this.el.shadowRoot.querySelector(getNamespacedTagFor('market-empty-state'));
        const willShowEmptyState = ((_a = this.inputSearchEl) === null || _a === void 0 ? void 0 : _a.value) && !((_b = this.filteredItems) === null || _b === void 0 ? void 0 : _b.visible.length);
        emptyStateEl === null || emptyStateEl === void 0 ? void 0 : emptyStateEl.classList.toggle('hidden', !willShowEmptyState);
    }
    /**
     * Updates the count that is injected to the control row
     * when theres a change on an items `disabled` attribute.
     */
    initItemDisabledAttributeObserver() {
        if (this.observers.itemDisabledAttribute) {
            return;
        }
        this.observers.itemDisabledAttribute = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.target.parentElement === this.el &&
                    mutation.type === 'attributes' &&
                    mutation.attributeName === 'disabled') {
                    this.injectCountOnControlRow();
                }
            }
        });
        this.observers.itemDisabledAttribute.observe(this.el, {
            attributes: true,
            attributeFilter: ['disabled'],
            childList: true,
            subtree: true,
        });
    }
    /* LIFECYCLE EVENTS */
    connectedCallback() {
        this.syncControlRowWithSelections();
    }
    componentWillLoad() {
        var _a;
        this.setInternalState();
        this.filterItems((_a = this.inputSearchEl) === null || _a === void 0 ? void 0 : _a.value);
    }
    componentWillRender() {
        this.syncListInteractiveWithItems();
        this.processItems();
        this.setListAndItemsRoles();
        this.updateSelectedItemsInFilteredItems();
        this.controlRowSlotchangeHandler();
        this.syncControlRowWithSelections();
        this.setEmptyStateVisibility();
    }
    componentDidLoad() {
        this.initItemDisabledAttributeObserver();
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observers.itemDisabledAttribute) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    /*
      KEYBOARD ACCESSIBILITY
  
      tabbing goes through rows (and slotted controls, if any) once before moving
      on to rest of page content
  
      once list has focus, up/down arrows can move focus up/down, stopping at end
      of list rather than cycling through (similar to native html <select>)
      - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select
  
      if slotted row contents have focus, up/down arrows do nothing
    */
    handleKeydown(e) {
        switch (e.key) {
            case 'ArrowDown':
                this.handleArrowDown(e);
                break;
            case 'ArrowUp':
                this.handleArrowUp(e);
                break;
        }
    }
    handleArrowDown(e) {
        const focused = this.el.querySelector(':focus');
        const prevFocusedRowIndex = [...this.items].indexOf(focused);
        // return if no rows are focused
        if (prevFocusedRowIndex === -1) {
            return;
        }
        // focus next enabled row
        for (let i = prevFocusedRowIndex + 1; i < this.items.length; i++) {
            if (!this.items[i].disabled) {
                this.items[i].focus();
                break;
            }
        }
        e.preventDefault(); // down arrow should not scroll page
    }
    handleArrowUp(e) {
        const focused = this.el.querySelector(':focus');
        const prevFocusedRowIndex = [...this.items].indexOf(focused);
        // return if no rows are focused
        if (prevFocusedRowIndex === -1) {
            return;
        }
        // focus last enabled row
        for (let i = prevFocusedRowIndex - 1; i >= 0; i--) {
            if (!this.items[i].disabled) {
                this.items[i].focus();
                break;
            }
        }
        e.preventDefault(); // up arrow should not scroll page
    }
    /**
     * Focuses the row at the given index.
     * @param index - The index of the row to focus.
     * @returns A promise that resolves when the row is focused.
     */
    async focusRowAtIndex(index) {
        const row = this.items[index];
        if (row) {
            row.focus();
            return Promise.resolve();
        }
        else {
            return Promise.reject(new Error(`Row at index ${index} not found`));
        }
    }
    setReorderable() {
        const { el, items, controlRow, reorderable, reorderMode, reorder, marketListItemsReordered } = this;
        if (reorderable === 'off') {
            reorder === null || reorder === void 0 ? void 0 : reorder.destroy();
            this.reorder = null;
        }
        else if (!reorder) {
            this.reorder = new Reorderable({
                el,
                accepts: [`${getNamespacedTagFor('market-row')}:not([slot="control"])`],
                event: marketListItemsReordered,
                mode: reorderMode,
            });
        }
        items === null || items === void 0 ? void 0 : items.forEach((item) => {
            if (!isDraggable(item))
                return;
            if (item === controlRow)
                return; // control row is not reorderable
            item.dragEnabled = reorderable !== 'off';
        });
    }
    onDragMove(e) {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragMove(e);
    }
    onDragLeave() {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragLeave();
    }
    onDragEnd(e) {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragEnd(e);
    }
    onDragDrop(e) {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragDrop(e);
    }
    componentDidRender() {
        this.setReorderable();
    }
    render() {
        var _a;
        const MarketEmptyState = getNamespacedTagFor('market-empty-state');
        return (hAsync(Host, { key: 'f01372045695a9776c6318303fecd322561cdb1d', class: "market-list", "aria-labelledby": this.name, "has-search": this.hasSearch, onKeydown: (e) => this.handleKeydown(e), onMarketDragMove: (e) => this.onDragMove(e), onMarketDragLeave: () => this.onDragLeave(), onMarketDragEnd: (e) => this.onDragEnd(e), onMarketDragDrop: (e) => this.onDragDrop(e) }, hAsync("slot", { key: 'e5a0f3a54f00422e2a116d5958a1d733d4aea540', name: "search", onSlotchange: () => this.handleSearchSlotchange() }), hAsync("slot", { key: '3aaca12e5456bc8df62bf982d00a997ffdd6a6d8', name: "control-row", onSlotchange: () => this.controlRowSlotchangeHandler() }), hAsync("slot", { key: '2b528867d3784890f0f54619b302c223eee4cdd5', onSlotchange: () => this.defaultSlotchangeHandler() }), hAsync("slot", { key: '7d6f8a7cf5a9add9811afe49fe24621260887769', name: "empty-state" }, hAsync(MarketEmptyState, { key: 'af825be4ce90fa63ec83b1f2fda05abb47401750', class: "hidden" }, hAsync("svg", { key: '9088bd651dca4d4beaaf6b22e1917af118767e21', height: "40", slot: "media", viewBox: "0 0 40 40", width: "40", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '795ff6d2afc5584c7b516e60fa385af8964e24be', d: "M34.4667 17.2L28.1 10.8333H26.6667C26.6667 9.45 25.55 8.33333 24.1667 8.33333C22.7834 8.33333 21.6667 9.45 21.6667 10.8333H18.3334C18.3334 9.45 17.2167 8.33333 15.8334 8.33333C14.45 8.33333 13.3334 9.45 13.3334 10.8333H11.9L5.53337 17.2C4.11671 18.6167 3.33337 20.5 3.33337 22.5C3.33337 26.6333 6.70004 30 10.8334 30C14.8 30 18.0167 26.9 18.2834 23.0167C18.8167 23.2167 19.4 23.3333 20 23.3333C20.6 23.3333 21.1834 23.2167 21.7167 23.0167C21.9834 26.9 25.2 30 29.1667 30C33.3 30 36.6667 26.6333 36.6667 22.5C36.6667 20.5 35.8834 18.6167 34.4667 17.2ZM10.8334 26.6667C8.53337 26.6667 6.66671 24.8 6.66671 22.5C6.66671 21.3833 7.10004 20.3333 7.88337 19.55C8.66671 18.7667 9.71671 18.3333 10.8334 18.3333C13.1334 18.3333 15 20.2 15 22.5C15 24.8 13.1334 26.6667 10.8334 26.6667ZM15.35 16.55C14.4667 15.8833 13.4334 15.3833 12.3 15.15L13.2667 14.1667H17.2334C16.3834 14.7333 15.7167 15.5667 15.35 16.55ZM20 20C19.0834 20 18.3334 19.25 18.3334 18.3333C18.3334 17.4167 19.0834 16.6667 20 16.6667C20.9167 16.6667 21.6667 17.4167 21.6667 18.3333C21.6667 19.25 20.9167 20 20 20ZM22.75 14.1667H26.7167L27.7 15.15C26.5667 15.3833 25.5334 15.8833 24.65 16.55C24.2834 15.5667 23.6167 14.7333 22.75 14.1667ZM29.1667 26.6667C26.8667 26.6667 25 24.8 25 22.5C25 20.2 26.8667 18.3333 29.1667 18.3333C30.2834 18.3333 31.3334 18.7667 32.1167 19.55C32.9 20.3333 33.3334 21.3833 33.3334 22.5C33.3334 24.8 31.4667 26.6667 29.1667 26.6667Z", fill: "var(--core-text-10-color)", "fill-opacity": "0.9" })), hAsync("h3", { key: '2ed929f1c74989aa9df9809fa509f8c037d05d9b', slot: "primary-text" }, hAsync("slot", { key: 'eb5ab0008deb0ca384e32a02448f72e836837b2a', name: "empty-state-primary-text" }, "No search results for \u201C", (_a = this.inputSearchEl) === null || _a === void 0 ? void 0 :
            _a.value, "\u201D")), hAsync("p", { key: 'd0cb3833586c6b08307cb3529876a44d3668be4c', slot: "secondary-text" }, hAsync("slot", { key: '690ffc4bb1f6c81d12ce44aca5aea14d1e8c1bec', name: "empty-state-secondary-text" }, "Try a different search."))))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "reorderable": ["reorderableWatcher"],
        "value": ["valueWatcher"],
        "hideSelectableCount": ["hideSelectableCountWatcher"]
    }; }
    static get style() { return MarketListStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-list",
        "$members$": {
            "value": [1537],
            "interactive": [1028],
            "transient": [4],
            "multiselect": [516],
            "name": [1],
            "filterStrategy": [1, "filter-strategy"],
            "reorderable": [513],
            "reorderMode": [1, "reorder-mode"],
            "hideSelectableCount": [516, "hide-selectable-count"],
            "hasSearch": [32],
            "items": [32],
            "selections": [32],
            "filteredItems": [32],
            "focusRowAtIndex": [64]
        },
        "$listeners$": [[0, "marketRowSelected", "rowSelectedEventHandler"], [0, "marketRowDeselected", "rowDeselectedEventHandler"], [0, "marketCardSelected", "cardSelectedEventHandler"], [0, "marketCardDeselected", "cardDeselectedEventHandler"], [0, "marketInputSearchValueChange", "marketInputSearchValueChangeEventHander"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["multiselect", "multiselect"], ["reorderable", "reorderable"], ["hideSelectableCount", "hide-selectable-count"]]
    }; }
}

const marketModalFullCss = "/*!@:host, ::slotted(*), **/.sc-market-modal-full-h,.sc-market-modal-full-s>*,*.sc-market-modal-full{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-modal-full-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-modal-full-h *.sc-market-modal-full,.sc-market-modal-full-h[disabled].sc-market-modal-full-s>*,.sc-market-modal-full-h[disabled] .sc-market-modal-full-s>*{cursor:not-allowed !important;pointer-events:none !important}@keyframes market-popup{from{opacity:0%;transform:scale(0.9, 0.9)}to{opacity:100%;transform:scale(1, 1)}}@keyframes market-popdown{from{opacity:100%;transform:scale(1, 1)}to{opacity:0%;transform:scale(0.9, 0.9)}}@keyframes market-slideup{from{opacity:0%;transform:translateY(80vh)}to{opacity:100%;transform:translateY(0)}}@keyframes market-slidedown{from{opacity:100%;transform:translateY(0)}to{opacity:0%;transform:translateY(80vh)}}@keyframes market-slide-left-enter{from{transform:translateX(100%)}to{transform:translateX(0)}}@keyframes market-slide-left-exit{from{transform:translateX(0)}to{transform:translateX(100%)}}@keyframes market-fade-in{from{opacity:0%}to{opacity:100%}}@keyframes market-fade-out{from{opacity:100%}to{opacity:0%}}@keyframes market-input-autofill-start{from{}to{}}@keyframes market-input-autofill-cancel{from{}to{}}@keyframes market-input-search-compact-enter{from{}to{}}@keyframes market-input-search-compact-exit{from{}to{}}/*!@:host*/.sc-market-modal-full-h{display:flex;flex-direction:column;justify-content:stretch;overflow:hidden}/*!@:host ::slotted(main), :host ::slotted(.main)*/.sc-market-modal-full-h .sc-market-modal-full-s>main,.sc-market-modal-full-h.sc-market-modal-full-s>.main,.sc-market-modal-full-h .sc-market-modal-full-s>.main{flex:0 1 100%;overflow-y:auto;height:100%}/*!@:host ::slotted(.market-header)*/.sc-market-modal-full-h .sc-market-modal-full-s>.market-header{margin-bottom:var(--core-metrics-spacing-300);padding-top:0}/*!@:host ::slotted(.market-footer)*/.sc-market-modal-full-h .sc-market-modal-full-s>.market-footer{padding-bottom:0}/*!@:host*/.sc-market-modal-full-h{position:absolute;top:0;left:0;width:100%;height:100%;padding-top:var(--modal-full-vertical-padding-size);padding-bottom:var(--modal-full-vertical-padding-size);background-color:var(--modal-full-background-color);animation:var(--modal-full-animation-enter-transition-duration)\n    market-slideup\n    forwards\n    var(--modal-full-animation-enter-transition-easing)}/*!@:host ::slotted(*)*/.sc-market-modal-full-h .sc-market-modal-full-s>*{padding-right:var(--modal-full-horizontal-padding-size);padding-left:var(--modal-full-horizontal-padding-size)}/*!@:host([hidden])*/[hidden].sc-market-modal-full-h{animation-name:market-slidedown;animation-duration:var(--modal-full-animation-exit-transition-duration);animation-timing-function:var(--modal-full-animation-exit-transition-easing)}/*!@:host*/.sc-market-modal-full-h{--modal-full-wide-layout-width:1200px;--regular-modal-main-horizontal-padding:calc((100vw - var(--modal-full-fixed-layout-width)) / 2);--wide-modal-main-horizontal-padding:calc((100vw - var(--modal-full-wide-layout-width)) / 2)}@media (min-width: 648px){/*!@:host([layout=\"regular\"]) > :not(.market-header,   .market-footer),   :host([layout=\"regular\"]) ::slotted(main),   :host([layout=\"regular\"]) ::slotted(.main)*/[layout=\"regular\"].sc-market-modal-full-h>.sc-market-modal-full:not(.market-header,.market-footer).sc-market-modal-full,.sc-market-modal-full-h[layout=\"regular\"].sc-market-modal-full-s>main,.sc-market-modal-full-h[layout=\"regular\"] .sc-market-modal-full-s>main,.sc-market-modal-full-h[layout=\"regular\"].sc-market-modal-full-s>.main,.sc-market-modal-full-h[layout=\"regular\"] .sc-market-modal-full-s>.main{padding:0 var(--regular-modal-main-horizontal-padding)}}@media (min-width: 1280px){/*!@:host([layout=\"wide\"]) > :not(.market-header,   .market-footer),   :host([layout=\"wide\"]) ::slotted(main),   :host([layout=\"wide\"]) ::slotted(.main)*/[layout=\"wide\"].sc-market-modal-full-h>.sc-market-modal-full:not(.market-header,.market-footer).sc-market-modal-full,.sc-market-modal-full-h[layout=\"wide\"].sc-market-modal-full-s>main,.sc-market-modal-full-h[layout=\"wide\"] .sc-market-modal-full-s>main,.sc-market-modal-full-h[layout=\"wide\"].sc-market-modal-full-s>.main,.sc-market-modal-full-h[layout=\"wide\"] .sc-market-modal-full-s>.main{padding:0 var(--wide-modal-main-horizontal-padding)}}";
var MarketModalFullStyle0 = marketModalFullCss;

class MarketModalFull {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDialogLoaded = createEvent(this, "marketDialogLoaded", 7);
        this.marketDialogDismissed = createEvent(this, "marketDialogDismissed", 7);
        this.marketDialogDidDismiss = createEvent(this, "marketDialogDidDismiss", 7);
        this.type = 'modal-full';
        this.hidden = false;
        this.dialogID = undefined;
        this.index = undefined;
        this.layout = 'regular';
        this.trapFocus = false;
        this.animationEnterDuration = cjs.MODAL_FULL_ANIMATION_ENTER_TRANSITION_DURATION;
        this.animationExitDuration = cjs.MODAL_FULL_ANIMATION_EXIT_TRANSITION_DURATION;
    }
    layoutWatcher() {
        this.repositionHeader();
    }
    /**
     * Listen to the headerNavigate event emitted by a market-header child component
     * so we can emit a close event if needed
     */
    headerNavigateEventHandler(event) {
        const { detail, target } = event;
        // TODO: 'close' should probably come from an enum of some sort
        if (detail.action === 'close') {
            // only dismiss if this is the first ancestor dialog
            if (target.closest(getDialogSelector()) === this.el) {
                this.dismiss();
            }
        }
    }
    /* The parent context will handle actually removing elements from the DOM,
    All the modal needs to do it emit an event so actually closing it can be
    some other elements problem */
    /**
     *  Repositions header inside of market-header to align with modal content */
    repositionHeader() {
        // since it isn't possible to style slotted child elements, we need to add
        // classes to the slotted header to apply needed styles to its shadow DOM.
        const slottedHeader = this.el.querySelector(getNamespacedTagFor('market-header'));
        if (slottedHeader) {
            slottedHeader.classList.remove('regular', 'wide');
            switch (this.layout) {
                case 'regular':
                    slottedHeader.classList.add('regular');
                    break;
                case 'wide':
                    slottedHeader.classList.add('wide');
                    break;
            }
        }
    }
    /**
     * Emits the dismiss event
     * The parent context will handle actually removing elements from the DOM,
     * All the modal needs to do it emit an event so actually closing it can be
     * some other elements problem
     */
    dismiss(dismissOptions) {
        const { defaultPrevented } = this.marketDialogDismissed.emit({
            dialog: this.el,
            type: this.type,
            origin: (dismissOptions === null || dismissOptions === void 0 ? void 0 : dismissOptions.origin) || this.el,
        });
        if (!defaultPrevented) {
            this.hidden = true;
            /**
             * Emit a marketDialogDidDismiss event when modal gets fully dismissed (after animation).
             */
            setTimeout(() => {
                this.marketDialogDidDismiss.emit({
                    dialog: this.el,
                    type: this.type,
                    origin: this.el,
                });
            }, this.animationExitDuration);
        }
        return Promise.resolve();
    }
    onTrapFocusChanged(newValue, oldValue) {
        // only activate/deactivate when the `trapFocus` prop value changes
        if (newValue !== oldValue) {
            if (newValue) {
                this.activateFocusTrap();
            }
            else {
                this.deactivateFocusTrap();
            }
        }
    }
    /**
     * Activates the focus trap
     *
     * See [`focus-trap.ts`](../../utils/focus-trap.ts) for default options
     *
     * @param {Object} [options] [focus-trap create options](https://github.com/focus-trap/focus-trap#createoptions)
     * @param {Object} [activateOptions] set options for [onActivate, onPostActivate, and checkCanFocusTrap](https://github.com/focus-trap/focus-trap#trapactivate)
     */
    activateFocusTrap(options, activateOptions) {
        if (this.focusTrap) {
            this.focusTrap.activate(activateOptions !== null && activateOptions !== void 0 ? activateOptions : {});
            if (!this.trapFocus) {
                this.trapFocus = true;
            }
        }
        else {
            this.focusTrap = createAndActivateFocusTrap({
                activateOptions,
                el: this.el,
                options,
            });
        }
        return Promise.resolve();
    }
    /**
     * Deactivates the focus trap
     *
     * @param {FocusTrapDeactivateOptions} [deactivateOptions] set options for [onDeactivate, onPostDeactivate, and checkCanReturnFocus](https://github.com/focus-trap/focus-trap#trapdeactivate)
     */
    deactivateFocusTrap(deactivateOptions) {
        if (this.focusTrap) {
            this.focusTrap.deactivate(Object.assign({ returnFocus: true, checkCanReturnFocus: (trigger) => new Promise((resolve) => {
                    if (typeof (trigger === null || trigger === void 0 ? void 0 : trigger.setFocus) === 'function') {
                        trigger.setFocus();
                    }
                    else {
                        resolve(); // node.focus(); will be called by focus-trap
                    }
                }) }, deactivateOptions));
            this.focusTrap = undefined;
        }
        return Promise.resolve();
    }
    connectedCallback() {
        this.connectedCallbackTimeout = setTimeout(() => {
            /**
             * Emit a dialogLoaded event when the component connects. Need this so
             * the context manager isn't rummaging around it's DOM to try and find the
             * dialog that was just appended
             */
            this.marketDialogLoaded.emit({
                dialog: this.el,
                type: this.type,
            });
            if (this.trapFocus) {
                this.activateFocusTrap();
            }
        }, this.animationEnterDuration);
    }
    componentWillLoad() {
        setupDialogCompactHandler(this.el);
    }
    disconnectedCallback() {
        this.deactivateFocusTrap();
        /**
         * Prevents error caused by race conditions during rapid mounting and
         * unmounting of component by clearing the setTimeout from connectedCallback
         * if it gets called after disconnectedCallback.
         */
        clearTimeout(this.connectedCallbackTimeout);
    }
    render() {
        return (hAsync(Host, { key: '53ab9cd6782b0337c4b49d8ed8547ff697737017', class: "market-modal-full", role: "dialog" }, hAsync("slot", { key: '31f2fa16cdfca98bda559b3ae777a73120acbc38', onSlotchange: () => this.repositionHeader() })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "layout": ["layoutWatcher"],
        "trapFocus": ["onTrapFocusChanged"]
    }; }
    static get style() { return MarketModalFullStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-modal-full",
        "$members$": {
            "hidden": [1540],
            "dialogID": [513, "data-dialog-id"],
            "index": [514, "data-dialog-index"],
            "layout": [513],
            "trapFocus": [1028, "trap-focus"],
            "animationEnterDuration": [2, "animation-enter-duration"],
            "animationExitDuration": [2, "animation-exit-duration"],
            "dismiss": [64],
            "activateFocusTrap": [64],
            "deactivateFocusTrap": [64]
        },
        "$listeners$": [[0, "marketHeaderNavigate", "headerNavigateEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"], ["dialogID", "data-dialog-id"], ["index", "data-dialog-index"], ["layout", "layout"]]
    }; }
}

const marketModalPartialCss = "/*!@:host, ::slotted(*), **/.sc-market-modal-partial-h,.sc-market-modal-partial-s>*,*.sc-market-modal-partial{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-modal-partial-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-modal-partial-h *.sc-market-modal-partial,.sc-market-modal-partial-h[disabled].sc-market-modal-partial-s>*,.sc-market-modal-partial-h[disabled] .sc-market-modal-partial-s>*{cursor:not-allowed !important;pointer-events:none !important}@keyframes market-popup{from{opacity:0%;transform:scale(0.9, 0.9)}to{opacity:100%;transform:scale(1, 1)}}@keyframes market-popdown{from{opacity:100%;transform:scale(1, 1)}to{opacity:0%;transform:scale(0.9, 0.9)}}@keyframes market-slideup{from{opacity:0%;transform:translateY(80vh)}to{opacity:100%;transform:translateY(0)}}@keyframes market-slidedown{from{opacity:100%;transform:translateY(0)}to{opacity:0%;transform:translateY(80vh)}}@keyframes market-slide-left-enter{from{transform:translateX(100%)}to{transform:translateX(0)}}@keyframes market-slide-left-exit{from{transform:translateX(0)}to{transform:translateX(100%)}}@keyframes market-fade-in{from{opacity:0%}to{opacity:100%}}@keyframes market-fade-out{from{opacity:100%}to{opacity:0%}}@keyframes market-input-autofill-start{from{}to{}}@keyframes market-input-autofill-cancel{from{}to{}}@keyframes market-input-search-compact-enter{from{}to{}}@keyframes market-input-search-compact-exit{from{}to{}}/*!@:host*/.sc-market-modal-partial-h{display:flex;flex-direction:column;justify-content:stretch;overflow:hidden}/*!@:host ::slotted(main), :host ::slotted(.main)*/.sc-market-modal-partial-h .sc-market-modal-partial-s>main,.sc-market-modal-partial-h.sc-market-modal-partial-s>.main,.sc-market-modal-partial-h .sc-market-modal-partial-s>.main{flex:0 1 100%;overflow-y:auto;height:100%}/*!@:host ::slotted(.market-header)*/.sc-market-modal-partial-h .sc-market-modal-partial-s>.market-header{margin-bottom:var(--core-metrics-spacing-300);padding-top:0}/*!@:host ::slotted(.market-footer)*/.sc-market-modal-partial-h .sc-market-modal-partial-s>.market-footer{padding-bottom:0}/*!@:host*/.sc-market-modal-partial-h{position:absolute;top:0;left:0;width:100%;height:100%;padding-top:var(--modal-full-vertical-padding-size);padding-bottom:var(--modal-full-vertical-padding-size);background-color:var(--modal-full-background-color);animation:var(--modal-full-animation-enter-transition-duration)\n    market-slideup\n    forwards\n    var(--modal-full-animation-enter-transition-easing)}/*!@:host ::slotted(*)*/.sc-market-modal-partial-h .sc-market-modal-partial-s>*{padding-right:var(--modal-full-horizontal-padding-size);padding-left:var(--modal-full-horizontal-padding-size)}/*!@:host([hidden])*/[hidden].sc-market-modal-partial-h{animation-name:market-slidedown;animation-duration:var(--modal-full-animation-exit-transition-duration);animation-timing-function:var(--modal-full-animation-exit-transition-easing)}@media (min-width: 800px){/*!@:host*/.sc-market-modal-partial-h{top:0;left:auto;width:var(--modal-partial-width);height:auto;max-height:calc(100vh - var(--modal-partial-vertical-screen-buffer-size) * 2);padding-top:var(--modal-partial-vertical-padding-size);padding-bottom:var(--modal-partial-vertical-padding-size);border-radius:var(--modal-partial-border-radius);animation:var(--modal-partial-animation-enter-transition-duration)\n      market-popup\n      forwards\n      var(--modal-partial-animation-enter-transition-easing)}/*!@:host ::slotted(*)*/.sc-market-modal-partial-h .sc-market-modal-partial-s>*{padding-right:var(--modal-partial-horizontal-padding-size);padding-left:var(--modal-partial-horizontal-padding-size)}/*!@:host([hidden])*/[hidden].sc-market-modal-partial-h{animation-name:market-popdown;animation-duration:var(--modal-partial-animation-exit-transition-duration);animation-timing-function:var(--modal-partial-animation-exit-transition-easing)}}";
var MarketModalPartialStyle0 = marketModalPartialCss;

class MarketModalPartial {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDialogLoaded = createEvent(this, "marketDialogLoaded", 7);
        this.marketDialogDismissed = createEvent(this, "marketDialogDismissed", 7);
        this.marketDialogDidDismiss = createEvent(this, "marketDialogDidDismiss", 7);
        this.type = 'modal-partial';
        this.hidden = false;
        this.dialogID = undefined;
        this.index = undefined;
        this.trapFocus = false;
        this.animationEnterDuration = cjs.MODAL_PARTIAL_ANIMATION_ENTER_TRANSITION_DURATION;
        this.animationExitDuration = cjs.MODAL_PARTIAL_ANIMATION_EXIT_TRANSITION_DURATION;
    }
    /**
     * Listen to the headerNavigate event emitted by a market-header child component
     * so we can emit a close event if needed
     */
    headerNavigateEventHandler(event) {
        const { detail, target } = event;
        // TODO: 'close' should probably come from an enum of some sort
        if (detail.action === 'close') {
            // only dismiss if this is the first ancestor dialog
            if (target.closest(getDialogSelector()) === this.el) {
                this.dismiss();
            }
        }
    }
    /* The parent context will handle actually removing elements from the DOM,
    All the modal needs to do it emit an event so actually closing it can be
    some other elements problem */
    /**
     * Emits the dismiss event
     * The parent context will handle actually removing elements from the DOM,
     * All the modal needs to do it emit an event so actually closing it can be
     * some other elements problem
     */
    dismiss(dismissOptions) {
        const { defaultPrevented } = this.marketDialogDismissed.emit({
            dialog: this.el,
            type: this.type,
            origin: (dismissOptions === null || dismissOptions === void 0 ? void 0 : dismissOptions.origin) || this.el,
        });
        if (!defaultPrevented) {
            this.hidden = true;
            /**
             * Emit a marketDialogDidDismiss event when modal gets fully dismissed (after animation).
             */
            setTimeout(() => {
                this.marketDialogDidDismiss.emit({
                    dialog: this.el,
                    type: this.type,
                    origin: this.el,
                });
            }, this.animationExitDuration);
        }
        return Promise.resolve();
    }
    onTrapFocusChanged(newValue, oldValue) {
        // only activate/deactivate when the `trapFocus` prop value changes
        if (newValue !== oldValue) {
            if (newValue) {
                this.activateFocusTrap();
            }
            else {
                this.deactivateFocusTrap();
            }
        }
    }
    /**
     * Activates the focus trap
     *
     * See [`focus-trap.ts`](../../utils/focus-trap.ts) for default options
     *
     * @param {Object} [options] [focus-trap create options](https://github.com/focus-trap/focus-trap#createoptions)
     * @param {Object} [activateOptions] set options for [onActivate, onPostActivate, and checkCanFocusTrap](https://github.com/focus-trap/focus-trap#trapactivate)
     */
    activateFocusTrap(options, activateOptions) {
        if (this.focusTrap) {
            this.focusTrap.activate(activateOptions !== null && activateOptions !== void 0 ? activateOptions : {});
            if (!this.trapFocus) {
                this.trapFocus = true;
            }
        }
        else {
            this.focusTrap = createAndActivateFocusTrap({
                el: this.el,
                options,
                activateOptions,
            });
        }
        return Promise.resolve();
    }
    /**
     * Deactivates the focus trap
     *
     * @param {FocusTrapDeactivateOptions} [deactivateOptions] set options for [onDeactivate, onPostDeactivate, and checkCanReturnFocus](https://github.com/focus-trap/focus-trap#trapdeactivate)
     */
    deactivateFocusTrap(deactivateOptions = {}) {
        if (this.focusTrap) {
            this.focusTrap.deactivate(Object.assign({ returnFocus: true, checkCanReturnFocus: (trigger) => new Promise((resolve) => {
                    if (typeof (trigger === null || trigger === void 0 ? void 0 : trigger.setFocus) === 'function') {
                        trigger.setFocus();
                    }
                    else {
                        resolve(); // node.focus(); will be called by focus-trap
                    }
                }) }, deactivateOptions));
            this.focusTrap = undefined;
        }
        return Promise.resolve();
    }
    connectedCallback() {
        this.connectedCallbackTimeout = setTimeout(() => {
            /**
             * Emit a dialogLoaded event when the component connects. Need this so
             * the context manager isn't rummaging around it's DOM to try and find the
             * dialog that was just appended
             */
            this.marketDialogLoaded.emit({
                dialog: this.el,
                type: this.type,
            });
            if (this.trapFocus) {
                this.activateFocusTrap();
            }
        }, this.animationEnterDuration);
    }
    componentWillLoad() {
        setupDialogCompactHandler(this.el);
    }
    disconnectedCallback() {
        this.deactivateFocusTrap();
        /**
         * Prevents error caused by race conditions during rapid mounting and
         * unmounting of component by clearing the setTimeout from connectedCallback
         * if it gets called after disconnectedCallback.
         */
        clearTimeout(this.connectedCallbackTimeout);
    }
    render() {
        return (hAsync(Host, { key: '3230415c4df282cc7e8d956fffdb01cdff152372', class: "market-modal-partial", role: "dialog" }, hAsync("slot", { key: 'd028733389b598ad8db15899e92a589ce3010cff' })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "trapFocus": ["onTrapFocusChanged"]
    }; }
    static get style() { return MarketModalPartialStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-modal-partial",
        "$members$": {
            "hidden": [1540],
            "dialogID": [513, "data-dialog-id"],
            "index": [514, "data-dialog-index"],
            "trapFocus": [1028, "trap-focus"],
            "animationEnterDuration": [2, "animation-enter-duration"],
            "animationExitDuration": [2, "animation-exit-duration"],
            "dismiss": [64],
            "activateFocusTrap": [64],
            "deactivateFocusTrap": [64]
        },
        "$listeners$": [[0, "marketHeaderNavigate", "headerNavigateEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"], ["dialogID", "data-dialog-id"], ["index", "data-dialog-index"]]
    }; }
}

const marketPaginationCss = "/*!@:host*/.sc-market-pagination-h{display:flex;flex-direction:column;align-items:stretch}/*!@.market-button-dropdown*/.market-button-dropdown.sc-market-pagination{display:flex;flex-direction:column;align-items:stretch}/*!@.market-button-dropdown .market-filter-button*/.market-button-dropdown.sc-market-pagination .market-filter-button.sc-market-pagination{display:block}/*!@.market-pagination-page-size + .market-pagination-nav*/.market-pagination-page-size.sc-market-pagination+.market-pagination-nav.sc-market-pagination{margin-top:var(--pagination-nav-vertical-margin)}@media only screen and (min-width: 600px){/*!@.market-pagination-page-size + .market-pagination-nav*/.market-pagination-page-size.sc-market-pagination+.market-pagination-nav.sc-market-pagination{margin-top:0;margin-left:var(--pagination-nav-horizontal-margin)}}/*!@.market-pagination-nav nav*/.market-pagination-nav.sc-market-pagination nav.sc-market-pagination{display:flex;justify-content:space-between;-moz-column-gap:var(--pagination-nav-content-spacing);column-gap:var(--pagination-nav-content-spacing)}/*!@.market-pagination-nav nav .market-button-dropdown*/.market-pagination-nav.sc-market-pagination nav.sc-market-pagination .market-button-dropdown.sc-market-pagination{flex-grow:1}@media only screen and (min-width: 600px){/*!@:host*/.sc-market-pagination-h{flex-direction:row;justify-content:space-between}/*!@.market-pagination-nav:only-child*/.market-pagination-nav.sc-market-pagination:only-child{margin-left:auto}}";
var MarketPaginationStyle0 = marketPaginationCss;

/**
 * @slot page-size-label - localized string to label the page size dropdown (defaults to English "Results per page")
 * @slot page-size-feedback - localized string to label the current page size (defaults to value of {this.pageSize})
 * @slot nav-label - localized string to label the page dropdown (defaults to English "Page")
 * @slot nav-feedback - localized string to label the current page of total pages
 *      (defaults to English "{this.currentPage} of {this.totalPages}").
 *      The #s for current page/total pages need to be passed in as part of the string.
 */
class MarketPagination {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketPaginationPageSizeChange = createEvent(this, "marketPaginationPageSizeChange", 7);
        this.marketPaginationNavigation = createEvent(this, "marketPaginationNavigation", 7);
        this.currentPage = undefined;
        this.disabled = false;
        this.totalPages = undefined;
        this.hasNextPage = undefined;
        this.hasPreviousPage = undefined;
        this.pageSize = undefined;
        this.pageSizeOptions = undefined;
    }
    /**
     * Rebroadcast up events from market-pagination-page-size.
     */
    changePageSize(e) {
        e.stopPropagation();
        const { detail } = e;
        this.marketPaginationPageSizeChange.emit(detail);
    }
    /**
     * Rebroadcast up events from market-pagination-nav.
     */
    navigatePage(e) {
        e.stopPropagation();
        const { detail } = e;
        this.marketPaginationNavigation.emit(detail);
    }
    render() {
        const MarketPaginationPageSizeTagName = getNamespacedTagFor('market-pagination-page-size');
        const MarketPaginationNavTagName = getNamespacedTagFor('market-pagination-nav');
        return (hAsync(Host, { key: '886ec957c0100e5ab77ae0f4782f44f145af5be6', class: "market-pagination" }, this.pageSizeOptions && (hAsync(MarketPaginationPageSizeTagName, { key: '5d22ac9b0db9bbba524cfef95d395177d7347b90', value: this.pageSize, pageSizeOptions: this.pageSizeOptions, disabled: this.disabled }, hAsync("slot", { key: 'a805b0072497159fe497617180886acafbeebd9f', name: "page-size-label", slot: "page-size-label" }, "Results per page"), hAsync("slot", { key: '172de2942561a2bbeac01adb45868f5268487403', name: "page-size-feedback", slot: "page-size-feedback" }, this.pageSize))), hAsync(MarketPaginationNavTagName, { key: '8a0229a3ea449e7aaf46af514a0907ce64ed1621', currentPage: this.currentPage, disabled: this.disabled, totalPages: this.totalPages, pageSize: this.pageSize, hasNextPage: this.hasNextPage, hasPreviousPage: this.hasPreviousPage }, hAsync("slot", { key: '36f5e388f866816f8305f73cf8e5f47b7e5ad43b', name: "nav-label", slot: "nav-label" }, "Page"), hAsync("slot", { key: '6e3a4e3957f624982b952d76a89dd94ff02e51a8', name: "nav-feedback", slot: "nav-feedback" }, this.currentPage, " of ", this.totalPages))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketPaginationStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-pagination",
        "$members$": {
            "currentPage": [2, "current-page"],
            "disabled": [516],
            "totalPages": [2, "total-pages"],
            "hasNextPage": [4, "has-next-page"],
            "hasPreviousPage": [4, "has-previous-page"],
            "pageSize": [1, "page-size"],
            "pageSizeOptions": [1, "page-size-options"]
        },
        "$listeners$": [[0, "marketInternalPaginationPageSizeChange", "changePageSize"], [0, "marketInternalPaginationNavigation", "navigatePage"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"]]
    }; }
}

class MarketPaginationNav {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketInternalPaginationNavigation = createEvent(this, "marketInternalPaginationNavigation", 7);
        this.currentPage = undefined;
        this.disabled = false;
        this.totalPages = undefined;
        this.hasNextPage = undefined;
        this.hasPreviousPage = undefined;
        this.pageSize = undefined;
    }
    listSelectionEventHandler(e) {
        const { newSelectionValue } = e.detail;
        this.marketInternalPaginationNavigation.emit({
            page: newSelectionValue,
            prevPage: `${this.currentPage}`,
            pageSize: this.pageSize,
        });
    }
    handlePrev() {
        if (this.hasPreviousPage === false || this.currentPage === 1) {
            return;
        }
        const prevPage = this.currentPage - 1;
        this.marketInternalPaginationNavigation.emit({
            page: `${prevPage}`,
            prevPage: `${this.currentPage}`,
            pageSize: this.pageSize,
        });
    }
    handleNext() {
        if (this.hasNextPage === false || (Boolean(this.totalPages) && this.currentPage === this.totalPages)) {
            return;
        }
        const nextPage = this.currentPage + 1;
        this.marketInternalPaginationNavigation.emit({
            page: `${nextPage}`,
            prevPage: `${this.currentPage}`,
            pageSize: this.pageSize,
        });
    }
    /**
     * Dropdown navigates by every 10 pages if there are more than 20 pages
     *
     * pageList for a large dataset = [10, 20, 30, 40, 50...]
     * pageList for a small dataset = [1, 2, 3, 5, 6, 7...]
     */
    get pageList() {
        const isLargeDataset = this.totalPages > 20;
        const largeDatasetSteps = 10;
        return isLargeDataset
            ? Array.from({ length: Math.floor(this.totalPages / largeDatasetSteps) }).map((_, i) => (i + 1) * largeDatasetSteps)
            : Array.from({ length: this.totalPages }).map((_, i) => i + 1);
    }
    render() {
        // Don't render page info when totalPages is missing or set to 0
        const renderPageInfo = Boolean(this.totalPages);
        const hasPreviousPage = this.currentPage > 1 || this.hasPreviousPage;
        const hasNextPage = this.currentPage < this.totalPages || this.hasNextPage;
        const MarketButtonTagName = getNamespacedTagFor('market-button');
        const MarketButtonDropdownTagName = getNamespacedTagFor('market-button-dropdown');
        const MarketFilterButtonTagName = getNamespacedTagFor('market-filter-button');
        const MarketListTagName = getNamespacedTagFor('market-list');
        const MarketRowTagName = getNamespacedTagFor('market-row');
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        return (hAsync(Host, { key: '1a1b08b672af0d218bfefd4224a55c28370f0b03', class: "market-pagination-nav" }, hAsync("nav", { key: '11e5fe0adc8bf825845d771a5a80c770b9e82859' }, hAsync(MarketButtonTagName, { key: '8b8de9d551c9931a8d055a61d4e040cddc161f81', size: "small", disabled: this.disabled || !hasPreviousPage, onClick: () => this.handlePrev() }, hAsync(MarketAccessoryTagName, { key: 'd68f8220c3e1d024382d34c25881bd2f147ae906', slot: "icon" }, hAsync("svg", { key: '3aa918aba8eb5108d81f6351284ad362c658af23', width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '362cea388001d27fe0761c2a1b2b8320dce857f5', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M4.29289 11.293C3.90237 11.6835 3.90237 12.3167 4.29289 12.7072L11.2929 19.7072L12.7071 18.293L7.41421 13.0001L19 13.0001V11.0001L7.41421 11.0001L12.7071 5.70718L11.2929 4.29297L4.29289 11.293Z" })))), renderPageInfo && (hAsync(MarketButtonDropdownTagName, { key: 'd161fc23d7ba148dbd353aeca60db66d6233b7fd', disabled: this.disabled, "no-caret": true, "popover-placement": "bottom-end", "persist-list": true }, hAsync(MarketFilterButtonTagName, { key: '9712f794d647f0769475b4109cc0ed0cb189fcc5', size: "small", slot: "trigger" }, hAsync("span", { key: '826ed87de74d5abecaf2e3ad07881ac975a92051' }, hAsync("slot", { key: '88ef338eaab4470e25e70a9d9b4c2833052c1fc3', name: "nav-label" }, "Page")), hAsync("span", { key: 'c9fca87a76e1203abb26bfb9ca80200dc5136bae', slot: "feedback" }, hAsync("slot", { key: '1d6207b2b3ce4995674d57dfa43d5232a16d95e4', name: "nav-feedback" }, this.currentPage, " of ", this.totalPages))), hAsync(MarketListTagName, { key: 'c04b1964074e1ddad685664ce1c4b80f8650586c', slot: "content" }, this.pageList.map((pageNum) => (hAsync(MarketRowTagName, { key: `pageNav_${pageNum}`, selected: this.currentPage === pageNum, value: `${pageNum}` }, pageNum)))))), hAsync(MarketButtonTagName, { key: '991e53ad933bd431aa3d33480a778927c8477ff0', size: "small", disabled: this.disabled || !hasNextPage, onClick: () => this.handleNext() }, hAsync(MarketAccessoryTagName, { key: '7933bfbed07cb4d488fba7c54b68455b00971d2e', slot: "icon" }, hAsync("svg", { key: '77d87ca20e25596108f752b0d13ed49bac34d441', width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '5536170797743ed022842af94a2be00fecabb58a', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M19.7071 11.293C20.0976 11.6835 20.0976 12.3167 19.7071 12.7072L12.7071 19.7072L11.2929 18.293L16.5858 13.0001L5 13.0001L5 11.0001L16.5858 11.0001L11.2929 5.70718L12.7071 4.29297L19.7071 11.293Z" })))))));
    }
    get el() { return getElement(this); }
    static get cmpMeta() { return {
        "$flags$": 4,
        "$tagName$": "market-pagination-nav",
        "$members$": {
            "currentPage": [2, "current-page"],
            "disabled": [516],
            "totalPages": [2, "total-pages"],
            "hasNextPage": [4, "has-next-page"],
            "hasPreviousPage": [4, "has-previous-page"],
            "pageSize": [1, "page-size"]
        },
        "$listeners$": [[0, "marketListSelectionsDidChange", "listSelectionEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"]]
    }; }
}

class MarketPaginationPageSize {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketInternalPaginationPageSizeChange = createEvent(this, "marketInternalPaginationPageSizeChange", 7);
        this.disabled = false;
        this.value = undefined;
        this.pageSizeOptions = undefined;
    }
    listSelectionEventHander(e) {
        const { newSelectionValue } = e.detail;
        this.marketInternalPaginationPageSizeChange.emit({
            value: newSelectionValue,
        });
    }
    render() {
        const MarketButtonDropdownTagName = getNamespacedTagFor('market-button-dropdown');
        const MarketFilterButtonTagName = getNamespacedTagFor('market-filter-button');
        const MarketListTagName = getNamespacedTagFor('market-list');
        const MarketRowTagName = getNamespacedTagFor('market-row');
        return (hAsync(Host, { key: 'c4511320fe668bb5e065a8f51957f819608757fa', class: "market-pagination-page-size" }, hAsync(MarketButtonDropdownTagName, { key: '289fe7e37f92932ee31a5ade32092fbeb4ffd4a4', "no-caret": true, "popover-placement": "bottom-start", "persist-list": true, disabled: this.disabled }, hAsync(MarketFilterButtonTagName, { key: '5f460172c2a650868946c795409161ca67238764', size: "small", slot: "trigger" }, hAsync("span", { key: 'dd8d9faa460a3eec20671666790e6baff9bc03f0' }, hAsync("slot", { key: '7d117121d9138aaf9950aecbc81f3965b6a3be7f', name: "page-size-label" }, "Results per page")), hAsync("span", { key: 'd0bdaa3b315b6b4b13536e57f6b268aa31b5a986', slot: "feedback" }, hAsync("slot", { key: '38f004fbb2b31bb0f0253b8c93fb161de4e08301', name: "page-size-feedback" }, this.value))), hAsync(MarketListTagName, { key: '51673197836c462aa9dee75c3d27fbe376a49d9f', value: this.value, slot: "content" }, this.pageSizeOptions.split(',').map((v) => (hAsync(MarketRowTagName, { key: `pageSize_${v}`, value: v }, v)))))));
    }
    get el() { return getElement(this); }
    static get cmpMeta() { return {
        "$flags$": 4,
        "$tagName$": "market-pagination-page-size",
        "$members$": {
            "disabled": [516],
            "value": [1],
            "pageSizeOptions": [1, "page-size-options"]
        },
        "$listeners$": [[0, "marketListSelectionsDidChange", "listSelectionEventHander"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"]]
    }; }
}

const marketPillCss = "/*!@:host, ::slotted(*), **/.sc-market-pill-h,.sc-market-pill-s>*,*.sc-market-pill{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-pill-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-pill-h *.sc-market-pill,.sc-market-pill-h[disabled].sc-market-pill-s>*,.sc-market-pill-h[disabled] .sc-market-pill-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-pill-h{display:inline-flex;justify-content:center;align-items:center;border-radius:var(--pill-normal-size-corner-radius);white-space:nowrap}/*!@:host svg, :host ::slotted([slot=\"icon\"])*/.sc-market-pill-h svg.sc-market-pill,.sc-market-pill-h.sc-market-pill-s>[slot=\"icon\"],.sc-market-pill-h .sc-market-pill-s>[slot=\"icon\"]{color:inherit;fill:currentcolor;stroke:inherit}/*!@:host([interactive])*/[interactive].sc-market-pill-h{cursor:pointer}/*!@:host([size=\"medium\"])*/[size=\"medium\"].sc-market-pill-h{gap:var(--pill-normal-size-spacing-horizontal);padding:var(--pill-normal-size-padding-vertical-size) var(--pill-normal-size-padding-horizontal-size);font-weight:var(--pill-normal-size-text-weight);font-size:var(--pill-normal-size-text-size);line-height:var(--pill-normal-size-text-leading);letter-spacing:var(--pill-normal-size-text-tracking)}/*!@:host([size=\"small\"])*/[size=\"small\"].sc-market-pill-h{gap:var(--pill-compact-size-spacing-horizontal);padding:var(--pill-compact-size-padding-vertical-size) var(--pill-compact-size-padding-horizontal-size);font-weight:var(--pill-compact-size-text-weight);font-size:var(--pill-compact-size-text-size);line-height:var(--pill-compact-size-text-leading);letter-spacing:var(--pill-compact-size-text-tracking)}/*!@:host([variant=\"normal\"])*/[variant=\"normal\"].sc-market-pill-h{background-color:var(--pill-normal-variant-background-color);color:var(--pill-normal-variant-text-color)}/*!@:host([variant=\"emphasis\"])*/[variant=\"emphasis\"].sc-market-pill-h{background-color:var(--pill-emphasis-variant-background-color);color:var(--pill-emphasis-variant-text-color)}/*!@:host([variant=\"success\"])*/[variant=\"success\"].sc-market-pill-h{background-color:var(--pill-success-variant-background-color);color:var(--pill-success-variant-text-color)}/*!@:host([variant=\"warning\"])*/[variant=\"warning\"].sc-market-pill-h{background-color:var(--pill-warning-variant-background-color);color:var(--pill-warning-variant-text-color)}/*!@:host([variant=\"critical\"])*/[variant=\"critical\"].sc-market-pill-h{background-color:var(--pill-critical-variant-background-color);color:var(--pill-critical-variant-text-color)}/*!@:host([variant=\"insight\"])*/[variant=\"insight\"].sc-market-pill-h{background-color:var(--pill-insight-variant-background-color);color:var(--pill-insight-variant-text-color)}/*!@:host([variant=\"alpha\"])*/[variant=\"alpha\"].sc-market-pill-h{background-color:var(--pill-alpha-variant-background-color);color:var(--pill-alpha-variant-text-color)}/*!@:host([variant=\"beta\"])*/[variant=\"beta\"].sc-market-pill-h{background-color:var(--pill-beta-variant-background-color);color:var(--pill-beta-variant-text-color)}@media (hover: hover){/*!@:host([variant=\"normal\"][interactive]:hover)*/[variant=\"normal\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-normal-variant-pressed-state-background-color)}/*!@:host([variant=\"emphasis\"][interactive]:hover)*/[variant=\"emphasis\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-emphasis-variant-pressed-state-background-color)}/*!@:host([variant=\"success\"][interactive]:hover)*/[variant=\"success\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-success-variant-pressed-state-background-color)}/*!@:host([variant=\"warning\"][interactive]:hover)*/[variant=\"warning\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-warning-variant-pressed-state-background-color)}/*!@:host([variant=\"critical\"][interactive]:hover)*/[variant=\"critical\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-critical-variant-pressed-state-background-color)}/*!@:host([variant=\"insight\"][interactive]:hover)*/[variant=\"insight\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-insight-variant-pressed-state-background-color)}/*!@:host([variant=\"alpha\"][interactive]:hover)*/[variant=\"alpha\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-alpha-variant-pressed-state-background-color)}/*!@:host([variant=\"beta\"][interactive]:hover)*/[variant=\"beta\"][interactive].sc-market-pill-h:hover{background-color:var(--pill-beta-variant-pressed-state-background-color)}}/*!@:host([variant=\"normal\"][interactive]:active)*/[variant=\"normal\"][interactive].sc-market-pill-h:active{background-color:var(--pill-normal-variant-pressed-state-background-color)}/*!@:host([variant=\"emphasis\"][interactive]:active)*/[variant=\"emphasis\"][interactive].sc-market-pill-h:active{background-color:var(--pill-emphasis-variant-pressed-state-background-color)}/*!@:host([variant=\"success\"][interactive]:active)*/[variant=\"success\"][interactive].sc-market-pill-h:active{background-color:var(--pill-success-variant-pressed-state-background-color)}/*!@:host([variant=\"warning\"][interactive]:active)*/[variant=\"warning\"][interactive].sc-market-pill-h:active{background-color:var(--pill-warning-variant-pressed-state-background-color)}/*!@:host([variant=\"critical\"][interactive]:active)*/[variant=\"critical\"][interactive].sc-market-pill-h:active{background-color:var(--pill-critical-variant-pressed-state-background-color)}/*!@:host([variant=\"insight\"][interactive]:active)*/[variant=\"insight\"][interactive].sc-market-pill-h:active{background-color:var(--pill-insight-variant-pressed-state-background-color)}/*!@:host([variant=\"alpha\"][interactive]:active)*/[variant=\"alpha\"][interactive].sc-market-pill-h:active{background-color:var(--pill-alpha-variant-pressed-state-background-color)}/*!@:host([variant=\"beta\"][interactive]:active)*/[variant=\"beta\"][interactive].sc-market-pill-h:active{background-color:var(--pill-beta-variant-pressed-state-background-color)}";
var MarketPillStyle0 = marketPillCss;

class MarketPill {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.variant = 'normal';
        this.size = 'medium';
        this.indicator = false;
        this.interactive = false;
    }
    renderIndicator() {
        const MarketAccessoryTag = getNamespacedTagFor('market-accessory');
        return this.size === 'medium' ? (hAsync(MarketAccessoryTag, null, hAsync("svg", { width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, hAsync("circle", { cx: "8", cy: "8", r: "5" })))) : (hAsync(MarketAccessoryTag, null, hAsync("svg", { width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, hAsync("circle", { cx: "8", cy: "8", r: "4" }))));
    }
    render() {
        return (hAsync(Host, { key: 'e96bb6d40d9226db752a3934a88d04b5c5aa0cac', class: "market-pill" }, hAsync("slot", { key: 'b1116a3e6fe9360b141f98c69c376ec2aea519f8', name: "icon" }, this.indicator && this.renderIndicator()), hAsync("slot", { key: '4b50c149d4029c6847887127815d6146ce32a380' })));
    }
    static get style() { return MarketPillStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-pill",
        "$members$": {
            "variant": [513],
            "size": [513],
            "indicator": [516],
            "interactive": [516]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["variant", "variant"], ["size", "size"], ["indicator", "indicator"], ["interactive", "interactive"]]
    }; }
}

const marketProgressTrackerCss = "/*!@:host, ::slotted(*), **/.sc-market-progress-tracker-h,.sc-market-progress-tracker-s>*,*.sc-market-progress-tracker{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-progress-tracker-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-progress-tracker-h *.sc-market-progress-tracker,.sc-market-progress-tracker-h[disabled].sc-market-progress-tracker-s>*,.sc-market-progress-tracker-h[disabled] .sc-market-progress-tracker-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-progress-tracker-h{display:flex;flex-direction:column;margin:0;padding:0;list-style:none}/*!@:host([orientation=\"horizontal\"])*/[orientation=\"horizontal\"].sc-market-progress-tracker-h{flex-direction:row}/*!@:host([orientation=\"horizontal\"][size=\"small\"]:not([compact]):not([interactive]))*/[orientation=\"horizontal\"][size=\"small\"].sc-market-progress-tracker-h:not([compact]):not([interactive]){gap:var(--tracker-horizontal-orientation-connectors-density-small-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"medium\"]:not([compact]):not([interactive]))*/[orientation=\"horizontal\"][size=\"medium\"].sc-market-progress-tracker-h:not([compact]):not([interactive]){gap:var(--tracker-horizontal-orientation-connectors-density-medium-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"large\"]:not([compact]):not([interactive]))*/[orientation=\"horizontal\"][size=\"large\"].sc-market-progress-tracker-h:not([compact]):not([interactive]){gap:var(--tracker-horizontal-orientation-connectors-density-large-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"small\"][compact]:not([interactive]))*/[orientation=\"horizontal\"][size=\"small\"][compact].sc-market-progress-tracker-h:not([interactive]){gap:var(--tracker-horizontal-orientation-compact-density-small-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"medium\"][compact]:not([interactive]))*/[orientation=\"horizontal\"][size=\"medium\"][compact].sc-market-progress-tracker-h:not([interactive]){gap:var(--tracker-horizontal-orientation-compact-density-medium-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"large\"][compact]:not([interactive]))*/[orientation=\"horizontal\"][size=\"large\"][compact].sc-market-progress-tracker-h:not([interactive]){gap:var(--tracker-horizontal-orientation-compact-density-large-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][compact][interactive])*/[orientation=\"horizontal\"][compact][interactive].sc-market-progress-tracker-h{gap:0}";
var MarketProgressTrackerStyle0 = marketProgressTrackerCss;

/**
 * @slot - Default slot, intended to be slotted with `<market-progress-tracker-step>`s
 */
class MarketProgressTracker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.compact = false;
        this.connectorless = false;
        this.currentStepIndex = undefined;
        this.indicator = undefined;
        this.interactive = false;
        this.orientation = 'vertical';
        this.reversed = false;
        this.size = 'medium';
    }
    marketProgressTrackerStepClickEventHandler(event) {
        const { defaultPrevented, detail: { index }, } = event;
        // state will be updated only if `currentStepIndex` is defined
        if (!defaultPrevented && this.currentStepIndex !== undefined) {
            this.currentStepIndex = index;
        }
    }
    currentStepIndexWatcher() {
        this.updateStepState();
    }
    reversedWatcher() {
        this.updateStepState();
    }
    otherPropsWatcher(newValue, propKey) {
        this.propagatePropsToSteps({ [propKey]: newValue });
    }
    get stepEls() {
        return [...this.el.children].filter((childEl) => isElementWithTagName(childEl, 'market-progress-tracker-step'));
    }
    updateStepState() {
        var _a;
        const { connectorless, currentStepIndex, reversed, stepEls } = this;
        const orderedSteps = reversed ? [...stepEls].reverse() : stepEls; // logical order
        // set `data-step-index` based on logical order
        orderedSteps.forEach((stepEl, index) => {
            stepEl.dataset.stepIndex = `${index}`;
        });
        // automatically updates steps `completed` and `active` states if `currentStepIndex` is defined
        if (currentStepIndex !== undefined) {
            orderedSteps.forEach((stepEl, index) => {
                stepEl.completed = index < currentStepIndex;
                stepEl.active = index === currentStepIndex;
            });
        }
        const activeIndex = (_a = currentStepIndex !== null && currentStepIndex !== void 0 ? currentStepIndex : orderedSteps.findIndex((stepEl) => stepEl.active)) !== null && _a !== void 0 ? _a : -1;
        stepEls.forEach((stepEl, index) => {
            if (index < stepEls.length - 1) {
                if (connectorless) {
                    stepEl.connector = null;
                }
                else if ((reversed && index >= stepEls.length - activeIndex - 1) || (!reversed && index < activeIndex)) {
                    stepEl.connector = 'active';
                }
                else {
                    stepEl.connector = 'inactive';
                }
            }
            else {
                /**
                 * visually hides the last items connector:
                 *  - null:   progress tracker is connectorless
                 *  - hidden: progress tracker has connectors, but only the last steps connector is hidden
                 * note that this has styling implications
                 */
                stepEl.connector = connectorless ? null : 'hidden';
            }
        });
    }
    /**
     * Updates the steps props based on the provided prop-value pair(s)
     */
    propagatePropsToSteps(propValues) {
        this.stepEls.forEach((stepEl) => {
            var _a, _b, _c, _d, _e;
            stepEl.compact = (_a = propValues === null || propValues === void 0 ? void 0 : propValues.compact) !== null && _a !== void 0 ? _a : stepEl.compact;
            stepEl.indicator = (_b = propValues === null || propValues === void 0 ? void 0 : propValues.indicator) !== null && _b !== void 0 ? _b : stepEl.indicator;
            stepEl.interactive = (_c = propValues === null || propValues === void 0 ? void 0 : propValues.interactive) !== null && _c !== void 0 ? _c : stepEl.interactive;
            stepEl.orientation = (_d = propValues === null || propValues === void 0 ? void 0 : propValues.orientation) !== null && _d !== void 0 ? _d : stepEl.orientation;
            stepEl.size = (_e = propValues === null || propValues === void 0 ? void 0 : propValues.size) !== null && _e !== void 0 ? _e : stepEl.size;
        });
    }
    handleDefaultSlotChange() {
        this.propagatePropsToSteps(pick$1(this, 'compact', 'indicator', 'interactive', 'orientation', 'size'));
        this.updateStepState();
    }
    connectedCallback() {
        this.propagatePropsToSteps(pick$1(this, 'compact', 'indicator', 'interactive', 'orientation', 'size'));
        this.updateStepState();
    }
    render() {
        const { handleDefaultSlotChange, interactive } = this;
        return (hAsync(Host, { key: '6641d3c058d83c786d2666dfce3992da9d3ef13c', class: "market-progress-tracker", role: interactive ? 'tablist' : 'list' }, hAsync("slot", { key: '531a425b494e0a91a5845da60b4a155b9eccdc86', onSlotchange: handleDefaultSlotChange.bind(this) })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "currentStepIndex": ["currentStepIndexWatcher"],
        "reversed": ["reversedWatcher"],
        "compact": ["otherPropsWatcher"],
        "indicator": ["otherPropsWatcher"],
        "interactive": ["otherPropsWatcher"],
        "orientation": ["otherPropsWatcher"],
        "size": ["otherPropsWatcher"]
    }; }
    static get style() { return MarketProgressTrackerStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-progress-tracker",
        "$members$": {
            "compact": [4],
            "connectorless": [4],
            "currentStepIndex": [1538, "current-step-index"],
            "indicator": [1],
            "interactive": [4],
            "orientation": [1],
            "reversed": [4],
            "size": [513]
        },
        "$listeners$": [[0, "marketProgressTrackerStepClick", "marketProgressTrackerStepClickEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["currentStepIndex", "current-step-index"], ["size", "size"]]
    }; }
}

const checkedIcon = () => (hAsync("svg", { class: "default-icon checked-icon", width: "18", height: "18", viewBox: "0 0 18 18", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { d: "M5.88683 7.62327L5.71005 7.4465L5.53327 7.62327L4.12327 9.03327L3.9465 9.21005L4.12327 9.38683L7.12327 12.3868C7.37411 12.6377 7.68955 12.75 8.01005 12.75C8.33627 12.75 8.64735 12.6239 8.89224 12.3913L8.89229 12.3914L8.89683 12.3868L13.8968 7.38683L14.0736 7.21005L13.8968 7.03327L12.4868 5.62327L12.3105 5.44691L12.1337 5.62286L8.00046 9.73691L5.88683 7.62327ZM0.25 9C0.25 4.16807 4.16807 0.25 9 0.25C13.8319 0.25 17.75 4.16807 17.75 9C17.75 13.8319 13.8319 17.75 9 17.75C4.16807 17.75 0.25 13.8319 0.25 9Z" })));
const uncheckedIcon = () => (hAsync("svg", { class: "default-icon unchecked-icon", width: "18", height: "18", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M9 16C12.866 16 16 12.866 16 9C16 5.13401 12.866 2 9 2C5.13401 2 2 5.13401 2 9C2 12.866 5.13401 16 9 16ZM9 18C13.9706 18 18 13.9706 18 9C18 4.02944 13.9706 0 9 0C4.02944 0 0 4.02944 0 9C0 13.9706 4.02944 18 9 18Z" })));
const smallerCheckedIcon = () => (hAsync("svg", { class: "default-icon small-checked-icon", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0 8C0 3.58222 3.58222 0 8 0C12.4178 0 16 3.58222 16 8C16 12.4178 12.4178 16 8 16C3.58222 16 0 12.4178 0 8ZM5.0756 6.93338L7.11115 8.96893L10.9423 5.1556L12.1956 6.40893L7.75116 10.8534C7.57338 11.0223 7.35115 11.1112 7.12004 11.1112C6.88893 11.1112 6.66671 11.0312 6.48893 10.8534L3.82227 8.18671L5.0756 6.93338Z" })));
const smallerUncheckedIcon = () => (hAsync("svg", { class: "default-icon small-unchecked-icon", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8 14.2222C11.4364 14.2222 14.2222 11.4364 14.2222 8C14.2222 4.56356 11.4364 1.77778 8 1.77778C4.56356 1.77778 1.77778 4.56356 1.77778 8C1.77778 11.4364 4.56356 14.2222 8 14.2222ZM8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16Z" })));
const activeCircleIcon = () => (hAsync("svg", { class: "default-icon active-circle-icon", width: "18", height: "18", viewBox: "0 0 18 18", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("circle", { cx: "9", cy: "9", r: "7", "stroke-width": "4" })));
const inactiveCircleIcon = () => (hAsync("svg", { class: "default-icon inactive-circle-icon", width: "8", height: "8", viewBox: "0 0 8 8", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("path", { d: "M0 4a4 4 0 1 0 8 0a4 4 0 1 0 -8 0" })));
const smallerActiveCircleIcon = () => (hAsync("svg", { class: "default-icon small-active-circle-icon", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("circle", { cx: "8", cy: "8", r: "6", "stroke-opacity": "0.9", "stroke-width": "4" })));
const smallerInactiveCircleIcon = () => (hAsync("svg", { class: "default-icon small-inactive-circle-icon", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" },
    hAsync("circle", { cx: "8", cy: "8", r: "4" })));
function getIcon({ active, completed, indicator, orientation, }) {
    if (orientation === 'vertical') {
        if (indicator === 'check') {
            if (completed) {
                return checkedIcon();
            }
            else {
                return uncheckedIcon();
            }
        }
        else if (indicator === 'circle') {
            if (active) {
                return activeCircleIcon();
            }
            else {
                return inactiveCircleIcon();
            }
        }
    }
    else if (orientation === 'horizontal') {
        if (indicator === 'check') {
            if (completed) {
                return smallerCheckedIcon();
            }
            else {
                return smallerUncheckedIcon();
            }
        }
        else if (indicator === 'circle') {
            if (active) {
                return smallerActiveCircleIcon();
            }
            else {
                return smallerInactiveCircleIcon();
            }
        }
    }
    return undefined;
}

const marketProgressTrackerStepCss = "/*!@:host, ::slotted(*), **/.sc-market-progress-tracker-step-h,.sc-market-progress-tracker-step-s>*,*.sc-market-progress-tracker-step{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-progress-tracker-step-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-progress-tracker-step-h *.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h[disabled].sc-market-progress-tracker-step-s>*,.sc-market-progress-tracker-step-h[disabled] .sc-market-progress-tracker-step-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host([orientation=\"horizontal\"][size=\"large\"]) ::slotted([slot=\"label\"]), :host([orientation=\"vertical\"][size=\"large\"]) ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"horizontal\"][size=\"large\"] .sc-market-progress-tracker-step-s>[slot=\"label\"],.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"large\"].sc-market-progress-tracker-step-s>[slot=\"label\"],.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"large\"] .sc-market-progress-tracker-step-s>[slot=\"label\"]{font-weight:var(--core-type-heading-20-weight);font-size:var(--core-type-heading-20-size);font-family:var(--core-type-heading-20-font-family);line-height:var(--core-type-heading-20-leading);letter-spacing:var(--core-type-heading-20-tracking);text-transform:var(--core-type-heading-20-case)}/*!@::slotted([slot=\"subtext\"])*/.sc-market-progress-tracker-step-s>[slot=\"subtext\"]{font-weight:var(--core-type-paragraph-10-weight);font-size:var(--core-type-paragraph-10-size);font-family:var(--core-type-paragraph-10-font-family);line-height:var(--core-type-paragraph-10-leading);letter-spacing:var(--core-type-paragraph-10-tracking);text-transform:var(--core-type-paragraph-10-case)}/*!@::slotted([slot=\"subtext\"]) b, ::slotted([slot=\"subtext\"]) strong*/.sc-market-progress-tracker-step-s>[slot=\"subtext\"] b,.sc-market-progress-tracker-step-s>[slot=\"subtext\"] strong{font-weight:var(--core-type-semibold-10-weight)}/*!@:host([orientation=\"vertical\"][size=\"small\"]) ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"small\"] .sc-market-progress-tracker-step-s>[slot=\"label\"]{font-weight:var(--core-type-medium-20-weight);font-size:var(--core-type-medium-20-size);font-family:var(--core-type-medium-20-font-family);line-height:var(--core-type-medium-20-leading);letter-spacing:var(--core-type-medium-20-tracking);text-transform:var(--core-type-medium-20-case)}/*!@:host([orientation=\"horizontal\"][size=\"small\"]) ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"horizontal\"][size=\"small\"] .sc-market-progress-tracker-step-s>[slot=\"label\"]{font-weight:var(--core-type-semibold-10-weight);font-size:var(--core-type-semibold-10-size);font-family:var(--core-type-semibold-10-font-family);line-height:var(--core-type-semibold-10-leading);letter-spacing:var(--core-type-semibold-10-tracking);text-transform:var(--core-type-semibold-10-case)}/*!@:host([orientation=\"horizontal\"][size=\"medium\"]) ::slotted([slot=\"label\"]), :host([orientation=\"vertical\"][size=\"medium\"]) ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"horizontal\"][size=\"medium\"] .sc-market-progress-tracker-step-s>[slot=\"label\"],.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"medium\"].sc-market-progress-tracker-step-s>[slot=\"label\"],.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"medium\"] .sc-market-progress-tracker-step-s>[slot=\"label\"]{font-weight:var(--core-type-semibold-30-weight);font-size:var(--core-type-semibold-30-size);font-family:var(--core-type-semibold-30-font-family);line-height:var(--core-type-semibold-30-leading);letter-spacing:var(--core-type-semibold-30-tracking);text-transform:var(--core-type-semibold-30-case)}/*!@.button, .label*/.button.sc-market-progress-tracker-step,.label.sc-market-progress-tracker-step{display:flex;grid-area:button;gap:var(--progress-tracker-horizontal-label-spacing, var(--core-metrics-spacing-100));border:0;background:transparent;color:inherit}/*!@.button*/.button.sc-market-progress-tracker-step{border-radius:var(--progress-tracker-horizontal-button-border-radius, 6px);cursor:pointer}/*!@.button:active, .button:hover:active*/.button.sc-market-progress-tracker-step:active,.button.sc-market-progress-tracker-step:hover:active{background-color:var(--progress-tracker-horizontal-button-pressed-background-color, var(--core-emphasis-40-color));color:var(--progress-tracker-horizontal-button-pressed-text-color, var(--core-text-10-color))}/*!@.button:focus-visible*/.button.sc-market-progress-tracker-step:focus-visible{outline:var(--core-focus-ring-border-size) solid var(--core-focus-ring-color);outline-offset:var(--core-focus-ring-buffer-size)}/*!@:host([compact]) .button*/[compact].sc-market-progress-tracker-step-h .button.sc-market-progress-tracker-step{padding-right:var(--progress-tracker-horizontal-compact-button-padding-right, var(--core-metrics-spacing-100));padding-left:var(--progress-tracker-horizontal-compact-button-padding-left, var(--core-metrics-spacing-100))}/*!@:host([compact]:not([connector])) .button*/[compact].sc-market-progress-tracker-step-h:not([connector]) .button.sc-market-progress-tracker-step{padding-right:var(--progress-tracker-horizontal-compact-button-padding-right, 6px);padding-left:var(--progress-tracker-horizontal-compact-button-padding-left, 6px)}/*!@:host([compact]:not([connector])) .button:hover, :host([compact]:not([connector])) .button:active, :host([compact]:not([connector])) .button:focus*/[compact].sc-market-progress-tracker-step-h:not([connector]) .button.sc-market-progress-tracker-step:hover,[compact].sc-market-progress-tracker-step-h:not([connector]) .button.sc-market-progress-tracker-step:active,[compact].sc-market-progress-tracker-step-h:not([connector]) .button.sc-market-progress-tracker-step:focus{margin-right:-2px;margin-left:-2px;padding-right:var(--progress-tracker-horizontal-compact-button-padding-right, var(--core-metrics-spacing-100));padding-left:var(--progress-tracker-horizontal-compact-button-padding-left, var(--core-metrics-spacing-100))}/*!@:host([size=\"small\"]:not([compact])) .button*/[size=\"small\"].sc-market-progress-tracker-step-h:not([compact]) .button.sc-market-progress-tracker-step{padding-right:var(--progress-tracker-horizontal-small-size-button-padding-right, var(--core-metrics-spacing-100));padding-left:var(--progress-tracker-horizontal-small-size-button-padding-left, var(--core-metrics-spacing-100))}/*!@:host([size=\"medium\"]:not([compact])) .button*/[size=\"medium\"].sc-market-progress-tracker-step-h:not([compact]) .button.sc-market-progress-tracker-step{padding-right:var(--progress-tracker-horizontal-medium-size-button-padding-right, var(--core-metrics-spacing-150));padding-left:var(--progress-tracker-horizontal-medium-size-button-padding-left, var(--core-metrics-spacing-150))}/*!@:host([size=\"large\"]:not([compact])) .button*/[size=\"large\"].sc-market-progress-tracker-step-h:not([compact]) .button.sc-market-progress-tracker-step{padding-right:var(--progress-tracker-horizontal-large-size-button-padding-right, var(--core-metrics-spacing-200));padding-left:var(--progress-tracker-horizontal-large-size-button-padding-left, var(--core-metrics-spacing-200))}@media (hover: hover){/*!@.button:hover*/.button.sc-market-progress-tracker-step:hover{background-color:var(--progress-tracker-horizontal-button-hover-background-color, var(--core-fill-40-color));color:var(--progress-tracker-horizontal-button-hover-text-color, var(--core-text-10-color))}/*!@.button:active, .button:hover:active*/.button.sc-market-progress-tracker-step:active,.button.sc-market-progress-tracker-step:hover:active{background-color:var(--progress-tracker-horizontal-button-pressed-background-color, var(--core-emphasis-40-color));color:var(--progress-tracker-horizontal-button-pressed-text-color, var(--core-text-10-color))}/*!@:host([compact]:not([connector])) .button*/[compact].sc-market-progress-tracker-step-h:not([connector]) .button.sc-market-progress-tracker-step{z-index:0}/*!@:host([compact]:not([connector])) .button:hover*/[compact].sc-market-progress-tracker-step-h:not([connector]) .button.sc-market-progress-tracker-step:hover{z-index:1;margin-right:-2px;margin-left:-2px;padding-right:var(--progress-tracker-horizontal-compact-button-padding-right, var(--core-metrics-spacing-100));padding-left:var(--progress-tracker-horizontal-compact-button-padding-left, var(--core-metrics-spacing-100))}}/*!@:host([orientation=\"horizontal\"])*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h{--connector-color:var(--progress-tracker-horizontal-connector-color, var(--core-fill-30-color));--connector-radius:var(--progress-tracker-horizontal-connector-radius, var(--divider-radius));--active-connector-color:var(--progress-tracker-horizontal-active-connector-color, var(--core-fill-10-color))}/*!@:host([orientation=\"vertical\"])*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h{--connector-color:var(--progress-tracker-vertical-connector-color, var(--core-fill-30-color));--connector-radius:var(--progress-tracker-vertical-connector-radius, 0);--active-connector-color:var(--progress-tracker-vertical-active-connector-color, var(--core-blue-fill-color))}/*!@:host::after*/.sc-market-progress-tracker-step-h::after{content:\"\";display:none;grid-area:connector;align-self:center;justify-self:center;border-radius:var(--connector-radius);pointer-events:none}/*!@:host([connector=\"inactive\"])::after*/[connector=\"inactive\"].sc-market-progress-tracker-step-h::after{display:flex;background-color:var(--connector-color)}/*!@:host([connector=\"active\"])::after*/[connector=\"active\"].sc-market-progress-tracker-step-h::after{display:flex;background-color:var(--active-connector-color)}/*!@:host([orientation=\"vertical\"])::after*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h::after{width:var(--progress-tracker-vertical-connector-size, 2px);height:100%}/*!@:host([orientation=\"horizontal\"])::after*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h::after{width:100%;height:var(--progress-tracker-horizontal-connector-size, 2px)}/*!@.content*/.content.sc-market-progress-tracker-step{display:flex;flex-shrink:0;flex-direction:column;grid-area:content;align-items:flex-start}/*!@.content ::slotted([slot=\"label\"])*/.content .sc-market-progress-tracker-step-s>[slot=\"label\"]{color:inherit;cursor:inherit}/*!@:host([orientation=\"vertical\"][size=\"small\"]) .content ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"small\"] .content .sc-market-progress-tracker-step-s>[slot=\"label\"]{margin:3px 0 0}/*!@:host([orientation=\"vertical\"][size=\"medium\"]) .content ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"medium\"] .content .sc-market-progress-tracker-step-s>[slot=\"label\"]{margin:2px 0 0}/*!@:host([orientation=\"vertical\"][size=\"large\"]) .content ::slotted([slot=\"label\"])*/.sc-market-progress-tracker-step-h[orientation=\"vertical\"][size=\"large\"] .content .sc-market-progress-tracker-step-s>[slot=\"label\"]{margin:1px 0 0}/*!@.content ::slotted([slot=\"subtext\"])*/.content .sc-market-progress-tracker-step-s>[slot=\"subtext\"]{margin:0;color:var(--progress-tracker-subtext-color, var(--core-text-20-color))}/*!@.content ::slotted(p:first-of-type)*/.content .sc-market-progress-tracker-step-s>p:first-of-type{margin-top:0}/*!@.content ::slotted(p:last-of-type)*/.content .sc-market-progress-tracker-step-s>p:last-of-type{margin-bottom:0}/*!@:host([orientation=\"horizontal\"]) .content*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h .content.sc-market-progress-tracker-step{align-self:center;white-space:nowrap}/*!@:host([orientation=\"horizontal\"]) .content ::slotted(:not([slot=\"icon\"]):not([slot=\"label\"]))*/.sc-market-progress-tracker-step-h[orientation=\"horizontal\"] .content .sc-market-progress-tracker-step-s>:not([slot=\"icon\"]):not([slot=\"label\"]){display:none}/*!@:host([orientation=\"vertical\"]) .content*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h .content.sc-market-progress-tracker-step{gap:var(--progress-tracker-line-spacing, var(--core-metrics-spacing-25));padding-bottom:var(--progress-tracker-content-padding-bottom-size, var(--core-metrics-spacing-200))}/*!@:host([orientation=\"horizontal\"][compact]:not([active])) .content*/[orientation=\"horizontal\"][compact].sc-market-progress-tracker-step-h:not([active]) .content.sc-market-progress-tracker-step{display:none}/*!@:host([orientation=\"horizontal\"]) .content ::slotted(:not([slot=\"label\"]))*/.sc-market-progress-tracker-step-h[orientation=\"horizontal\"] .content .sc-market-progress-tracker-step-s>:not([slot=\"label\"]){display:none}/*!@:host([orientation=\"horizontal\"]:not([active]):not([completed]))*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h:not([active]):not([completed]){color:var(--progress-tracker-horizontal-inactive-text-color, var(--core-text-20-color))}/*!@:host([orientation=\"horizontal\"][active]), :host([orientation=\"horizontal\"][completed])*/[orientation=\"horizontal\"][active].sc-market-progress-tracker-step-h,[orientation=\"horizontal\"][completed].sc-market-progress-tracker-step-h{color:var(--progress-tracker-horizontal-active-text-color, var(--core-text-10-color))}/*!@:host([orientation=\"horizontal\"][connector=\"active\"]), :host([orientation=\"horizontal\"][connector=\"inactive\"])*/[orientation=\"horizontal\"][connector=\"active\"].sc-market-progress-tracker-step-h,[orientation=\"horizontal\"][connector=\"inactive\"].sc-market-progress-tracker-step-h{grid-template-areas:\"button connector\"}/*!@:host([orientation=\"horizontal\"]:not([connector])), :host([orientation=\"horizontal\"][connector=\"hidden\"])*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h:not([connector]),[orientation=\"horizontal\"][connector=\"hidden\"].sc-market-progress-tracker-step-h{grid-template-areas:\"button\";grid-template-columns:auto}/*!@:host([orientation=\"horizontal\"][connector=\"active\"]:not([compact])), :host([orientation=\"horizontal\"][connector=\"inactive\"]:not([compact]))*/[orientation=\"horizontal\"][connector=\"active\"].sc-market-progress-tracker-step-h:not([compact]),[orientation=\"horizontal\"][connector=\"inactive\"].sc-market-progress-tracker-step-h:not([compact]){grid-template-columns:auto\n    minmax(\n      var(--tracker-horizontal-orientation-compact-density-small-size-current-state-connector-width),\n      var(--tracker-horizontal-orientation-regular-density-small-size-current-state-connector-width)\n    )}/*!@:host([orientation=\"horizontal\"][connector=\"active\"][compact]), :host([orientation=\"horizontal\"][connector=\"inactive\"][compact])*/[orientation=\"horizontal\"][connector=\"active\"][compact].sc-market-progress-tracker-step-h,[orientation=\"horizontal\"][connector=\"inactive\"][compact].sc-market-progress-tracker-step-h{grid-template-columns:auto\n    minmax(\n      auto,\n      var(--tracker-horizontal-orientation-compact-density-small-size-current-state-connector-width)\n    )}/*!@:host([orientation=\"horizontal\"][size=\"small\"])*/[orientation=\"horizontal\"][size=\"small\"].sc-market-progress-tracker-step-h{grid-template-rows:minmax(var(--progress-tracker-horizontal-small-size-height, 34px), 1fr)}/*!@:host([orientation=\"horizontal\"][size=\"medium\"])*/[orientation=\"horizontal\"][size=\"medium\"].sc-market-progress-tracker-step-h{grid-template-rows:minmax(var(--progress-tracker-horizontal-medium-size-height, 40px), 1fr)}/*!@:host([orientation=\"horizontal\"][size=\"large\"])*/[orientation=\"horizontal\"][size=\"large\"].sc-market-progress-tracker-step-h{grid-template-rows:minmax(var(--progress-tracker-horizontal-large-size-height, 42px), 1fr)}/*!@:host([orientation=\"horizontal\"][size=\"small\"][connector]:not([compact]):not([interactive]))*/[orientation=\"horizontal\"][size=\"small\"][connector].sc-market-progress-tracker-step-h:not([compact]):not([interactive]){gap:var(--tracker-horizontal-orientation-connectors-density-small-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"medium\"][connector]:not([compact]):not([interactive]))*/[orientation=\"horizontal\"][size=\"medium\"][connector].sc-market-progress-tracker-step-h:not([compact]):not([interactive]){gap:var(--tracker-horizontal-orientation-connectors-density-medium-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"large\"][connector]:not([compact]):not([interactive]))*/[orientation=\"horizontal\"][size=\"large\"][connector].sc-market-progress-tracker-step-h:not([compact]):not([interactive]){gap:var(--tracker-horizontal-orientation-connectors-density-large-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"small\"][compact][connector]:not([interactive]))*/[orientation=\"horizontal\"][size=\"small\"][compact][connector].sc-market-progress-tracker-step-h:not([interactive]){gap:var(--tracker-horizontal-orientation-compact-density-small-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"medium\"][compact][connector]:not([interactive]))*/[orientation=\"horizontal\"][size=\"medium\"][compact][connector].sc-market-progress-tracker-step-h:not([interactive]){gap:var(--tracker-horizontal-orientation-compact-density-medium-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][size=\"large\"][compact][connector]:not([interactive]))*/[orientation=\"horizontal\"][size=\"large\"][compact][connector].sc-market-progress-tracker-step-h:not([interactive]){gap:var(--tracker-horizontal-orientation-compact-density-large-size-current-state-step-spacing)}/*!@:host([orientation=\"horizontal\"][interactive])*/[orientation=\"horizontal\"][interactive].sc-market-progress-tracker-step-h{gap:0}/*!@:host([orientation=\"horizontal\"])*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h{--default-icon-fill-color:var(--progress-tracker-horizontal-default-icon-fill-color, var(--core-fill-30-color));--custom-icon-fill-color:var(--progress-tracker-horizontal-custom-icon-fill-color, var(--core-fill-20-color));--active-icon-fill-color:var(--progress-tracker-horizontal-active-icon-fill-color, var(--core-fill-10-color));--completed-icon-fill-color:var(\n      --progress-tracker-horizontal-completed-icon-fill-color,\n      var(--core-fill-10-color)\n    )}/*!@:host([orientation=\"vertical\"])*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h{--default-icon-fill-color:var(--progress-tracker-vertical-default-icon-fill-color, var(--core-fill-30-color));--custom-icon-fill-color:var(--progress-tracker-vertical-custom-icon-fill-color, var(--core-fill-20-color));--active-icon-fill-color:var(--progress-tracker-vertical-active-icon-fill-color, var(--core-blue-fill-color));--completed-icon-fill-color:var(\n      --progress-tracker-vertical-completed-icon-fill-color,\n      var(--core-blue-fill-color)\n    )}/*!@.icon*/.icon.sc-market-progress-tracker-step{display:flex;grid-area:icon;justify-content:center;align-items:center;align-self:center;fill:var(--default-icon-fill-color)}/*!@.icon.custom-icon*/.icon.custom-icon.sc-market-progress-tracker-step{fill:var(--custom-icon-fill-color)}/*!@:host([active]) .icon*/[active].sc-market-progress-tracker-step-h .icon.sc-market-progress-tracker-step{fill:var(--active-icon-fill-color)}/*!@:host([completed]) .icon*/[completed].sc-market-progress-tracker-step-h .icon.sc-market-progress-tracker-step{fill:var(--completed-icon-fill-color)}/*!@:host([orientation=\"horizontal\"]) .icon*/[orientation=\"horizontal\"].sc-market-progress-tracker-step-h .icon.sc-market-progress-tracker-step{min-width:var(--progress-tracker-horizontal-icon-width, var(--core-metrics-spacing-200));min-height:var(--progress-tracker-horizontal-icon-height, var(--core-metrics-spacing-200))}/*!@:host([orientation=\"vertical\"]) .icon*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h .icon.sc-market-progress-tracker-step{flex:0 0 var(--progress-tracker-vertical-icon-width, var(--accessory-icon-variant-medium-size-width));max-width:var(--progress-tracker-vertical-icon-width, var(--accessory-icon-variant-medium-size-width));max-height:var(--progress-tracker-vertical-icon-height, 28px)}/*!@:host(:not([completed]):not([active])) .default-icon.active-circle-icon, :host(:not([completed]):not([active])) .default-icon.small-active-circle-icon*/.sc-market-progress-tracker-step-h:not([completed]):not([active]) .default-icon.active-circle-icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .default-icon.small-active-circle-icon.sc-market-progress-tracker-step{fill:none;stroke:var(--default-icon-fill-color)}/*!@:host([active]) .default-icon.active-circle-icon, :host([active]) .default-icon.small-active-circle-icon*/[active].sc-market-progress-tracker-step-h .default-icon.active-circle-icon.sc-market-progress-tracker-step,[active].sc-market-progress-tracker-step-h .default-icon.small-active-circle-icon.sc-market-progress-tracker-step{fill:none;stroke:var(--active-icon-fill-color)}/*!@:host([completed]) .default-icon.active-circle-icon, :host([completed]) .default-icon.small-active-circle-icon*/[completed].sc-market-progress-tracker-step-h .default-icon.active-circle-icon.sc-market-progress-tracker-step,[completed].sc-market-progress-tracker-step-h .default-icon.small-active-circle-icon.sc-market-progress-tracker-step{fill:none;stroke:var(--completed-icon-fill-color)}@media (hover: hover){/*!@:host(:not([completed]):not([active])) .button:hover .icon, :host(:not([completed]):not([active])) .button:hover .default-icon, :host(:not([completed]):not([active])) .button:active .icon, :host(:not([completed]):not([active])) .button:active .default-icon*/.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:hover .icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:hover .default-icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:active .icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:active .default-icon.sc-market-progress-tracker-step{fill:var(--progress-tracker-horizontal-hover-icon-fill-color, var(--core-fill-10-color))}/*!@:host(:not([completed]):not([active])) .button:hover .default-icon.active-circle-icon, :host(:not([completed]):not([active])) .button:hover .default-icon.small-active-circle-icon, :host(:not([completed]):not([active])) .button:active .default-icon.active-circle-icon, :host(:not([completed]):not([active])) .button:active .default-icon.small-active-circle-icon*/.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:hover .default-icon.active-circle-icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:hover .default-icon.small-active-circle-icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:active .default-icon.active-circle-icon.sc-market-progress-tracker-step,.sc-market-progress-tracker-step-h:not([completed]):not([active]) .button.sc-market-progress-tracker-step:active .default-icon.small-active-circle-icon.sc-market-progress-tracker-step{fill:none;stroke:var(--progress-tracker-horizontal-hover-icon-fill-color, var(--core-fill-10-color))}}/*!@:host([orientation=\"vertical\"])*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h{grid-template-rows:var(--progress-tracker-step-vertical-icon-height, 28px) auto;grid-template-columns:var(--progress-tracker-step-vertical-icon-width, var(--accessory-icon-variant-medium-size-width))\n    auto;gap:0 var(--core-metrics-spacing-200);align-self:flex-start;color:var(--progress-tracker-vertical-text-color, var(--core-text-10-color))}/*!@:host([orientation=\"vertical\"][connector])*/[orientation=\"vertical\"][connector].sc-market-progress-tracker-step-h{grid-template-areas:\"icon content\"\n    \"connector content\"}/*!@:host([orientation=\"vertical\"]:not([connector]))*/[orientation=\"vertical\"].sc-market-progress-tracker-step-h:not([connector]){grid-template-areas:\"icon content\"\n    \". content\"}/*!@:host*/.sc-market-progress-tracker-step-h{display:inline-grid}";
var MarketProgressTrackerStepStyle0 = marketProgressTrackerStepCss;

/**
 * @slot label - Primary text for the step
 * @slot subtext - Secondary text for the step
 * @part icon - The `<market-accessory>` that contains the custom icon indicator
 * @part content - The container for the text content
 * @part button - The clickable part when interactive and on horizontal orientation
 */
class MarketProgressTrackerStep {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketProgressTrackerStepClick = createEvent(this, "marketProgressTrackerStepClick", 7);
        this.active = false;
        this.compact = false;
        this.connector = undefined;
        this.completed = false;
        this.indicator = 'circle';
        this.interactive = false;
        this.name = undefined;
        this.orientation = 'vertical';
        this.size = 'medium';
        this.defaultIcon = undefined;
    }
    /**
     * Updates the default icon based on the following attributes
     */
    updateDefaultIcon() {
        const { active, completed, el, indicator, orientation } = this;
        const slottedIcon = [...el.children].some((e) => e.slot === 'icon');
        if (slottedIcon) {
            this.defaultIcon = null;
        }
        else {
            this.defaultIcon = getIcon({ active, completed, indicator, orientation });
        }
    }
    handleClick() {
        const { el, interactive, marketProgressTrackerStepClick, name } = this;
        if (interactive) {
            marketProgressTrackerStepClick.emit({
                index: el.dataset.stepIndex !== undefined ? Number.parseInt(el.dataset.stepIndex, 10) : null,
                name: name !== null && name !== void 0 ? name : null,
            });
        }
    }
    connectedCallback() {
        this.updateDefaultIcon();
    }
    render() {
        const { defaultIcon, handleClick, interactive, orientation, updateDefaultIcon } = this;
        const MarketAccessoryTagName = getNamespacedTagFor('market-accessory');
        const HorizontalWrapperTagName = interactive ? 'button' : 'div';
        const renderContent = () => {
            return (hAsync(Fragment, null, hAsync("div", { class: classNames('icon', { 'custom-icon': Boolean(!defaultIcon) }), part: "icon" }, hAsync("slot", { name: "icon", onSlotchange: updateDefaultIcon.bind(this) }, hAsync(MarketAccessoryTagName, null, defaultIcon))), hAsync("div", { class: "content", part: "content" }, hAsync("slot", { name: "label" }), hAsync("slot", { name: "subtext" }), hAsync("slot", null))));
        };
        return (hAsync(Host, { class: "market-progress-tracker-step", role: orientation === 'horizontal' ? 'presentation' : 'listitem' }, orientation === 'horizontal' ? (hAsync(HorizontalWrapperTagName, { class: interactive ? 'button' : 'label', onClick: interactive ? handleClick.bind(this) : null, part: interactive ? 'button' : null, role: interactive ? 'tab' : 'listitem' }, renderContent())) : (renderContent())));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "active": ["updateDefaultIcon"],
        "completed": ["updateDefaultIcon"],
        "indicator": ["updateDefaultIcon"],
        "orientation": ["updateDefaultIcon"]
    }; }
    static get style() { return MarketProgressTrackerStepStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-progress-tracker-step",
        "$members$": {
            "active": [516],
            "compact": [516],
            "connector": [513],
            "completed": [516],
            "indicator": [1],
            "interactive": [516],
            "name": [1],
            "orientation": [513],
            "size": [513],
            "defaultIcon": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["compact", "compact"], ["connector", "connector"], ["completed", "completed"], ["interactive", "interactive"], ["orientation", "orientation"], ["size", "size"]]
    }; }
}

const ALIGNMENT_PATTERN_LOCATIONS = Object.freeze([
  [],
  [4, 16],
  [4, 20],
  [4, 24],
  [4, 28],
  [4, 32],
  [4, 20, 36],
  [4, 22, 40],
  [4, 24, 44],
  [4, 26, 48],
  [4, 28, 52],
  [4, 30, 56],
  [4, 32, 60],
  [4, 24, 44, 64],
  [4, 24, 46, 68],
  [4, 24, 48, 72],
  [4, 28, 52, 76],
  [4, 28, 54, 80],
  [4, 28, 56, 84],
  [4, 32, 60, 88],
  [4, 26, 48, 70, 92],
  [4, 24, 48, 72, 96],
  [4, 28, 52, 76, 100],
  [4, 26, 52, 78, 104],
  [4, 30, 56, 82, 108],
  [4, 28, 56, 84, 112],
  [4, 32, 60, 88, 116],
  [4, 24, 48, 72, 96, 120],
  [4, 28, 52, 76, 100, 124],
  [4, 24, 50, 76, 102, 128],
  [4, 28, 54, 80, 106, 132],
  [4, 32, 58, 84, 110, 136],
  [4, 28, 56, 84, 112, 140],
  [4, 32, 60, 88, 116, 144],
  [4, 28, 52, 76, 100, 124, 148],
  [4, 22, 48, 74, 100, 126, 152],
  [4, 26, 52, 78, 104, 130, 156],
  [4, 30, 56, 82, 108, 134, 160],
  [4, 24, 52, 80, 108, 136, 164],
  [4, 28, 56, 84, 112, 140, 168],
]);
const DATA_CAPACITY = Object.freeze({
  LOW: [
    19, 34, 55, 80, 108, 136, 156, 194, 232, 274, 324, 370, 428, 461, 523, 589, 647, 721, 795, 861, 932, 1006, 1094,
    1174, 1276, 1370, 1468, 1531, 1631, 1735, 1843, 1955, 2071, 2191, 2306, 2434, 2566, 2702, 2812, 2956,
  ],
  MEDIUM: [
    16, 28, 44, 64, 86, 108, 124, 154, 182, 216, 254, 290, 334, 365, 415, 453, 507, 563, 627, 669, 714, 782, 860, 914,
    1000, 1062, 1128, 1193, 1267, 1373, 1455, 1541, 1631, 1725, 1812, 1914, 1992, 2102, 2216, 2334,
  ],
  QUARTER: [
    13, 22, 34, 48, 62, 76, 88, 110, 132, 154, 180, 206, 244, 261, 295, 325, 367, 397, 445, 485, 512, 568, 614, 664,
    718, 754, 808, 871, 911, 985, 1033, 1115, 1171, 1231, 1286, 1354, 1426, 1502, 1582, 1666,
  ],
  HIGH: [
    9, 16, 26, 36, 46, 60, 66, 86, 100, 122, 140, 158, 180, 197, 223, 253, 283, 313, 341, 385, 406, 442, 464, 514, 538,
    596, 628, 661, 701, 745, 793, 845, 901, 961, 986, 1054, 1096, 1142, 1222, 1276,
  ],
});
const ENCODING = Object.freeze({
  NUMERIC: 'NUMERIC',
  ALPHANUMERIC: 'ALPHANUMERIC',
  KANJI: 'KANJI',
  BYTE: 'BYTE',
});
const ERROR_CORRECTION = Object.freeze({
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  QUARTER: 'QUARTER',
  HIGH: 'HIGH',
});

/**
 * CLASS BitWriter
 * A internal class for writing bits to an Uint8Array for QRCode encoding.
 */
class BitWriter {
  constructor(length) {
    this.length = length;
    this.content = new Uint8Array(length);
    this.byte = 0;
    this.bit = 0;
  }

  get bitsLeft() {
    return (this.length - this.byte) * 8 - this.bit;
  }

  get bytesLeft() {
    return this.bit === 0 ? this.length - this.byte : this.length - this.byte - 1;
  }

  codeForAlphaNUMERICal(char) {
    const lookIn = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
    for (let index = 0; index < lookIn.length; index++) {
      if (lookIn[index] === char) return index;
    }
  }

  completeByte() {
    if (this.bit === 0) return;
    this.bit = 0;
    this.byte++;
  }

  nextPutAlphaNUMERIC(string) {
    // Two ALPHANUMERICal characters at a time.
    for (let last = 1; last < string.length; last += 2) {
      this.nextPutBits(
        this.codeForAlphaNUMERICal(string[last - 1]) * 45 + this.codeForAlphaNUMERICal(string[last]),
        11
      );
    }
    if (string.length % 2 === 1) {
      this.nextPutBits(this.codeForAlphaNUMERICal(string[string.length - 1]), 6);
    }
  }

  nextPutBits(int, bits) {
    if (bits === 0) return;
    let amount = this.bit + bits;
    if (amount < 8) {
      this.content[this.byte] = this.content[this.byte] | (int << (8 - amount));
      this.bit += bits;
    } else if (amount === 8) {
      this.content[this.byte] = this.content[this.byte] | int;
      this.byte++;
      this.bit = 0;
    } else {
      amount -= 8;
      let shift = int >> amount;
      this.content[this.byte] = this.content[this.byte] | shift;
      shift = int - (shift << amount);
      this.byte++;
      this.bit = 0;
      this.nextPutBits(shift, amount);
    }
  }

  nextPutByte(byteArray) {
    byteArray.forEach((byte) => {
      this.nextPutBits(byte, 8);
    });
  }

  nextPutCompleteByte(byte) {
    this.completeByte();
    this.content[this.byte] = byte;
    this.byte++;
  }

  nextPutKanji(string) {
    for (let index = 0; index < string.length; index++) {
      let charCode = string.charCodeAt(index);
      if (charCode <= 0x9ffc) {
        // in the range 0x8140 to 0x9FFC
        charCode -= 0x8140;
      } else {
        // in the range 0xE040 to 0xEBBF
        charCode -= 0xc140;
      }
      let lByte = charCode % 256;
      let bByte = (charCode - lByte) / 256;
      this.nextPutBits(bByte * 0xc0 + lByte, 13);
    }
  }

  nextPutNumeric(string) {
    const asNumbers = [];
    for (let index = 0; index < string.length; index++) {
      asNumbers.push(string.charCodeAt(index) - 48);
    }
    // Three NUMERICal characters at a time.
    for (let last = 2; last < string.length; last += 3) {
      this.nextPutBits(asNumbers[last - 2] * 100 + asNumbers[last - 1] * 10 + asNumbers[last], 10);
    }
    switch (string.length % 3) {
      case 0:
        break;
      case 1:
        this.nextPutBits(asNumbers[string.length - 1], 4);
        break;
      case 2:
        this.nextPutBits(asNumbers[string.length - 2] * 10 + asNumbers[string.length - 1], 7);
        break;
    }
  }
}

/**
 * CLASS Matrix
 * A class for manipulating a 2D array.
 */
class Matrix$1 {
  static withAll(width, height, fill) {
    const content = [];
    if (fill === undefined) {
      for (let row = 0; row < height; row++) {
        content.push(new Array(width));
      }
    } else {
      for (let row = 0; row < height; row++) {
        content.push(new Array(width).fill(fill));
      }
    }
    return new this(content);
  }

  constructor(content) {
    this.content = content;
  }

  at(x, y) {
    return this.content[y][x];
  }

  copy() {
    return new this.constructor(this.content.map((row) => row.slice()));
  }

  fill(x, y, width, height, value) {
    for (let top = y; top < y + height; top++) {
      let row = this.content[top];
      for (let col = x; col < x + width; col++) {
        row[col] = value;
      }
    }
  }

  get height() {
    return this.content.length;
  }

  put(x, y, value) {
    return (this.content[y][x] = value);
  }

  get width() {
    return this.content[0].length;
  }
}

/**
 * CLASS BooleanMatrix
 * A class for keeping and manipulating 2D boolean data.
 */
class BooleanMatrix extends Matrix$1 {
  static forIntegerArray(width, height, array) {
    const content = [];
    for (let y = 0; y < height; y++) {
      let rowInteger = array[y];
      const row = [];
      for (let x = width - 1; x >= 0; x--) {
        if (rowInteger % 2 === 1) {
          row.unshift(true);
          rowInteger--;
        } else {
          row.unshift(false);
        }
        rowInteger = rowInteger / 2;
      }
      content.push(row);
    }
    return new this(content);
  }

  asIntegerArray() {
    return this.content.map((row) => {
      let integer = 0;
      row.forEach((bool) => {
        integer *= 2;
        if (bool === true) integer++;
      });
      return integer;
    });
  }

  bitAt(x, y) {
    return this.at(x, y) ? 1 : 0;
  }

  fillAlignmentPatternAt(x, y) {
    for (let size = 0; size < 4; size++) {
      this.content[y][x + size] = true;
      this.content[y + 4][x + size + 1] = true;
      this.content[y + 1 + size][x] = true;
      this.content[y + size][x + 4] = true;
    }
    this.content[y + 2][x + 2] = true;
  }

  fillFinderPatternAt(x, y) {
    for (let size = 0; size < 6; size++) {
      this.content[y][x + size] = true;
      this.content[y + 6][x + size + 1] = true;
      this.content[y + 1 + size][x] = true;
      this.content[y + size][x + 6] = true;
    }
    this.fill(x + 2, y + 2, 3, 3, true);
  }
}

/**
 * CLASS QRCodeMap
 * An instance holds the mapping for a QR code at a version and level of error correction.
 * The instances are cached so they can be reused. The map has the responsibility for adding
 * error correction to the codewords, positioning those codewords as data into a boolean
 * matrix, and masking that matrix. Instances are cached so this can be used as a service.
 */
class QRCodeMap extends Matrix$1 {
  // CHUNKING
  static chunkingAt(errorCorrection, version) {
    return {
      LOW: [
        [[1, 26, 19]],
        [[1, 44, 34]],
        [[1, 70, 55]],
        [[1, 100, 80]],
        [[1, 134, 108]],
        [[2, 86, 68]],
        [[2, 98, 78]],
        [[2, 121, 97]],
        [[2, 146, 116]],
        [
          [2, 86, 68],
          [2, 87, 69],
        ],
        [[4, 101, 81]],
        [
          [2, 116, 92],
          [2, 117, 93],
        ],
        [[4, 133, 107]],
        [
          [3, 145, 115],
          [1, 146, 116],
        ],
        [
          [5, 109, 87],
          [1, 110, 88],
        ],
        [
          [5, 122, 98],
          [1, 123, 99],
        ],
        [
          [1, 135, 107],
          [5, 136, 108],
        ],
        [
          [5, 150, 120],
          [1, 151, 121],
        ],
        [
          [3, 141, 113],
          [4, 142, 114],
        ],
        [
          [3, 135, 107],
          [5, 136, 108],
        ],
        [
          [4, 144, 116],
          [4, 145, 117],
        ],
        [
          [2, 139, 111],
          [7, 140, 112],
        ],
        [
          [4, 151, 121],
          [5, 152, 122],
        ],
        [
          [6, 147, 117],
          [4, 148, 118],
        ],
        [
          [8, 132, 106],
          [4, 133, 107],
        ],
        [
          [10, 142, 114],
          [2, 143, 115],
        ],
        [
          [8, 152, 122],
          [4, 153, 123],
        ],
        [
          [3, 147, 117],
          [10, 148, 118],
        ],
        [
          [7, 146, 116],
          [7, 147, 117],
        ],
        [
          [5, 145, 115],
          [10, 146, 116],
        ],
        [
          [13, 145, 115],
          [3, 146, 116],
        ],
        [[17, 145, 115]],
        [
          [17, 145, 115],
          [1, 146, 116],
        ],
        [
          [13, 145, 115],
          [6, 146, 116],
        ],
        [
          [12, 151, 121],
          [7, 152, 122],
        ],
        [
          [6, 151, 121],
          [14, 152, 122],
        ],
        [
          [17, 152, 122],
          [4, 153, 123],
        ],
        [
          [4, 152, 122],
          [18, 153, 123],
        ],
        [
          [20, 147, 117],
          [4, 148, 118],
        ],
        [
          [19, 148, 118],
          [6, 149, 119],
        ],
      ],
      HIGH: [
        [[1, 26, 9]],
        [[1, 44, 16]],
        [[2, 35, 13]],
        [[4, 25, 9]],
        [
          [2, 33, 11],
          [2, 34, 12],
        ],
        [[4, 43, 15]],
        [
          [4, 39, 13],
          [1, 40, 14],
        ],
        [
          [4, 40, 14],
          [2, 41, 15],
        ],
        [
          [4, 36, 12],
          [4, 37, 13],
        ],
        [
          [6, 43, 15],
          [2, 44, 16],
        ],
        [
          [3, 36, 12],
          [8, 37, 13],
        ],
        [
          [7, 42, 14],
          [4, 43, 15],
        ],
        [
          [12, 33, 11],
          [4, 34, 12],
        ],
        [
          [11, 36, 12],
          [5, 37, 13],
        ],
        [
          [11, 36, 12],
          [7, 37, 13],
        ],
        [
          [3, 45, 15],
          [13, 46, 16],
        ],
        [
          [2, 42, 14],
          [17, 43, 15],
        ],
        [
          [2, 42, 14],
          [19, 43, 15],
        ],
        [
          [9, 39, 13],
          [16, 40, 14],
        ],
        [
          [15, 43, 15],
          [10, 44, 16],
        ],
        [
          [19, 46, 16],
          [6, 47, 17],
        ],
        [[34, 37, 13]],
        [
          [16, 45, 15],
          [14, 46, 16],
        ],
        [
          [30, 46, 16],
          [2, 47, 17],
        ],
        [
          [22, 45, 15],
          [13, 46, 16],
        ],
        [
          [33, 46, 16],
          [4, 47, 17],
        ],
        [
          [12, 45, 15],
          [28, 46, 16],
        ],
        [
          [11, 45, 15],
          [31, 46, 16],
        ],
        [
          [19, 45, 15],
          [26, 46, 16],
        ],
        [
          [23, 45, 15],
          [25, 46, 16],
        ],
        [
          [23, 45, 15],
          [28, 46, 16],
        ],
        [
          [19, 45, 15],
          [35, 46, 16],
        ],
        [
          [11, 45, 15],
          [46, 46, 16],
        ],
        [
          [59, 46, 16],
          [1, 47, 17],
        ],
        [
          [22, 45, 15],
          [41, 46, 16],
        ],
        [
          [2, 45, 15],
          [64, 46, 16],
        ],
        [
          [24, 45, 15],
          [46, 46, 16],
        ],
        [
          [42, 45, 15],
          [32, 46, 16],
        ],
        [
          [10, 45, 15],
          [67, 46, 16],
        ],
        [
          [20, 45, 15],
          [61, 46, 16],
        ],
      ],
      MEDIUM: [
        [[1, 26, 16]],
        [[1, 44, 28]],
        [[1, 70, 44]],
        [[2, 50, 32]],
        [[2, 67, 43]],
        [[4, 43, 27]],
        [[4, 49, 31]],
        [
          [2, 60, 38],
          [2, 61, 39],
        ],
        [
          [3, 58, 36],
          [2, 59, 37],
        ],
        [
          [4, 69, 43],
          [1, 70, 44],
        ],
        [
          [1, 80, 50],
          [4, 81, 51],
        ],
        [
          [6, 58, 36],
          [2, 59, 37],
        ],
        [
          [8, 59, 37],
          [1, 60, 38],
        ],
        [
          [4, 64, 40],
          [5, 65, 41],
        ],
        [
          [5, 65, 41],
          [5, 66, 42],
        ],
        [
          [7, 73, 45],
          [3, 74, 46],
        ],
        [
          [10, 74, 46],
          [1, 75, 47],
        ],
        [
          [9, 69, 43],
          [4, 70, 44],
        ],
        [
          [3, 70, 44],
          [11, 71, 45],
        ],
        [
          [3, 67, 41],
          [13, 68, 42],
        ],
        [[17, 68, 42]],
        [[17, 74, 46]],
        [
          [4, 75, 47],
          [14, 76, 48],
        ],
        [
          [6, 73, 45],
          [14, 74, 46],
        ],
        [
          [8, 75, 47],
          [13, 76, 48],
        ],
        [
          [19, 74, 46],
          [4, 75, 47],
        ],
        [
          [22, 73, 45],
          [3, 74, 46],
        ],
        [
          [3, 73, 45],
          [23, 74, 46],
        ],
        [
          [21, 73, 45],
          [7, 74, 46],
        ],
        [
          [19, 75, 47],
          [10, 76, 48],
        ],
        [
          [2, 74, 46],
          [29, 75, 47],
        ],
        [
          [10, 74, 46],
          [23, 75, 47],
        ],
        [
          [14, 74, 46],
          [21, 75, 47],
        ],
        [
          [14, 74, 46],
          [23, 75, 47],
        ],
        [
          [12, 75, 47],
          [26, 76, 48],
        ],
        [
          [6, 75, 47],
          [34, 76, 48],
        ],
        [
          [29, 74, 46],
          [14, 75, 47],
        ],
        [
          [13, 74, 46],
          [32, 75, 47],
        ],
        [
          [40, 75, 47],
          [7, 76, 48],
        ],
        [
          [18, 75, 47],
          [31, 76, 48],
        ],
      ],
      QUARTER: [
        [[1, 26, 13]],
        [[1, 44, 22]],
        [[2, 35, 17]],
        [[2, 50, 24]],
        [
          [2, 33, 15],
          [2, 34, 16],
        ],
        [[4, 43, 19]],
        [
          [2, 32, 14],
          [4, 33, 15],
        ],
        [
          [4, 40, 18],
          [2, 41, 19],
        ],
        [
          [4, 36, 16],
          [4, 37, 17],
        ],
        [
          [6, 43, 19],
          [2, 44, 20],
        ],
        [
          [4, 50, 22],
          [4, 51, 23],
        ],
        [
          [4, 46, 20],
          [6, 47, 21],
        ],
        [
          [8, 44, 20],
          [4, 45, 21],
        ],
        [
          [11, 36, 16],
          [5, 37, 17],
        ],
        [
          [5, 54, 24],
          [7, 55, 25],
        ],
        [
          [15, 43, 19],
          [2, 44, 20],
        ],
        [
          [1, 50, 22],
          [15, 51, 23],
        ],
        [
          [17, 50, 22],
          [1, 51, 23],
        ],
        [
          [17, 47, 21],
          [4, 48, 22],
        ],
        [
          [15, 54, 24],
          [5, 55, 25],
        ],
        [
          [17, 50, 22],
          [6, 51, 23],
        ],
        [
          [7, 54, 24],
          [16, 55, 25],
        ],
        [
          [11, 54, 24],
          [14, 55, 25],
        ],
        [
          [11, 54, 24],
          [16, 55, 25],
        ],
        [
          [7, 54, 24],
          [22, 55, 25],
        ],
        [
          [28, 50, 22],
          [6, 51, 23],
        ],
        [
          [8, 53, 23],
          [26, 54, 24],
        ],
        [
          [4, 54, 24],
          [31, 55, 25],
        ],
        [
          [1, 53, 23],
          [37, 54, 24],
        ],
        [
          [15, 54, 24],
          [25, 55, 25],
        ],
        [
          [42, 54, 24],
          [1, 55, 25],
        ],
        [
          [10, 54, 24],
          [35, 55, 25],
        ],
        [
          [29, 54, 24],
          [19, 55, 25],
        ],
        [
          [44, 54, 24],
          [7, 55, 25],
        ],
        [
          [39, 54, 24],
          [14, 55, 25],
        ],
        [
          [46, 54, 24],
          [10, 55, 25],
        ],
        [
          [49, 54, 24],
          [10, 55, 25],
        ],
        [
          [48, 54, 24],
          [14, 55, 25],
        ],
        [
          [43, 54, 24],
          [22, 55, 25],
        ],
        [
          [34, 54, 24],
          [34, 55, 25],
        ],
      ],
    }[errorCorrection][version - 1];
  }

  // GALOIS FIELD POLYNOMIALS
  static fromGF256Alpha(index) {
    return [
      1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117, 234, 201, 143, 3, 6,
      12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193, 159, 35, 70, 140, 5, 10, 20,
      40, 80, 160, 93, 186, 105, 210, 185, 111, 222, 161, 95, 190, 97, 194, 153, 47, 94, 188, 101, 202, 137, 15, 30, 60,
      120, 240, 253, 231, 211, 187, 107, 214, 177, 127, 254, 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17,
      34, 68, 136, 13, 26, 52, 104, 208, 189, 103, 206, 129, 31, 62, 124, 248, 237, 199, 147, 59, 118, 236, 197, 151,
      51, 102, 204, 133, 23, 46, 92, 184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77, 154, 41, 82, 164,
      85, 170, 73, 146, 57, 114, 228, 213, 183, 115, 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246,
      241, 255, 227, 219, 171, 75, 150, 49, 98, 196, 149, 55, 110, 220, 165, 87, 174, 65, 130, 25, 50, 100, 200, 141, 7,
      14, 28, 56, 112, 224, 221, 167, 83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195, 155, 43, 86, 172, 69, 138, 9,
      18, 36, 72, 144, 61, 122, 244, 245, 247, 243, 251, 235, 203, 139, 11, 22, 44, 88, 176, 125, 250, 233, 207, 131,
      27, 54, 108, 216, 173, 71, 142,
    ][index];
  }

  static polynomial(size) {
    // cache the polynomials
    if (this.polynomials.length >= size) {
      return this.polynomials[size - 1];
    }
    let polynomial = this.polynomials[this.polynomials.length - 1];
    for (let multiplier = this.polynomials.length; multiplier < size; multiplier++) {
      let factor = new Uint8Array(2);
      factor[1] = multiplier;
      polynomial = this.product(polynomial, factor);
      this.polynomials.push(polynomial);
    }
    return polynomial;
  }

  static product(first, second) {
    let product = new Uint8Array(first.length + second.length - 1);
    first.forEach((firstValue, firstIndex) => {
      second.forEach((secondValue, secondIndex) => {
        let productIndex = firstIndex + secondIndex;
        product[productIndex] = this.fromGF256Alpha((firstValue + secondValue) % 255) ^ product[productIndex];
      });
    });
    return product.map((entry) => this.toGF256Alpha(entry));
  }

  static quotient(dividend, divisor) {
    let quotient = new Uint8Array(dividend.length + divisor.length - 1);
    for (let index = 0; index < dividend.length; index++) quotient[index] = dividend[index];
    for (let dividendIndex = 0; dividendIndex < dividend.length; dividendIndex++) {
      let startEntry = quotient[dividendIndex];
      if (startEntry !== 0) {
        startEntry = this.toGF256Alpha(startEntry);
        divisor.forEach((alpha, divisorIndex) => {
          let quotientIndex = dividendIndex + divisorIndex;
          quotient[quotientIndex] = this.fromGF256Alpha((startEntry + alpha) % 255) ^ quotient[quotientIndex];
        });
      }
    }
    return quotient.slice(quotient.length - divisor.length + 1);
  }

  static toGF256Alpha(index) {
    return [
      0, 0, 1, 25, 2, 50, 26, 198, 3, 223, 51, 238, 27, 104, 199, 75, 4, 100, 224, 14, 52, 141, 239, 129, 28, 193, 105,
      248, 200, 8, 76, 113, 5, 138, 101, 47, 225, 36, 15, 33, 53, 147, 142, 218, 240, 18, 130, 69, 29, 181, 194, 125,
      106, 39, 249, 185, 201, 154, 9, 120, 77, 228, 114, 166, 6, 191, 139, 98, 102, 221, 48, 253, 226, 152, 37, 179, 16,
      145, 34, 136, 54, 208, 148, 206, 143, 150, 219, 189, 241, 210, 19, 92, 131, 56, 70, 64, 30, 66, 182, 163, 195, 72,
      126, 110, 107, 58, 40, 84, 250, 133, 186, 61, 202, 94, 155, 159, 10, 21, 121, 43, 78, 212, 229, 172, 115, 243,
      167, 87, 7, 112, 192, 247, 140, 128, 99, 13, 103, 74, 222, 237, 49, 197, 254, 24, 227, 165, 153, 119, 38, 184,
      180, 124, 17, 68, 146, 217, 35, 32, 137, 46, 55, 63, 209, 91, 149, 188, 207, 205, 144, 135, 151, 178, 220, 252,
      190, 97, 242, 86, 211, 171, 20, 42, 93, 158, 132, 60, 57, 83, 71, 109, 65, 162, 31, 45, 67, 216, 183, 123, 164,
      118, 196, 23, 73, 236, 127, 12, 111, 246, 108, 161, 59, 82, 41, 157, 85, 170, 251, 96, 134, 177, 187, 204, 62, 90,
      203, 89, 95, 176, 156, 169, 160, 81, 11, 245, 22, 235, 122, 117, 44, 215, 79, 174, 213, 233, 230, 231, 173, 232,
      116, 214, 244, 234, 168, 80, 88, 175,
    ][index];
  }

  // MASKS
  static get masks() {
    if (this.maskArray.length === 0) {
      [
        (x, y) => (x + y) % 2 === 0,
        (x, y) => y % 2 === 0,
        (x) => x % 3 === 0,
        (x, y) => (x + y) % 3 === 0,
        (x, y) => ((y - (y % 2)) / 2 + (x - (x % 3)) / 3) % 2 === 0,
        (x, y) => ((x * y) % 2) + ((x * y) % 3) === 0,
        (x, y) => (x * y + ((x * y) % 3)) % 2 === 0,
        (x, y) => (((x * y) % 3) + x + y) % 2 === 0,
      ].forEach((generator) => {
        const content = [];
        for (let y = 0; y < 12; y++) {
          const row = [];
          for (let x = 0; x < 12; x++) {
            row.push(generator(x, y));
          }
          content.push(row);
        }
        this.maskArray.push(new BooleanMatrix(content));
      });
    }
    return this.maskArray;
  }

  // INSTANCE CREATION
  static for(errorCorrection, version) {
    // cache the instances
    let instance = this.instances[errorCorrection + version];
    if (instance === undefined) {
      const dimension = version * 4 + 17;
      const content = [];
      for (let row = 0; row < dimension; row++) {
        content.push(new Array(dimension).fill(this.AVAILABLE));
      }
      instance = new this(content, errorCorrection, version);
      this.instances[errorCorrection + version] = instance;
    }
    return instance;
  }

  // INSTANCE
  // chunking
  // chunkingOffsets          where each chunk can be found in the data
  // errorCorrection
  // errorCorrectionCapacity  the number of codewords that can be messed up
  //                          (1x for erasure, 2x for miscoding) per chunk
  // version
  constructor(content, errorCorrection, version) {
    super(content);
    this.errorCorrection = errorCorrection;
    this.version = version;
    this.initialize();
  }

  initialize() {
    // calculate misdecodeProtectionCodewords
    let misdecodeProtectionCodewords = 0;
    if (this.errorCorrection === ERROR_CORRECTION.LOW) {
      if (this.version === 1) {
        misdecodeProtectionCodewords = 3;
      } else if (this.version === 2) {
        misdecodeProtectionCodewords = 2;
      } else if (this.version === 3) {
        misdecodeProtectionCodewords = 1;
      }
    } else if (this.version === 1) {
      if (this.errorCorrection === ERROR_CORRECTION.MEDIUM) {
        misdecodeProtectionCodewords = 2;
      } else {
        misdecodeProtectionCodewords = 1;
      }
    }
    // get data and errorCorrection
    this.chunking = this.constructor.chunkingAt(this.errorCorrection, this.version);
    const data = [];
    const errorCorrection = [];
    let dataWidth = 0;
    let errorCorrectionWidth = 0;
    const errorCorrectionCapacity = [];
    const chunkingOffsets = [];
    let chunkingOffset = 0;
    let chunk = 0;
    this.chunking.forEach((arr) => {
      for (let i = 0; i < arr[0]; i++) {
        let byte = 0;
        chunkingOffsets.push(chunkingOffset * 8);
        chunkingOffset += arr[1];
        const dataI = [];
        const numberOfDataCodewords = arr[2];
        for (let j = 0; j < numberOfDataCodewords; j++) {
          dataI.push({ chunk, byte });
          byte++;
        }
        data.push(dataI);
        dataWidth = Math.max(dataWidth, dataI.length);
        const errorCorrectionI = [];
        const numberOfErrorCorrectionCodewords = arr[1] - numberOfDataCodewords;
        for (let j = 0; j < numberOfErrorCorrectionCodewords; j++) {
          errorCorrectionI.push({ chunk, byte });
          byte++;
        }
        errorCorrection.push(errorCorrectionI);
        errorCorrectionWidth = Math.max(errorCorrectionWidth, errorCorrectionI.length);
        errorCorrectionCapacity.push(numberOfErrorCorrectionCodewords - misdecodeProtectionCodewords);
        chunk++;
      }
    });
    this.chunkingOffsets = chunkingOffsets;
    this.errorCorrectionCapacity = errorCorrectionCapacity;
    // combine the data and errorCorrection
    const combined = [];
    for (let column = 0; column < dataWidth; column++) {
      data.forEach((row) => {
        if (row.length > column) combined.push(row[column]);
      });
    }
    for (let column = 0; column < errorCorrectionWidth; column++) {
      errorCorrection.forEach((row) => {
        if (row.length > column) combined.push(row[column]);
      });
    }
    // create the pixels
    const pixels = [];
    combined.forEach((byteAndChunk) => {
      const byte = byteAndChunk.byte;
      const chunk = byteAndChunk.chunk;
      for (let bit = 0; bit < 8; bit++) {
        pixels.push({ chunk, byte, bit });
      }
    });
    // finder patterns & format information
    const dimension = this.width;
    this.fill(0, 0, 9, 9, this.constructor.AVOID);
    this.fill(dimension - 8, 0, 8, 9, this.constructor.AVOID);
    this.fill(0, dimension - 8, 9, 8, this.constructor.AVOID);
    // version information
    if (this.version > 6) {
      this.fill(dimension - 11, 0, 3, 6, this.constructor.AVOID);
      this.fill(0, dimension - 11, 6, 3, this.constructor.AVOID);
    }
    // timing patterns
    this.fill(9, 6, dimension - 17, 1, this.constructor.AVOID);
    this.fill(6, 9, 1, dimension - 17, this.constructor.AVOID);
    // alignment patterns
    for (const position of QRCode$1.alignmentPatternPositions(this.version)) {
      this.fill(position.x, position.y, 5, 5, this.constructor.AVOID);
    }
    // fill the pixels
    let x = dimension - 2;
    let y = dimension;
    pixels.forEach((pixel) => {
      // get next position
      do {
        let shift;
        let halfOdd = ((x - (x % 2)) / 2) % 2 === 1;
        if (x === 6) {
          shift = false;
          x = 5;
        } else if (x < 6) {
          shift = x % 2 === 1;
        } else {
          shift = x % 2 === 0;
        }
        if (shift) {
          x--;
        } else if (halfOdd) {
          if (y === 0) {
            x--;
          } else {
            x++;
            y--;
          }
        } else {
          if (y + 1 === dimension) {
            x--;
          } else {
            x++;
            y++;
          }
        }
      } while (this.at(x, y) === this.constructor.AVOID && x > -1);
      // place the bit
      this.put(x, y, pixel);
    });
  }

  codewordsFor(codewords) {
    let bytePosition = 0;
    const withErrorCorrection = [];
    this.chunking.forEach((arr) => {
      for (let i = 0; i < arr[0]; i++) {
        const data = codewords.slice(bytePosition, bytePosition + arr[2]);
        bytePosition += arr[2];
        const errorCorrection = this.constructor.quotient(data, this.constructor.polynomial(arr[1] - arr[2]));
        withErrorCorrection.push(...data);
        withErrorCorrection.push(...errorCorrection);
      }
    });
    return withErrorCorrection;
  }

  dataFor(codewords) {
    // convert to bits
    const bits = [];
    codewords.forEach((byte) => {
      let remainder = byte;
      [128, 64, 32, 16, 8, 4, 2, 1].forEach((subtract) => {
        if (remainder >= subtract) {
          bits.push(true);
          remainder -= subtract;
        } else {
          bits.push(false);
        }
      });
    });
    this.bits = bits;
    // place bits in matrix
    const dimension = this.content.length;
    const encodedData = BooleanMatrix.withAll(dimension, dimension, false);
    for (let y = 0; y < dimension; y++) {
      for (let x = 0; x < dimension; x++) {
        const pixel = this.at(x, y);
        if (this.isDataPixel(pixel)) {
          encodedData.put(x, y, bits[this.chunkingOffsets[pixel.chunk] + pixel.byte * 8 + pixel.bit]);
        }
      }
    }
    return encodedData;
  }

  isDataPixel(pixel) {
    return pixel !== this.constructor.AVOID && pixel !== this.constructor.AVAILABLE;
  }

  maskedDataFor(data) {
    const dimension = data.height;
    return this.constructor.masks.map((mask) => {
      const masked = BooleanMatrix.withAll(dimension, dimension);
      for (let x = 0; x < dimension; x++) {
        for (let y = 0; y < dimension; y++) {
          let value = data.at(x, y);
          if (this.at(x, y) !== QRCodeMap.AVOID) {
            if (mask.at(x % 12, y % 12)) value = !value;
          }
          masked.put(x, y, value);
        }
      }
      return masked;
    });
  }

  // TESTING
  asIntegerArray() {
    return this.content.map((row) => {
      let integer = 0;
      row.forEach((pixel) => {
        integer *= 2;
        if (this.isDataPixel(pixel)) integer++;
      });
      return integer;
    });
  }
}
// static variables
QRCodeMap.AVAILABLE = 'available';
QRCodeMap.AVOID = 'avoid';
QRCodeMap.GENERATOR_FUNCTIONS = [
  (x, y) => (x + y) % 2 === 0,
  (x, y) => y % 2 === 0,
  (x) => x % 3 === 0,
  (x, y) => (x + y) % 3 === 0,
  (x, y) => ((y - (y % 2)) / 2 + (x - (x % 3)) / 3) % 2 === 0,
  (x, y) => ((x * y) % 2) + ((x * y) % 3) === 0,
  (x, y) => (x * y + ((x * y) % 3)) % 2 === 0,
  (x, y) => (((x * y) % 3) + x + y) % 2 === 0,
];
QRCodeMap.instances = {};
QRCodeMap.maskArray = [];
QRCodeMap.polynomials = [new Uint8Array(2)];

/**
 * CLASS QRCode
 * This represents an encoded QRCode based on the following:
 *   content         the string to encode
 *   options         an object with the options, such as the ECI integer and errorCorrection
 * An encoder generates the following:
 *   data            the BooleanMatrix of mapped data, along with the format and version information
 *   eci             (see above)
 *   encoding        'NUMERIC' | 'ALPHANUMERIC' | 'KANJI' | BYTE
 *   errorCorrection (see above)
 *   version         the QRCode version from 1 to 40.
 * It also provides pattern positions and derivative information.
 */
class QRCode$1 {
  static alignmentPatternPositions(version) {
    let locations = ALIGNMENT_PATTERN_LOCATIONS[version - 1];
    if (locations.length === 0) return [];
    const positions = [];
    // top and left
    const first = locations[0];
    locations.slice(1, locations.length - 1).forEach((location) => {
      positions.push({
        x: first,
        y: location,
      });
      positions.push({
        x: location,
        y: first,
      });
    });
    // others
    locations = locations.slice(1);
    locations.forEach((y) => {
      locations.forEach((x) => {
        positions.push({ x, y });
      });
    });
    return positions;
  }

  static finderPatternPositions(version) {
    const far = 4 * version + 10;
    return [
      { x: 0, y: 0 },
      { x: 0, y: far },
      { x: far, y: 0 },
    ];
  }

  static timingPatternPositions(version) {
    const positions = [];
    const far = 4 * version + 9;
    for (let position = 8; position < far; position += 2) {
      positions.push({ x: position, y: 6 });
      positions.push({ x: 6, y: position });
    }
    return positions;
  }

  constructor(content, options) {
    if (content === undefined || content.length === 0) throw 'no content to encode';
    this.content = content;
    this.options = options || {};
    if ('eci' in this.options) this.eci = this.options.eci;
    if ('errorCorrection' in this.options) this.errorCorrection = this.options.errorCorrection;
  }

  get alignmentPatternPositions() {
    return this.constructor.alignmentPatternPositions(this.version);
  }

  get dimension() {
    return this.version * 4 + 17;
  }

  get encoding() {
    return this._encoding;
  }

  set encoding(string) {
    this._encoding = string;
  }

  get finderPatternPositions() {
    return this.constructor.finderPatternPositions(this.version);
  }

  get hasEci() {
    return this.eci !== undefined && this.eci !== 3;
  }

  get hasAlignmentPattern() {
    return this.version > 1;
  }

  get timingPatternPositions() {
    return this.constructor.timingPatternPositions(this.version);
  }
}
// static variables
QRCode$1.MAX_VERSION = 40;

/**
 * CLASS QRCodeEncoder
 * This class does the encoding work for the QRCode class, hiding the algorithmic details and
 * intermediate step data. It populates the QRCode with encoding, version, errorCorrection, and data.
 * It is only exported to be used in tests.
 */
class QRCodeEncoder$1 {
  constructor(contents, options) {
    this.code = new QRCode$1(contents, options);
    this.encode();
  }

  encode() {
    this.initializeEncoding();
    this.initializeVersion();
    this.initializeCodewords();
    this.initializeMapping();
    this.initializeMasking();
  }

  initializeCodewords() {
    const writer = new BitWriter(DATA_CAPACITY[this.code.errorCorrection][this.code.version - 1]);
    switch (this.code.encoding) {
      case ENCODING.NUMERIC:
        // mode
        writer.nextPutBits(1, 4);
        // number of bits
        if (this.code.version < 10) {
          writer.nextPutBits(this.length, 10);
        } else if (this.code.version < 27) {
          writer.nextPutBits(this.length, 12);
        } else {
          writer.nextPutBits(this.length, 14);
        }
        // content
        writer.nextPutNumeric(this.code.content);
        break;
      case ENCODING.ALPHANUMERIC:
        // mode
        writer.nextPutBits(2, 4);
        // number of bits
        if (this.code.version < 10) {
          writer.nextPutBits(this.length, 9);
        } else if (this.code.version < 27) {
          writer.nextPutBits(this.length, 11);
        } else {
          writer.nextPutBits(this.length, 13);
        }
        // content
        writer.nextPutAlphaNUMERIC(this.code.content);
        break;
      case ENCODING.KANJI:
        // mode
        writer.nextPutBits(8, 8);
        // number of bits
        if (this.code.version < 10) {
          writer.nextPutBits(this.length, 8);
        } else if (this.code.version < 27) {
          writer.nextPutBits(this.length, 10);
        } else {
          writer.nextPutBits(this.length, 12);
        }
        // content
        writer.nextPutKanji(this.code.content);
        break;
      case ENCODING.BYTE:
        if (this.code.hasEci) {
          // specife ECI mode
          writer.nextPutBits(7, 4);
          // Add the ECI assignment number
          if (this.code.eci < 128) {
            writer.nextPutBits(0, 1);
            writer.nextPutBits(this.code.eci, 7);
          } else if (this.code.eci < 16384) {
            writer.nextPutBits(2, 2);
            writer.nextPutBits(this.code.eci, 14);
          } else {
            writer.nextPutBits(6, 3);
            writer.nextPutBits(this.code.eci, 21);
          }
        }
        // mode
        writer.nextPutBits(4, 4);
        // number of bits
        if (this.code.version < 10) {
          writer.nextPutBits(this.length, 8);
        } else {
          writer.nextPutBits(this.length, 16);
        }
        // content
        writer.nextPutByte(this.bytes);
        break;
    }
    // Terminate the sequence / Skip to next byte for error correction
    if (writer.bitsLeft > 3) writer.nextPutBits(0, 4);
    // Add error correction sequence, alternating between 11101100 and 00010001
    const bytesLeft = writer.bytesLeft;
    for (let index = 0; index < bytesLeft; index++) {
      writer.nextPutCompleteByte(index % 2 === 0 ? 236 : 17);
    }
    this.codewords = writer.content;
  }

  initializeEncoding() {
    if (this.code.hasEci) {
      this.code.encoding = ENCODING.BYTE;
      if (this.code.eci === 3) {
        // jis
        this.length = this.code.content.length;
        this.bytes = [];
        for (let i = 0; i < length; i++) {
          this.bytes.push(this.code.content.charCodeAt(i) % 128);
        }
      } else if (this.code.eci === 25) {
        // utf-16be
        this.bytes = this.toUtf16Bytes(this.code.content);
        this.length = this.bytes.length;
      } else if (this.code.eci === 26) {
        // utf-8
        this.bytes = this.toUtf8Bytes(this.code.content);
        this.length = this.bytes.length;
      } else {
        this.length = this.code.content.length;
        this.bytes = [];
        for (let i = 0; i < length; i++) {
          this.bytes.push(this.code.content.charCodeAt(i) % 256);
        }
      }
    } else if (/^\d*$/.test(this.code.content)) {
      this.code.encoding = ENCODING.NUMERIC;
      this.length = this.code.content.length;
    } else if (/^[A-Z\d\dA-Z $%*+-./:]+$/.test(this.code.content)) {
      this.code.encoding = ENCODING.ALPHANUMERIC;
      this.length = this.code.content.length;
    } else if (/^[\u8140-\u9ffc\ue040-\uebbf]+$/.test(this.code.content)) {
      this.code.encoding = ENCODING.KANJI;
      this.length = this.code.content.length;
    } else {
      this.code.encoding = ENCODING.BYTE;
      this.bytes = this.toUtf8Bytes(this.code.content);
      this.length = this.bytes.length;
      // use utf-8 encoding if it is needed, jis if that is sufficient
      this.code.eci = this.length === this.code.content.length ? 3 : 26;
    }
  }

  initializeMapping() {
    this.map = QRCodeMap.for(this.code.errorCorrection, this.code.version);
    this.mapCodewords = this.map.codewordsFor(this.codewords);
    this.mapData = this.map.dataFor(this.mapCodewords);
  }

  initializeMasking() {
    // Get the masked choices
    const choices = this.map.maskedDataFor(this.mapData);
    // Find the one with the lowest penalty
    let data;
    let dataIndex;
    let lowestPenalty = 1000000;
    choices.forEach((matrix, index) => {
      const penalty = this.penaltyForMatrix(matrix);
      if (penalty < lowestPenalty) {
        lowestPenalty = penalty;
        data = matrix;
        dataIndex = index;
      }
    });
    this.lowestPenalty = lowestPenalty;
    // Generate the format information
    let format = [1, 0, 3, 2][this.errorCorrections.indexOf(this.code.errorCorrection)];
    format = (8 * format + dataIndex) * 1024;
    let errorCorrection = format;
    for (let i = 14; i >= 10; i--) {
      if (errorCorrection >= Math.pow(2, i)) {
        errorCorrection = (Math.pow(2, i - 10) * 1335) ^ errorCorrection;
      }
    }
    format = (format + errorCorrection) ^ 21522;
    // Place the format information
    const dimension = this.code.dimension;
    [
      [8, 0, dimension - 1, 8],
      [8, 1, dimension - 2, 8],
      [8, 2, dimension - 3, 8],
      [8, 3, dimension - 4, 8],
      [8, 4, dimension - 5, 8],
      [8, 5, dimension - 6, 8],
      [8, 7, dimension - 7, 8],
      [8, 8, dimension - 8, 8],
      [7, 8, 8, dimension - 7],
      [5, 8, 8, dimension - 6],
      [4, 8, 8, dimension - 5],
      [3, 8, 8, dimension - 4],
      [2, 8, 8, dimension - 3],
      [1, 8, 8, dimension - 2],
      [0, 8, 8, dimension - 1],
    ].forEach((arr, index) => {
      if ((Math.pow(2, index) & format) > 0) {
        data.put(arr[0], arr[1], true);
        data.put(arr[2], arr[3], true);
      }
    });
    // Add dark module
    data.put(8, dimension - 8, true);
    // Version information
    if (this.code.version > 6) {
      // Generate the bitVersion information
      let bitVersion = this.code.version * 4096;
      errorCorrection = bitVersion;
      for (let i = 17; i >= 12; i--) {
        if (errorCorrection >= Math.pow(2, i)) {
          errorCorrection = (Math.pow(2, i - 12) * 7973) ^ errorCorrection;
        }
      }
      bitVersion += errorCorrection;
      // Place the bitVersion information
      let count = 0;
      for (let x = 0; x < 6; x++) {
        for (let y = dimension - 11; y <= dimension - 9; y++) {
          if ((Math.pow(2, count) & bitVersion) > 0) {
            data.put(x, y, true);
            data.put(y, x, true);
          }
          count++;
        }
      }
    }
    // finalize loading of QRCode
    this.code.data = data;
  }

  initializeVersion() {
    if (this.errorCorrections.includes(this.code.errorCorrection)) {
      // Error correction has already been specified
      let version = this.versionForLength(this.length, this.code.errorCorrection);
      if (version > QRCode$1.MAX_VERSION)
        throw 'This content is too long to be encoded for the specified error correction.';
      this.code.version = version;
    } else {
      // Choose the error correction that gets the smallest size but the highest error correction
      let versions = this.errorCorrections.map((errorCorrection) =>
        this.versionForLength(this.length, errorCorrection)
      );
      let version = versions[0];
      if (version > QRCode$1.MAX_VERSION) throw 'This string is too long to be encoded.';
      this.code.version = version;
      for (let index = 3; index >= 0; index--) {
        if (versions[index] === version) {
          this.code.errorCorrection = this.errorCorrections[index];
          return;
        }
      }
    }
  }

  capacity(encoding, errorCorrection) {
    return {
      NUMERIC: {
        LOW: [
          41, 77, 127, 187, 255, 322, 370, 461, 552, 652, 772, 883, 1022, 1101, 1250, 1408, 1548, 1725, 1903, 2061,
          2232, 2409, 2620, 2812, 3057, 3283, 3517, 3669, 3909, 4158, 4417, 4686, 4965, 5253, 5529, 5836, 6153, 6479,
          6743, 7089,
        ],
        MEDIUM: [
          34, 63, 101, 149, 202, 255, 293, 365, 432, 513, 604, 691, 796, 871, 991, 1082, 1212, 1346, 1500, 1600, 1708,
          1872, 2059, 2188, 2395, 2544, 2701, 2857, 3035, 3289, 3486, 3693, 3909, 4134, 4343, 4588, 4775, 5039, 5313,
          5596,
        ],
        QUARTER: [
          27, 48, 77, 111, 144, 178, 207, 259, 312, 364, 427, 489, 580, 621, 703, 775, 876, 948, 1063, 1159, 1224, 1358,
          1468, 1588, 1718, 1804, 1933, 2085, 2181, 2358, 2473, 2670, 2805, 2949, 3081, 3244, 3417, 3599, 3791, 3993,
        ],
        HIGH: [
          17, 34, 58, 82, 106, 139, 154, 202, 235, 288, 331, 374, 427, 468, 530, 602, 674, 746, 813, 919, 969, 1056,
          1108, 1228, 1286, 1425, 1501, 1581, 1677, 1782, 1897, 2022, 2157, 2301, 2361, 2524, 2625, 2735, 2927, 3057,
        ],
      },
      ALPHANUMERIC: {
        LOW: [
          25, 47, 77, 114, 154, 195, 224, 279, 335, 395, 468, 535, 619, 667, 758, 854, 938, 1046, 1153, 1249, 1352,
          1460, 1588, 1704, 1853, 1990, 2132, 2223, 2369, 2520, 2677, 2840, 3009, 3183, 3351, 3537, 3729, 3927, 4087,
          4296,
        ],
        MEDIUM: [
          20, 38, 61, 90, 122, 154, 178, 221, 262, 311, 366, 419, 483, 528, 600, 656, 734, 816, 909, 970, 1035, 1134,
          1248, 1326, 1451, 1542, 1637, 1732, 1839, 1994, 2113, 2238, 2369, 2506, 2632, 2780, 2894, 3054, 3220, 3391,
        ],
        QUARTER: [
          16, 29, 47, 67, 87, 108, 125, 157, 189, 221, 259, 296, 352, 376, 426, 470, 531, 574, 644, 702, 742, 823, 890,
          963, 1041, 1094, 1172, 1263, 1322, 1429, 1499, 1618, 1700, 1787, 1867, 1966, 2071, 2181, 2298, 2420,
        ],
        HIGH: [
          10, 20, 35, 50, 64, 84, 93, 122, 143, 174, 200, 227, 259, 283, 321, 365, 408, 452, 493, 557, 587, 640, 672,
          744, 779, 864, 910, 958, 1016, 1080, 1150, 1226, 1307, 1394, 1431, 1530, 1591, 1658, 1774, 1852,
        ],
      },
      KANJI: {
        LOW: [
          10, 20, 32, 48, 65, 82, 95, 118, 141, 167, 198, 226, 262, 282, 320, 361, 397, 442, 488, 528, 572, 618, 672,
          721, 784, 842, 902, 940, 1002, 1066, 1132, 1201, 1273, 1347, 1417, 1496, 1577, 1661, 1729, 1817,
        ],
        MEDIUM: [
          8, 16, 26, 38, 52, 65, 75, 93, 111, 131, 155, 177, 204, 223, 254, 277, 310, 345, 384, 410, 438, 480, 528, 561,
          614, 652, 692, 732, 778, 843, 894, 947, 1002, 1060, 1113, 1176, 1224, 1292, 1362, 1435,
        ],
        QUARTER: [
          7, 12, 20, 28, 37, 45, 53, 66, 80, 93, 109, 125, 149, 159, 180, 198, 224, 243, 272, 297, 314, 348, 376, 407,
          440, 462, 496, 534, 559, 604, 634, 684, 719, 756, 790, 832, 876, 923, 972, 1024,
        ],
        HIGH: [
          4, 8, 15, 21, 27, 36, 39, 52, 60, 74, 85, 96, 109, 120, 136, 154, 173, 191, 208, 235, 248, 270, 284, 315, 330,
          365, 385, 405, 430, 457, 486, 518, 553, 590, 605, 647, 673, 701, 750, 784,
        ],
      },
      BYTE: {
        LOW: [
          17, 32, 53, 78, 106, 134, 154, 192, 230, 271, 321, 367, 425, 458, 520, 586, 644, 718, 792, 858, 929, 1003,
          1091, 1171, 1273, 1367, 1465, 1528, 1628, 1732, 1840, 1952, 2068, 2188, 2303, 2431, 2563, 2699, 2809, 2953,
        ],
        MEDIUM: [
          14, 26, 42, 62, 84, 106, 122, 152, 180, 213, 251, 287, 331, 362, 412, 450, 504, 560, 624, 666, 711, 779, 857,
          911, 997, 1059, 1125, 1190, 1264, 1370, 1452, 1538, 1628, 1722, 1809, 1911, 1989, 2099, 2213, 2331,
        ],
        QUARTER: [
          11, 20, 32, 46, 60, 74, 86, 108, 130, 151, 177, 203, 241, 258, 292, 322, 364, 394, 442, 482, 509, 565, 611,
          661, 715, 751, 805, 868, 908, 982, 1030, 1112, 1168, 1228, 1283, 1351, 1423, 1499, 1579, 1663,
        ],
        HIGH: [
          7, 14, 24, 34, 44, 58, 64, 84, 98, 119, 137, 155, 177, 194, 220, 250, 280, 310, 338, 382, 403, 439, 461, 511,
          535, 593, 625, 658, 698, 742, 790, 842, 898, 958, 983, 1051, 1093, 1139, 1219, 1273,
        ],
      },
    }[encoding][errorCorrection];
  }

  get errorCorrections() {
    return [ERROR_CORRECTION.LOW, ERROR_CORRECTION.MEDIUM, ERROR_CORRECTION.QUARTER, ERROR_CORRECTION.HIGH];
  }

  penaltyForMatrix(matrix) {
    /*
      Return the penalty score for the symbol, according to the following criteria:
      Penalty 1: A penalty (n-2) for each group of five or more same-colored modules in a row (or column)
      Penalty 2: A penalty (3) for each 2x2 area of same-colored modules
      Penalty 3: A penalty (40) if there are patterns that look similar to the finder patterns
      Penalty 4: A penalty based on the percentage of tiles that are black / white
    */
    let penalty = 0;
    const dimension = matrix.content.length;
    let current, last, run, runTest, finderPattern;
    for (let y = 0; y < dimension - 1; y++) {
      current = matrix.bitAt(0, y);
      last = current;
      run = 1;
      runTest = current;
      finderPattern = current;
      for (let x = 1; x < 10; x++) {
        current = matrix.bitAt(x, y);
        if (last === current) {
          if (matrix.bitAt(x, y + 1) === last && matrix.bitAt(x - 1, y + 1) === last) penalty += 3;
        } else {
          last = current;
        }
        if (runTest === current) {
          run++;
        } else {
          if (run > 4) penalty += run - 2;
          run = 1;
          runTest = current;
        }
        finderPattern = finderPattern * 2 + current;
      }
      for (let x = 10; x < dimension; x++) {
        current = matrix.bitAt(x, y);
        if (last === current) {
          if (matrix.bitAt(x, y + 1) === last && matrix.bitAt(x - 1, y + 1) === last) penalty += 3;
        } else {
          last = current;
        }
        if (runTest === current) {
          run++;
        } else {
          if (run > 4) penalty += run - 2;
          run = 1;
          runTest = current;
        }
        finderPattern = (finderPattern * 2 + current) % 2048;
        if (finderPattern === 1488 || finderPattern === 93) penalty += 40;
      }
      if (run > 4) penalty += run - 2;
    }
    // Process the last row without Penalty 2
    let lastY = dimension - 1;
    current = matrix.bitAt(0, lastY);
    run = 1;
    runTest = current;
    finderPattern = current;
    for (let x = 1; x < 10; x++) {
      current = matrix.bitAt(x, lastY);
      if (runTest === current) {
        run++;
      } else {
        if (run > 4) penalty += run - 2;
        run = 1;
        runTest = current;
      }
      finderPattern = finderPattern * 2 + current;
    }
    for (let x = 10; x < dimension; x++) {
      current = matrix.bitAt(x, lastY);
      if (runTest === current) {
        run++;
      } else {
        if (run > 4) penalty += run - 2;
        run = 1;
        runTest = current;
      }
      finderPattern = (finderPattern * 2 + current) % 2048;
      if (finderPattern === 1488 || finderPattern === 93) penalty += 40;
    }
    if (run > 4) penalty += run - 2;
    // Penalty 4
    let count = 0;
    for (let x = 0; x < dimension; x++) {
      current = matrix.bitAt(x, 0);
      count += current;
      run = 1;
      runTest = current;
      finderPattern = current;
      for (let y = 1; y < 10; y++) {
        current = matrix.bitAt(x, y);
        count += current;
        if (runTest === current) {
          run++;
        } else {
          if (run > 4) penalty += run - 2;
          run = 1;
          runTest = current;
        }
        finderPattern = finderPattern * 2 + current;
      }
      for (let y = 10; y < dimension; y++) {
        current = matrix.bitAt(x, y);
        count += current;
        if (runTest === current) {
          run++;
        } else {
          if (run > 4) penalty += run - 2;
          run = 1;
          runTest = current;
        }
        finderPattern = (finderPattern * 2 + current) % 2048;
        if (finderPattern === 1488 || finderPattern === 93) penalty += 40;
      }
      if (run > 4) penalty += run - 2;
    }
    penalty += Math.floor(Math.abs(count / (dimension * dimension) - 0.5) * 10);
    return penalty;
  }

  toUtf16Bytes(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
      let code = string.charCodeAt(i);
      let remainder = code % 256;
      let quotient = (code - remainder) / 256;
      bytes.push(quotient);
      bytes.push(remainder);
    }
    return bytes;
  }

  toUtf8Bytes(string) {
    const bytes = [];
    let position = 0;
    for (let i = 0; i < string.length; i++) {
      let code = string.charCodeAt(i);
      if (code < 128) {
        bytes[position++] = code;
      } else if (code < 2048) {
        bytes[position++] = (code >> 6) | 192;
        bytes[position++] = (code & 63) | 128;
      } else if ((code & 0xfc00) == 0xd800 && i + 1 < string.length && (string.charCodeAt(i + 1) & 0xfc00) == 0xdc00) {
        // Surrogate Pair
        code = 0x10000 + ((code & 0x03ff) << 10) + (string.charCodeAt(++i) & 0x03ff);
        bytes[position++] = (code >> 18) | 240;
        bytes[position++] = ((code >> 12) & 63) | 128;
        bytes[position++] = ((code >> 6) & 63) | 128;
        bytes[position++] = (code & 63) | 128;
      } else {
        bytes[position++] = (code >> 12) | 224;
        bytes[position++] = ((code >> 6) & 63) | 128;
        bytes[position++] = (code & 63) | 128;
      }
    }
    return bytes;
  }

  versionForLength(length, errorCorrection) {
    let capacity;
    if (this.code.hasEci) {
      capacity = DATA_CAPACITY[errorCorrection];
    } else {
      capacity = this.capacity(this.code.encoding, errorCorrection);
    }
    let index = capacity.findIndex((allows) => allows >= length);
    if (index === -1) return 100;
    return index + 1;
  }
}

var qrcode = {
  ENCODING,
  ERROR_CORRECTION,
  BitWriter,
  Matrix: Matrix$1,
  BooleanMatrix,
  QRCodeMap,
  QRCode: QRCode$1,
  QRCodeEncoder: QRCodeEncoder$1,
};

const { QRCode, QRCodeEncoder } = qrcode;

/**
 * CLASS SquareQRCodeEncoder
 * While it can render an SVG, it mainly provides a base encoder for MarketQRCodeEncoder and EmbedQRCodeEncoder.
 * It adds these features to QRCodeEncoder:
 *   - svg rendering using the Turtle to edge trace data
 *   - hooks for adjusting the data for turtle rendering
 *   - using lowestPenalty calculation to make sure the code can be read
 *   - some base methods for SVG rendering
 * The following options can be specified:
 *   border          boolean (default false) whether to add a 4-pixel quiet zone
 *   invert          boolean (default false) light data on dark background when on
 *   styleBackground string to override style inserted in SVG background rectangle
 *   styleForeground string to override style inserted in SVG foreground data and patterns
 */
class SquareQRCodeEncoder$1 extends QRCodeEncoder {
  encode() {
    this.initializeEncoding();
    for (const errorCorrection of this.errorCorrections) {
      this.code.errorCorrection = errorCorrection;
      this.initializeVersion();
      if (this.code.version < this.minimumVersion) continue;
      this.initializeCodewords();
      this.initializeMapping();
      this.initializeMasking();
      if (this.lowestPenalty < this.constructor.PENALTY_FOR_NEGATIVE_CAPACITY) {
        this.initializeTurtleData();
        this.initializeSvg();
        return;
      }
    }
    // go up in version, keep H errorCorrection
    const start = Math.max(this.minimumVersion, this.code.version + 1);
    for (let version = start; version <= QRCode.MAX_VERSION; version++) {
      this.code.version = version;
      this.initializeCodewords();
      this.initializeMapping();
      this.initializeMasking();
      if (this.lowestPenalty < this.constructor.PENALTY_FOR_NEGATIVE_CAPACITY) {
        this.initializeTurtleData();
        this.initializeSvg();
        return;
      }
    }
  }

  initializeSvg() {
    const offset = this.svgOffset;
    const dimension = this.svgDimension;
    const foregroundStyle = this.svgForegroundStyle;
    const backgroundStyle = this.svgBackgroundStyle;
    const source = [];
    source.push(this.svgTag(dimension));
    source.push('<defs>');
    source.push(this.svgFinderPattern(foregroundStyle));
    source.push('</defs>');
    source.push(this.svgBackground(backgroundStyle, dimension, offset === 0 ? undefined : offset / 2));
    this.svgFinderPatterns(source, offset);
    this.svgTurtle(source, foregroundStyle, offset);
    source.push('</svg>');
    this.svg = source.join('');
  }

  initializeTurtleData() {
    // add timing and alignment patterns as data
    const data = this.code.data.copy();
    for (const point of this.code.timingPatternPositions) {
      data.put(point.x, point.y, true);
    }
    for (const point of this.code.alignmentPatternPositions) {
      data.fillAlignmentPatternAt(point.x, point.y);
    }
    this.turtleData = data;
  }

  get inverted() {
    const inverted = this.code.options.invert;
    if (inverted === undefined) return false;
    return inverted;
  }

  get hasBorder() {
    const hasBorder = this.code.options.border;
    if (hasBorder === undefined) return false;
    return hasBorder;
  }

  get minimumVersion() {
    return 1;
  }

  async png() {
    if (this._png !== undefined) return this._png;
    if (this.svg === undefined) throw 'no SVG to convert to PNG';
    const image = new Image();
    const imageBlob = new Blob([this.svg], { type: 'image/svg+xml;charset=utf-8' });
    image.src = URL.createObjectURL(imageBlob);
    await image.decode();
    const dimension = this.svgDimension;
    const canvas = document.createElement('canvas');
    canvas.width = dimension;
    canvas.height = dimension;
    canvas.getContext('2d').drawImage(image, 0, 0, dimension, dimension);
    this._png = canvas.toDataURL();
    return this._png;
  }

  svgBackground(style, dimension, cornerRadius) {
    if (style === '') return '';
    return cornerRadius === undefined
      ? `<rect ${style} x="0" y="0" width="${dimension}" height="${dimension}" />`
      : `<rect ${style} x="0" y="0" width="${dimension}" height="${dimension}" rx="${cornerRadius}" ry="${cornerRadius}" />`;
  }

  get svgBackgroundStyle() {
    const fromOptions = this.code.options.styleBackground;
    if (fromOptions !== undefined) return fromOptions;
    return this.inverted ? 'fill="black"' : 'fill="white"';
  }

  get svgDimension() {
    return 2 * this.svgOffset + 8 * this.code.dimension;
  }

  svgFinderPattern(style) {
    return `<path id="f" ${style} fill-rule="evenodd" d="M 0 10 a10,10 0 0 1 10,-10 h36 a10,10 0 0 1 10,10 v36 a10,10 0 0 1 -10,10 h-36 a10,10 0 0 1 -10,-10 Z M 8 10 a2,2 0 0 1 2,-2 h36 a2,2 0 0 1 2,2 v36 a2,2 0 0 1 -2,2 h-36 a2,2 0 0 1 -2,-2 Z M 16 18 a2,2 0 0 1 2,-2 h20 a2,2 0 0 1 2,2 v20 a2,2 0 0 1 -2,2 h-20 a2,2 0 0 1 -2,-2 Z" />`;
  }

  svgFinderPatterns(source, offset) {
    for (const point of this.code.finderPatternPositions) {
      source.push(`<use xlink:href="#f" x="${point.x * 8 + offset}" y="${point.y * 8 + offset}" />`);
    }
  }

  get svgForegroundStyle() {
    const fromOptions = this.code.options.styleForeground;
    if (fromOptions !== undefined) return fromOptions;
    return this.inverted ? 'fill="white"' : 'fill="black"';
  }

  get svgOffset() {
    return this.hasBorder ? 32 : 0;
  }

  svgTag(dimension) {
    return `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${dimension}" height="${dimension}" viewBox="0 0 ${dimension} ${dimension}">`;
  }

  svgTurtle(source, style, offset) {
    const dimension = this.code.dimension;
    for (let y = 0; y < dimension; y++) {
      for (let x = 0; x < dimension; x++) {
        if (this.turtleData.at(x, y)) {
          source.push(new Turtle(this.turtleData, style, offset, x, y).element);
        }
      }
    }
  }
}
// static variables
SquareQRCodeEncoder$1.PENALTY_FOR_LEFTOVER_CAPACITY = [32, 16, 8, 4, 2, 1];
SquareQRCodeEncoder$1.PENALTY_FOR_NEGATIVE_CAPACITY = 10000;

/**
 * CLASS Turtle
 * This is used to draw a path at a point, drawing both the outline and any cutouts.
 *   data            the BooleanMatrix of encoded data, along with the format and version information
 *   style           injected into the SVG element
 *   offset          how many SVG pixels to offset the topleft corner
 *   x               the x coordinate of the pixel to start from
 *   y               the y coordinate of the pixel to start from
 * It is only exported to be used in tests.
 */
class Turtle {
  constructor(data, style, offset, x, y) {
    this.data = data;
    this.dimension = data.width;
    this.style = style || '';
    this.offset = offset || 0;
    this.start = { x, y };
    this.visitedLocations = new Set();
    this.generateElement();
    this.clearVisited();
  }

  clearVisited() {
    this.visitedLocations.forEach((location) => {
      const point = this.fromLocation(location);
      this.data.put(point.x, point.y, false);
    });
  }

  get element() {
    return this._element;
  }

  fromLocation(location) {
    const x = location % this.dimension;
    const y = (location - x) / this.dimension;
    return { x, y };
  }

  generateElement() {
    // build outside edges
    const startX = this.start.x;
    const startY = this.start.y;
    const startEdge = 'left';
    let x = startX;
    let y = startY;
    const outsideEdges = [];
    outsideEdges.push(startEdge);
    let edge = 'top';
    const tops = new Set();
    const rights = new Set();
    const bottoms = new Set();
    const lefts = new Set();
    lefts.add(this.toLocation(x, y));
    while (!(x === startX && y === startY && edge === startEdge)) {
      outsideEdges.push(edge);
      const location = this.toLocation(x, y);
      this.visitLocation(location);
      switch (edge) {
        case 'top':
          tops.add(location);
          if (!this.hasPixelAtCoordinate(x + 1, y)) {
            edge = 'right';
          } else if (this.hasPixelAtCoordinate(x + 1, y - 1)) {
            x += 1;
            y -= 1;
            edge = 'left';
          } else {
            x += 1;
          }
          break;
        case 'right':
          rights.add(location);
          if (!this.hasPixelAtCoordinate(x, y + 1)) {
            edge = 'bottom';
          } else if (this.hasPixelAtCoordinate(x + 1, y + 1)) {
            x += 1;
            y += 1;
            edge = 'top';
          } else {
            y += 1;
          }
          break;
        case 'bottom':
          bottoms.add(location);
          if (!this.hasPixelAtCoordinate(x - 1, y)) {
            edge = 'left';
          } else if (this.hasPixelAtCoordinate(x - 1, y + 1)) {
            x -= 1;
            y += 1;
            edge = 'right';
          } else {
            x -= 1;
          }
          break;
        case 'left':
          lefts.add(location);
          if (!this.hasPixelAtCoordinate(x, y - 1)) {
            edge = 'top';
          } else if (this.hasPixelAtCoordinate(x - 1, y - 1)) {
            x -= 1;
            y -= 1;
            edge = 'bottom';
          } else {
            y -= 1;
          }
          break;
      }
    }
    // render outside edges
    if (outsideEdges.length === 4) {
      // if it only a single pixel, just make it a rectangle
      this._element = `<rect ${this.style} x="${startX * 8 + this.offset}" y="${
        startY * 8 + this.offset
      }" width="8" height="8" rx="2" ry="2" />`;
      return;
    }
    let d = [];
    d.push(`M${startX * 8 + this.offset + 1} ${startY * 8 + this.offset + 4}`);
    let next = outsideEdges[0];
    outsideEdges.push(next);
    let now;
    let length = 0;
    for (let i = 1; i < outsideEdges.length; i++) {
      now = next;
      next = outsideEdges[i];
      if (now === next) {
        length += 8;
      } else if (now === 'top' && next === 'right') {
        if (length !== 0) {
          d.push(`h${length}`);
          length = 0;
        }
        d.push('a3,3 0 0 1 3,3');
      } else if (now === 'right' && next === 'bottom') {
        if (length !== 0) {
          d.push(`v${length}`);
          length = 0;
        }
        d.push('a3,3 0 0 1 -3,3');
      } else if (now === 'bottom' && next === 'left') {
        if (length !== 0) {
          d.push(`h-${length}`);
          length = 0;
        }
        d.push('a3,3 0 0 1 -3,-3');
      } else if (now === 'left' && next === 'top') {
        if (length !== 0) {
          d.push(`v-${length}`);
          length = 0;
        }
        d.push('a3,3 0 0 1 3,-3');
      } else if (now === 'top' && next === 'left') {
        d.push(`h${length + 5}`);
        length = 5;
      } else if (now === 'right' && next === 'top') {
        d.push(`v${length + 5}`);
        length = 5;
      } else if (now === 'bottom' && next === 'right') {
        d.push(`h-${length + 5}`);
        length = 5;
      } else if (now === 'left' && next === 'bottom') {
        d.push(`v-${length + 5}`);
        length = 5;
      }
    }
    if (length > 0) d.push(`v-${length}`);
    d.push('z');
    // determine the interior pixels
    let interior = new Set();
    let process = new Set();
    this.visitedLocations.forEach((location) => {
      if (!tops.has(location)) process.add(location - this.dimension);
      if (!lefts.has(location)) process.add(location - 1);
      if (!bottoms.has(location)) process.add(location + this.dimension);
      if (!rights.has(location)) process.add(location + 1);
    });
    process = [...process].filter((location) => !this.hasVisitedLocation(location));
    while (process.length > 0) {
      let fanOutFrom = [];
      process.forEach((location) => {
        if (this.hasPixelAtLocation(location)) {
          this.visitLocation(location);
          fanOutFrom.push(location);
        } else {
          interior.add(location);
        }
      });
      process = new Set();
      fanOutFrom.forEach((location) => {
        process.add(location - this.dimension);
        process.add(location + this.dimension);
        process.add(location + 1);
        process.add(location - 1);
      });
      process = [...process].filter((location) => !this.hasVisitedLocation(location));
    }
    while (interior.size > 0) {
      // determine and move to the top right
      let topRight, topRightX, topRightY;
      interior.forEach((location) => {
        x = location % this.dimension;
        y = (location - x) / this.dimension;
        if (topRight === undefined || y < topRightY || (y === topRightY && x > topRightX)) {
          topRight = location;
          topRightX = x;
          topRightY = y;
        }
      });
      d.push(`M${topRightX * 8 + this.offset + 9} ${topRightY * 8 + this.offset - 1}`);
      // move counterclockwise to remove interior
      x = topRightX;
      y = topRightY;
      edge = 'top';
      let distance = 5;
      while (!(x === topRightX && y === topRightY && edge === 'right')) {
        const location = this.toLocation(x, y);
        interior.delete(location);
        switch (edge) {
          case 'top':
            if (!this.hasPixelAtCoordinate(x - 1, y - 1)) {
              if (distance > 0) d.push(`h-${distance}`);
              d.push('a3,3 0 0 1 -3,-3');
              distance = 0;
              edge = 'right';
              x--;
              y--;
            } else if (!this.hasPixelAtCoordinate(x - 1, y)) {
              distance += 8;
              x--;
            } else {
              d.push(`h-${distance + 5}`);
              distance = 5;
              edge = 'left';
            }
            break;
          case 'left':
            if (!this.hasPixelAtCoordinate(x - 1, y + 1)) {
              if (distance > 0) d.push(`v${distance}`);
              d.push('a3,3 0 0 1 -3,3');
              distance = 0;
              edge = 'top';
              x--;
              y++;
            } else if (!this.hasPixelAtCoordinate(x, y + 1)) {
              distance += 8;
              y++;
            } else {
              d.push(`v${distance + 5}`);
              distance = 5;
              edge = 'bottom';
            }
            break;
          case 'bottom':
            if (!this.hasPixelAtCoordinate(x + 1, y + 1)) {
              if (distance > 0) d.push(`h${distance}`);
              d.push('a3,3 0 0 1 3,3');
              distance = 0;
              edge = 'left';
              x++;
              y++;
            } else if (!this.hasPixelAtCoordinate(x + 1, y)) {
              distance += 8;
              x++;
            } else {
              d.push(`h${distance + 5}`);
              distance = 5;
              edge = 'right';
            }
            break;
          case 'right':
            if (!this.hasPixelAtCoordinate(x + 1, y - 1)) {
              if (distance > 0) d.push(`v-${distance}`);
              d.push('a3,3 0 0 1 3,-3');
              distance = 0;
              edge = 'bottom';
              x++;
              y--;
            } else if (!this.hasPixelAtCoordinate(x, y - 1)) {
              distance += 8;
              y--;
            } else {
              d.push(`v-${distance + 5}`);
              distance = 5;
              edge = 'top';
            }
            break;
        }
      }
      d.push(`v-${distance + 5}`);
      d.push('z');
    }
    this._element = `<path ${this.style} d="${d.join('')}" />`;
  }

  hasPixelAtCoordinate(x, y) {
    if (x >= this.dimension || x < 0 || y >= this.dimension || y < 0) return false;
    return this.data.at(x, y);
  }

  hasPixelAtLocation(location) {
    const x = location % this.dimension;
    const y = (location - x) / this.dimension;
    return this.data.at(x, y);
  }

  hasVisitedCoordinate(x, y) {
    return this.hasVisitedLocation(this.toLocation(x, y));
  }

  hasVisitedLocation(location) {
    return this.visitedLocations.has(location);
  }

  toLocation(x, y) {
    return this.dimension * y + x;
  }

  visitCoordinate(x, y) {
    this.visitLocation(this.toLocation(x, y));
  }

  visitLocation(location) {
    this.visitedLocations.add(location);
  }
}

var squareQrcode = { SquareQRCodeEncoder: SquareQRCodeEncoder$1, Turtle };

const { Matrix } = qrcode;
const { SquareQRCodeEncoder } = squareQrcode;

const JEWEL_VALUE = Object.freeze({
  AVAILABLE: 'AVAILABLE',
  FALSE: 'FALSE',
  TRUE: 'TRUE',
  UNDECIDED: 'UNDECIDED',
});

/**
 * CLASS MarketQRCodeEncoder
 * This is used to generate an SVG for a QR code with a Square logo embedded in the center.
 * Contact #qrcode-design for design specifics
 * The following options can be specified:
 *   border          boolean (default false) whether to add a 6-pixel quiet zone
 *   invert          boolean (default false) light data on dark background when on
 *   monochrome      boolean (default false) whether to make it all black and white
 *                   This is useful for things like thermal printers that only print black
 *   styleBackground string to override style inserted in SVG background rectangle
 *   styleForeground string to override style inserted in SVG foreground data and patterns
 *   styleLogo       string to override style inserted in SVG for Square jewel
 */
class MarketQRCodeEncoder extends SquareQRCodeEncoder {
  static getJewel() {
    if (this.jewel !== undefined) return this.jewel;
    const jewel = Matrix.withAll(9, 9, JEWEL_VALUE.UNDECIDED);
    // corners are available
    jewel.put(0, 0, JEWEL_VALUE.AVAILABLE);
    jewel.put(0, 8, JEWEL_VALUE.AVAILABLE);
    jewel.put(8, 0, JEWEL_VALUE.AVAILABLE);
    jewel.put(8, 8, JEWEL_VALUE.AVAILABLE);
    // forced false
    for (let offset = 0; offset < 7; offset++) {
      jewel.put(offset + 1, 0, JEWEL_VALUE.FALSE);
      jewel.put(offset + 1, 8, JEWEL_VALUE.FALSE);
      jewel.put(0, offset + 1, JEWEL_VALUE.FALSE);
      jewel.put(8, offset + 1, JEWEL_VALUE.FALSE);
    }
    jewel.put(3, 3, JEWEL_VALUE.FALSE);
    jewel.put(3, 5, JEWEL_VALUE.FALSE);
    jewel.put(5, 3, JEWEL_VALUE.FALSE);
    jewel.put(5, 5, JEWEL_VALUE.FALSE);
    // forced true
    for (let offset = 0; offset < 6; offset++) {
      jewel.put(1 + offset, 1, JEWEL_VALUE.TRUE);
      jewel.put(2 + offset, 7, JEWEL_VALUE.TRUE);
      jewel.put(7, 1 + offset, JEWEL_VALUE.TRUE);
      jewel.put(1, 2 + offset, JEWEL_VALUE.TRUE);
    }
    jewel.put(4, 4, JEWEL_VALUE.TRUE);
    this.jewel = jewel;
    return jewel;
  }

  initializeSvg() {
    // generate the SVG
    const offset = this.svgOffset;
    const dimension = this.svgDimension;
    const foregroundStyle = this.svgForegroundStyle;
    const logoStyle = this.svgLogoStyle;
    const source = [];
    source.push(this.svgTag(dimension));
    source.push('<defs>');
    source.push(this.svgFinderPattern(foregroundStyle));
    source.push(this.svgLogo(logoStyle));
    source.push('</defs>');
    source.push(this.svgBackground(this.svgBackgroundStyle, dimension, offset === 0 ? undefined : 16));
    this.svgFinderPatterns(source, offset);
    this.svgTurtle(source, foregroundStyle, offset);
    // Square logo
    const logoPosition = (this.code.dimension - 7) * 4 + offset;
    source.push(`<use xlink:href="#s" x="${logoPosition}" y="${logoPosition}" />`);
    // finish
    source.push('</svg>');
    this.svg = source.join('');
  }

  initializeTurtleData() {
    super.initializeTurtleData();
    // clear out middle for Square logo
    const start = (this.code.dimension - 9) / 2;
    this.turtleData.fill(start, start + 1, 9, 7, false);
    this.turtleData.fill(start + 1, start, 7, 1, false);
    this.turtleData.fill(start + 1, start + 8, 7, 1, false);
  }

  get isMonochrome() {
    const isMonochrome = this.code.options.monochrome;
    if (isMonochrome === undefined) return false;
    return isMonochrome;
  }

  get minimumVersion() {
    // if the code version is 1, then the jewel would cut out the timing patterns
    return 2;
  }

  penaltyForMatrix(matrix) {
    const errorCorrectionCapacity = this.map.errorCorrectionCapacity;
    const messedUpBytes = errorCorrectionCapacity.map(() => new Set());
    // figure out the messed up bytes based on putting the jewel in the center
    const jewel = this.constructor.getJewel();
    const start = (matrix.content.length - 9) / 2;
    for (let y = 0; y < 9; y++) {
      const yData = y + start;
      for (let x = 0; x < 9; x++) {
        const xData = x + start;
        const pixel = this.map.at(xData, yData);
        if (this.map.isDataPixel(pixel)) {
          switch (jewel.at(x, y)) {
            case JEWEL_VALUE.FALSE:
              if (matrix.at(xData, yData) !== false) messedUpBytes[pixel.chunk].add(pixel.byte);
              break;
            case JEWEL_VALUE.TRUE:
              if (matrix.at(xData, yData) !== true) messedUpBytes[pixel.chunk].add(pixel.byte);
              break;
            case JEWEL_VALUE.UNDECIDED:
              messedUpBytes[pixel.chunk].add(pixel.byte);
              break;
          }
        }
      }
    }
    // calculate penalty based on how many messed up bytes
    let penalty = 0;
    errorCorrectionCapacity.forEach((capacity, index) => {
      const leftoverCapacity = capacity - messedUpBytes[index].size * 2;
      if (leftoverCapacity < 0) {
        penalty += this.constructor.PENALTY_FOR_NEGATIVE_CAPACITY;
      } else if (leftoverCapacity < this.constructor.PENALTY_FOR_LEFTOVER_CAPACITY.length) {
        penalty += this.constructor.PENALTY_FOR_LEFTOVER_CAPACITY[leftoverCapacity];
      }
    });
    // add additional penalties on trying to have the corners be filled
    if (!matrix.at(start, start)) penalty++;
    if (!matrix.at(start, start + 8)) penalty++;
    if (!matrix.at(start + 8, start)) penalty++;
    if (!matrix.at(start + 8, start + 8)) penalty++;
    return penalty;
  }

  get svgForegroundStyle() {
    const fromOptions = this.code.options.styleForeground;
    if (fromOptions !== undefined) return fromOptions;
    if (this.inverted) {
      return this.isMonochrome ? 'fill="white"' : 'fill="white" fill-opacity="0.95"';
    } else {
      return this.isMonochrome ? 'fill="black"' : 'fill="black" fill-opacity="0.9"';
    }
  }

  get svgLogoStyle() {
    if (this.isMonochrome) return this.svgForegroundStyle;
    const fromOptions = this.code.options.styleLogo;
    if (fromOptions !== undefined) return fromOptions;
    return 'fill="#006AFF"';
  }

  svgLogo(style) {
    return `<path id="s" ${style} fill-rule="evenodd" d="M 0 9.8 C 0 3.92 3.92 0 9.8 0 L 46.2 0 C 52.08 0 56 3.92 56 9.8 L 56 46.2 C 56 52.08 52.08 56 46.2 56 L 9.8 56 C 3.92 56 0 52.08 0 46.2 Z M 11.2 14 C 11.2 12.32 12.32 11.2 14 11.2 L 42 11.2 C 43.68 11.2 44.8 12.32 44.8 14 L 44.8 42 C 44.8 43.68 43.68 44.8 42 44.8 L 14 44.8 C 12.32 44.8 11.2 43.68 11.2 42 Z M 21 22.4 C 21 21.7 21.7 21 22.4 21 L 33.6 21 C 34.3 21 35 21.7 35 22.4 L 35 33.6 C 35 34.3 34.3 35 33.6 35 L 22.4 35 C 21.7 35 21 34.3 21 33.6 Z" />`;
  }

  get svgOffset() {
    return this.hasBorder ? 48 : 0;
  }
}

var marketQrcode = { MarketQRCodeEncoder, JEWEL_VALUE };

var qrcodeEncoder = {
  ...marketQrcode,
  ...qrcode,
  ...squareQrcode,
};

const marketQrcodeCss = "/*!@:host*/.sc-market-qrcode-h{display:block}/*!@:host svg .foreground*/.sc-market-qrcode-h svg.sc-market-qrcode .foreground.sc-market-qrcode{fill:var(--qrcode-normal-variant-foreground-color)}/*!@:host svg .background*/.sc-market-qrcode-h svg.sc-market-qrcode .background.sc-market-qrcode{fill:var(--qrcode-normal-variant-background-color)}/*!@:host svg .logo*/.sc-market-qrcode-h svg.sc-market-qrcode .logo.sc-market-qrcode{fill:var(--qrcode-normal-variant-icon-color)}/*!@:host([monochrome]) .foreground*/[monochrome].sc-market-qrcode-h .foreground.sc-market-qrcode{fill:var(--qrcode-monochrome-variant-foreground-color)}/*!@:host([monochrome]) .background*/[monochrome].sc-market-qrcode-h .background.sc-market-qrcode{fill:var(--qrcode-monochrome-variant-background-color)}/*!@:host([monochrome]) .logo*/[monochrome].sc-market-qrcode-h .logo.sc-market-qrcode{fill:var(--qrcode-monochrome-variant-icon-color)}/*!@:host([size]) svg*/[size].sc-market-qrcode-h svg.sc-market-qrcode{width:100%;height:100%}";
var MarketQrcodeStyle0 = marketQrcodeCss;

class MarketQrcode {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.content = '';
        this.size = undefined;
        this.border = false;
        this.monochrome = false;
    }
    render() {
        const encoder = this.content
            ? new qrcodeEncoder.MarketQRCodeEncoder(this.content, {
                border: this.border,
                styleBackground: this.border ? 'class="background"' : '',
                styleForeground: 'class="foreground"',
                styleLogo: 'class="logo"',
            })
            : null;
        const containerStyle = this.size !== undefined
            ? {
                height: `${this.size}px`,
                width: `${this.size}px`,
            }
            : null;
        return (hAsync(Host, { key: '5045d27eb8bd396a873727da5ac09bdabb1dcde9', class: "market-qrcode", "aria-hidden": "true" }, hAsync("div", { key: '661f296b07f7e0278fdeeab78fe6b734a05bcce4', innerHTML: encoder ? encoder.svg : '', style: containerStyle })));
    }
    static get style() { return MarketQrcodeStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-qrcode",
        "$members$": {
            "content": [513],
            "size": [514],
            "border": [4],
            "monochrome": [516]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["content", "content"], ["size", "size"], ["monochrome", "monochrome"]]
    }; }
}

const marketRadioCss = "/*!@:host, ::slotted(*), **/.sc-market-radio-h,.sc-market-radio-s>*,*.sc-market-radio{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-radio-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-radio-h *.sc-market-radio,.sc-market-radio-h[disabled].sc-market-radio-s>*,.sc-market-radio-h[disabled] .sc-market-radio-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-radio-h{--transition-duration:0.2s;--radio-offset:calc(-1 * var(--radio-border-size));--focus-ring-color:color-mix(in srgb, var(--radio-focus-ring-color) 100%, transparent);position:relative;display:inline-block;width:var(--radio-width);height:var(--radio-height);border:var(--radio-border-size) solid var(--radio-normal-state-normal-validity-unselected-value-border-color);border-radius:var(--radio-border-radius);background-color:var(--radio-normal-state-normal-validity-unselected-value-background-color)}/*!@input*/input.sc-market-radio{position:absolute;top:var(--radio-offset);left:var(--radio-offset);width:var(--radio-width);height:var(--radio-height);margin:0;border-radius:var(--radio-border-radius);background:transparent;outline:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@input:focus-visible*/input.sc-market-radio:focus-visible{outline:var(--radio-focus-ring-border-size, var(--core-focus-ring-border-size)) solid var(--focus-ring-color);outline-offset:var(--radio-focus-ring-buffer-size)}/*!@svg*/svg.sc-market-radio{position:absolute;top:calc(50% - var(--radio-svg-radius));left:calc(50% - var(--radio-svg-radius));align-items:center;pointer-events:none}@media (hover: hover){/*!@:host(:hover), :host([hovered])*/.sc-market-radio-h:hover,[hovered].sc-market-radio-h{border-color:var(--radio-hover-state-normal-validity-unselected-value-border-color);background-color:var(--radio-hover-state-normal-validity-unselected-value-background-color)}}/*!@:host(:focus), :host([focused])*/.sc-market-radio-h:focus,[focused].sc-market-radio-h{border-color:var(--radio-focus-state-normal-validity-unselected-value-border-color);background-color:var(--radio-focus-state-normal-validity-unselected-value-background-color)}/*!@:host(:active), :host([active])*/.sc-market-radio-h:active,[active].sc-market-radio-h{border-color:var(--radio-pressed-state-normal-validity-unselected-value-border-color);background-color:var(--radio-pressed-state-normal-validity-unselected-value-background-color)}/*!@:host([invalid])*/[invalid].sc-market-radio-h{border-color:var(--radio-normal-state-invalid-validity-unselected-value-border-color);background-color:var(--radio-normal-state-invalid-validity-unselected-value-background-color)}@media (hover: hover){/*!@:host([invalid]:hover), :host([invalid][hovered])*/[invalid].sc-market-radio-h:hover,[invalid][hovered].sc-market-radio-h{border-color:var(--radio-hover-state-invalid-validity-unselected-value-border-color);background-color:var(--radio-hover-state-invalid-validity-unselected-value-background-color)}}/*!@:host([invalid]:focus), :host([invalid][focused])*/[invalid].sc-market-radio-h:focus,[invalid][focused].sc-market-radio-h{border-color:var(--radio-focus-state-invalid-validity-unselected-value-border-color);background-color:var(--radio-focus-state-invalid-validity-unselected-value-background-color)}/*!@:host([invalid]:active), :host([invalid][active])*/[invalid].sc-market-radio-h:active,[invalid][active].sc-market-radio-h{border-color:var(--radio-pressed-state-invalid-validity-unselected-value-border-color);background-color:var(--radio-pressed-state-invalid-validity-unselected-value-background-color)}/*!@:host([disabled]), :host([invalid][disabled])*/[disabled].sc-market-radio-h,[invalid][disabled].sc-market-radio-h{border-color:var(--radio-disabled-state-normal-validity-unselected-value-border-color);background-color:var(--radio-disabled-state-normal-validity-unselected-value-background-color)}/*!@:host([selected])*/[selected].sc-market-radio-h{border-color:var(--radio-normal-state-normal-validity-selected-value-border-color);background-color:var(--radio-normal-state-normal-validity-selected-value-background-color)}/*!@:host([selected]) svg*/[selected].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-normal-state-normal-validity-selected-value-icon-color)}@media (hover: hover){/*!@:host([selected]:hover), :host([selected][hovered])*/[selected].sc-market-radio-h:hover,[selected][hovered].sc-market-radio-h{border-color:var(--radio-hover-state-normal-validity-selected-value-border-color);background-color:var(--radio-hover-state-normal-validity-selected-value-background-color)}/*!@:host([selected]:hover) svg, :host([selected][hovered]) svg*/[selected].sc-market-radio-h:hover svg.sc-market-radio,[selected][hovered].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-normal-state-normal-validity-selected-value-icon-color)}}/*!@:host([selected]:focus), :host([selected][focused])*/[selected].sc-market-radio-h:focus,[selected][focused].sc-market-radio-h{border-color:var(--radio-focus-state-normal-validity-selected-value-border-color);background-color:var(--radio-focus-state-normal-validity-selected-value-background-color)}/*!@:host([selected]:focus) svg, :host([selected][focused]) svg*/[selected].sc-market-radio-h:focus svg.sc-market-radio,[selected][focused].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-focus-state-normal-validity-selected-value-icon-color)}/*!@:host([selected]:active), :host([selected][active])*/[selected].sc-market-radio-h:active,[selected][active].sc-market-radio-h{border-color:var(--radio-pressed-state-normal-validity-selected-value-border-color);background-color:var(--radio-pressed-state-normal-validity-selected-value-background-color)}/*!@:host([selected]:active) svg, :host([selected][active]) svg*/[selected].sc-market-radio-h:active svg.sc-market-radio,[selected][active].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-pressed-state-normal-validity-selected-value-icon-color)}/*!@:host([invalid][selected])*/[invalid][selected].sc-market-radio-h{border-color:var(--radio-normal-state-invalid-validity-selected-value-border-color);background-color:var(--radio-normal-state-invalid-validity-selected-value-background-color)}/*!@:host([invalid][selected]) svg*/[invalid][selected].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-normal-state-invalid-validity-selected-value-icon-color)}@media (hover: hover){/*!@:host([invalid][selected]:hover), :host([invalid][selected][hovered])*/[invalid][selected].sc-market-radio-h:hover,[invalid][selected][hovered].sc-market-radio-h{border-color:var(--radio-hover-state-invalid-validity-selected-value-border-color);background-color:var(--radio-hover-state-invalid-validity-selected-value-background-color)}/*!@:host([invalid][selected]:hover) svg, :host([invalid][selected][hovered]) svg*/[invalid][selected].sc-market-radio-h:hover svg.sc-market-radio,[invalid][selected][hovered].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-hover-state-invalid-validity-selected-value-icon-color)}}/*!@:host([invalid][selected]:focus), :host([invalid][selected][focused])*/[invalid][selected].sc-market-radio-h:focus,[invalid][selected][focused].sc-market-radio-h{border-color:var(--radio-focus-state-invalid-validity-selected-value-border-color);background-color:var(--radio-focus-state-invalid-validity-selected-value-background-color)}/*!@:host([invalid][selected]:focus) svg, :host([invalid][selected][focused]) svg*/[invalid][selected].sc-market-radio-h:focus svg.sc-market-radio,[invalid][selected][focused].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-focus-state-invalid-validity-selected-value-icon-color)}/*!@:host([invalid][selected]:active), :host([invalid][selected][active])*/[invalid][selected].sc-market-radio-h:active,[invalid][selected][active].sc-market-radio-h{border-color:var(--radio-pressed-state-invalid-validity-selected-value-border-color);background-color:var(--radio-pressed-state-invalid-validity-selected-value-background-color)}/*!@:host([invalid][selected]:active) svg, :host([invalid][selected][active]) svg*/[invalid][selected].sc-market-radio-h:active svg.sc-market-radio,[invalid][selected][active].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-pressed-state-invalid-validity-selected-value-icon-color)}/*!@:host([selected][disabled]), :host([selected][disabled][invalid])*/[selected][disabled].sc-market-radio-h,[selected][disabled][invalid].sc-market-radio-h{border-color:var(--radio-disabled-state-normal-validity-selected-value-border-color);background-color:var(--radio-disabled-state-normal-validity-selected-value-background-color)}/*!@:host([selected][disabled]) svg, :host([selected][disabled][invalid]) svg*/[selected][disabled].sc-market-radio-h svg.sc-market-radio,[selected][disabled][invalid].sc-market-radio-h svg.sc-market-radio{fill:var(--radio-disabled-state-normal-validity-selected-value-icon-color)}";
var MarketRadioStyle0 = marketRadioCss;

class MarketRadio {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketRadioValueChange = createEvent(this, "marketRadioValueChange", 7);
        this.selected = false;
        this.disabled = false;
        this.invalid = false;
        this.focused = false;
        this.hovered = false;
        this.active = false;
    }
    /**
     * Toggles `selected` prop, and emits a change event accordingly.
     * Used by `market-row` to sync its selected state w/ slotted radio buttons.
     */
    setSelection(newValue, { silent = false } = {}) {
        const { marketRadioValueChange, selected: prevValue, innerInput } = this;
        if (typeof newValue !== 'boolean')
            return Promise.resolve();
        if (prevValue === newValue)
            return Promise.resolve();
        if (!silent) {
            const { defaultPrevented } = marketRadioValueChange.emit({
                current: newValue,
                previous: prevValue,
            });
            if (defaultPrevented) {
                return Promise.resolve();
            }
        }
        this.selected = newValue;
        // When using the non-lazy output target, this method sometimes gets called from
        // market-row's watcher before/after innerInput is removed, hence this check.
        if (innerInput) {
            innerInput.checked = newValue;
        }
        return Promise.resolve();
    }
    /**
     * DEPRECATED (3.x): Toggles `selected` state (unrelated to the HTML attribute `value`).
     */
    setValue(newValue) {
        /* eslint-disable-next-line no-console */
        console.warn("market-radio's setValue() method has been deprecated. Use setSelection() instead.", this.el);
        this.setSelection(newValue);
        return Promise.resolve();
    }
    /**
     * Sets `active` state. Allows external elements to programmatically
     * trigger active styling, ex. when slotted as a control into `market-row`.
     */
    setActive(value) {
        this.active = value;
        return Promise.resolve();
    }
    /**
     * Sets `hovered` state. Allows external elements to programmatically
     * trigger hover styling, ex. when slotted as a control into `market-row`.
     */
    setHover(value) {
        this.hovered = value;
        return Promise.resolve();
    }
    /**
     * Sets `disabled` state. Allows external elements to programmatically
     * trigger disabled styling, ex. when slotted as a control into `market-row`.
     */
    setDisabled(value) {
        this.disabled = value;
        return Promise.resolve();
    }
    /**
     * Sets `focused` state, except when disabled.
     * Allows external consumers to programmatically
     * trigger focused styling.
     */
    setFocus(value = true) {
        if (this.disabled) {
            return Promise.resolve();
        }
        this.focused = value;
        return Promise.resolve();
    }
    onFocus() {
        if (this.disabled) {
            return;
        }
        this.focused = true;
        this.el.shadowRoot.querySelector('input').focus();
    }
    handleClick(event) {
        // Always prevent default so we can manually control the selection
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        // once a radio is selected, it shouldn't be togglable/deselectable on click
        if (!this.selected) {
            this.setFocus();
            this.setSelection(true);
        }
    }
    render() {
        return (hAsync(Host, { key: 'e4bc0538b6c3c6fb1d384cf4f4e500f34d4e0fb3', class: "market-radio", onBlur: () => {
                this.setFocus(false);
            }, onClick: this.handleClick, onFocus: () => {
                this.setFocus();
            } }, hAsync("input", { key: '5150cbff8f7852b9541a7078551f6e30436e28ce', ref: (el) => (this.innerInput = el), type: "radio", "aria-label": getControlInputAriaLabel(this.el), checked: this.selected, disabled: this.disabled }), this.selected && (hAsync("svg", { key: '0051115cef2bf8e95ec556ecc3a9b81d32fbf7db', width: "6", height: "6", viewBox: "0 0 6 6", xmlns: "http://www.w3.org/2000/svg" }, hAsync("circle", { key: '9a8a954420a18075bfed037d82dfbb0467cb7823', cx: "3", cy: "3", r: "3" })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketRadioStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-radio",
        "$members$": {
            "selected": [1540],
            "disabled": [1540],
            "invalid": [516],
            "focused": [1540],
            "hovered": [1540],
            "active": [1540],
            "setSelection": [64],
            "setValue": [64],
            "setActive": [64],
            "setHover": [64],
            "setDisabled": [64],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selected", "selected"], ["disabled", "disabled"], ["invalid", "invalid"], ["focused", "focused"], ["hovered", "hovered"], ["active", "active"]]
    }; }
}

/**
 * @param {unknown} el - Element to be checked
 * @returns {boolean} Whether `el` is a `TMarketRowValidControlElement`
 */
function isValidRowControl(el) {
    return isCheckboxElement(el) || isRadioElement(el) || isToggleElement(el);
}

const marketRowCss = "/*!@:host, ::slotted(*), **/.sc-market-row-h,.sc-market-row-s>*,*.sc-market-row{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-row-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-row-h *.sc-market-row,.sc-market-row-h[disabled].sc-market-row-s>*,.sc-market-row-h[disabled] .sc-market-row-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-row-h{--transition-duration:0.2s;--row-horizontal-spacing:16px;position:relative;display:block;margin:0 calc(-1 * var(--row-normal-variant-background-horizontal-outset-padding));background-color:var(--row-normal-variant-normal-state-background-color);transition:background-color var(--transition-duration)}/*!@:host::before*/.sc-market-row-h::before{content:\"\";position:absolute;right:var(--row-normal-variant-background-horizontal-outset-padding);bottom:0;left:var(--row-normal-variant-background-horizontal-outset-padding);display:block;height:var(--row-normal-variant-separator-height);background-color:var(--row-normal-variant-normal-state-separator-color)}/*!@:host(:last-of-type)::before*/.sc-market-row-h:last-of-type::before{content:none}/*!@.container*/.container.sc-market-row{display:flex;justify-content:space-between;align-items:center;height:100%;padding-right:var(--row-normal-variant-background-horizontal-outset-padding);padding-left:var(--row-normal-variant-background-horizontal-outset-padding);outline:none;text-decoration:none;-moz-column-gap:var(--row-horizontal-spacing);column-gap:var(--row-horizontal-spacing)}/*!@.main*/.main.sc-market-row{display:flex;flex-grow:2;flex-direction:column;min-width:0}/*!@.side*/.side.sc-market-row{display:flex;flex-direction:column;text-align:right}/*!@.drill-icon*/.drill-icon.sc-market-row{flex-shrink:0;fill:var(--row-normal-variant-normal-state-drill-color)}/*!@.hidden*/.hidden.sc-market-row{display:none}/*!@::slotted(*)*/.sc-market-row-s>*{cursor:inherit}/*!@::slotted([slot=\"label\"])*/.sc-market-row-s>[slot=\"label\"]{display:block;margin:0;color:var(--row-normal-variant-normal-state-text-color)}/*!@::slotted([slot=\"subtext\"])*/.sc-market-row-s>[slot=\"subtext\"]{display:block;margin:0;color:var(--row-normal-variant-normal-state-subtext-color)}/*!@::slotted([slot=\"side-label\"])*/.sc-market-row-s>[slot=\"side-label\"]{display:block;margin:0;color:var(--row-normal-variant-normal-state-side-text-primary-color)}/*!@::slotted([slot=\"side-subtext\"])*/.sc-market-row-s>[slot=\"side-subtext\"]{display:block;margin:0;color:var(--row-normal-variant-normal-state-side-text-secondary-color)}/*!@::slotted([slot=\"control\"]), ::slotted([slot=\"leading-accessory\"]), ::slotted([slot=\"trailing-accessory\"])*/.sc-market-row-s>[slot=\"control\"],.sc-market-row-s>[slot=\"leading-accessory\"],.sc-market-row-s>[slot=\"trailing-accessory\"]{flex-shrink:0}/*!@:host(.market-drag-placeholder)::before*/.market-drag-placeholder.sc-market-row-h::before{content:\"\" !important;top:0;bottom:0;display:block !important;height:auto;background-color:var(--core-fill-50-color)}/*!@:host(.market-drag-placeholder) .market-drag-handle*/.market-drag-placeholder.sc-market-row-h .market-drag-handle.sc-market-row{pointer-events:none}/*!@:host(.market-drag-placeholder) *, :host(.market-drag-placeholder) ::slotted(*)*/.market-drag-placeholder.sc-market-row-h *.sc-market-row,.sc-market-row-h.market-drag-placeholder.sc-market-row-s>*,.sc-market-row-h.market-drag-placeholder .sc-market-row-s>*{opacity:0%;pointer-events:none}/*!@:host(.market-drag-clone)*/.market-drag-clone.sc-market-row-h{--row-dragged-min-width:240px;width:-moz-fit-content;width:fit-content;min-width:var(--row-dragged-min-width);margin:0;border-radius:var(--row-normal-variant-background-radius);background-color:var(--core-surface-20-color);cursor:grabbing;transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:top, width, height}/*!@:host(.market-drag-clone)::after*/.market-drag-clone.sc-market-row-h::after{content:\"\";position:absolute;inset:0;display:block;border-radius:var(--row-normal-variant-background-radius);box-shadow:var(--elevation-20-shadow);opacity:var(--market-drag-clone-shadow-opacity, 0%);transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:opacity}/*!@:host(.market-drag-clone) .market-drag-handle*/.market-drag-clone.sc-market-row-h .market-drag-handle.sc-market-row{cursor:grabbing}/*!@:host(.market-drag-clone) ::slotted([slot=\"label\"])*/.sc-market-row-h.market-drag-clone .sc-market-row-s>[slot=\"label\"]{overflow:hidden;max-width:var(--row-dragged-min-width);text-overflow:ellipsis;white-space:nowrap}/*!@:host(.market-drag-clone) ::slotted(*:not([slot=\"label\"], [slot=\"leading-accessory\"]))*/.sc-market-row-h.market-drag-clone .sc-market-row-s>*:not([slot=\"label\"],[slot=\"leading-accessory\"]).sc-market-row{display:none}/*!@:host(.market-drag-released)*/.market-drag-released.sc-market-row-h{pointer-events:none;transition-property:top, width, height, transform}/*!@:host([size=\"small\"])*/[size=\"small\"].sc-market-row-h{min-height:var(--row-small-size-min-height, 40px);font-size:var(--row-small-size-text-size);line-height:var(--row-small-size-text-leading);letter-spacing:var(--row-small-size-text-tracking);text-transform:var(--row-small-size-text-case)}/*!@:host([size=\"small\"]) .container*/[size=\"small\"].sc-market-row-h .container.sc-market-row{padding-top:var(--row-small-size-vertical-padding);padding-bottom:var(--row-small-size-vertical-padding)}/*!@:host([size=\"small\"]) .main*/[size=\"small\"].sc-market-row-h .main.sc-market-row{gap:var(--row-small-size-text-vertical-spacing)}/*!@:host([size=\"small\"]) .side*/[size=\"small\"].sc-market-row-h .side.sc-market-row{gap:var(--row-small-size-text-vertical-spacing)}/*!@:host([size=\"small\"]) ::slotted([slot=\"label\"])*/.sc-market-row-h[size=\"small\"] .sc-market-row-s>[slot=\"label\"]{font-weight:var(--row-small-size-text-weight);font-size:var(--row-small-size-text-size);line-height:var(--row-small-size-text-leading);letter-spacing:var(--row-small-size-text-tracking);text-transform:var(--row-small-size-text-case)}/*!@:host([size=\"small\"]) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[size=\"small\"] .sc-market-row-s>[slot=\"subtext\"]{font-weight:var(--row-small-size-subtext-weight);font-size:var(--row-small-size-subtext-size);line-height:var(--row-small-size-subtext-leading);letter-spacing:var(--row-small-size-subtext-tracking);text-transform:var(--row-small-size-subtext-case)}/*!@:host([size=\"small\"]) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[size=\"small\"] .sc-market-row-s>[slot=\"side-label\"]{font-weight:var(--row-small-size-side-text-primary-weight);font-size:var(--row-small-size-side-text-primary-size);line-height:var(--row-small-size-side-text-primary-leading);letter-spacing:var(--row-small-size-side-text-primary-tracking);text-transform:var(--row-small-size-side-text-primary-case)}/*!@:host([size=\"small\"]) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[size=\"small\"] .sc-market-row-s>[slot=\"side-subtext\"]{font-weight:var(--row-small-size-side-text-secondary-weight);font-size:var(--row-small-size-side-text-secondary-size);line-height:var(--row-small-size-side-text-secondary-leading);letter-spacing:var(--row-small-size-side-text-secondary-tracking);text-transform:var(--row-small-size-side-text-secondary-case)}/*!@:host([size=\"medium\"])*/[size=\"medium\"].sc-market-row-h{min-height:var(--row-medium-size-min-height, 56px);font-size:var(--row-medium-size-text-size);line-height:var(--row-medium-size-text-leading);letter-spacing:var(--row-medium-size-text-tracking);text-transform:var(--row-medium-size-text-case)}/*!@:host([size=\"medium\"]) .container*/[size=\"medium\"].sc-market-row-h .container.sc-market-row{padding-top:var(--row-medium-size-vertical-padding);padding-bottom:var(--row-medium-size-vertical-padding)}/*!@:host([size=\"medium\"]) .main*/[size=\"medium\"].sc-market-row-h .main.sc-market-row{gap:var(--row-medium-size-text-vertical-spacing)}/*!@:host([size=\"medium\"]) .side*/[size=\"medium\"].sc-market-row-h .side.sc-market-row{gap:var(--row-medium-size-text-vertical-spacing)}/*!@:host([size=\"medium\"]) ::slotted([slot=\"label\"])*/.sc-market-row-h[size=\"medium\"] .sc-market-row-s>[slot=\"label\"]{font-weight:var(--row-medium-size-text-weight);font-size:var(--row-medium-size-text-size);line-height:var(--row-medium-size-text-leading);letter-spacing:var(--row-medium-size-text-tracking);text-transform:var(--row-medium-size-text-case)}/*!@:host([size=\"medium\"]) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[size=\"medium\"] .sc-market-row-s>[slot=\"subtext\"]{font-weight:var(--row-medium-size-subtext-weight);font-size:var(--row-medium-size-subtext-size);line-height:var(--row-medium-size-subtext-leading);letter-spacing:var(--row-medium-size-subtext-tracking);text-transform:var(--row-medium-size-subtext-case)}/*!@:host([size=\"medium\"]) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[size=\"medium\"] .sc-market-row-s>[slot=\"side-label\"]{font-weight:var(--row-medium-size-side-text-primary-weight);font-size:var(--row-medium-size-side-text-primary-size);line-height:var(--row-medium-size-side-text-primary-leading);letter-spacing:var(--row-medium-size-side-text-primary-tracking);text-transform:var(--row-medium-size-side-text-primary-case)}/*!@:host([size=\"medium\"]) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[size=\"medium\"] .sc-market-row-s>[slot=\"side-subtext\"]{font-weight:var(--row-medium-size-side-text-secondary-weight);font-size:var(--row-medium-size-side-text-secondary-size);line-height:var(--row-medium-size-side-text-secondary-leading);letter-spacing:var(--row-medium-size-side-text-secondary-tracking);text-transform:var(--row-medium-size-side-text-secondary-case)}/*!@:host([interactive]), :host([role=\"option\"])*/[interactive].sc-market-row-h,[role=\"option\"].sc-market-row-h{--focus-ring-color:color-mix(in srgb, var(--row-normal-variant-focus-ring-color) 100%, transparent);border-radius:var(--row-normal-variant-background-radius);outline:none;cursor:pointer}/*!@:host([interactive]) .drill-icon, :host([role=\"option\"]) .drill-icon*/[interactive].sc-market-row-h .drill-icon.sc-market-row,[role=\"option\"].sc-market-row-h .drill-icon.sc-market-row{color:var(--row-normal-variant-normal-state-drill-color)}/*!@.container:focus-visible, :host(:focus-visible) .container, :host(.pseudo-focus) .container*/.container.sc-market-row:focus-visible,.sc-market-row-h:focus-visible .container.sc-market-row,.pseudo-focus.sc-market-row-h .container.sc-market-row{border-radius:var(--row-normal-variant-background-radius);outline:var(--row-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:calc(var(--row-focus-ring-border-size) * -1)}/*!@:host(.preload) ::slotted([slot=\"control\"])*/.sc-market-row-h.preload .sc-market-row-s>[slot=\"control\"]{--row-slotted-control-transition:none}@media (hover: hover){/*!@:host([interactive]:hover), :host([role=\"option\"]:hover)*/[interactive].sc-market-row-h:hover,[role=\"option\"].sc-market-row-h:hover{background-color:var(--row-normal-variant-hover-state-background-color)}/*!@:host([interactive]:hover)::before, :host([role=\"option\"]:hover)::before*/[interactive].sc-market-row-h:hover::before,[role=\"option\"].sc-market-row-h:hover::before{background-color:var(--row-normal-variant-hover-state-separator-color)}/*!@:host([interactive]:hover) .drill-icon, :host([role=\"option\"]:hover) .drill-icon*/[interactive].sc-market-row-h:hover .drill-icon.sc-market-row,[role=\"option\"].sc-market-row-h:hover .drill-icon.sc-market-row{color:var(--row-normal-variant-hover-state-drill-color)}/*!@:host([interactive]:hover) ::slotted([slot=\"label\"]), :host([role=\"option\"]:hover) ::slotted([slot=\"label\"])*/.sc-market-row-h[interactive]:hover .sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"]:hover.sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"]:hover .sc-market-row-s>[slot=\"label\"]{color:var(--row-normal-variant-hover-state-text-color)}/*!@:host([interactive]:hover) ::slotted([slot=\"subtext\"]), :host([role=\"option\"]:hover) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[interactive]:hover .sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"]:hover.sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"]:hover .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-normal-variant-hover-state-subtext-color)}/*!@:host([interactive]:hover) ::slotted([slot=\"side-label\"]), :host([role=\"option\"]:hover) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[interactive]:hover .sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"]:hover.sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"]:hover .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-normal-variant-hover-state-side-text-primary-color)}/*!@:host([interactive]:hover) ::slotted([slot=\"side-subtext\"]), :host([role=\"option\"]:hover) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[interactive]:hover .sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"]:hover.sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"]:hover .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-normal-variant-hover-state-side-text-secondary-color)}}/*!@:host([interactive][selected]:not(.has-slotted-control)), :host([role=\"option\"][selected]:not(.has-slotted-control))*/[interactive][selected].sc-market-row-h:not(.has-slotted-control),[role=\"option\"][selected].sc-market-row-h:not(.has-slotted-control){background-color:var(--row-normal-variant-selected-state-background-color)}/*!@:host([interactive][selected]:not(.has-slotted-control))::before, :host([role=\"option\"][selected]:not(.has-slotted-control))::before*/[interactive][selected].sc-market-row-h:not(.has-slotted-control)::before,[role=\"option\"][selected].sc-market-row-h:not(.has-slotted-control)::before{background-color:var(--row-normal-variant-selected-state-separator-color)}/*!@:host([interactive][selected]:not(.has-slotted-control)) .drill-icon, :host([role=\"option\"][selected]:not(.has-slotted-control)) .drill-icon*/[interactive][selected].sc-market-row-h:not(.has-slotted-control) .drill-icon.sc-market-row,[role=\"option\"][selected].sc-market-row-h:not(.has-slotted-control) .drill-icon.sc-market-row{color:var(--row-normal-variant-selected-state-drill-color)}/*!@:host([interactive][selected]:not(.has-slotted-control)) ::slotted([slot=\"label\"]), :host([role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"label\"])*/.sc-market-row-h[interactive][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control).sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"label\"]{color:var(--row-normal-variant-selected-state-text-color)}/*!@:host([interactive][selected]:not(.has-slotted-control)) ::slotted([slot=\"subtext\"]), :host([role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[interactive][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control).sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-normal-variant-selected-state-subtext-color)}/*!@:host([interactive][selected]:not(.has-slotted-control)) ::slotted([slot=\"side-label\"]), :host([role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[interactive][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control).sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-normal-variant-selected-state-side-text-primary-color)}/*!@:host([interactive][selected]:not(.has-slotted-control)) ::slotted([slot=\"side-subtext\"]), :host([role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[interactive][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control).sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-normal-variant-selected-state-side-text-secondary-color)}/*!@:host([interactive]:active), :host([role=\"option\"]:active)*/[interactive].sc-market-row-h:active,[role=\"option\"].sc-market-row-h:active{background-color:var(--row-normal-variant-pressed-state-background-color)}/*!@:host([interactive]:active)::before, :host([role=\"option\"]:active)::before*/[interactive].sc-market-row-h:active::before,[role=\"option\"].sc-market-row-h:active::before{background-color:var(--row-normal-variant-pressed-state-separator-color)}/*!@:host([interactive]:active) .drill-icon, :host([role=\"option\"]:active) .drill-icon*/[interactive].sc-market-row-h:active .drill-icon.sc-market-row,[role=\"option\"].sc-market-row-h:active .drill-icon.sc-market-row{color:var(--row-normal-variant-pressed-state-drill-color)}/*!@:host([interactive]:active) ::slotted([slot=\"label\"]), :host([role=\"option\"]:active) ::slotted([slot=\"label\"])*/.sc-market-row-h[interactive]:active .sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"]:active.sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"]:active .sc-market-row-s>[slot=\"label\"]{color:var(--row-normal-variant-pressed-state-text-color)}/*!@:host([interactive]:active) ::slotted([slot=\"subtext\"]), :host([role=\"option\"]:active) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[interactive]:active .sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"]:active.sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"]:active .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-normal-variant-pressed-state-subtext-color)}/*!@:host([interactive]:active) ::slotted([slot=\"side-label\"]), :host([role=\"option\"]:active) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[interactive]:active .sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"]:active.sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"]:active .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-normal-variant-pressed-state-side-text-primary-color)}/*!@:host([interactive]:active) ::slotted([slot=\"side-subtext\"]), :host([role=\"option\"]:active) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[interactive]:active .sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"]:active.sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"]:active .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-normal-variant-pressed-state-side-text-secondary-color)}/*!@:host([interactive][disabled]), :host([role=\"option\"][disabled])*/[interactive][disabled].sc-market-row-h,[role=\"option\"][disabled].sc-market-row-h{background-color:var(--row-normal-variant-disabled-state-background-color);color:var(--row-normal-variant-disabled-state-text-color);pointer-events:none}/*!@:host([interactive][disabled])::before, :host([role=\"option\"][disabled])::before*/[interactive][disabled].sc-market-row-h::before,[role=\"option\"][disabled].sc-market-row-h::before{background-color:var(--row-normal-variant-disabled-state-separator-color)}/*!@:host([interactive][disabled]) .drill-icon, :host([role=\"option\"][disabled]) .drill-icon*/[interactive][disabled].sc-market-row-h .drill-icon.sc-market-row,[role=\"option\"][disabled].sc-market-row-h .drill-icon.sc-market-row{color:var(--row-normal-variant-disabled-state-drill-color)}/*!@:host([interactive][disabled]) ::slotted([slot=\"label\"]), :host([role=\"option\"][disabled]) ::slotted([slot=\"label\"])*/.sc-market-row-h[interactive][disabled] .sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>[slot=\"label\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>[slot=\"label\"]{color:var(--row-normal-variant-disabled-state-text-color)}/*!@:host([interactive][disabled]) ::slotted([slot=\"subtext\"]), :host([role=\"option\"][disabled]) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[interactive][disabled] .sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-normal-variant-disabled-state-subtext-color)}/*!@:host([interactive][disabled]) ::slotted([slot=\"side-label\"]), :host([role=\"option\"][disabled]) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[interactive][disabled] .sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-normal-variant-disabled-state-side-text-primary-color)}/*!@:host([interactive][disabled]) ::slotted([slot=\"side-subtext\"]), :host([role=\"option\"][disabled]) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[interactive][disabled] .sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-normal-variant-disabled-state-side-text-secondary-color)}/*!@:host([interactive][disabled]) ::slotted(.market-accessory), :host([interactive][disabled]) ::slotted(img[slot*=\"accessory\"]), :host([interactive][disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([interactive][disabled]) ::slotted(div[slot*=\"accessory\"]), :host([role=\"option\"][disabled]) ::slotted(.market-accessory), :host([role=\"option\"][disabled]) ::slotted(img[slot*=\"accessory\"]), :host([role=\"option\"][disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([role=\"option\"][disabled]) ::slotted(div[slot*=\"accessory\"])*/.sc-market-row-h[interactive][disabled] .sc-market-row-s>.market-accessory,.sc-market-row-h[interactive][disabled].sc-market-row-s>img[slot*=\"accessory\"],.sc-market-row-h[interactive][disabled] .sc-market-row-s>img[slot*=\"accessory\"],.sc-market-row-h[interactive][disabled].sc-market-row-s>svg[slot*=\"accessory\"],.sc-market-row-h[interactive][disabled] .sc-market-row-s>svg[slot*=\"accessory\"],.sc-market-row-h[interactive][disabled].sc-market-row-s>div[slot*=\"accessory\"],.sc-market-row-h[interactive][disabled] .sc-market-row-s>div[slot*=\"accessory\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>.market-accessory,.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>.market-accessory,.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>img[slot*=\"accessory\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>img[slot*=\"accessory\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>svg[slot*=\"accessory\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>svg[slot*=\"accessory\"],.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>div[slot*=\"accessory\"],.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>div[slot*=\"accessory\"]{opacity:var(--row-disabled-state-leading-accessory-opacity)}/*!@:host([interactive][disabled]) ::slotted(.market-tooltip), :host([role=\"option\"][disabled]) ::slotted(.market-tooltip)*/.sc-market-row-h[interactive][disabled] .sc-market-row-s>.market-tooltip,.sc-market-row-h[role=\"option\"][disabled].sc-market-row-s>.market-tooltip,.sc-market-row-h[role=\"option\"][disabled] .sc-market-row-s>.market-tooltip{pointer-events:auto !important}/*!@:host([slot=\"displayed-selection\"])*/[slot=\"displayed-selection\"].sc-market-row-h{pointer-events:none}/*!@:host([slot=\"displayed-selection\"]) .container*/[slot=\"displayed-selection\"].sc-market-row-h .container.sc-market-row{padding:0}/*!@:host([slot=\"displayed-selection\"]) .main*/[slot=\"displayed-selection\"].sc-market-row-h .main.sc-market-row{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}/*!@:host([slot=\"displayed-selection\"]) ::slotted([slot=\"label\"])*/.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"label\"]{overflow:hidden;color:inherit;font-weight:var(--field-input-weight);font-size:inherit;line-height:inherit;text-overflow:ellipsis;white-space:nowrap}/*!@:host([slot=\"displayed-selection\"]) .side*/[slot=\"displayed-selection\"].sc-market-row-h .side.sc-market-row{display:none}/*!@:host([slot=\"displayed-selection\"]) ::slotted([slot=\"subtext\"]), :host([slot=\"displayed-selection\"]) ::slotted([slot=\"side-label\"]), :host([slot=\"displayed-selection\"]) ::slotted([slot=\"side-subtext\"]), :host([slot=\"displayed-selection\"]) ::slotted([slot=\"leading-accessory\"]), :host([slot=\"displayed-selection\"]) ::slotted([slot=\"trailing-accessory\"]), :host([slot=\"displayed-selection\"]) ::slotted([slot=\"control\"])*/.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"subtext\"],.sc-market-row-h[slot=\"displayed-selection\"].sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"side-label\"],.sc-market-row-h[slot=\"displayed-selection\"].sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"side-subtext\"],.sc-market-row-h[slot=\"displayed-selection\"].sc-market-row-s>[slot=\"leading-accessory\"],.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"leading-accessory\"],.sc-market-row-h[slot=\"displayed-selection\"].sc-market-row-s>[slot=\"trailing-accessory\"],.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"trailing-accessory\"],.sc-market-row-h[slot=\"displayed-selection\"].sc-market-row-s>[slot=\"control\"],.sc-market-row-h[slot=\"displayed-selection\"] .sc-market-row-s>[slot=\"control\"]{display:none}/*!@:host([destructive]) ::slotted([slot=\"label\"])*/.sc-market-row-h[destructive] .sc-market-row-s>[slot=\"label\"]{color:var(--row-destructive-variant-normal-state-text-color)}/*!@:host([destructive]) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[destructive] .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-destructive-variant-normal-state-subtext-color)}/*!@:host([destructive]) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[destructive] .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-destructive-variant-normal-state-side-text-primary-color)}/*!@:host([destructive]) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[destructive] .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-destructive-variant-normal-state-side-text-secondary-color)}/*!@:host([destructive][role=\"option\"])*/[destructive][role=\"option\"].sc-market-row-h{border-radius:var(--row-destructive-variant-background-radius)}@media (hover: hover){/*!@:host([destructive][role=\"option\"]:hover)*/[destructive][role=\"option\"].sc-market-row-h:hover{background-color:var(--row-destructive-variant-hover-state-background-color)}/*!@:host([destructive][role=\"option\"]:hover)::before*/[destructive][role=\"option\"].sc-market-row-h:hover::before{background-color:var(--row-destructive-variant-hover-state-separator-color)}/*!@:host([destructive][role=\"option\"]:hover) .drill-icon*/[destructive][role=\"option\"].sc-market-row-h:hover .drill-icon.sc-market-row{fill:var(--row-destructive-variant-hover-state-drill-color)}/*!@:host([destructive][role=\"option\"]:hover) ::slotted([slot=\"label\"])*/.sc-market-row-h[destructive][role=\"option\"]:hover .sc-market-row-s>[slot=\"label\"]{color:var(--row-destructive-variant-hover-state-text-color)}/*!@:host([destructive][role=\"option\"]:hover) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[destructive][role=\"option\"]:hover .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-destructive-variant-hover-state-subtext-color)}/*!@:host([destructive][role=\"option\"]:hover) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[destructive][role=\"option\"]:hover .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-destructive-variant-hover-state-side-text-primary-color)}/*!@:host([destructive][role=\"option\"]:hover) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[destructive][role=\"option\"]:hover .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-destructive-variant-hover-state-side-text-secondary-color)}}/*!@:host([destructive][role=\"option\"]:focus)*/[destructive][role=\"option\"].sc-market-row-h:focus{background-color:var(--row-destructive-variant-focus-state-background-color)}/*!@:host([destructive][role=\"option\"]:focus)::before*/[destructive][role=\"option\"].sc-market-row-h:focus::before{background-color:var(--row-destructive-variant-focus-state-separator-color)}/*!@:host([destructive][role=\"option\"]:focus) .drill-icon*/[destructive][role=\"option\"].sc-market-row-h:focus .drill-icon.sc-market-row{fill:var(--row-destructive-variant-focus-state-drill-color)}/*!@:host([destructive][role=\"option\"]:focus) ::slotted([slot=\"label\"])*/.sc-market-row-h[destructive][role=\"option\"]:focus .sc-market-row-s>[slot=\"label\"]{color:var(--row-destructive-variant-focus-state-text-color)}/*!@:host([destructive][role=\"option\"]:focus) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[destructive][role=\"option\"]:focus .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-destructive-variant-focus-state-subtext-color)}/*!@:host([destructive][role=\"option\"]:focus) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[destructive][role=\"option\"]:focus .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-destructive-variant-focus-state-side-text-primary-color)}/*!@:host([destructive][role=\"option\"]:focus) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[destructive][role=\"option\"]:focus .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-destructive-variant-focus-state-side-text-secondary-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control))*/[destructive][role=\"option\"][selected].sc-market-row-h:not(.has-slotted-control){background-color:var(--row-destructive-variant-selected-state-background-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control))::before*/[destructive][role=\"option\"][selected].sc-market-row-h:not(.has-slotted-control)::before{background-color:var(--row-destructive-variant-selected-state-separator-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control)) .drill-icon*/[destructive][role=\"option\"][selected].sc-market-row-h:not(.has-slotted-control) .drill-icon.sc-market-row{fill:var(--row-destructive-variant-selected-state-drill-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"label\"])*/.sc-market-row-h[destructive][role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"label\"]{color:var(--row-destructive-variant-selected-state-text-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[destructive][role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-destructive-variant-selected-state-subtext-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[destructive][role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-destructive-variant-selected-state-side-text-primary-color)}/*!@:host([destructive][role=\"option\"][selected]:not(.has-slotted-control)) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[destructive][role=\"option\"][selected]:not(.has-slotted-control) .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-destructive-variant-selected-state-side-text-secondary-color)}/*!@:host([destructive][role=\"option\"]:active)*/[destructive][role=\"option\"].sc-market-row-h:active{background-color:var(--row-destructive-variant-pressed-state-background-color)}/*!@:host([destructive][role=\"option\"]:active)::before*/[destructive][role=\"option\"].sc-market-row-h:active::before{background-color:var(--row-destructive-variant-pressed-state-separator-color)}/*!@:host([destructive][role=\"option\"]:active) .drill-icon*/[destructive][role=\"option\"].sc-market-row-h:active .drill-icon.sc-market-row{fill:var(--row-destructive-variant-pressed-state-drill-color)}/*!@:host([destructive][role=\"option\"]:active) ::slotted([slot=\"label\"])*/.sc-market-row-h[destructive][role=\"option\"]:active .sc-market-row-s>[slot=\"label\"]{color:var(--row-destructive-variant-pressed-state-text-color)}/*!@:host([destructive][role=\"option\"]:active) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[destructive][role=\"option\"]:active .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-destructive-variant-pressed-state-subtext-color)}/*!@:host([destructive][role=\"option\"]:active) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[destructive][role=\"option\"]:active .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-destructive-variant-pressed-state-side-text-primary-color)}/*!@:host([destructive][role=\"option\"]:active) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[destructive][role=\"option\"]:active .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-destructive-variant-pressed-state-side-text-secondary-color)}/*!@:host([destructive][role=\"option\"][disabled])*/[destructive][role=\"option\"][disabled].sc-market-row-h{background-color:var(--row-destructive-variant-disabled-state-background-color);color:var(--row-destructive-variant-disabled-state-text-color);pointer-events:none}/*!@:host([destructive][role=\"option\"][disabled])::before*/[destructive][role=\"option\"][disabled].sc-market-row-h::before{background-color:var(--row-destructive-variant-disabled-state-separator-color)}/*!@:host([destructive][role=\"option\"][disabled]) .drill-icon*/[destructive][role=\"option\"][disabled].sc-market-row-h .drill-icon.sc-market-row{fill:var(--row-destructive-variant-disabled-state-drill-color)}/*!@:host([destructive][role=\"option\"][disabled]) ::slotted([slot=\"label\"])*/.sc-market-row-h[destructive][role=\"option\"][disabled] .sc-market-row-s>[slot=\"label\"]{color:var(--row-destructive-variant-disabled-state-text-color)}/*!@:host([destructive][role=\"option\"][disabled]) ::slotted([slot=\"subtext\"])*/.sc-market-row-h[destructive][role=\"option\"][disabled] .sc-market-row-s>[slot=\"subtext\"]{color:var(--row-destructive-variant-disabled-state-subtext-color)}/*!@:host([destructive][role=\"option\"][disabled]) ::slotted([slot=\"side-label\"])*/.sc-market-row-h[destructive][role=\"option\"][disabled] .sc-market-row-s>[slot=\"side-label\"]{color:var(--row-destructive-variant-disabled-state-side-text-primary-color)}/*!@:host([destructive][role=\"option\"][disabled]) ::slotted([slot=\"side-subtext\"])*/.sc-market-row-h[destructive][role=\"option\"][disabled] .sc-market-row-s>[slot=\"side-subtext\"]{color:var(--row-destructive-variant-disabled-state-side-text-secondary-color)}";
var MarketRowStyle0 = marketRowCss;

/**
 * @slot label - Text label for the row
 * @slot subtext - Secondary text for the row
 * @slot side-label - Additional text label to display on the side of the row
 * @slot side-subtext - Secondary text to display on the side of the row
 * @slot control - An interactive control, intended for use with `<market-checkbox>`, `<market-radio>`, or `<market-toggle>`.
 * The row's `selected` prop will set the control's selection state.
 * @slot leading-accessory - An icon set on the left side of the row; intended for use with `<market-accessory>`
 * @slot trailing-accessory - An icon set on the right side of the row; intended for use with `<market-accessory>`
 * @slot - Default slot can take any content, intended as an "escape hatch" for
 * scenarios where rows need to contain more complex HTML content stylable from
 * the light DOM.
 *
 * @part container - Wraps the main and side areas (see below). The outer padding of the row is specified on this element.
 * @part main - Wraps the label and subtext slots, can be used for styling purposes as needed.
 * @part side - Wraps the side-label and side-subtext slots, can be used for styling purposes as needed.
 * @part drag-handle - the drag handle when `dragEnabled` is true.
 */
class MarketRow {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketRowSelected = createEvent(this, "marketRowSelected", 7);
        this.marketRowDeselected = createEvent(this, "marketRowDeselected", 7);
        this.slottedControlEl = undefined;
        this.selected = false;
        this.value = undefined;
        this.disabled = false;
        this.size = 'medium';
        this.interactive = false;
        this.transient = false;
        this.togglable = true;
        this.variant = 'regular';
        this.destructive = false;
        this.controlPosition = 'trailing';
        this.href = undefined;
        this.target = undefined;
        this.dragEnabled = false;
        this.dragHandlePosition = 'trailing';
        this.hasSideText = false;
    }
    /**
     * If a control gets slotted in, set the value to match that of the row
     */
    selectedWatcher(newValue) {
        var _a;
        // prevent the row from being selected if it is transient
        const selected = newValue && this.transient ? false : newValue;
        this.selected = selected;
        (_a = this.slottedControlEl) === null || _a === void 0 ? void 0 : _a.setSelection(selected);
    }
    /**
     * If a control gets slotted in, set the value to match that of the row
     */
    disabledWatcher(newValue) {
        var _a;
        (_a = this.slottedControlEl) === null || _a === void 0 ? void 0 : _a.setDisabled(newValue);
    }
    /**
     * Link rows should not be selectable
     */
    hrefWatcher(newValue) {
        if (!isEmpty(newValue)) {
            this.transient = true;
        }
    }
    /**
     * Drill rows are interactive and transient
     */
    variantWatcher(newValue) {
        if (newValue === 'drill') {
            this.interactive = true;
            this.transient = true;
        }
    }
    /**
     * @internal
     * @private
     *
     * Used for setting the selection state to true without emiting the `marketRowSelected` event.
     */
    async silentlySelect() {
        this.selected = true;
        return Promise.resolve();
    }
    /**
     * @internal
     * @private
     *
     * Used for setting the selection state to false without emiting the `marketRowDeselected` event.
     */
    async silentlyDeselect() {
        this.selected = false;
        return Promise.resolve();
    }
    /**
     * @internal
     * @private
     *
     * Used for manually setting `selected` to true. Generally speaking, it
     * is preferable to avoid using this method and allow `market-row` to
     * manage its own selection state based on user interaction. It should only
     * be used for parent components that need to manage a group of rows, such as
     * `market-list`.
     */
    select() {
        this.selected = true;
        const { defaultPrevented } = this.marketRowSelected.emit({ value: this.value });
        if (defaultPrevented) {
            this.selected = false;
        }
        return Promise.resolve();
    }
    /**
     * @internal
     * @private
     *
     * Used for manually setting `selected` to false. Generally speaking, it
     * is preferable to avoid using this method and allow `market-row` to
     * manage its own selection state based on user interaction. It should only
     * be used for parent components that need to manage a group of rows, such as
     * `market-list`.
     */
    deselect() {
        this.selected = false;
        const { defaultPrevented } = this.marketRowDeselected.emit({ value: this.value });
        if (defaultPrevented) {
            this.selected = true;
        }
        return Promise.resolve();
    }
    /**
     * @internal
     * @private
     *
     * Used for toggling the row's selected state.
     */
    toggle() {
        return !this.selected ? this.select() : this.deselect();
    }
    handleControlSlotChange() {
        var _a;
        this.querySlots();
        if (this.slottedControlEl) {
            this.interactive = true;
            this.selectedWatcher(this.selected);
            this.disabledWatcher(this.disabled);
            const slottedControlLabel = (_a = this.el.querySelector('[slot="label"]')) === null || _a === void 0 ? void 0 : _a.textContent;
            this.slottedControlEl.setAttribute('aria-label', slottedControlLabel);
        }
    }
    setControlActive(value) {
        var _a, _b;
        (_b = (_a = this.slottedControlEl) === null || _a === void 0 ? void 0 : _a.setActive) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    }
    setControlHover(value) {
        var _a, _b;
        (_b = (_a = this.slottedControlEl) === null || _a === void 0 ? void 0 : _a.setHover) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    }
    async handleClick(e) {
        // clicks on links inside row content shouldn't select the row itself
        if (this.disabled ||
            this.transient ||
            !this.interactive ||
            e.target.tagName === 'A' ||
            e.target.tagName === 'BUTTON' ||
            e.target.tagName === getNamespacedTagFor('market-button').toUpperCase() ||
            e.target.tagName === getNamespacedTagFor('market-link').toUpperCase()) {
            return;
        }
        if (this.togglable) {
            await this.toggle();
        }
        else if (!this.selected) {
            await this.select();
        }
        // fixes a weird UI bug where the row keeps its focus when clicked using a mouse
        if (e.type === 'click' && e.pointerType === 'mouse') {
            this.el.blur();
        }
    }
    handleKeydown(e) {
        // don't intercept keydown of descendant elements
        // e.g. when typing into nested input fields (gross)
        if (e.target !== this.el) {
            return;
        }
        if (e.key === ' ') {
            e.preventDefault(); // spacebar should not scroll page
            this.el.click();
        }
        if (e.key === 'Enter') {
            this.el.click();
        }
    }
    async onDragStart(e) {
        e.stopPropagation();
        const { el, dragHandlePosition } = this;
        const coords = e.detail;
        const anchor = dragHandlePosition === 'leading' ? 'left' : 'right';
        const drag = new Draggable(el, { anchor });
        this.drag = drag;
        await drag.start(coords);
    }
    onDragMove(e) {
        e.stopPropagation();
        const coords = e.detail;
        this.drag.move(coords);
    }
    async onDragEnd(e) {
        e.stopPropagation();
        const coords = e.detail;
        await this.drag.end(coords);
        this.drag.destroy();
    }
    checkIfSideTextIsPresent() {
        const sideTextEl = this.el.querySelector('[slot="side-label"], [slot="side-subtext"]');
        this.hasSideText = Boolean(sideTextEl);
    }
    querySlots() {
        this.slottedControlEl = [...this.el.querySelectorAll('[slot="control"]')].find(isValidRowControl);
        this.checkIfSideTextIsPresent();
    }
    determineRowRole() {
        // Should only apply an a11y role if the row acts as a button.
        // Links are covered with the anchor tag, and option roles are handled by market-list.
        if (this.interactive && this.transient && !this.href) {
            return 'button';
        }
        return undefined;
    }
    connectedCallback() {
        this.querySlots();
        this.selectedWatcher(this.selected);
        this.disabledWatcher(this.disabled);
        this.hrefWatcher(this.href);
        this.variantWatcher(this.variant);
    }
    componentWillLoad() {
        this.checkIfSideTextIsPresent();
    }
    async componentDidUpdate() {
        // remove preload class (used to manage slotted control transitions)
        if (this.el.classList.contains('preload')) {
            await asyncRequestAnimationFrame();
            this.el.classList.remove('preload');
        }
    }
    render() {
        const { controlPosition, disabled, href, interactive, selected, slottedControlEl, target, variant, hasSideText, dragEnabled, dragHandlePosition, size, el, } = this;
        /*
         * a11y: If the row has a slotted control, we want to tab directly to the inner control element.
         * Doing this ensures we don't violate the "no nested interactive" rule:
         * https://dequeuniversity.com/rules/axe/html/4.3/nested-interactive
         */
        const tabindex = interactive && !disabled && !slottedControlEl ? '0' : null;
        const ContainerTag = href === undefined ? 'div' : 'a';
        const ContainerTagAttrs = ContainerTag === 'a' ? { href, target } : {};
        ContainerTagAttrs['role'] = this.determineRowRole();
        const leadingControl = controlPosition === 'leading';
        const MarketDragHandleTagName = getNamespacedTagFor('market-drag-handle');
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        const drillIconName = size === 'small' ? cjs.ROW_SMALL_SIZE_CARET_ICON_ASSET : cjs.ROW_MEDIUM_SIZE_CARET_ICON_ASSET;
        return (hAsync(Host, { key: 'e0af5fb30f2569971d64057d871af60405d80b75', tabindex: tabindex, "aria-selected": el.role === 'option' ? Boolean(selected).toString() : undefined, class: classNames('market-row', 'preload', {
                'has-slotted-control': typeof slottedControlEl !== 'undefined',
                'has-leading-control': leadingControl,
            }), onMouseDown: () => this.setControlActive(true), onMouseUp: () => this.setControlActive(false), onMouseEnter: () => this.setControlHover(true), onMouseLeave: () => this.setControlHover(false), onClick: (e) => this.handleClick(e), onKeydown: (e) => this.handleKeydown(e), onMarketDragHandleDragStart: (e) => this.onDragStart(e), onMarketDragHandleDragMove: (e) => this.onDragMove(e), onMarketDragHandleDragEnd: (e) => this.onDragEnd(e) }, hAsync(ContainerTag, Object.assign({ key: '0147448e4008da14a2597f43676707e1f6276f2a', part: "container", class: "container", tabindex: tabindex }, ContainerTagAttrs), dragEnabled && dragHandlePosition === 'leading' && (hAsync(MarketDragHandleTagName, { key: '8845f82742506140a6cd2b252f1b44ca2581f71b', part: "drag-handle" })), leadingControl && hAsync("slot", { key: 'b29f3a7673646aab9e2fa1d7698e793bce4f7854', name: "control", onSlotchange: () => this.handleControlSlotChange() }), hAsync("slot", { key: '38f2988c383126c852a3a92ba0eaaa0c0754039c', name: "leading-accessory" }), hAsync("div", { key: '7e4e81d29f8c9cb9af9dc0980cb73d5d1e60541e', class: "main", part: "main" }, hAsync("slot", { key: '251e758e1ad0c07de7713a7b608314bd17fcbf6e', name: "label" }), hAsync("slot", { key: '090c451be4b114a61dc79c2a256ac6dbda53efbd', name: "subtext" }), hAsync("slot", { key: '144000d524652a21de2f011bae7534356c20d288' })), hAsync("div", { key: 'd99b67c24f5ce1c4628414ebbb376926f2d58ef9', part: "side", class: classNames('side', { hidden: !hasSideText }) }, hAsync("slot", { key: '4dd0e0f24441e84871a0ecedca2330caf2a8595b', name: "side-label", onSlotchange: () => this.checkIfSideTextIsPresent() }), hAsync("slot", { key: '075ef3d3278322018477a0704b5f96a9cfab043c', name: "side-subtext", onSlotchange: () => this.checkIfSideTextIsPresent() })), hAsync("slot", { key: '3ca9095e427e5326ccb54ed1dd1cd7d7a97c28eb', name: "trailing-accessory" }), variant === 'regular' && !leadingControl && (hAsync("slot", { key: '41155201ba966c0ef66a0424302f0b3361fd9a10', name: "control", onSlotchange: () => this.handleControlSlotChange() })), variant === 'drill' && hAsync(MarketIconTagName, { key: '85e1065ce85fa95d5588811629c2cb1d64271e0d', class: "drill-icon", name: drillIconName }), dragEnabled && dragHandlePosition === 'trailing' && (hAsync(MarketDragHandleTagName, { key: '60ca3ae6e23bfe53caefc31806c69f96e456f940', part: "drag-handle" })))));
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selected": ["selectedWatcher"],
        "disabled": ["disabledWatcher"],
        "href": ["hrefWatcher"],
        "variant": ["variantWatcher"]
    }; }
    static get style() { return MarketRowStyle0; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "market-row",
        "$members$": {
            "selected": [1540],
            "value": [513],
            "disabled": [516],
            "size": [513],
            "interactive": [1540],
            "transient": [1540],
            "togglable": [4],
            "variant": [1],
            "destructive": [516],
            "controlPosition": [1, "control-position"],
            "href": [1],
            "target": [1],
            "dragEnabled": [516, "drag-enabled"],
            "dragHandlePosition": [513, "drag-handle-position"],
            "slottedControlEl": [32],
            "hasSideText": [32],
            "silentlySelect": [64],
            "silentlyDeselect": [64],
            "select": [64],
            "deselect": [64],
            "toggle": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selected", "selected"], ["value", "value"], ["disabled", "disabled"], ["size", "size"], ["interactive", "interactive"], ["transient", "transient"], ["destructive", "destructive"], ["dragEnabled", "drag-enabled"], ["dragHandlePosition", "drag-handle-position"]]
    }; }
}

const marketSegmentCss = "/*!@:host, ::slotted(*), **/.sc-market-segment-h,.sc-market-segment-s>*,*.sc-market-segment{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-segment-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-segment-h *.sc-market-segment,.sc-market-segment-h[disabled].sc-market-segment-s>*,.sc-market-segment-h[disabled] .sc-market-segment-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-segment-h{--segmented-control-option-min-width:var(--core-small-size-minimum-height);display:flex;flex-direction:row;justify-content:center;align-items:center;min-width:var(--segmented-control-option-min-width);padding:var(--segmented-control-option-padding-vertical) var(--segmented-control-option-padding-horizontal);border-radius:var(--segmented-control-option-background-radius);color:var(--segmented-control-option-label-normal-state);font-weight:var(--segmented-control-option-label-weight);font-size:var(--segmented-control-option-label-size);line-height:var(--segmented-control-option-label-leading);letter-spacing:var(--segmented-control-option-label-tracking);text-align:center;cursor:pointer;transition:color var(--segmented-control-animation-duration)}/*!@:host([selected])*/[selected].sc-market-segment-h{color:var(--segmented-control-option-label-selected-state);box-shadow:none !important}/*!@:host([disabled])*/[disabled].sc-market-segment-h{background:var(--segmented-control-option-background-disabled-state-color);color:var(--segmented-control-option-label-disabled-state-color);cursor:not-allowed}/*!@:host(:hover:not([selected]):not([disabled]))*/.sc-market-segment-h:hover:not([selected]):not([disabled]){color:var(--segmented-control-option-label-hover-state-color)}/*!@:host(:active:not([disabled]))*/.sc-market-segment-h:active:not([disabled]){color:var(--segmented-control-option-label-pressed-state-color)}";
var MarketSegmentStyle0 = marketSegmentCss;

class MarketSegment {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketSegmentSelectedChanged = createEvent(this, "marketSegmentSelectedChanged", 7);
        this.disabled = false;
        this.value = undefined;
        this.selected = false;
    }
    setSelectedState(state) {
        this.selected = state;
        return Promise.resolve();
    }
    selectSegment() {
        if (this.selected || this.disabled) {
            return Promise.resolve();
        }
        this.marketSegmentSelectedChanged.emit();
        return Promise.resolve();
    }
    render() {
        return (hAsync(Host, { key: '9927e6b28aeeab4bb55f8ed43af995ff17ca009d', selected: this.selected, class: "market-segment", onClick: () => this.selectSegment() }, hAsync("slot", { key: '705146bdc557b8eb2ff952c0c8dd1b8aedc6edcf' })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketSegmentStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-segment",
        "$members$": {
            "disabled": [1540],
            "value": [1537],
            "selected": [32],
            "setSelectedState": [64],
            "selectSegment": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["value", "value"]]
    }; }
}

const marketSegmentedControlCss = "/*!@:host, ::slotted(*), **/.sc-market-segmented-control-h,.sc-market-segmented-control-s>*,*.sc-market-segmented-control{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-segmented-control-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-segmented-control-h *.sc-market-segmented-control,.sc-market-segmented-control-h[disabled].sc-market-segmented-control-s>*,.sc-market-segmented-control-h[disabled] .sc-market-segmented-control-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-segmented-control-h{position:relative;display:inline-flex;flex-direction:row;gap:calc(var(--segmented-control-padding-horizontal) * 2);align-items:center;min-width:100%;padding:var(--segmented-control-padding-vertical) var(--segmented-control-padding-horizontal);border-radius:var(--segmented-control-background-radius);background:var(--segmented-control-background-normal-state-color)}/*!@:host([disabled])*/[disabled].sc-market-segmented-control-h{background:var(--segmented-control-background-disabled-state-color);color:var(--segmented-control-option-label-disabled-state-color)}/*!@::slotted(.market-segment)*/.sc-market-segmented-control-s>.market-segment{z-index:2;width:100%;height:100%}/*!@:host::before*/.sc-market-segmented-control-h::before{content:\"\";position:absolute;left:var(--selected-slider-left);z-index:1;width:var(--selected-slider-width);height:calc(100% - var(--segmented-control-padding-vertical) * 2);border-radius:var(--segmented-control-option-background-radius);background:var(--segmented-control-option-background-selected-state-color);box-shadow:var(--elevation-10-shadow);transition:left var(--segmented-control-animation-duration)}";
var MarketSegmentedControlStyle0 = marketSegmentedControlCss;

function isValueEmpty(value) {
    return value === '' || value === ' ' || value === null || value === undefined;
}
class MarketSegmentedControl {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketSegmentedSelectionDidChange = createEvent(this, "marketSegmentedSelectionDidChange", 7);
        this.items = undefined;
        this.value = '';
        this.disabled = false;
    }
    valueWatcher() {
        this.setSelectionsFromValue();
    }
    /**
     * If a segment gets slotted in, set the value to match that of the row
     */
    disabledChangeHandler() {
        var _a;
        (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => (item.disabled = this.disabled));
    }
    /**
     * Select item that corresponds to passed value, or clear all values if value is empty string.
     */
    setSelectionsFromValue() {
        var _a;
        (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
            if (this.value === item.value) {
                item.setSelectedState(true);
                this.setSliderPosition(item);
            }
            else {
                item.setSelectedState(false);
            }
        });
    }
    /**
     * Sets the initial state of the segmented-control by updating and propagating props and setting
     * default value.
     */
    setInternalState() {
        this.items = this.el.querySelectorAll(`${getNamespacedTagFor('market-segment')}`);
        this.selectedSlider = this.el.shadowRoot.getElementById('selected-slider');
        if (this.items.length > 0) {
            if (isValueEmpty(this.value)) {
                this.value = this.items[0].value;
            }
            this.setSelectionsFromValue();
        }
    }
    /**
     * Sets slider size to be the size of a segment
     */
    setSliderSize() {
        var _a;
        this.el.style.setProperty('--selected-slider-width', `calc(${100 / ((_a = this.items) === null || _a === void 0 ? void 0 : _a.length)}% - ${cjs.SEGMENTED_CONTROL_PADDING_HORIZONTAL * 2}px)`);
    }
    /**
     * Sets slider position (left offset) based on the currently selected item
     */
    setSliderPosition(selectedItem = undefined) {
        if (!selectedItem) {
            this.el.style.setProperty('--selected-slider-left', `${cjs.SEGMENTED_CONTROL_PADDING_HORIZONTAL}px`);
            return;
        }
        const newSelectionIndex = [...this.items].indexOf(selectedItem);
        this.el.style.setProperty('--selected-slider-left', `calc(${(newSelectionIndex / this.items.length) * 100}% + ${cjs.SEGMENTED_CONTROL_PADDING_HORIZONTAL}px)`);
    }
    /**
     * Sets the initial state of the segmented-control by updating and propagating props and setting
     * default value.
     */
    defaultSlotchangeHandler() {
        this.setInternalState();
        this.setSliderSize();
    }
    marketSegmentSelectedEventHandler(e) {
        const newSelection = e.target;
        const prevSelection = this.el.querySelector(`${getNamespacedTagFor('market-segment')}[selected]`);
        prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.setSelectedState(false);
        newSelection.setSelectedState(true);
        this.setSliderPosition(newSelection);
        this.marketSegmentedSelectionDidChange.emit({
            selectedSegment: newSelection,
            selectedSegmentValue: newSelection.value,
            deselectedSegment: prevSelection,
            deselectedSegmentValue: prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.value,
        });
    }
    render() {
        return (hAsync(Host, { key: '9b4e2e05d111b43b02ad003f5ff57f9f65afa610', class: "market-segmented-control" }, hAsync("slot", { key: '25608a3e24e8bfff6d9683db3a92553cffb896e0', onSlotchange: () => this.defaultSlotchangeHandler() })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueWatcher"],
        "disabled": ["disabledChangeHandler"]
    }; }
    static get style() { return MarketSegmentedControlStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-segmented-control",
        "$members$": {
            "value": [1537],
            "disabled": [516],
            "items": [32]
        },
        "$listeners$": [[0, "marketSegmentSelectedChanged", "marketSegmentSelectedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["disabled", "disabled"]]
    }; }
}

/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = min(...rects.map(rect => rect.left));
  const minY = min(...rects.map(rect => rect.top));
  const maxX = max(...rects.map(rect => rect.right));
  const maxY = max(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset$1 = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [':popover-open', ':modal'].some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return getComputedStyle$1(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = offset$1;

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = autoPlacement$1;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = shift$1;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
flip;

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = size$1;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
hide;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
arrow;

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
inline;

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
limitShift;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

/**
 * helper functions for managing callback timing (ex. delay, throttle, debounce)
 *
 * these will probably be most useful in situations where we wish to respond to
 * user input events (particularly ones that happen in "streams" like scrolling,
 * window resizing, or typing) in a performant way.
 *
 * if this file ends up larger than a few functions, we should consider bringing
 * in lodash as a dependency instead: https://lodash.com/docs
 *
 * recommended pattern for using these functions in your stencil components:
 * myEventHandler = debounce(() => {
 *   // your code
 * }, timeout)
 */
/**
 * returns a function that will not be triggered until it stops being called for
 * N milliseconds, adapted from https://davidwalsh.name/javascript-debounce-function
 *
 * @param callback - callback to be executed after the wait
 * @param {number} wait - wait in milliseconds
 */
const debounce = (callback, wait) => {
    let timeout;
    return (...args) => {
        const later = () => {
            timeout = null;
            callback.apply(undefined, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

const marketSelectCss = "/*!@:host, ::slotted(*), **/.sc-market-select-h,.sc-market-select-s>*,*.sc-market-select{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-select-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-select-h *.sc-market-select,.sc-market-select-h[disabled].sc-market-select-s>*,.sc-market-select-h[disabled] .sc-market-select-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-select-h{position:relative;outline:none;font-weight:var(--field-input-weight);font-size:var(--field-input-size);line-height:var(--field-input-leading);cursor:text}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-select-h input.sc-market-select,.sc-market-select-h.sc-market-select-s>input,.sc-market-select-h .sc-market-select-s>input,.sc-market-select-h textarea.sc-market-select,.sc-market-select-h.sc-market-select-s>textarea,.sc-market-select-h .sc-market-select-s>textarea{width:100%;margin:0;padding:0;border:none;background-color:transparent;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;cursor:inherit}/*!@:host ::slotted(label)*/.sc-market-select-h .sc-market-select-s>label{cursor:inherit}/*!@:host input:focus, :host ::slotted(input:focus), :host textarea:focus, :host ::slotted(textarea:focus)*/.sc-market-select-h input.sc-market-select:focus,.sc-market-select-h.sc-market-select-s>input,.sc-market-select-h.sc-market-select-s>input:focus,.sc-market-select-h .sc-market-select-s>input:focus,.sc-market-select-h textarea.sc-market-select:focus,.sc-market-select-h.sc-market-select-s>textarea,.sc-market-select-h.sc-market-select-s>textarea:focus,.sc-market-select-h .sc-market-select-s>textarea:focus{outline:none}/*!@:host input::-moz-placeholder, :host textarea::-moz-placeholder*/.sc-market-select-h input.sc-market-select::-moz-placeholder,.sc-market-select-h textarea.sc-market-select::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host input::placeholder, :host textarea::placeholder*/.sc-market-select-h input.sc-market-select::placeholder,.sc-market-select-h textarea.sc-market-select::placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::-moz-placeholder, :host ::slotted(textarea)::-moz-placeholder*/.sc-market-select-h.sc-market-select-s>input,.sc-market-select-h .sc-market-select-s>input::-moz-placeholder,.sc-market-select-h.sc-market-select-s>textarea,.sc-market-select-h.sc-market-select-s>textarea::-moz-placeholder,.sc-market-select-h .sc-market-select-s>textarea::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::placeholder, :host ::slotted(textarea)::placeholder*/.sc-market-select-h.sc-market-select-s>input,.sc-market-select-h .sc-market-select-s>input::placeholder,.sc-market-select-h.sc-market-select-s>textarea,.sc-market-select-h.sc-market-select-s>textarea::placeholder,.sc-market-select-h .sc-market-select-s>textarea::placeholder{color:var(--field-placeholder-text-color)}/*!@:host([size='small'])*/[size='small'].sc-market-select-h{font-size:var(--core-type-paragraph-20-size);line-height:var(--core-type-paragraph-20-leading)}/*!@:host*/.sc-market-select-h{border-radius:var(--field-border-radius);background-color:var(--field-normal-state-background-color);color:var(--field-normal-state-input-color)}/*!@:host::after*/.sc-market-select-h::after{content:\"\";position:absolute;inset:0;border-radius:var(--field-border-radius);box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color);pointer-events:none}/*!@:host([invalid])::after*/[invalid].sc-market-select-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-invalid-validity-border-color)}/*!@:host(:hover)*/.sc-market-select-h:hover{background-color:var(--field-hover-state-background-color);color:var(--field-hover-state-input-color)}/*!@:host(:hover)::after*/.sc-market-select-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-normal-validity-border-color)}/*!@:host([invalid]:hover)::after*/[invalid].sc-market-select-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-invalid-validity-border-color)}/*!@:host([focused])*/[focused].sc-market-select-h{color:var(--field-focus-state-input-color)}/*!@:host([focused])::after*/[focused].sc-market-select-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size)\n        var(--field-focus-state-normal-validity-border-color)}/*!@:host([focused][invalid])::after*/[focused][invalid].sc-market-select-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size) var(--field-focus-state-invalid-validity-border-color)}/*!@:host([readonly]:hover)::after*/[readonly].sc-market-select-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color)}/*!@:host([disabled])*/[disabled].sc-market-select-h{background-color:var(--field-disabled-state-background-color) !important;color:var(--field-disabled-state-input-color) !important;cursor:not-allowed !important}/*!@:host([disabled])::after*/[disabled].sc-market-select-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-disabled-state-border-color) !important}/*!@:host([disabled]) ::slotted(.market-accessory), :host([disabled]) ::slotted(img[slot*=\"accessory\"]), :host([disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([disabled]) ::slotted(div[slot*=\"accessory\"])*/.sc-market-select-h[disabled] .sc-market-select-s>.market-accessory,.sc-market-select-h[disabled].sc-market-select-s>img[slot*=\"accessory\"],.sc-market-select-h[disabled] .sc-market-select-s>img[slot*=\"accessory\"],.sc-market-select-h[disabled].sc-market-select-s>svg[slot*=\"accessory\"],.sc-market-select-h[disabled] .sc-market-select-s>svg[slot*=\"accessory\"],.sc-market-select-h[disabled].sc-market-select-s>div[slot*=\"accessory\"],.sc-market-select-h[disabled] .sc-market-select-s>div[slot*=\"accessory\"]{--field-disabled-state-accessory-opacity:var(--row-disabled-state-leading-accessory-opacity);opacity:var(--field-disabled-state-accessory-opacity)}/*!@:host([value=\"\"]) ::slotted(label)*/.sc-market-select-h[value=\"\"] .sc-market-select-s>label{color:var(--field-normal-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"][autofilled]) ::slotted(label)*/.sc-market-select-h:not([value=\"\"]) .sc-market-select-s>label,.sc-market-select-h[value=\"\"][autofilled].sc-market-select-s>label,.sc-market-select-h[value=\"\"][autofilled] .sc-market-select-s>label{color:var(--field-normal-state-float-phase-label-color)}/*!@:host(:hover) ::slotted(label)*/.sc-market-select-h:hover .sc-market-select-s>label{color:var(--field-hover-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"]):hover) ::slotted(label), :host([value=\"\"][autofilled]:hover) ::slotted(label)*/.sc-market-select-h:not([value=\"\"]):hover .sc-market-select-s>label,.sc-market-select-h[value=\"\"][autofilled]:hover.sc-market-select-s>label,.sc-market-select-h[value=\"\"][autofilled]:hover .sc-market-select-s>label{color:var(--field-hover-state-float-phase-label-color)}/*!@:host([focused]) ::slotted(label)*/.sc-market-select-h[focused].sc-market-select-s>label,.sc-market-select-h[focused] .sc-market-select-s>label{color:var(--field-focus-state-float-phase-label-color)}/*!@:host([value=\"\"][disabled]) ::slotted(label)*/.sc-market-select-h[value=\"\"][disabled] .sc-market-select-s>label{color:var(--field-disabled-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])[disabled]) ::slotted(label), :host([value=\"\"][autofilled][disabled]) ::slotted(label)*/.sc-market-select-h:not([value=\"\"])[disabled] .sc-market-select-s>label,.sc-market-select-h[value=\"\"][autofilled][disabled].sc-market-select-s>label,.sc-market-select-h[value=\"\"][autofilled][disabled] .sc-market-select-s>label{color:var(--field-disabled-state-float-phase-label-color)}/*!@:host*/.sc-market-select-h{--field-accessory-horizontal-spacing-size:16px;--field-size-small-accessory-horizontal-spacing-size:12px;--field-size-large-image-accessory-outer-spacing-size:12px;--field-size-medium-image-accessory-outer-spacing-size:4px;--field-size-large-button-accessory-outer-spacing-size:12px;--field-size-medium-button-accessory-outer-spacing-size:4px;--field-size-large-tooltip-accessory-horizontal-spacing-size:5px;--field-size-large-tooltip-accessory-vertical-spacing-size:-1px;--field-size-small-tooltip-accessory-horizontal-spacing-size:1px}/*!@:host ::slotted([slot=\"leading-accessory\"])*/.sc-market-select-h .sc-market-select-s>[slot=\"leading-accessory\"]{flex-shrink:0;margin-right:var(--field-accessory-horizontal-spacing-size);margin-left:var(--field-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-accessory[slot=\"leading-accessory\"][size=\"image\"])*/.sc-market-select-h .sc-market-select-s>.market-accessory[slot=\"leading-accessory\"][size=\"image\"]{margin-left:var(--field-size-large-image-accessory-outer-spacing-size)}/*!@:host ::slotted(.market-tooltip[slot=\"leading-accessory\"])*/.sc-market-select-h .sc-market-select-s>.market-tooltip[slot=\"leading-accessory\"]{margin:var(--field-size-large-tooltip-accessory-vertical-spacing-size)\n      var(--field-size-large-tooltip-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-button[slot=\"leading-accessory\"][size=\"small\"])*/.sc-market-select-h .sc-market-select-s>.market-button[slot=\"leading-accessory\"][size=\"small\"]{margin-left:var(--field-size-large-button-accessory-outer-spacing-size)}/*!@:host ::slotted([slot=\"trailing-accessory\"])*/.sc-market-select-h .sc-market-select-s>[slot=\"trailing-accessory\"]{flex-shrink:0;margin-right:var(--field-accessory-horizontal-spacing-size);margin-left:var(--field-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-accessory[slot=\"trailing-accessory\"][size=\"image\"])*/.sc-market-select-h .sc-market-select-s>.market-accessory[slot=\"trailing-accessory\"][size=\"image\"]{margin-right:var(--field-size-large-image-accessory-outer-spacing-size)}/*!@:host ::slotted(.market-tooltip[slot=\"trailing-accessory\"])*/.sc-market-select-h .sc-market-select-s>.market-tooltip[slot=\"trailing-accessory\"]{margin:var(--field-size-large-tooltip-accessory-vertical-spacing-size)\n      var(--field-size-large-tooltip-accessory-horizontal-spacing-size)}/*!@:host ::slotted(.market-button[slot=\"trailing-accessory\"][size=\"small\"])*/.sc-market-select-h .sc-market-select-s>.market-button[slot=\"trailing-accessory\"][size=\"small\"]{margin-right:var(--field-size-large-button-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-accessory[slot=\"leading-accessory\"][size=\"image\"])*/.sc-market-select-h[size='medium'] .sc-market-select-s>.market-accessory[slot=\"leading-accessory\"][size=\"image\"]{margin-left:var(--field-size-medium-image-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-button[slot=\"leading-accessory\"][size=\"small\"])*/.sc-market-select-h[size='medium'] .sc-market-select-s>.market-button[slot=\"leading-accessory\"][size=\"small\"]{margin-left:var(--field-size-medium-button-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-accessory[slot=\"trailing-accessory\"][size=\"image\"])*/.sc-market-select-h[size='medium'] .sc-market-select-s>.market-accessory[slot=\"trailing-accessory\"][size=\"image\"]{margin-right:var(--field-size-medium-image-accessory-outer-spacing-size)}/*!@:host([size='medium']) ::slotted(.market-button[slot=\"trailing-accessory\"][size=\"small\"])*/.sc-market-select-h[size='medium'] .sc-market-select-s>.market-button[slot=\"trailing-accessory\"][size=\"small\"]{margin-right:var(--field-size-medium-button-accessory-outer-spacing-size)}/*!@:host([size='small']) ::slotted([slot=\"leading-accessory\"]), :host([size='small']) ::slotted([slot=\"trailing-accessory\"])*/.sc-market-select-h[size='small'] .sc-market-select-s>[slot=\"leading-accessory\"],.sc-market-select-h[size='small'].sc-market-select-s>[slot=\"trailing-accessory\"],.sc-market-select-h[size='small'] .sc-market-select-s>[slot=\"trailing-accessory\"]{margin-right:var(--field-size-small-accessory-horizontal-spacing-size);margin-left:var(--field-size-small-accessory-horizontal-spacing-size)}/*!@:host([size='small']) ::slotted(.market-tooltip[slot=\"leading-accessory\"]), :host([size='small']) ::slotted(.market-tooltip[slot=\"trailing-accessory\"])*/.sc-market-select-h[size='small'] .sc-market-select-s>.market-tooltip[slot=\"leading-accessory\"],.sc-market-select-h[size='small'].sc-market-select-s>.market-tooltip[slot=\"trailing-accessory\"],.sc-market-select-h[size='small'] .sc-market-select-s>.market-tooltip[slot=\"trailing-accessory\"]{margin-right:var(--field-size-small-tooltip-accessory-horizontal-spacing-size);margin-left:var(--field-size-small-tooltip-accessory-horizontal-spacing-size)}/*!@:host .label-input-container.has-leading-accessory*/.sc-market-select-h .label-input-container.has-leading-accessory.sc-market-select{padding-left:0 !important}/*!@:host .label-input-container.has-trailing-accessory*/.sc-market-select-h .label-input-container.has-trailing-accessory.sc-market-select{padding-right:0 !important}/*!@:host*/.sc-market-select-h{--field-input-animation-speed:0.2s;--field-input-label-translate:12px;--field-empty-phase-label-text-size-unitless:16;--field-float-phase-label-text-size-unitless:14;--field-size-medium-float-phase-vertical-padding-size:12px;--field-size-medium-float-phase-horizontal-padding-size:16px;--field-size-small-float-phase-vertical-padding-size:9px;--field-size-small-float-phase-horizontal-padding-size:12px;display:flex;align-items:center}/*!@:host .label-input-container, :host([value='']:not([focused]):not([autofilled])) .label-input-container*/.sc-market-select-h .label-input-container.sc-market-select,[value=''].sc-market-select-h:not([focused]):not([autofilled]) .label-input-container.sc-market-select{flex-grow:1;padding:var(--field-float-phase-vertical-padding-size) var(--field-float-phase-horizontal-padding-size)}/*!@:host([size='medium']) .label-input-container, :host([size='medium'][value='']:not([focused]):not([autofilled])) .label-input-container*/[size='medium'].sc-market-select-h .label-input-container.sc-market-select,[size='medium'][value=''].sc-market-select-h:not([focused]):not([autofilled]) .label-input-container.sc-market-select{padding:var(--field-size-medium-float-phase-vertical-padding-size)\n      var(--field-size-medium-float-phase-horizontal-padding-size)}/*!@:host([size='small']) .label-input-container, :host([size='small'][value='']:not([focused]):not([autofilled])) .label-input-container*/[size='small'].sc-market-select-h .label-input-container.sc-market-select,[size='small'][value=''].sc-market-select-h:not([focused]):not([autofilled]) .label-input-container.sc-market-select{padding:var(--field-size-small-float-phase-vertical-padding-size)\n      var(--field-size-small-float-phase-horizontal-padding-size)}/*!@:host ::slotted(label)*/.sc-market-select-h .sc-market-select-s>label{display:block;min-height:var(--field-empty-phase-label-text-leading);font-weight:var(--field-empty-phase-label-text-weight);font-size:var(--field-empty-phase-label-text-size);line-height:var(--field-empty-phase-label-text-leading);letter-spacing:var(--field-empty-phase-label-text-tracking);transition:all var(--field-input-animation-speed);transform:translateY(var(--field-input-label-translate));transform-origin:0 0}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"]:not([focused])[autofilled]) ::slotted(label), :host([focused]) ::slotted(label)*/.sc-market-select-h:not([value=\"\"]) .sc-market-select-s>label,.sc-market-select-h[value=\"\"]:not([focused])[autofilled].sc-market-select-s>label,.sc-market-select-h[value=\"\"]:not([focused])[autofilled] .sc-market-select-s>label,.sc-market-select-h[focused].sc-market-select-s>label,.sc-market-select-h[focused] .sc-market-select-s>label{font-weight:var(--field-float-phase-label-text-weight);transform:scale(\n        calc(var(--field-float-phase-label-text-size-unitless) / var(--field-empty-phase-label-text-size-unitless))\n      )}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-select-h input.sc-market-select,.sc-market-select-h.sc-market-select-s>input,.sc-market-select-h .sc-market-select-s>input,.sc-market-select-h textarea.sc-market-select,.sc-market-select-h.sc-market-select-s>textarea,.sc-market-select-h .sc-market-select-s>textarea{opacity:0%}/*!@:host([focused]) input, :host([focused]) ::slotted(input), :host([focused]) textarea, :host([focused]) ::slotted(textarea), :host(:not([value=''])) input, :host(:not([value=''])) ::slotted(input), :host(:not([value=''])) textarea, :host(:not([value=''])) ::slotted(textarea)*/[focused].sc-market-select-h input.sc-market-select,.sc-market-select-h[focused].sc-market-select-s>input,.sc-market-select-h[focused] .sc-market-select-s>input,[focused].sc-market-select-h textarea.sc-market-select,.sc-market-select-h[focused].sc-market-select-s>textarea,.sc-market-select-h[focused] .sc-market-select-s>textarea,.sc-market-select-h:not([value='']) input.sc-market-select,.sc-market-select-h:not([value='']).sc-market-select-s>input,.sc-market-select-h:not([value='']) .sc-market-select-s>input,.sc-market-select-h:not([value='']) textarea.sc-market-select,.sc-market-select-h:not([value='']).sc-market-select-s>textarea,.sc-market-select-h:not([value='']) .sc-market-select-s>textarea{opacity:100%}/*!@:host([size='small']) ::slotted(label), :host([size='medium']) ::slotted(label)*/.sc-market-select-h[size='small'] .sc-market-select-s>label,.sc-market-select-h[size='medium'].sc-market-select-s>label,.sc-market-select-h[size='medium'] .sc-market-select-s>label{position:absolute;overflow:hidden;clip:rect(0 0 0 0);width:1px;height:1px;white-space:nowrap;-webkit-clip-path:inset(50%);clip-path:inset(50%)}/*!@:host([size='small']) input, :host([size='small']) ::slotted(input), :host([size='small']) textarea, :host([size='small']) ::slotted(textarea), :host([size='medium']) input, :host([size='medium']) ::slotted(input), :host([size='medium']) textarea, :host([size='medium']) ::slotted(textarea)*/[size='small'].sc-market-select-h input.sc-market-select,.sc-market-select-h[size='small'].sc-market-select-s>input,.sc-market-select-h[size='small'] .sc-market-select-s>input,[size='small'].sc-market-select-h textarea.sc-market-select,.sc-market-select-h[size='small'].sc-market-select-s>textarea,.sc-market-select-h[size='small'] .sc-market-select-s>textarea,[size='medium'].sc-market-select-h input.sc-market-select,.sc-market-select-h[size='medium'].sc-market-select-s>input,.sc-market-select-h[size='medium'] .sc-market-select-s>input,[size='medium'].sc-market-select-h textarea.sc-market-select,.sc-market-select-h[size='medium'].sc-market-select-s>textarea,.sc-market-select-h[size='medium'] .sc-market-select-s>textarea{opacity:100%}/*!@:host*/.sc-market-select-h{cursor:pointer}/*!@.label-input-container*/.label-input-container.sc-market-select{overflow:hidden}/*!@.caret*/.caret.sc-market-select{flex-shrink:0;margin-right:var(--field-float-phase-horizontal-padding-size);pointer-events:none;transition:transform var(--field-input-animation-speed)}/*!@.caret path*/.caret.sc-market-select path.sc-market-select{fill:var(--select-caret-color)}/*!@:host([aria-expanded=\"true\"]) .caret*/[aria-expanded=\"true\"].sc-market-select-h .caret.sc-market-select{transform:rotate(180deg)}/*!@.placeholder*/.placeholder.sc-market-select{overflow:hidden;height:var(--field-input-leading);color:var(--field-placeholder-text-color);font-size:var(--field-input-size);line-height:var(--field-input-leading);text-overflow:ellipsis;white-space:nowrap;visibility:hidden}/*!@:host([focused]) .placeholder, :host([size=\"small\"]) .placeholder, :host([size=\"medium\"]) .placeholder*/[focused].sc-market-select-h .placeholder.sc-market-select,[size=\"small\"].sc-market-select-h .placeholder.sc-market-select,[size=\"medium\"].sc-market-select-h .placeholder.sc-market-select{visibility:visible}/*!@:host([size=\"small\"]) .placeholder*/[size=\"small\"].sc-market-select-h .placeholder.sc-market-select{height:var(--core-type-paragraph-20-leading);font-size:var(--core-type-paragraph-20-size);line-height:var(--core-type-paragraph-20-leading)}/*!@::slotted(label)*/.sc-market-select-s>label{cursor:pointer}/*!@::slotted([slot=\"displayed-selection\"])*/.sc-market-select-s>[slot=\"displayed-selection\"]{min-height:0;margin:0}/*!@::slotted([slot=\"displayed-selection\"])::before, ::slotted([slot=\"displayed-selection\"])::after*/.sc-market-select-s>[slot=\"displayed-selection\"]::before,.sc-market-select-s>[slot=\"displayed-selection\"]::after{display:none}/*!@::slotted([slot=\"list\"])*/.sc-market-select-s>[slot=\"list\"]{display:none}";
var MarketSelectStyle0 = marketSelectCss;

const UP_DIRECTION = -1;
const DOWN_DIRECTION = 1;
/**
 * @slot - Intended for use as the input's text label.
 * @slot list - Intended for use with a slotted `<market-list>` containing `<market-row>`s.
 * @slot leading-accessory - An accessory set on the left side of the input.
 * @slot trailing-accessory - An accessory set on the right side of the input.
 * @slot displayed-selection - Used internally to display the selected `market-row` while retaining any custom styling. Not intended for use by Market consumers.
 */
class MarketSelect {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketSelectValueDidChange = createEvent(this, "marketSelectValueDidChange", 7);
        this.marketSelectOpened = createEvent(this, "marketSelectOpened", 7);
        this.marketSelectClosed = createEvent(this, "marketSelectClosed", 7);
        /* TYPEAHEAD FUNCTIONALITY
        - https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
        - type a character: focus moves to the next item with a name that starts with
          the typed character
        - type multiple characters in rapid succession: focus moves to the next item
          with a name that starts with the string of characters typed
        - if no match is found, focus remains where it was
        - search wraps around end of list
        */
        this.rowsInnerText = [];
        this.keypresses = [];
        this.debounceDelay = 250;
        this.setFocusOnMatch = debounce(() => {
            const searchString = this.keypresses.join('');
            // array slicing is so we start the search from the currently focused row
            const nextMatch = [
                ...this.rowsInnerText.slice(this.focusedRowIndex + 1),
                ...this.rowsInnerText.slice(0, this.focusedRowIndex + 1),
            ].find((innerText) => innerText.startsWith(searchString));
            const matchIndex = this.rowsInnerText.findIndex((innerText) => {
                return innerText.startsWith(nextMatch);
            });
            const matchingRow = this.rows[matchIndex];
            // if matching row exists and is not disabled, focus it
            if (matchingRow && !matchingRow.disabled) {
                this.focusedRowIndex = matchIndex;
                // if list is closed and single select, set the value
                if (!this.listIsActive && !this.multiselect) {
                    // row is not in the DOM, so matchingRow.click() doesn't bubble
                    // instead we manually set the value to the row's value
                    this.value = matchingRow.value;
                    // since we're bypassing marketListSelectionsDidChange event here,
                    // we also need to manually emit marketSelectValueDidChange event
                    this.marketSelectValueDidChange.emit({
                        value: this.value,
                        newSelectedOption: matchingRow,
                        newDeselectedOption: null,
                        currentSelectedOptions: [matchingRow],
                    });
                }
            }
            this.keypresses = []; // reset keypress array
        }, this.debounceDelay);
        this.list = null;
        this.rows = null;
        this.popoverElement = null;
        this.name = undefined;
        this.value = '';
        this.size = 'large';
        this.placeholder = undefined;
        this.readonly = false;
        this.disabled = false;
        this.focused = false;
        this.invalid = false;
        this.required = false;
        this.multiselect = false;
        this.popoverContainer = undefined;
        this.popoverStrategy = 'absolute';
        this.listIsActive = false;
        this.focusedRowIndex = -1;
        this.hasLeadingAccessory = false;
        this.hasTrailingAccessory = false;
    }
    valueWatcher() {
        this.propagateValue();
    }
    multiselectWatcher() {
        this.list.multiselect = this.multiselect;
    }
    focusedRowIndexWatcher() {
        var _a;
        if (this.rows) {
            this.rows.forEach((r) => r.classList.remove('pseudo-focus'));
            (_a = this.rows[this.focusedRowIndex]) === null || _a === void 0 ? void 0 : _a.classList.add('pseudo-focus');
        }
    }
    // Listener for the change event emitted by `market-list`
    handleListSelection({ detail: { currentSelectionValues, currentSelections, newDeselection, newSelection } }) {
        const value = currentSelectionValues.join(',');
        this.value = value;
        if (this.multiselect) {
            this.setFocusedRow(newDeselection || newSelection);
        }
        else {
            this.setFocusedRow(newSelection);
        }
        this.marketSelectValueDidChange.emit({
            value,
            newSelectedOption: newSelection,
            newDeselectedOption: newDeselection,
            currentSelectedOptions: currentSelections,
        });
    }
    handleListItemsFiltered() {
        window.requestAnimationFrame(() => {
            if (this.listIsActive) {
                this.updatePopper();
            }
        });
    }
    windowClick(e) {
        var _a;
        if (this.el.contains(e.target) || ((_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.contains(e.target))) {
            return;
        }
        this.focused = false;
        if (this.listIsActive) {
            this.closeList();
        }
    }
    getValues() {
        if (Array.isArray(this.value)) {
            return new Set(this.value);
        }
        return new Set(this.multiselect ? this.value.split(',') : [this.value]);
    }
    getValuesCount() {
        return this.getValues().size;
    }
    /**
     * We search based on the `value` property rather than using querySelector and the `value`
     * attribute (i.e. `market-row[value=${this.value}]`) due to rendering issues we've seen
     * with Ember/Handlebars, where the property may be set before attribute is present.
     * See here for details: https://github.com/squareup/market/issues/2635
     */
    getMatchingRows() {
        if (this.rows === null) {
            return [];
        }
        else {
            const values = this.getValues();
            return [...this.rows].filter((row) => values.has(row.value));
        }
    }
    get hasMultipleSelections() {
        return this.multiselect && this.getValues().size > 1;
    }
    getMultiselectDisplayValue() {
        const values = this.getValues();
        return values.size > 1 ? `${values.size} selected` : '';
    }
    getDisplayedSelectionRow() {
        return this.el.querySelector(`${getNamespacedTagFor('market-row')}[slot="displayed-selection"]`);
    }
    /**
     * Ensure the passed `value` is reflected in the selected list item and the displayed selection row.
     */
    propagateValue() {
        if (!this.list || !this.rows)
            return;
        const matchingRows = this.getMatchingRows();
        if (matchingRows.length === 0) {
            // there were no matching rows, so sanitize & reset the value
            this.list.value = this.value = '';
            this.focusedRowIndex = -1;
        }
        else {
            // set the list value so the correct list row will be selected
            this.list.value = this.value;
            this.setFocusedRow(matchingRows[0]);
        }
        this.displaySelection(matchingRows);
    }
    /**
     * Renders the passed row into the displayed selection slot, so it's visible
     * as the current selection in the main "input" area of the select.
     */
    displaySelection(selectedRows = []) {
        var _a, _b, _c;
        // Remove existing selected row from the DOM
        (_b = (_a = this.getDisplayedSelectionRow()) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (selectedRows.length === 1) {
            /**
             * For single select, we need to clone the row from the list so we can place a
             * duplicate into the field area. If we don't clone it, the row
             * will be removed from the list when we append it to the selection area
             */
            const clonedRow = selectedRows[0].cloneNode(true);
            // Row was cloned from the list, so we need to remove its interactive attribute + reset its role
            clonedRow.interactive = false;
            clonedRow.removeAttribute('tabindex');
            clonedRow.setAttribute('role', 'listitem'); // needed after Stencil 4 upgrade
            // don't duplicate cloned element IDs!
            clonedRow.removeAttribute('id');
            clonedRow.querySelectorAll('[id]').forEach((el) => el.removeAttribute('id'));
            // We don't want the row to show as "focused" inside the select box
            clonedRow.classList.remove('pseudo-focus');
            /**
             * Set slot='displayed-selection' so this shows up within the slotted area.
             * We use a slot instead of appending this directly into the shadowDOM
             * because we want to keep whatever styling cascaded from the Light DOM
             * on the row because market - row can accept any markup.
             */
            clonedRow.setAttribute('slot', 'displayed-selection');
            // if the select size is small, the selected row needs to be small too
            clonedRow.size = this.size === 'small' ? 'small' : 'medium';
            // Append the cloned node after the first slot element (label).
            this.el.append(clonedRow);
        }
        else if (selectedRows.length > 1) {
            /**
             * For multiselect, we need to create a `market-row` element to display "n selected"
             * and possibly clone the "selected-translation" slot, if provided
             */
            const multiselectDisplayRow = document.createElement(`${getNamespacedTagFor('market-row')}`);
            multiselectDisplayRow.setAttribute('slot', 'displayed-selection');
            multiselectDisplayRow.innerText = `${this.getValuesCount().toLocaleString()} `;
            // if the select size is small, the selected row needs to be small too
            multiselectDisplayRow.size = this.size === 'small' ? 'small' : 'medium';
            // Add slot for "selected"
            const selectedTranslationSlot = document.createElement('slot');
            selectedTranslationSlot.setAttribute('name', 'selected-translation');
            // Clone the contents of the "selected-translation"
            const selectedTranslation = this.el.querySelector('[slot="selected-translation"]');
            selectedTranslationSlot.innerHTML = (_c = selectedTranslation === null || selectedTranslation === void 0 ? void 0 : selectedTranslation.innerHTML) !== null && _c !== void 0 ? _c : 'selected';
            multiselectDisplayRow.appendChild(selectedTranslationSlot);
            // Observe for changes on the "selected-translation" slot
            if (selectedTranslation) {
                const observer = new MutationObserver(() => {
                    selectedTranslationSlot.innerHTML = selectedTranslation === null || selectedTranslation === void 0 ? void 0 : selectedTranslation.innerHTML;
                });
                observer.observe(selectedTranslation, { characterData: true, subtree: true });
            }
            this.el.append(multiselectDisplayRow);
        }
    }
    /**
     * Listens to changes in list content to ensure that if the content is dynamically updated,
     * those changes will be copied to the popover and the displayed-selection row.
     */
    initListObserver() {
        const observer = new MutationObserver(this.onListChange.bind(this));
        observer.observe(this.list, { childList: true, characterData: true, subtree: true });
    }
    onListChange() {
        this.initRows();
        this.propagateValue();
        this.updatePopper();
    }
    /**
     * Record the index of the new selected row for keyboard navigation
     */
    setFocusedRow(row) {
        this.focusedRowIndex = Array.prototype.indexOf.call(this.rows, row);
    }
    /**
     * Opens the select.
     */
    async openList() {
        if (this.listIsActive || !this.popoverElement) {
            return Promise.resolve();
        }
        const container = this.el.closest(this.popoverContainer) || document.body;
        Object.assign(this.popoverElement.style, {
            zIndex: `${getMaxZIndex(container) + 1}`,
            visibility: 'hidden',
        });
        this.moveListToPopover();
        container.append(this.popoverElement);
        this.initPopperListeners();
        return new Promise((resolve) => {
            // hack: ensure initial position is correctly set before visible
            setTimeout(() => {
                this.updatePopper();
                this.popoverElement.style.visibility = 'visible';
                this.listIsActive = true;
                this.marketSelectOpened.emit();
                resolve();
            }, 50);
        });
    }
    /**
     * Closes the select.
     */
    closeList() {
        if (!this.listIsActive) {
            return Promise.resolve();
        }
        this.popoverElement.remove();
        this.cleanupPopperListeners();
        this.moveListToSelect();
        this.listIsActive = false;
        this.marketSelectClosed.emit();
        return Promise.resolve();
    }
    /**
     * Toggles the select open and closed.
     */
    async toggleList() {
        this.listIsActive ? await this.closeList() : await this.openList();
    }
    /* KEYBOARD ACCESSIBILITY */
    // keyboard handler on the trigger (separate from the list)
    handleTriggerKeyDown(ev) {
        switch (ev.key) {
            case 'ArrowDown':
                this.handleArrowKey(ev, DOWN_DIRECTION);
                break;
            case 'ArrowUp':
                this.handleArrowKey(ev, UP_DIRECTION);
                break;
            case ' ':
                this.handleSpacebar(ev);
                break;
            case 'Enter':
                this.handleEnterKey();
                break;
            case 'Escape':
                this.handleEscape();
                break;
            case 'Tab':
                this.handleTab(ev);
                break;
            case 'Home':
                this.handleHomeKey(ev);
                break;
            case 'End':
                this.handleEndKey(ev);
                break;
            default:
                this.typeaheadHandler(ev);
                break;
        }
        ev.stopPropagation();
    }
    /**
     * NOTE: market-list has its own internal keyboard functionality,
     * so we only handle the key presses while the parent select is focused.
     *
     * - if the list is open:
     *   - update the selected row to the next or previous row depending on the arrow direction
     * - if the list is closed:
     *   - open the list
     */
    async handleArrowKey(ev, direction) {
        ev.preventDefault(); // do not scroll page while select has focus
        if (this.listIsActive) {
            for (let i = this.focusedRowIndex + direction; i >= 0 && i < this.rows.length; i += direction) {
                if (!this.rows[i].disabled) {
                    this.focusedRowIndex = i;
                    break;
                }
            }
        }
        else {
            await this.openList();
        }
    }
    /**
     * - if the list is open:
     *   - close it
     * - if the list is closed:
     *   - open the list
     *   - if there is a current selection, focus it
     */
    async handleSpacebar(ev) {
        var _a;
        ev.preventDefault(); // do not scroll page while select has focus
        if (this.listIsActive) {
            (_a = this.rows[this.focusedRowIndex]) === null || _a === void 0 ? void 0 : _a.toggle();
        }
        else {
            await this.openList();
        }
    }
    /**
     * when the list is closed, invoke implicit submission
     */
    handleEnterKey() {
        var _a;
        if (this.listIsActive) {
            (_a = this.rows[this.focusedRowIndex]) === null || _a === void 0 ? void 0 : _a.select();
            this.closeList();
        }
        else {
            submitFormImplicitly(this.el);
        }
    }
    /*
    - when the list is open, close it
    */
    handleEscape() {
        if (this.listIsActive) {
            this.closeList();
        }
    }
    /*
    - when the list is open, suppress tab navigation
    - when the list is closed, allow tab navigation and remove focus
    */
    handleTab(ev) {
        if (this.listIsActive) {
            ev.preventDefault();
        }
        else {
            this.focused = false;
        }
    }
    // On Mac, use Fn-Left as "Home"
    handleHomeKey(ev) {
        if (this.listIsActive) {
            ev.preventDefault();
            this.focusedRowIndex = 0;
        }
    }
    // On Mac, use Fn-Right as "End"
    handleEndKey(ev) {
        if (this.listIsActive) {
            ev.preventDefault();
            this.focusedRowIndex = this.rows.length - 1;
        }
    }
    // keyboard handler on the list (separate from the trigger)
    handleListKeyDown(ev) {
        switch (ev.key) {
            case 'Enter':
                this.handleListEnter();
                break;
            case 'Escape':
                this.handleEscape();
                break;
            case 'Tab':
                this.handleTab(ev);
                break;
            case ' ':
                this.handleListSpacebar(ev);
                break;
            default:
                this.typeaheadHandler(ev);
                break;
        }
        ev.stopPropagation();
    }
    /**
     * market-list handles selection functionality internally
     * just need to close the list if single select
     */
    handleListSpacebar(ev) {
        // do nothing if list is multiselect or keydown event is emitted by typing into a slotted search input
        if (this.multiselect || ev.target.hasAttribute('slot', 'search')) {
            return;
        }
        ev.preventDefault(); // do not scroll page while select has focus
        this.closeList();
        this.el.focus();
    }
    /**
     * market-list handles selection functionality internally
     * just need to close the list if single select
     */
    handleListEnter() {
        if (!this.multiselect) {
            this.closeList();
            this.el.focus();
        }
    }
    typeaheadHandler(ev) {
        var _a;
        // if list has a search, that will be used instead of a typeahead
        if ((_a = this.list) === null || _a === void 0 ? void 0 : _a.hasAttribute('has-search')) {
            // TODO: Proxy key events to the search input
            return;
        }
        // because this is the default keydown event handler, we're ignoring
        // "special" keys, numbers, and punctuation for typeahead functionality
        // note that this check will also ignore characters from languages that have
        // no concept of upper/lowercase (ex. japanese)
        // TODO: revisit if localization requires it
        if (ev.key.length > 1 || ev.key.toUpperCase() === ev.key.toLowerCase()) {
            return;
        }
        this.storeKeypresses(ev);
        this.setFocusOnMatch();
    }
    storeKeypresses(ev) {
        this.keypresses = [...this.keypresses, ev.key];
    }
    /* EVENT HANDLING */
    handleFocus() {
        if (this.readonly || this.disabled) {
            return;
        }
        this.focused = true;
    }
    handleTriggerClick(ev) {
        if (ev.target.tagName.toLowerCase() === getNamespacedTagFor('market-tooltip')) {
            return;
        }
        if (this.readonly || this.disabled) {
            return;
        }
        this.toggleList();
    }
    handleListClick() {
        if (!this.multiselect) {
            this.closeList();
            this.el.focus();
        }
    }
    initPopperListeners() {
        const { el, popoverElement, updatePopper } = this;
        this.cleanupPopperListeners = autoUpdate(el, popoverElement, updatePopper.bind(this), {
            elementResize: false,
        });
    }
    updatePopper() {
        const { el, popoverElement, popoverStrategy } = this;
        // TODO: use design tokens
        const MARGIN_OFFSET = 8;
        const MAX_HEIGHT = 464;
        computePosition(el, popoverElement, {
            strategy: popoverStrategy,
            middleware: [
                offset(MARGIN_OFFSET),
                autoPlacement({
                    allowedPlacements: ['top', 'bottom'],
                }),
                size({
                    apply({ rects, availableHeight }) {
                        Object.assign(popoverElement.style, {
                            width: `${rects.reference.width}px`,
                            maxHeight: `${Math.min(availableHeight - MARGIN_OFFSET, MAX_HEIGHT)}px`,
                        });
                    },
                }),
                shift({ padding: MARGIN_OFFSET }),
            ],
        }).then(({ x, y }) => {
            Object.assign(popoverElement.style, {
                left: `${x}px`,
                top: `${y}px`,
            });
        });
    }
    initPopover() {
        this.popoverElement =
            this.popoverElement ||
                document.createElement(getNamespacedTagFor('market-popover'));
        this.popoverElement.id = this.popoverId;
        this.popoverElement.style.position = this.popoverStrategy;
    }
    initList() {
        this.list = this.el.querySelector('[slot="list"]');
        this.list.interactive = true;
        this.list.multiselect = this.multiselect;
        this.list.addEventListener('marketListSelectionsDidChange', this.handleListSelection.bind(this));
        this.list.addEventListener('marketListItemsFiltered', this.handleListItemsFiltered.bind(this));
        this.list.addEventListener('keydown', this.handleListKeyDown.bind(this));
        this.list.addEventListener('click', this.handleListClick.bind(this));
    }
    initRows() {
        this.rows = this.list.querySelectorAll(`${getNamespacedTagFor('market-row')}`);
        this.rows.forEach((row) => {
            // Set an ID for the row if it doesn't have one (we need this for aria-activedescendant)
            if (!row.id) {
                row.id = `market-row-${v4()}`;
            }
        });
        // used for typeahead functionality
        this.rowsInnerText = [...this.rows]
            .filter((row) => {
            /**
             * Addresses an issue in test environments where the innerText of
             * market-rows isn't set before componentWillLoad of the parent market-select (this file)
             * is executed.
             */
            return row && row.innerText;
        })
            .map((row) => row.innerText.trim().toLowerCase());
    }
    moveListToPopover() {
        this.list.removeAttribute('slot');
        this.popoverElement.append(this.list);
    }
    moveListToSelect() {
        this.list.setAttribute('slot', 'list');
        this.el.append(this.list);
    }
    /* COMPONENT LIFECYCLE EVENTS AND HELPERS */
    registerSlottedAccessories() {
        const leadingAccessory = [...this.el.children].filter(function (child) {
            return child.matches('[slot="leading-accessory"]');
        });
        const trailingAccessory = [...this.el.children].filter(function (child) {
            return child.matches('[slot="trailing-accessory"]');
        });
        this.hasLeadingAccessory = leadingAccessory.length > 0;
        this.hasTrailingAccessory = trailingAccessory.length > 0;
    }
    componentWillLoad() {
        this.registerSlottedAccessories();
        this.popoverId = this.popoverId || `popover-${v4()}`;
    }
    componentDidLoad() {
        this.initList();
        this.initRows();
        this.initPopover();
        this.initListObserver();
        this.propagateValue();
    }
    componentWillRender() {
        const { listIsActive, list } = this;
        if (list && listIsActive) {
            list.removeAttribute('slot');
        }
    }
    disconnectedCallback() {
        this.closeList();
    }
    render() {
        const tabindex = this.disabled ? null : '0';
        return (hAsync(Host, { key: '9dc67f571060f9c4d9fc02684f5a1e6a4aeaf1ab', class: "market-select", role: "combobox", "aria-label": getTextInputAriaLabel(this.el), "aria-expanded": this.listIsActive.toString(), "aria-controls": this.popoverId, "aria-activedescendant": this.focusedRowIndex > -1 ? this.rows[this.focusedRowIndex].id : null, "aria-required": this.required.toString(), tabindex: tabindex, onClick: (e) => {
                this.handleTriggerClick(e);
            }, onFocus: () => {
                this.handleFocus();
            }, onKeyDown: (e) => {
                this.handleTriggerKeyDown(e);
            } }, hAsync("slot", { key: '4b32c361f91a9e3ec8d602cf1f876008f5faca75', name: "leading-accessory", onSlotchange: () => this.registerSlottedAccessories() }), hAsync("div", { key: '2f0a75e0c406f2b1e84c0c050505109f2f6707dc', class: classNames('label-input-container', {
                'has-leading-accessory': this.hasLeadingAccessory,
                'has-trailing-accessory': this.hasTrailingAccessory,
            }) }, hAsync("slot", { key: '01e62bf7c3d22901f05ba0d050e5acb2a40fca34' }), hAsync("slot", { key: '6e3f1047cda70d511eb140be503f536991002af0', name: "displayed-selection" }, hAsync("div", { key: 'f82cb1204a14479df042296bcdf038a5050b10eb', class: "placeholder" }, this.placeholder))), hAsync("slot", { key: 'c101691da11b4a75af72cafa91f42fc7bb8da3b1', name: "list" }), hAsync("slot", { key: 'a156419f608e21bec5ea1d6075fc07f7638dfe96', name: "trailing-accessory", onSlotchange: () => this.registerSlottedAccessories() }), hAsync("svg", { key: '7fa3d353a90501483e0e5adb804af1b51a1b5593', class: "caret", width: "14", height: "8", viewBox: "0 0 14 8", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '4e3ff52b7499db8f87bfae74ef7757378858891b', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M7.70715 7.70711C7.31663 8.09763 6.68346 8.09763 6.29294 7.70711L0.29294 1.70711L1.70715 0.292892L7.00005 5.58579L12.2929 0.292893L13.7072 1.70711L7.70715 7.70711Z", fill: "black" }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueWatcher"],
        "multiselect": ["multiselectWatcher"],
        "focusedRowIndex": ["focusedRowIndexWatcher"]
    }; }
    static get style() { return MarketSelectStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-select",
        "$members$": {
            "name": [1],
            "value": [1537],
            "size": [513],
            "placeholder": [1],
            "readonly": [516],
            "disabled": [516],
            "focused": [1540],
            "invalid": [516],
            "required": [516],
            "multiselect": [516],
            "popoverContainer": [1, "popover-container"],
            "popoverStrategy": [1, "popover-strategy"],
            "listIsActive": [32],
            "focusedRowIndex": [32],
            "hasLeadingAccessory": [32],
            "hasTrailingAccessory": [32],
            "openList": [64],
            "closeList": [64],
            "toggleList": [64]
        },
        "$listeners$": [[8, "click", "windowClick"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["size", "size"], ["readonly", "readonly"], ["disabled", "disabled"], ["focused", "focused"], ["invalid", "invalid"], ["required", "required"], ["multiselect", "multiselect"]]
    }; }
}

const compressDefaults = { threshold: 0, linearRatio: 1, quadraticRatio: 1, invert: false };
/**
 * Compress a given input value as it exceeds a given threshhold.
 * Both quadratic and linear compression is supported.
 * the output grows by an increasingly diminishing amount.
 * @param {number} input - The value to be compressed.
 * @param {CompressOptions} options - Override defaults for the compression.
 * @param {number} options.threshhold - The value where compression starts. Input values that exceed the threshhold will be compressed. Default of 0.
 * @param {number} options.linearRatio - (0-1) The ratio to which the input exceeding the threshhold will be reduced. 0.33 creates a ~3-to-1 compression. Default of 1 (no compression).
 * @param {number} options.quadraticRatio - (0-1) The ratio of quadratic compression to which the input exceeding the threshhold will be reduced. 0.33 creates a ~cube-root compression. Default of 1 (no compression).
 * @param {boolean} options.invert - If true, the compression instead comrpesses values below the threshhold.
 */
function compress(input, options = {}) {
    const { quadraticRatio, linearRatio, threshold, invert } = Object.assign({}, compressDefaults, options);
    const inverter = invert ? -1 : 1;
    if (input * inverter < threshold * inverter) {
        return input;
    }
    const inputDelta = (input - threshold) * inverter;
    // note we offset by 1 to avoid values 0-1 being adjusted in the opposite direction when exponentialized.
    // this means that a provided quadratic ration of 0.5 does not result in a perfect square root.
    let outputDelta = (inputDelta + 1) ** quadraticRatio - 1;
    outputDelta = outputDelta * linearRatio;
    return threshold + outputDelta * inverter;
}
function lerp(a, b, alpha) {
    return a + alpha * (b - a);
}
function getDelta(startCoords, endCoords) {
    return {
        x: endCoords.x - startCoords.x,
        y: endCoords.y - startCoords.y,
    };
}
function magnitude(delta) {
    return (delta.x ** 2 + delta.y ** 2) ** 0.5;
}

const marketSheetCss = "@keyframes market-popup{from{opacity:0%;transform:scale(0.9, 0.9)}to{opacity:100%;transform:scale(1, 1)}}@keyframes market-popdown{from{opacity:100%;transform:scale(1, 1)}to{opacity:0%;transform:scale(0.9, 0.9)}}@keyframes market-slideup{from{opacity:0%;transform:translateY(80vh)}to{opacity:100%;transform:translateY(0)}}@keyframes market-slidedown{from{opacity:100%;transform:translateY(0)}to{opacity:0%;transform:translateY(80vh)}}@keyframes market-slide-left-enter{from{transform:translateX(100%)}to{transform:translateX(0)}}@keyframes market-slide-left-exit{from{transform:translateX(0)}to{transform:translateX(100%)}}@keyframes market-fade-in{from{opacity:0%}to{opacity:100%}}@keyframes market-fade-out{from{opacity:100%}to{opacity:0%}}@keyframes market-input-autofill-start{from{}to{}}@keyframes market-input-autofill-cancel{from{}to{}}@keyframes market-input-search-compact-enter{from{}to{}}@keyframes market-input-search-compact-exit{from{}to{}}/*!@:host*/.sc-market-sheet-h{display:flex;flex-direction:column;justify-content:stretch;overflow:hidden}/*!@:host ::slotted(main), :host ::slotted(.main)*/.sc-market-sheet-h .sc-market-sheet-s>main,.sc-market-sheet-h.sc-market-sheet-s>.main,.sc-market-sheet-h .sc-market-sheet-s>.main{flex:0 1 100%;overflow-y:auto;height:100%}/*!@:host ::slotted(.market-header)*/.sc-market-sheet-h .sc-market-sheet-s>.market-header{margin-bottom:var(--core-metrics-spacing-300);padding-top:0}/*!@:host ::slotted(.market-footer)*/.sc-market-sheet-h .sc-market-sheet-s>.market-footer{padding-bottom:0}/*!@:host*/.sc-market-sheet-h{--handle-whitespace:calc(var(--modal-sheet-handle-padding-top-size) + var(--modal-sheet-handle-padding-bottom-size));--handle-area-height:calc(var(--handle-whitespace) + var(--modal-sheet-handle-height));--max-width-padding:var(--modal-sheet-regular-horizontal-size-class-horizontal-padding);--min-width-padding:var(--modal-sheet-compact-horizontal-size-class-horizontal-padding);--padding-width:clamp(var(--min-width-padding), calc(50% - 200px), var(--max-width-padding));--padding-height:var(--modal-sheet-regular-vertical-size-class-vertical-padding);position:fixed;top:calc(100vh + var(--handle-area-height));bottom:auto;left:50%;overflow:visible;box-sizing:border-box;width:100%;max-width:calc(400px + calc(var(--max-width-padding) + var(--max-width-padding)));max-height:calc(100% - var(--handle-area-height));padding-top:var(--padding-height);border-radius:var(--modal-sheet-border-radius) var(--modal-sheet-border-radius) 0 0;background-color:var(--modal-sheet-background-color);opacity:0%;-webkit-user-select:none;-moz-user-select:none;user-select:none;transition:top var(--core-animation-enter-transition-moderate-speed-duration),\n    opacity var(--core-animation-enter-transition-moderate-speed-duration);transform:translate(-50%, 0)}/*!@:host([state=\"closed\"])*/[state=\"closed\"].sc-market-sheet-h{top:calc(100vh + var(--handle-area-height));opacity:0%;transition:top var(--core-animation-exit-transition-moderate-speed-duration),\n      opacity var(--core-animation-exit-transition-moderate-speed-duration)}/*!@:host([state=\"partial-open\"])*/[state=\"partial-open\"].sc-market-sheet-h{opacity:100%}/*!@:host([state=\"full-open\"])*/[state=\"full-open\"].sc-market-sheet-h{opacity:100%}/*!@:host([dragging])*/[dragging].sc-market-sheet-h{transition:opacity var(--core-animation-enter-transition-moderate-speed-duration)}/*!@:host([tapdisabled])*/[tapdisabled].sc-market-sheet-h{pointer-events:none}/*!@:host ::slotted([slot=\"header\"])*/.sc-market-sheet-h .sc-market-sheet-s>[slot=\"header\"]{padding-right:var(--padding-width);padding-left:var(--padding-width)}/*!@:host::after*/.sc-market-sheet-h::after{content:\"\";position:absolute;top:100%;display:block;width:inherit;max-width:inherit;height:100vh;background-color:inherit}/*!@.handle*/.handle.sc-market-sheet{position:fixed;bottom:calc(100% + var(--modal-sheet-handle-padding-bottom-size));left:50%;display:block;width:var(--modal-sheet-handle-width);height:var(--modal-sheet-handle-height);border:none;border-radius:var(--modal-sheet-border-radius);background-color:var(--modal-sheet-handle-background-color);-webkit-user-select:none;-moz-user-select:none;user-select:none;transform:translate(-50%, 0)}/*!@.handle::before*/.handle.sc-market-sheet::before{content:\"\";position:absolute;inset:calc(var(--modal-sheet-handle-padding-bottom-size) * -1)}/*!@.handle:focus*/.handle.sc-market-sheet:focus{outline:var(--button-focus-ring-border-size) solid var(--button-focus-ring-color)}/*!@.main*/.main.sc-market-sheet{overflow-x:hidden;overflow-y:auto;padding-right:var(--padding-width);padding-bottom:var(--padding-height);padding-left:var(--padding-width);overscroll-behavior:contain}/*!@.main[dragging]*/.main[dragging].sc-market-sheet{overflow-y:hidden}";
var MarketSheetStyle0 = marketSheetCss;

const TOP_GAP = cjs.MODAL_SHEET_HANDLE_HEIGHT + cjs.MODAL_SHEET_HANDLE_PADDING_BOTTOM_SIZE + cjs.MODAL_SHEET_HANDLE_PADDING_TOP_SIZE;
const SWIPE_DISTANCE = 0.12; // ratio of screen height before drag registers as a gesture
const SWIPE_WINDOW = 250; // time in milliseconds to consider for gesture recognition
const TAP_DISABLE_DISTANCE = 0.01; // ratio of screen height before drag disables tapping child elements
const MIN_DRAG_COMPRESSION_RATIO = 0.8; // (0-1) how much the sheet allows itself to be dragged past its natural boundaries
const MAX_DRAG_COMPRESSION_RATIO = 0.55; // (0-1) how much the sheet allows itself to be dragged past its natural boundaries
const RESIZE_DEBOUNCE_DURATION$1 = 16; // 60fps
class MarketSheet {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketDialogLoaded = createEvent(this, "marketDialogLoaded", 7);
        this.marketDialogDismissed = createEvent(this, "marketDialogDismissed", 7);
        this.marketDialogDidDismiss = createEvent(this, "marketDialogDidDismiss", 7);
        this.type = 'sheet';
        // These bound func refs are so we can remove them later
        this.boundOnDragMove = this.onDragMove.bind(this);
        this.boundOnDragEnd = this.onDragEnd.bind(this);
        this.boundOnScrollDrag = this.onScrollDrag.bind(this);
        this.hidden = false;
        this.dialogID = undefined;
        this.openMode = 'partial';
        this.animationEnterDuration = cjs.CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION;
        this.animationExitDuration = cjs.CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION;
        this.disableFocus = false;
        this.closeHandleAriaLabel = 'Close';
    }
    /* eslint-disable @typescript-eslint/require-await */
    /**
     * Activates the focus trap
     * @param {Object} [options] [focus-trap `.createFocusTrap` options](https://github.com/focus-trap/focus-trap#createoptions)
     * @param {Object} [activateOptions] [focus-trap `.activate` options](https://github.com/focus-trap/focus-trap#trapactivate)
     */
    async activateFocusTrap(options, activateOptions) {
        if (this.focusTrap) {
            this.focusTrap.activate(activateOptions);
            if (this.disableFocus) {
                this.disableFocus = false;
            }
        }
        else {
            this.focusTrap = createAndActivateFocusTrap({
                activateOptions,
                el: this.el,
                options: Object.assign(Object.assign({}, options), { initialFocus: false }),
            });
        }
        this.focusTrapActivateOptions = activateOptions;
    }
    /**
     * Deactivates the focus trap
     * @param {Object} [deactivateOptions] [focus-trap `.deactivate` options](https://github.com/focus-trap/focus-trap#trapdeactivate)
     */
    async deactivateFocusTrap(deactivateOptions) {
        if (this.focusTrap) {
            this.focusTrap.deactivate(deactivateOptions);
            this.focusTrap = undefined;
        }
    }
    /**
     * Emits the dismiss event
     * The parent context will handle actually removing elements from the DOM,
     * All the sheet needs to do it emit an event so actually closing it can be
     * some other elements problem
     */
    async dismiss(options) {
        const { defaultPrevented } = this.marketDialogDismissed.emit({
            dialog: this.el,
            type: this.type,
            origin: (options === null || options === void 0 ? void 0 : options.origin) || this.el,
        });
        if (!defaultPrevented) {
            this.hidden = true;
            await new Promise((resolve) => setTimeout(resolve, cjs.CORE_ANIMATION_EXIT_TRANSITION_MODERATE_SPEED_DURATION));
            this.marketDialogDidDismiss.emit({
                dialog: this.el,
                type: this.type,
                origin: this.el,
            });
        }
    }
    /* eslint-enable @typescript-eslint/require-await */
    // Given a desired state, we update our actual state according to the open mode.
    // e.g. "fully opening" a sheet in partial open mode will result in a partial-open state.
    setState(state) {
        let targetState = state;
        if (targetState !== 'closed' && this.openMode !== 'dynamic') {
            // override open state according to open mode
            targetState = `${this.openMode}-open`;
        }
        this.el.setAttribute('state', targetState);
        this.resetTopByState();
    }
    // Calculate the `top` value for the sheet according to the state.
    resetTopByState() {
        this.calculateTopBoundary();
        const state = this.el.getAttribute('state');
        // For some incredibly arcane reason, if you do not read the clientHeight property
        // then the second time a context manager opens the sheet it will not animate open correctly.
        // So we set this variable to ensure that the clientHeight gets read regardless of state.
        const clientHeight = this.el.clientHeight;
        if (state === 'closed') {
            this.el.style.removeProperty('top');
        }
        else if (clientHeight + TOP_GAP >= window.innerHeight || state === 'full-open') {
            // Stick to the top of the screen even if the window resizes.
            this.el.style.top = `${TOP_GAP + window.visualViewport.offsetTop}px`;
        }
        else {
            // partial-open
            // We essentially recreate `top: auto` here. This is necessary
            // because `top: auto` breaks css transitions.
            // It's important to use % rather than vh here so that the
            // address bar is accounted for.
            this.el.style.top = `calc(100% - ${clientHeight}px)`;
        }
        // when virtual keyboard is open, add padding to bottom of sheet to allow space for content to scroll
        this.el.style.paddingBottom = window.visualViewport.offsetTop ? `${window.visualViewport.offsetTop}px` : '0';
    }
    // Calculate the highest top value allowed by the open mode.
    // Dragging past this boundary will experience resitance.
    // The closer the top boundary is to the top of the screen, the more resistance.
    calculateTopBoundary() {
        this.topBoundary = this.openMode === 'partial' ? window.innerHeight - this.el.clientHeight : TOP_GAP;
        this.compressionRatio = lerp(MAX_DRAG_COMPRESSION_RATIO, MIN_DRAG_COMPRESSION_RATIO, this.topBoundary / window.innerHeight);
    }
    setTop(top) {
        // Add some 'springiness' that resists sheet being dragged past its topBoundary
        // by compressing movement past that threshhold.
        const newTop = compress(top, { threshold: this.topBoundary, quadraticRatio: this.compressionRatio, invert: true });
        this.el.style.top = `${newTop}px`;
        return newTop;
    }
    onDragStart(e) {
        // only start drag on touch events or left mouse clicks
        if (!isTouchEvent(e) && e.button !== 0) {
            return;
        }
        // special cases if virtual keyboard is open
        if (window.visualViewport.offsetTop) {
            // if clicking an already-focused element, do nothing
            if (e.target === document.activeElement) {
                return;
            }
            // blur currently-focused element (dismisses virtual keyboard)
            document.activeElement.blur();
            // click event target (element will get focus if focusable)
            e.target.click();
            return;
        }
        const { top } = this.el.getBoundingClientRect();
        this.dragStartTop = top;
        this.el.setAttribute('dragging', '');
        this.calculateTopBoundary();
        const newTop = this.setTop(top);
        const eventCoords = getCoordsFromEvent(e);
        this.dragEventStack = [[e.timeStamp, newTop]];
        this.touchStartCoords = eventCoords;
        this.dragDelta = { x: 0, y: 0 };
        const { boundOnDragMove, boundOnDragEnd } = this;
        document.addEventListener('mousemove', boundOnDragMove);
        document.addEventListener('mouseup', boundOnDragEnd);
        document.addEventListener('touchmove', boundOnDragMove);
        document.addEventListener('touchend', boundOnDragEnd);
    }
    onDragMove(e) {
        const eventCoords = getCoordsFromEvent(e);
        this.dragDelta = getDelta(this.touchStartCoords, eventCoords);
        if (!this.el.hasAttribute('tapdisabled') && magnitude(this.dragDelta) / window.innerHeight > TAP_DISABLE_DISTANCE) {
            this.el.setAttribute('tapdisabled', '');
        }
        const newTop = this.setTop(this.dragStartTop + this.dragDelta.y);
        this.dragEventStack.push([e.timeStamp, newTop]);
        this.pruneStack(e.timeStamp);
    }
    // When we end drag we need to calculate what gesture was performed and update the state accordingly.
    // There are two categories of gesture: 'swipe' and 'drop'. If the gesture ends with movement that exceeds
    // the SWIPE_DISTANCE within the SWIPE_WINDOW, then the gesture is a 'swipe', otherwise it is a 'drop.'
    // A 'swipe' up always sets the sheet to its maximally open mode, while a swipe down closes it.
    // A 'drop' sets the state according to where on the page the sheet was released (e.g) releasing the sheet
    // near the bottom of the screen will close it.
    onDragEnd(e) {
        const eventCoords = getCoordsFromEvent(e);
        this.dragDelta = getDelta(this.touchStartCoords, eventCoords);
        const finalTop = this.dragStartTop + this.dragDelta.y;
        const newTop = this.setTop(finalTop);
        // this differs from the 'topBoundary' for sheets in dynamic mode
        const naturalTop = this.openMode === 'full' ? TOP_GAP : window.innerHeight - this.el.clientHeight;
        const halfwayBreakpoint = window.innerHeight / 2;
        const bottomDropBreakpoint = lerp(window.innerHeight, naturalTop, 0.6);
        const topDropBreakpoint = lerp(TOP_GAP, naturalTop, 0.6);
        const minSwipeDistance = SWIPE_DISTANCE * window.innerHeight;
        this.dragEventStack.push([e.timeStamp, newTop]);
        const gestureDelta = this.getGestureDelta(e, minSwipeDistance);
        if (gestureDelta > minSwipeDistance) {
            // we have finished the drag by swiping downward,
            // so dismiss regardless of final position
            this.dismiss();
        }
        else if (gestureDelta < -minSwipeDistance) {
            // we have finished the drag by swiping upward,
            // so open the sheet regardless of final position
            this.setState('full-open');
        }
        else if (finalTop > halfwayBreakpoint && finalTop > bottomDropBreakpoint) {
            // we have dragged down to within the bottom drop distance
            this.dismiss();
        }
        else if (finalTop < topDropBreakpoint) {
            // we have dragged up to within the top drop distance
            this.setState('full-open');
        }
        else {
            // we have dragged to a middle position
            this.setState('partial-open');
        }
        this.cleanupDragging();
    }
    // When we start a touch within the scrollable part of the sheet we set up a listener
    // to track this move.
    onScrollStart() {
        this.scrollStart = this.mainContent.scrollTop;
        document.addEventListener('touchmove', this.boundOnScrollDrag, { passive: true });
    }
    // When we get our first touch move event (after touching within the scrollable area)
    // we calculate whether this move will result in scrolling within the sheet. If so we disable
    // the drag event handling for the rest of the touch move and let the browser handle scrolling.
    // If the move won't result in scrolling (i.e. we've alreadry reached the end of the scrollable area)
    // then instead we disable scrolling until the touch move completes, allowing the drag event
    // handlers to operate as normal.
    onScrollDrag(e) {
        const maxScroll = this.mainContent.scrollHeight - this.mainContent.clientHeight;
        const dragCoords = getCoordsFromEvent(e);
        const scrollDelta = getDelta(this.touchStartCoords, dragCoords);
        const scrollTarget = this.scrollStart - scrollDelta.y;
        const { boundOnScrollDrag, mainContent } = this;
        // If the calculated scroll is within the scrollable area, scroll instead of dragging the sheet.
        if (scrollTarget >= 0 && scrollTarget <= maxScroll) {
            // We are scrolling, so we stop all of our drag handling and let the browser handle things from here
            e.stopImmediatePropagation();
            this.cleanupDragging();
        }
        else {
            // this disables scrolling on the scrollable area while the drag is in progress.
            mainContent.setAttribute('dragging', '');
        }
        document.removeEventListener('touchmove', boundOnScrollDrag);
    }
    // Remove expired events from the gesutre tracking stack.
    pruneStack(timeStamp) {
        while (this.dragEventStack.length > 0 && this.dragEventStack[0][0] < timeStamp - SWIPE_WINDOW) {
            this.dragEventStack.shift();
        }
    }
    // 'Replay' events from our gesture tracking stack until we reach total movement
    // that exceeds the minSwipeDistance threshhold (indicating a 'swipe' rather than a 'drop').
    // This means the most recent movement will be considered first, and so if the gesture ends in a
    // swipe this will be detected regardless of the total delta of the gesture.
    // (e.g. the sheet is dragged downward before ending with a swipe up will register as a swipe up
    // even if the released position of the sheet is below its starting position.
    getGestureDelta(e, minSwipeDistance) {
        let gestureDelta = 0;
        let currentTop = this.dragEventStack.pop()[1];
        this.pruneStack(e.timeStamp);
        while (this.dragEventStack.length > 0) {
            const previousTop = this.dragEventStack.pop()[1];
            const updateDelta = currentTop - previousTop;
            gestureDelta += updateDelta;
            currentTop = previousTop;
            if (Math.abs(gestureDelta) > minSwipeDistance)
                break;
        }
        return gestureDelta;
    }
    cleanupDragging() {
        const { boundOnDragMove, boundOnDragEnd, el, mainContent } = this;
        el.removeAttribute('dragging');
        mainContent.removeAttribute('dragging');
        el.removeAttribute('tapdisabled');
        document.removeEventListener('mousemove', boundOnDragMove);
        document.removeEventListener('mouseup', boundOnDragEnd);
        document.removeEventListener('touchmove', boundOnDragMove);
        document.removeEventListener('touchend', boundOnDragEnd);
    }
    onKeyDown(e) {
        switch (e.key) {
            case 'Enter':
                this.dismiss();
                break;
            case ' ':
                this.dismiss(e);
                e.preventDefault(); // spacebar should not scroll page
                break;
        }
    }
    connectedCallback() {
        /**
         * Emit a dialogLoaded event when the component connects. Need this so
         * the context manager isn't rummaging around it's DOM to try and find the
         * dialog that was just appended
         */
        setTimeout(() => {
            this.marketDialogLoaded.emit({
                dialog: this.el,
                type: this.type,
            });
            if (!this.disableFocus) {
                this.activateFocusTrap();
            }
        }, this.hidden ? 0 : cjs.CORE_ANIMATION_ENTER_TRANSITION_MODERATE_SPEED_DURATION);
    }
    hiddenHandler() {
        this.setState(this.hidden ? 'closed' : 'partial-open');
    }
    componentDidLoad() {
        this.hiddenHandler();
        // when element is resized
        this.heightObserver = new ResizeObserver(throttle(() => {
            this.resetTopByState();
        }, RESIZE_DEBOUNCE_DURATION$1));
        this.heightObserver.observe(this.el);
        // when visual viewport is resized (aka when virtual keyboard is opened or closed)
        window.visualViewport.addEventListener('resize', throttle(() => {
            this.resetTopByState();
        }, RESIZE_DEBOUNCE_DURATION$1));
        // when child elements get focus (via click/touch event, keyboard, or browser form assistant)
        this.mainContent.addEventListener('focusin', (e) => {
            this.resetTopByState();
            // wait for any related resetTopByState style changes to settle
            delay$1(() => {
                var _a, _b;
                // if virtual keyboard is open (mobile only), programmatically scroll to focused input
                if (window.visualViewport.offsetTop) {
                    const prevOffsetTop = (_a = e.relatedTarget) === null || _a === void 0 ? void 0 : _a.offsetTop;
                    const currOffsetTop = (_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.offsetTop;
                    // scrollIntoView needs to use different block (vertical alignment) behavior depending on
                    // how the focus was set, otherwise mobile Safari Form Assistant can't reliably move
                    // between all inputs (clicking an input or moving to the previous input uses "center",
                    // moving to the next input uses "start")
                    document.activeElement.scrollIntoView({
                        behavior: 'smooth',
                        block: prevOffsetTop < currOffsetTop ? 'start' : 'center',
                        inline: 'start',
                    });
                }
            }, 250);
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.heightObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    render() {
        return (hAsync(Host, { key: '0141e61e23a2b16ef9768c130296e7664c99ddcd', role: "dialog", onMouseDown: (e) => this.onDragStart(e), onTouchStart: (e) => this.onDragStart(e) }, hAsync("button", { key: '08b465eb785a4f2055d448f3db5b062228458f40', "aria-label": this.closeHandleAriaLabel, class: "handle", onClick: this.dismiss.bind(this), onKeyDown: this.onKeyDown.bind(this) }), hAsync("slot", { key: '7d87505923bbd66b5c0ee95c4c8f79f544fda8f6', name: "header" }), hAsync("div", { key: 'c643d8f2e58a18035ca76cbc034bd50922114fe9', class: "main", ref: (el) => (this.mainContent = el), onTouchStart: () => this.onScrollStart() }, hAsync("slot", { key: 'ce2087b1d85f22c5b2edc78b8f6cf9dd687a54e3' }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "hidden": ["hiddenHandler"]
    }; }
    static get style() { return MarketSheetStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-sheet",
        "$members$": {
            "hidden": [1540],
            "dialogID": [513, "data-dialog-id"],
            "openMode": [1025, "open-mode"],
            "animationEnterDuration": [2, "animation-enter-duration"],
            "animationExitDuration": [2, "animation-exit-duration"],
            "disableFocus": [1028, "disable-focus"],
            "closeHandleAriaLabel": [1, "close-handle-aria-label"],
            "activateFocusTrap": [64],
            "deactivateFocusTrap": [64],
            "dismiss": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"], ["dialogID", "data-dialog-id"]]
    }; }
}

const marketStepperCss = "/*!@:host, ::slotted(*), **/.sc-market-stepper-h,.sc-market-stepper-s>*,*.sc-market-stepper{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-stepper-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-stepper-h *.sc-market-stepper,.sc-market-stepper-h[disabled].sc-market-stepper-s>*,.sc-market-stepper-h[disabled] .sc-market-stepper-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-stepper-h{position:relative;outline:none;font-weight:var(--field-input-weight);font-size:var(--field-input-size);line-height:var(--field-input-leading);cursor:text}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-stepper-h input.sc-market-stepper,.sc-market-stepper-h.sc-market-stepper-s>input,.sc-market-stepper-h .sc-market-stepper-s>input,.sc-market-stepper-h textarea.sc-market-stepper,.sc-market-stepper-h.sc-market-stepper-s>textarea,.sc-market-stepper-h .sc-market-stepper-s>textarea{width:100%;margin:0;padding:0;border:none;background-color:transparent;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;cursor:inherit}/*!@:host ::slotted(label)*/.sc-market-stepper-h .sc-market-stepper-s>label{cursor:inherit}/*!@:host input:focus, :host ::slotted(input:focus), :host textarea:focus, :host ::slotted(textarea:focus)*/.sc-market-stepper-h input.sc-market-stepper:focus,.sc-market-stepper-h.sc-market-stepper-s>input,.sc-market-stepper-h.sc-market-stepper-s>input:focus,.sc-market-stepper-h .sc-market-stepper-s>input:focus,.sc-market-stepper-h textarea.sc-market-stepper:focus,.sc-market-stepper-h.sc-market-stepper-s>textarea,.sc-market-stepper-h.sc-market-stepper-s>textarea:focus,.sc-market-stepper-h .sc-market-stepper-s>textarea:focus{outline:none}/*!@:host input::-moz-placeholder, :host textarea::-moz-placeholder*/.sc-market-stepper-h input.sc-market-stepper::-moz-placeholder,.sc-market-stepper-h textarea.sc-market-stepper::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host input::placeholder, :host textarea::placeholder*/.sc-market-stepper-h input.sc-market-stepper::placeholder,.sc-market-stepper-h textarea.sc-market-stepper::placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::-moz-placeholder, :host ::slotted(textarea)::-moz-placeholder*/.sc-market-stepper-h.sc-market-stepper-s>input,.sc-market-stepper-h .sc-market-stepper-s>input::-moz-placeholder,.sc-market-stepper-h.sc-market-stepper-s>textarea,.sc-market-stepper-h.sc-market-stepper-s>textarea::-moz-placeholder,.sc-market-stepper-h .sc-market-stepper-s>textarea::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::placeholder, :host ::slotted(textarea)::placeholder*/.sc-market-stepper-h.sc-market-stepper-s>input,.sc-market-stepper-h .sc-market-stepper-s>input::placeholder,.sc-market-stepper-h.sc-market-stepper-s>textarea,.sc-market-stepper-h.sc-market-stepper-s>textarea::placeholder,.sc-market-stepper-h .sc-market-stepper-s>textarea::placeholder{color:var(--field-placeholder-text-color)}/*!@:host([size='small'])*/[size='small'].sc-market-stepper-h{font-size:var(--core-type-paragraph-20-size);line-height:var(--core-type-paragraph-20-leading)}/*!@:host*/.sc-market-stepper-h{border-radius:var(--field-border-radius);background-color:var(--field-normal-state-background-color);color:var(--field-normal-state-input-color)}/*!@:host::after*/.sc-market-stepper-h::after{content:\"\";position:absolute;inset:0;border-radius:var(--field-border-radius);box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color);pointer-events:none}/*!@:host([invalid])::after*/[invalid].sc-market-stepper-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-invalid-validity-border-color)}/*!@:host(:hover)*/.sc-market-stepper-h:hover{background-color:var(--field-hover-state-background-color);color:var(--field-hover-state-input-color)}/*!@:host(:hover)::after*/.sc-market-stepper-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-normal-validity-border-color)}/*!@:host([invalid]:hover)::after*/[invalid].sc-market-stepper-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-invalid-validity-border-color)}/*!@:host([focused])*/[focused].sc-market-stepper-h{color:var(--field-focus-state-input-color)}/*!@:host([focused])::after*/[focused].sc-market-stepper-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size)\n        var(--field-focus-state-normal-validity-border-color)}/*!@:host([focused][invalid])::after*/[focused][invalid].sc-market-stepper-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size) var(--field-focus-state-invalid-validity-border-color)}/*!@:host([readonly]:hover)::after*/[readonly].sc-market-stepper-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color)}/*!@:host([disabled])*/[disabled].sc-market-stepper-h{background-color:var(--field-disabled-state-background-color) !important;color:var(--field-disabled-state-input-color) !important;cursor:not-allowed !important}/*!@:host([disabled])::after*/[disabled].sc-market-stepper-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-disabled-state-border-color) !important}/*!@:host([disabled]) ::slotted(.market-accessory), :host([disabled]) ::slotted(img[slot*=\"accessory\"]), :host([disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([disabled]) ::slotted(div[slot*=\"accessory\"])*/.sc-market-stepper-h[disabled] .sc-market-stepper-s>.market-accessory,.sc-market-stepper-h[disabled].sc-market-stepper-s>img[slot*=\"accessory\"],.sc-market-stepper-h[disabled] .sc-market-stepper-s>img[slot*=\"accessory\"],.sc-market-stepper-h[disabled].sc-market-stepper-s>svg[slot*=\"accessory\"],.sc-market-stepper-h[disabled] .sc-market-stepper-s>svg[slot*=\"accessory\"],.sc-market-stepper-h[disabled].sc-market-stepper-s>div[slot*=\"accessory\"],.sc-market-stepper-h[disabled] .sc-market-stepper-s>div[slot*=\"accessory\"]{--field-disabled-state-accessory-opacity:var(--row-disabled-state-leading-accessory-opacity);opacity:var(--field-disabled-state-accessory-opacity)}/*!@:host([value=\"\"]) ::slotted(label)*/.sc-market-stepper-h[value=\"\"] .sc-market-stepper-s>label{color:var(--field-normal-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"][autofilled]) ::slotted(label)*/.sc-market-stepper-h:not([value=\"\"]) .sc-market-stepper-s>label,.sc-market-stepper-h[value=\"\"][autofilled].sc-market-stepper-s>label,.sc-market-stepper-h[value=\"\"][autofilled] .sc-market-stepper-s>label{color:var(--field-normal-state-float-phase-label-color)}/*!@:host(:hover) ::slotted(label)*/.sc-market-stepper-h:hover .sc-market-stepper-s>label{color:var(--field-hover-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"]):hover) ::slotted(label), :host([value=\"\"][autofilled]:hover) ::slotted(label)*/.sc-market-stepper-h:not([value=\"\"]):hover .sc-market-stepper-s>label,.sc-market-stepper-h[value=\"\"][autofilled]:hover.sc-market-stepper-s>label,.sc-market-stepper-h[value=\"\"][autofilled]:hover .sc-market-stepper-s>label{color:var(--field-hover-state-float-phase-label-color)}/*!@:host([focused]) ::slotted(label)*/.sc-market-stepper-h[focused] .sc-market-stepper-s>label{color:var(--field-focus-state-float-phase-label-color)}/*!@:host([value=\"\"][disabled]) ::slotted(label)*/.sc-market-stepper-h[value=\"\"][disabled] .sc-market-stepper-s>label{color:var(--field-disabled-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])[disabled]) ::slotted(label), :host([value=\"\"][autofilled][disabled]) ::slotted(label)*/.sc-market-stepper-h:not([value=\"\"])[disabled] .sc-market-stepper-s>label,.sc-market-stepper-h[value=\"\"][autofilled][disabled].sc-market-stepper-s>label,.sc-market-stepper-h[value=\"\"][autofilled][disabled] .sc-market-stepper-s>label{color:var(--field-disabled-state-float-phase-label-color)}/*!@:host input::-webkit-outer-spin-button, :host input::-webkit-inner-spin-button*/.sc-market-stepper-h input.sc-market-stepper::-webkit-outer-spin-button,.sc-market-stepper-h input.sc-market-stepper::-webkit-inner-spin-button{margin:0;-webkit-appearance:none;appearance:none}/*!@:host input[type=\"number\"]*/.sc-market-stepper-h input[type=\"number\"].sc-market-stepper{-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield}/*!@:host*/.sc-market-stepper-h{--focus-ring-color:color-mix(in srgb, var(--core-focus-ring-color) 100%, transparent);display:flex;align-items:center}/*!@:host input*/.sc-market-stepper-h input.sc-market-stepper{--stepper-quantity-input-field-height:calc(\n        var(--stepper-quantity-input-field-value-text-leading) + var(--stepper-padding-size) * 2\n      );position:relative;bottom:0;width:100%;height:var(--stepper-quantity-input-field-height);color:var(--stepper-quantity-input-field-value-text-normal-state-color);font-weight:var(--stepper-quantity-input-field-value-text-weight);font-size:var(--stepper-quantity-input-field-value-text-size);font-family:var(--stepper-quantity-input-field-value-text-font-family);line-height:var(--stepper-quantity-input-field-value-text-leading);letter-spacing:var(--stepper-quantity-input-field-value-text-tracking);text-align:center;text-transform:var(--stepper-quantity-input-field-value-text-case);cursor:text;font-feature-settings:\"tnum\"}/*!@:host input[disabled]*/.sc-market-stepper-h input[disabled].sc-market-stepper{color:var(--stepper-quantity-input-field-value-text-disabled-state-color)}/*!@:host input::-moz-placeholder*/.sc-market-stepper-h input.sc-market-stepper::-moz-placeholder{color:var(--stepper-quantity-input-field-value-text-placeholder-color)}/*!@:host input::placeholder*/.sc-market-stepper-h input.sc-market-stepper::placeholder{color:var(--stepper-quantity-input-field-value-text-placeholder-color)}/*!@button*/button.sc-market-stepper{--transition-duration:0.2s;--stepper-button-size:var(--stepper-button-minimum-height);position:relative;display:inline-flex;flex-shrink:0;justify-content:center;align-items:center;box-sizing:content-box;width:var(--stepper-button-size);height:var(--stepper-button-size);padding:var(--stepper-padding-size);border:none;border-radius:var(--stepper-border-radius);background:none;cursor:pointer;transition:background-color color var(--transition-duration)}/*!@button::before*/button.sc-market-stepper::before{content:\"\";position:absolute;inset:0;display:block;margin:var(--stepper-padding-size);border-radius:var(--stepper-button-border-radius);background:var(--stepper-button-normal-state-background-color)}/*!@button svg*/button.sc-market-stepper svg.sc-market-stepper{position:relative;pointer-events:none;fill:var(--stepper-button-normal-state-icon-color)}/*!@button:hover::before*/button.sc-market-stepper:hover::before{background:var(--stepper-button-hover-state-background-color)}/*!@button:hover svg*/button.sc-market-stepper:hover svg.sc-market-stepper{fill:var(--stepper-button-hover-state-icon-color)}/*!@button:focus*/button.sc-market-stepper:focus{outline:none}/*!@button:focus::before*/button.sc-market-stepper:focus::before{background:var(--stepper-button-focus-state-background-color)}/*!@button:focus svg*/button.sc-market-stepper:focus svg.sc-market-stepper{fill:var(--stepper-button-focus-state-icon-color)}/*!@button:focus-visible::before*/button.sc-market-stepper:focus-visible::before{outline:var(--core-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--core-focus-ring-border-size)}/*!@button:active::before*/button.sc-market-stepper:active::before{background:var(--stepper-button-pressed-state-background-color)}/*!@button:active svg*/button.sc-market-stepper:active svg.sc-market-stepper{fill:var(--stepper-button-pressed-state-icon-color)}/*!@button[disabled]*/button[disabled].sc-market-stepper{cursor:not-allowed}/*!@button[disabled]::before*/button[disabled].sc-market-stepper::before{background:var(--stepper-button-disabled-state-background-color)}/*!@button[disabled] svg*/button[disabled].sc-market-stepper svg.sc-market-stepper{fill:var(--stepper-button-disabled-state-icon-color)}";
var MarketStepperStyle0 = marketStepperCss;

/**
 * @part native-input - the native input element.
 */
class MarketStepper {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketStepperValueChange = createEvent(this, "marketStepperValueChange", 7);
        this.marketStepperInputFocus = createEvent(this, "marketStepperInputFocus", 7);
        this.value = undefined;
        this.inputId = undefined;
        this.name = undefined;
        this.placeholder = '0';
        this.max = undefined;
        this.min = undefined;
        this.step = 1;
        this.readonly = false;
        this.disabled = false;
        this.focused = false;
        this.invalid = false;
        this.inputAriaLabel = 'Number';
        this.decrementAriaLabel = 'Decrement';
        this.incrementAriaLabel = 'Increment';
        this.incrementDisabled = false;
        this.decrementDisabled = false;
    }
    valueChangeHandler() {
        // sanitize value in case it was set programmatically
        const sanitized = this.sanitizeValue(this.value);
        if (sanitized !== this.value) {
            this.value = sanitized;
        }
        this.updateButtonDisabledStates();
    }
    /**
     * Toggle focus styling on `<market-stepper>` and focus/blur the inner `<input />`.
     */
    setFocus(value = true) {
        if (this.readonly || this.disabled) {
            return Promise.resolve();
        }
        this.focused = value;
        this.focused ? this.inputEl.focus() : this.inputEl.blur();
        return Promise.resolve();
    }
    onChange() {
        const previousValue = this.value;
        let nextValue = Number.parseFloat(this.inputEl.value);
        if (Number.isNaN(nextValue)) {
            // not a valid number, so reset it to null/empty
            nextValue = null;
            this.inputEl.value = '';
        }
        else {
            // a valid number, so sanitize it against min/max/step props
            nextValue = this.sanitizeValue(nextValue);
            this.inputEl.value = nextValue.toString();
        }
        // if value has changed, set it and emit event
        if (nextValue !== previousValue) {
            this.value = nextValue;
            this.emitChangeEvent(previousValue);
        }
    }
    onInputFocus() {
        this.emitInputFocusEvent();
    }
    onDecrementClick() {
        this.stepValue(-this.step);
    }
    onIncrementClick() {
        this.stepValue(this.step);
    }
    onKeyDown(e) {
        if (e.key === 'Enter') {
            submitFormImplicitly(this.el);
        }
    }
    stepValue(step) {
        const previousValue = this.value;
        const nextValue = (previousValue || 0) + step;
        const sanitizedValue = this.sanitizeValue(nextValue);
        if (sanitizedValue !== previousValue) {
            this.value = sanitizedValue;
            this.emitChangeEvent(previousValue);
        }
    }
    sanitizeValue(value) {
        var _a;
        const decimalPlaces = ((_a = this.step.toString().split('.')[1]) === null || _a === void 0 ? void 0 : _a.length) || 0;
        const hasMax = this.max !== null && this.max !== undefined;
        const hasMin = this.min !== null && this.min !== undefined;
        // round value to the nearest step
        let sanitized = Math.round(value / this.step) * this.step;
        // correct any floating point math errors
        sanitized = Number.parseFloat(sanitized.toFixed(decimalPlaces));
        // limit value to max
        sanitized = hasMax ? Math.min(sanitized, this.max) : sanitized;
        // limit value to min
        return hasMin ? Math.max(sanitized, this.min) : sanitized;
    }
    updateButtonDisabledStates() {
        const { value, max, min } = this;
        const hasValue = value !== null && value !== undefined;
        this.incrementDisabled = hasValue ? value === max : false;
        this.decrementDisabled = hasValue ? value === min : false;
    }
    emitChangeEvent(previousValue) {
        const { el, value, marketStepperValueChange } = this;
        marketStepperValueChange.emit({ el, value, previousValue });
    }
    emitInputFocusEvent() {
        const { marketStepperInputFocus } = this;
        marketStepperInputFocus.emit();
    }
    componentWillRender() {
        this.updateButtonDisabledStates();
    }
    render() {
        return (hAsync(Host, { key: '4fa66a3ae5b2e85fc2c0930c0c7662fd13a73109', class: "market-stepper", onFocus: () => {
                this.focused = true;
            }, onBlur: () => {
                this.focused = false;
            } }, hAsync("button", { key: 'd0b486eb97f7d2f277ef7077da51a3736b4e11cb', tabindex: this.disabled || this.decrementDisabled ? -1 : null, disabled: this.disabled || this.decrementDisabled, onClick: () => this.onDecrementClick(), "aria-label": this.decrementAriaLabel }, hAsync("svg", { key: '1f49587ce03a3ac77437e68b9acec58e675870a7', width: "10", height: "2", viewBox: "0 0 10 2", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '22eed75f2afcf818339fb56f4afa5b6d8615127f', d: "M9.66667 0.333328H0.333336V1.66666H9.66667V0.333328Z" }))), hAsync("input", { key: 'cd43e7befba83e6666deb680801145ed3cc92323', ref: (el) => (this.inputEl = el), type: "number", id: this.inputId, name: this.name, readonly: this.readonly, disabled: this.disabled, placeholder: this.placeholder, step: this.step, min: this.min, max: this.max, value: this.value, "aria-label": this.inputAriaLabel, onChange: () => this.onChange(), onFocus: () => this.onInputFocus(), onKeyDown: (e) => this.onKeyDown(e), part: "native-input" }), hAsync("button", { key: '6b2e74af300494bfac3c3796d369421e163dda06', tabindex: this.disabled || this.incrementDisabled ? -1 : null, disabled: this.disabled || this.incrementDisabled, onClick: () => this.onIncrementClick(), "aria-label": this.incrementAriaLabel }, hAsync("svg", { key: 'b8ee04c78ce8c07cc16e4b47d761db6f359dee2b', width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: 'bbd4fa4531041fada7b5e5794d33d0be968033a6', d: "M5.66665 9.66666V5.66666H9.66665V4.33333H5.66665V0.333328H4.33331V4.33333H0.333313V5.66666H4.33331V9.66666H5.66665Z" })))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueChangeHandler"]
    }; }
    static get style() { return MarketStepperStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-stepper",
        "$members$": {
            "value": [1538],
            "inputId": [1, "input-id"],
            "name": [1],
            "placeholder": [1],
            "max": [2],
            "min": [2],
            "step": [2],
            "readonly": [516],
            "disabled": [516],
            "focused": [1540],
            "invalid": [516],
            "inputAriaLabel": [513, "input-aria-label"],
            "decrementAriaLabel": [513, "decrement-aria-label"],
            "incrementAriaLabel": [513, "increment-aria-label"],
            "incrementDisabled": [32],
            "decrementDisabled": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["readonly", "readonly"], ["disabled", "disabled"], ["focused", "focused"], ["invalid", "invalid"], ["inputAriaLabel", "input-aria-label"], ["decrementAriaLabel", "decrement-aria-label"], ["incrementAriaLabel", "increment-aria-label"]]
    }; }
}

const marketTabCss = "/*!@:host([size=\"large\"])*/[size=\"large\"].sc-market-tab-h{font-weight:var(--core-type-heading-30-weight);font-size:var(--core-type-heading-30-size);font-family:var(--core-type-heading-30-font-family);line-height:var(--core-type-heading-30-leading);letter-spacing:var(--core-type-heading-30-tracking);text-transform:var(--core-type-heading-30-case)}/*!@:host(:not([size])), :host([size=\"medium\"])*/.sc-market-tab-h:not([size]),[size=\"medium\"].sc-market-tab-h{font-weight:var(--core-type-heading-20-weight);font-size:var(--core-type-heading-20-size);font-family:var(--core-type-heading-20-font-family);line-height:var(--core-type-heading-20-leading);letter-spacing:var(--core-type-heading-20-tracking);text-transform:var(--core-type-heading-20-case)}/*!@:host([size=\"small\"])*/[size=\"small\"].sc-market-tab-h{font-weight:var(--core-type-medium-20-weight);font-size:var(--core-type-medium-20-size);font-family:var(--core-type-medium-20-font-family);line-height:var(--core-type-medium-20-leading);letter-spacing:var(--core-type-medium-20-tracking);text-transform:var(--core-type-medium-20-case)}/*!@:host*/.sc-market-tab-h{color:var(--tabs-tab-text-color, var(--core-text-20-color))}/*!@:host [part=\"button\"]*/.sc-market-tab-h [part=\"button\"].sc-market-tab{position:relative;border:0;background:none;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;text-transform:inherit;cursor:pointer;transition:color\n    var(--core-animation-enter-transition-fast-speed-duration)\n    var(--core-animation-enter-transition-easing)}/*!@:host [part=\"button\"]::after*/.sc-market-tab-h [part=\"button\"].sc-market-tab::after{content:\"\";position:absolute;bottom:0;left:0;width:100%;height:0;border-radius:var(--tabs-tab-bottom-border-border-radius-top-left, var(--core-metrics-spacing-25))\n      var(--tabs-tab-bottom-border-border-radius-top-right, var(--core-metrics-spacing-25))\n      var(--tabs-tab-bottom-border-border-radius-bottom-right, 0)\n      var(--tabs-tab-bottom-border-border-radius-bottom-left, 0);background:var(--tabs-tab-bottom-border-background-color, var(--core-text-10-color));transition:height\n      var(--core-animation-enter-transition-fast-speed-duration)\n      var(--core-animation-enter-transition-easing),\n      background\n      var(--core-animation-enter-transition-fast-speed-duration)\n      var(--core-animation-enter-transition-easing)}/*!@:host(:hover), :host(:active)*/.sc-market-tab-h:hover,.sc-market-tab-h:active{color:var(--tabs-tab-hover-state-text-color, var(--core-emphasis-text-color));transition:color\n    var(--core-animation-exit-transition-fast-speed-duration)\n    var(--core-animation-exit-transition-easing)}@media (-webkit-device-pixel-ratio: 1){/*!@:host [part=\"button\"]::after*/.sc-market-tab-h [part=\"button\"].sc-market-tab::after{border-radius:0}}/*!@:host([size=\"small\"]) [part=\"button\"]*/[size=\"small\"].sc-market-tab-h [part=\"button\"].sc-market-tab{padding:var(--tabs-tab-small-size-top-padding-size, 4px)\n      0\n      var(--tabs-tab-small-size-bottom-padding-size, 10px)}/*!@:host(:not([size])) [part=\"button\"], :host([size=\"medium\"]) [part=\"button\"]*/.sc-market-tab-h:not([size]) [part=\"button\"].sc-market-tab,[size=\"medium\"].sc-market-tab-h [part=\"button\"].sc-market-tab{padding:var(--tabs-tab-medium-size-top-padding-size, 4px)\n      0\n      var(--tabs-tab-medium-size-bottom-padding-size, 10px)}/*!@:host([size=\"large\"]) [part=\"button\"]*/[size=\"large\"].sc-market-tab-h [part=\"button\"].sc-market-tab{padding:var(--tabs-tab-large-size-top-padding-size, 4px)\n      0\n      var(--tabs-tab-large-size-bottom-padding-size, 12px)}/*!@:host([selected])*/[selected].sc-market-tab-h{color:var(--tabs-tab-selected-text-color, var(--core-text-10-color))}/*!@:host([selected]) [part=\"button\"]::after*/[selected].sc-market-tab-h [part=\"button\"].sc-market-tab::after{height:var(--tabs-tab-selected-bottom-border-height, var(--core-metrics-spacing-25))}/*!@:host([selected]):hover*/[selected].sc-market-tab-h:hover{color:var(--tabs-tab-hover-state-selected-text-color, var(--core-text-10-color))}/*!@:host([selected]):active*/[selected].sc-market-tab-h:active{color:var(--tabs-tab-active-state-selected-text-color, var(--core-emphasis-text-color))}/*!@:host([selected]):active [part=\"button\"]::after*/[selected].sc-market-tab-h:active [part=\"button\"].sc-market-tab::after{background:var(--tabs-tab-active-state-bottom-border-background-color, var(--core-emphasis-text-color))}/*!@:host([disabled])*/[disabled].sc-market-tab-h{color:var(--tabs-tab-disabled-state-text-color, var(--core-text-30-color))}/*!@:host([disabled]):hover*/[disabled].sc-market-tab-h:hover{color:var(--tabs-tab-disabled-state-text-color, var(--core-text-30-color))}/*!@:host([disabled]) [part=\"button\"]*/[disabled].sc-market-tab-h [part=\"button\"].sc-market-tab{cursor:not-allowed}";
var MarketTabStyle0 = marketTabCss;

/**
 * @slot - (Default slot) The text used for the button label
 * @part button - The `<button>` in the shadow DOM
 */
class MarketTab {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTabSelectedChanged = createEvent(this, "marketTabSelectedChanged", 7);
        this.disabled = false;
        this.size = 'medium';
        this.selected = false;
    }
    /**
     * Select the tab and emits a `marketTabSelectedChanged` event
     */
    select() {
        if (this.selected || this.disabled) {
            return Promise.resolve();
        }
        const { defaultPrevented } = this.marketTabSelectedChanged.emit({
            panelId: this.el.getAttribute('aria-controls'),
            prevValue: this.selected,
            tabId: this.el.id,
            value: true,
        });
        if (!defaultPrevented) {
            this.selected = true;
        }
        return Promise.resolve();
    }
    /**
     * Deselects the tab and emits a `marketTabSelectedChanged` event
     */
    deselect() {
        if (!this.selected) {
            return Promise.resolve();
        }
        const { defaultPrevented } = this.marketTabSelectedChanged.emit({
            panelId: this.el.getAttribute('aria-controls'),
            prevValue: this.selected,
            tabId: this.el.id,
            value: false,
        });
        if (!defaultPrevented) {
            this.selected = false;
        }
        return Promise.resolve();
    }
    disabledWatcher() {
        this.selected = false;
    }
    handleClick() {
        this.select();
    }
    handleKeydown(e) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault(); // prevents scroll down when Space is pressed
            this.select();
        }
    }
    render() {
        return (hAsync(Host, { key: '63c07a1172617ce4a15296229d059bc449de69cc', "aria-disabled": this.disabled.toString(), "aria-selected": this.selected.toString(), class: "market-tab", onClick: this.handleClick.bind(this), onKeydown: this.handleKeydown.bind(this), role: "tab", tabindex: "0" }, hAsync("button", { key: 'be7240c4232ba41743c7274f2630563267055b5a', disabled: this.disabled, part: "button", ref: (el) => (this.buttonEl = el), tabindex: "-1" }, hAsync("slot", { key: '8d4d35e1d14a52fb3e6d71805ab83eae31a83009' }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["disabledWatcher"]
    }; }
    static get style() { return MarketTabStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tab",
        "$members$": {
            "disabled": [516],
            "size": [513],
            "selected": [1540],
            "select": [64],
            "deselect": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["size", "size"], ["selected", "selected"]]
    }; }
}

const marketTabListCss = "/*!@:host*/.sc-market-tab-list-h{position:relative;display:flex}/*!@:host::after*/.sc-market-tab-list-h::after{content:\"\";position:absolute;bottom:0;left:0;display:block;width:100%;height:var(--tabs-list-bottom-border-size, 1px);background-color:var(--tabs-list-bottom-border-color, var(--core-divider-20-color))}/*!@:host(:not([size])), :host([size=\"small\"]), :host([size=\"medium\"])*/.sc-market-tab-list-h:not([size]),[size=\"small\"].sc-market-tab-list-h,[size=\"medium\"].sc-market-tab-list-h{gap:var(--tabs-list-medium-size-horizontal-spacing, var(--core-metrics-spacing-200))}/*!@:host([size=\"large\"])*/[size=\"large\"].sc-market-tab-list-h{gap:var(--tabs-list-large-size-horizontal-spacing, var(--core-metrics-spacing-300))}";
var MarketTabListStyle0 = marketTabListCss;

/**
 * @slot - Default slot for `<market-tab>`s
 */
class MarketTabList {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTabListSelectedTabChanged = createEvent(this, "marketTabListSelectedTabChanged", 7);
        this.size = undefined;
        this.selectedTab = undefined;
        this.defaultTab = undefined;
    }
    marketTabSelectedChangedEventHandler(e) {
        var _a;
        const { tabId, value } = e.detail;
        if (!value) {
            return;
        }
        if (this.selectedTab !== tabId) {
            const { defaultPrevented } = this.marketTabListSelectedTabChanged.emit({
                prevValue: this.selectedTab,
                value: tabId,
            });
            if (!defaultPrevented) {
                this.selectedTab = tabId;
            }
        }
        (_a = this.tabEls) === null || _a === void 0 ? void 0 : _a.forEach((tabEl) => {
            if (tabEl.id !== tabId) {
                tabEl.deselect();
                tabEl.tabIndex = -1;
            }
            else {
                tabEl.tabIndex = 0;
            }
        });
    }
    tabWatcher(newTabId) {
        this.selectTab(newTabId);
    }
    sizeWatcher(newSize) {
        this.propagateSizeProp(newSize);
    }
    selectTab(tabId) {
        var _a, _b;
        const tabEl = ((_a = this.tabEls) === null || _a === void 0 ? void 0 : _a.find((el) => tabId === el.id && !el.disabled)) || ((_b = this.tabEls) === null || _b === void 0 ? void 0 : _b.find((el) => !el.disabled));
        tabEl === null || tabEl === void 0 ? void 0 : tabEl.select();
    }
    propagateSizeProp(size) {
        this.tabEls.forEach((el) => {
            if (this.size && el.size !== this.size) {
                el.size = size;
            }
        });
    }
    focusOnTab(el) {
        var _a, _b;
        (_b = (_a = el === null || el === void 0 ? void 0 : el.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('button')) === null || _b === void 0 ? void 0 : _b.focus();
    }
    handleKeyDown(e) {
        if (!this.tabEls || this.tabEls.every((el) => el.disabled)) {
            return;
        }
        /**
         * These keyboard shortcut behaviours are from:
         * https://www.w3.org/WAI/ARIA/apg/patterns/tabs/examples/tabs-manual/#kbd_label
         *
         * Tab, Enter, and Space behaviours should already natively work.
         */
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'Home' || e.key === 'End') {
            e.preventDefault(); // prevent key press from triggering scroll events
            const currentTabIndex = this.tabEls.indexOf(e.target);
            if (currentTabIndex < 0) {
                return;
            }
            const left = this.tabEls.slice(0, currentTabIndex);
            const right = this.tabEls.slice(currentTabIndex + 1);
            switch (e.key) {
                case 'ArrowRight': {
                    const focusableTabEls = [...right, ...left].find((el) => !el.disabled);
                    this.focusOnTab(focusableTabEls);
                    break;
                }
                case 'ArrowLeft': {
                    const focusableTabEls = [...right, ...left].reverse().find((el) => !el.disabled);
                    this.focusOnTab(focusableTabEls);
                    break;
                }
                case 'Home': {
                    const focusableTabEls = this.tabEls.find((el) => !el.disabled);
                    this.focusOnTab(focusableTabEls);
                    break;
                }
                case 'End': {
                    const focusableTabEls = this.tabEls.filter((el) => !el.disabled);
                    this.focusOnTab(focusableTabEls[focusableTabEls.length - 1]);
                    break;
                }
            }
        }
    }
    handleSlotChange() {
        this.tabEls = [...this.el.querySelectorAll(getNamespacedTagFor('market-tab'))];
        this.propagateSizeProp(this.size);
    }
    componentWillLoad() {
        this.handleSlotChange();
        this.selectTab(this.selectedTab || this.defaultTab);
    }
    render() {
        return (hAsync(Host, { key: 'a2159152585d6f16a997a913e9044a7139f66ddb', class: "market-tab-list", onKeyDown: this.handleKeyDown.bind(this), role: "tablist" }, hAsync("slot", { key: '45fce6685de615924133dec82799db58f2f6557b', onSlotchange: () => this.handleSlotChange() })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectedTab": ["tabWatcher"],
        "size": ["sizeWatcher"]
    }; }
    static get style() { return MarketTabListStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tab-list",
        "$members$": {
            "size": [1],
            "selectedTab": [1537, "selected-tab"],
            "defaultTab": [1, "default-tab"]
        },
        "$listeners$": [[0, "marketTabSelectedChanged", "marketTabSelectedChangedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selectedTab", "selected-tab"]]
    }; }
}

const marketTabPanelCss = "/*!@:host*/.sc-market-tab-panel-h{display:block}/*!@:host([hidden])*/[hidden].sc-market-tab-panel-h{display:none}";
var MarketTabPanelStyle0 = marketTabPanelCss;

class MarketTabPanel {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.hidden = false;
    }
    render() {
        return (hAsync(Host, { key: '6d3e25ab96517ba62ea131f1f205afb5036aadbc', "aria-hidden": this.hidden.toString(), class: "market-tab-panel", role: "tabpanel", tabindex: "0" }, hAsync("slot", { key: '348c7928d64c672f5562456f6faea14a1b549075' })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketTabPanelStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tab-panel",
        "$members$": {
            "hidden": [516]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["hidden", "hidden"]]
    }; }
}

/**
 * Parses a CSS grid-template-columns declaration and attempts to return an array with one entry for each column.
 *
 * @param {string} cssPropertyValue - Value of the `grid-template-columns` property.
 *
 * Example inputs and outputs:
 * '100px 80px 50px' --> ['100px', '80px', '50px']
 * '100px repeat(2, 80px)' --> ['100px', '80px', '80px']
 * '100px repeat(3, 50px, 75px)' --> ['100px', '50px', '75px', '50px']
 * 'repeat(2, 80px) repeat(3, 50px, 75px) 100px' --> ['80px', '80px', '50px', '75px', '50px', '100px']
 *
 * Why do we need this?
 * `market-table` has a `styleDeclaration` watcher which checks the CSS styles applied to the table. this gets used to
 * determine the grid template definition for the table (`this.gridColumnTemplate`), which in turn is used to set column
 * widths and update the grid layout. however, in situations where `grid-template-columns` is defined using the
 * `repeat()` function, we need to parse the value to ensure that we have a width explicitly specified for each column.
 * this ensures consistent column sizing and behavior when columns are being stuck/unstuck to the left/right.
 *
 * Cases where this will break:
 * 1. If user is using <auto-repeat> values ("auto-fill", "auto-fit") instead of explicit widths
 * 2. If user is using a CSS function other than `repeat()` (ex. `minmax()`, `fit-content()`)
 * https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns
 * https://developer.mozilla.org/en-US/docs/Web/CSS/repeat
 */
const parsedGridTemplateColumnValues = (cssPropertyValue) => {
    const array = cssPropertyValue.split(' '); // ex. '100px repeat(2, 80px)' --> ['100px', 'repeat(2', '80px)']
    // error handling for unsupported cases
    const unsupportedValues = ['auto-fill', 'auto-fit', 'minmax', 'fit-content'];
    const matches = unsupportedValues.filter((value) => cssPropertyValue.includes(value));
    const unsupportedValuesText = `${matches.length > 0 ? 'features' : 'feature'} ${matches
        .map((match) => `\`${match}\``)
        .join(', ')}`;
    if (matches.length > 0) {
        // eslint-disable-next-line no-console
        console.warn(`<market-table>'s grid layout is not built to support the use of the CSS ${unsupportedValuesText}.
To avoid potential column layout issues, try using explicitly defined \`grid-template-column\` widths using length, percentage, or flex units.`);
        // while this seems wonky (will return an array like ['repeat(auto-fill,', '250px)']), it means that table rows will
        // inherit the parent table's `grid-template-columns` declaration and will look as intended except for in situations
        // where columns are being stuck/unstuck.
        return array;
    }
    const output = [];
    let i = 0;
    let repeatedColCount = null;
    for (i = 0; i < array.length; i++) {
        const item = array[i];
        // check to see if we are at the start of a `repeat` block
        if (item.includes('repeat(')) {
            // get number of repeats, ex. "repeat(4" --> 4)
            repeatedColCount = Number.parseInt(item.match(/\d+/).toString(), 10);
            // figure out what's being repeated
            // look ahead from current index to the next index containing ")" (the end of the repeat block)
            const endOfRepeatFunctionIndex = array.findIndex((item, index) => index > i && item.includes(')'));
            // slice grid-template-columns values into their own array and strip parens/commas
            const repeatedValues = array.slice(i + 1, endOfRepeatFunctionIndex + 1).map((item) => item.replace(/\W/, ''));
            // push as many values from the set of repeating column sizes as are needed
            for (let j = 0; j < repeatedColCount; j++) {
                output.push(repeatedValues[j % repeatedValues.length].toString());
            }
            // reset repeatedColCount bc we're done w/ the repeat block
            repeatedColCount = null;
            // increment for loop to skip all the items we just dealt with
            i += repeatedValues.length;
        }
        else if (!repeatedColCount) {
            // if not in a `repeat()` block, save value as normal
            output.push(item);
        }
    }
    return output;
};

const marketTableCss = "/*!@:host*/.sc-market-table-h{position:relative;display:grid;grid-auto-columns:1fr;grid-auto-flow:rows;overflow-x:clip;height:auto}/*!@::slotted(.market-table-row:last-of-type:not([slot=\"header\"])), ::slotted(.market-table-row.buffer-row)*/.sc-market-table-s>.market-table-row:last-of-type:not([slot=\"header\"]),.sc-market-table-s>.market-table-row.buffer-row{border-bottom:none !important}";
var MarketTableStyle0 = marketTableCss;

const RESIZE_DEBOUNCE_DURATION = 16; // 60fps
/**
 * @slot - Default slot for all rows
 *
 * @slot header - Slot for header rows at the top of the table. Slotting a header row is required to set custom column
 * widths.
 *
 * **NOTE:** slotting rows into this area will not sticky rows to the top. Use `sticky` or
 * `stick-to="top"` on the row element instead.
 *
 * @slot footer - Slot for footer rows at the bottom of the table
 *
 * **NOTE:** slotting rows into this area will not sticky rows to the bottom. Use `sticky` or
 * `stick-to="bottom"` on the row element instead.
 */
class MarketTable {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.observers = {};
        this.throttledDetectStyleDeclaration = throttle(this.detectStyleDeclaration.bind(this), RESIZE_DEBOUNCE_DURATION);
        this.styleDeclaration = undefined;
        this.gridColumnTemplate = undefined;
        this.allColumns = [];
        this.visibleColumns = [];
        this.columnsStuckLeft = [];
        this.columnsStuckRight = [];
        this.columnsUnstuck = [];
        this.allRows = [];
        this.rowsStuckTop = [];
        this.rowsStuckBottom = [];
        this.rowsUnstuck = [];
        this.hasAccordionRows = false;
    }
    /* Everytime the computed CSS style for this element is updated, we want to
      mutate the grid template definition, and save whatever template they have set
      to our grid definition so we know what size the columns are */
    styleDeclarationObserver(newValue, oldValue) {
        /* lodash's `isEqual` should not be used on CSSStyleDeclaration as it's vulnerable to prototype pollution causing false negatives
        and modifying the data in place. More at https://square.slack.com/archives/C06RMPM072N/p1717600186722089 */
        if (newValue !== oldValue) {
            /* unset this.gridColumnTemplate value when there is no explicit grid-template-columns style
              in this situation, the computed value of grid-template-columns === the width of the element
              https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value */
            if (newValue.getPropertyValue('grid-template-columns') === newValue.getPropertyValue('width')) {
                this.gridColumnTemplate = [];
                return;
            }
            /* when there is an explicit grid-template-columns style, update this.gridColumnTemplate */
            const gridTemplateColumnsValue = parsedGridTemplateColumnValues(newValue.getPropertyValue('grid-template-columns'));
            if (!isEqual(gridTemplateColumnsValue, this.gridColumnTemplate)) {
                this.gridColumnTemplate = gridTemplateColumnsValue;
            }
        }
    }
    /* When the grid template changes, forward it's value to the child sections.
    Use an observer instead of binding in the template to prevent polluting
    the DOM with unneeded attributes */
    gridTemplateObserver(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.setColumnWidths(newValue);
            this.updateGridLayout();
        }
    }
    /* If the columns change, forward their values to the child rows, and update
    the column count */
    allColumnsObserver(columns, oldValue) {
        if (columns && (!oldValue || columns !== oldValue)) {
            this.setColumnWidths(this.gridColumnTemplate);
            this.forwardColumnPropertiesToCells(this.allColumns);
            this.updateGridLayout();
        }
    }
    allRowsObserver(rows, oldValue) {
        if (rows !== oldValue && rows) {
            this.updateGridLayout();
            this.forwardColumnPropertiesToCells(this.allColumns);
            this.updateStickyRows();
        }
    }
    stuckRowsObserver(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.allRows.map((row) => row.classList.remove('buffer-row'));
            if (this.rowsStuckTop.length > 0) {
                this.rowsStuckTop[this.rowsStuckTop.length - 1].classList.add('buffer-row');
            }
            if (this.rowsUnstuck.length > 0 && this.rowsStuckBottom.length > 0) {
                this.rowsUnstuck[this.rowsUnstuck.length - 1].classList.add('buffer-row');
            }
        }
    }
    marketTableHeaderLoadedEventHandler({ detail }) {
        this.allColumns = [...detail.columns];
        this.checkColumnVisibility();
    }
    marketTableRowStickEventHandler({ target, detail }) {
        switch (detail.position) {
            case 'top':
                target.slot = 'sticky-header';
                break;
            case 'bottom':
                target.slot = 'sticky-footer';
                break;
            default:
                // eslint-disable-next-line no-console
                console.warn('could not stick row to an unknown position');
                break;
        }
        this.updateStickyRows();
    }
    marketTableRowUnstickEventHandler({ target }) {
        /* If the row was originally in a named slot, we want to put the
        row back into that slot */
        if (target.originalSlot) {
            target.slot = target.originalSlot;
            /* Otherwise we just remove the slot attribute so it will return
          to the default slot */
        }
        else {
            target.removeAttribute('slot');
        }
        this.updateStickyRows();
    }
    async marketTableColumnStickEventHandler({ target, detail }) {
        // Stick each cell to the correct side in the row
        await Promise.all([...this.allRows].map(async (row) => {
            await row._stickColumn(target.name, detail.position);
        }));
        this.updateGridLayout();
    }
    async marketTableColumnUnstickEventHandler({ target }) {
        await Promise.all([...this.allRows].map(async (row) => {
            await row._unstickColumn(target.name);
        }));
        this.updateGridLayout();
    }
    marketTableColumnVisibilityChangeHandler({ detail }) {
        this.checkColumnVisibility();
        this.allRows.forEach((row) => row._syncColumnVisibilityWithCells(detail.columnName, detail.hidden));
        this.detectStyleDeclaration();
    }
    checkColumnVisibility() {
        this.visibleColumns = this.allColumns.filter((column) => !column.hidden);
    }
    setColumnWidths(gridTemplate) {
        if (this.allColumns.length > 0) {
            this.visibleColumns.forEach((column, i) => {
                column.width = gridTemplate[i];
            });
        }
    }
    forwardColumnPropertiesToCells(columns) {
        this.allRows.forEach((row) => (row.tableColumns = columns));
    }
    updateGridLayout() {
        if (this.allColumns.length > 0) {
            this.columnsUnstuck = this.visibleColumns.filter((column) => !column.stickTo);
            this.columnsStuckLeft = this.visibleColumns.filter((column) => column.stickTo === 'left');
            this.columnsStuckRight = this.visibleColumns.filter((column) => column.stickTo === 'right');
            const mainGrid = this.columnsUnstuck.map((column) => column.width);
            const leftGrid = this.columnsStuckLeft.map((column) => column.width);
            const rightGrid = this.columnsStuckRight.map((column) => column.width);
            if (this.allRows.length > 0) {
                this.allRows.forEach((row) => {
                    row.gridTemplateMain = mainGrid;
                    row.gridTemplateLeft = leftGrid;
                    row.gridTemplateRight = rightGrid;
                });
            }
        }
    }
    updateStickyRows() {
        this.rowsStuckTop = this.allRows.filter((row) => (row.sticky && row.header) || row.stickTo === 'top');
        this.rowsStuckBottom = this.allRows.filter((row) => (row.sticky && row.footer) || row.stickTo === 'bottom');
        this.rowsUnstuck = this.allRows.filter((row) => !row.stickTo && !row.sticky);
    }
    /* If the slotted content of the table changes, we need to update
    our saved copy of the section and column children */
    handleSlotChange() {
        // Get all the child rows
        this.allRows = [...this.el.querySelectorAll(getNamespacedTagFor('market-table-row'))];
        // Check for root accordion fields or default to passed in prop
        const hasAccordionElements = [...this.el.children].some((element) => {
            return element.tagName.toLowerCase() === getNamespacedTagFor('market-accordion-item');
        }) || this.hasAccordionRows;
        /* Set an index for each row so we have some sort of id and can track it
        this will perhaps come in useful later when we need to add a row re-ordering
        drag & drop feature (although we probably need some conditional, or to set
        the index somewhere else than here) - jbiggs */
        this.allRows.forEach((row) => {
            row.index = Array.prototype.indexOf.call(this.allRows, row);
            row.nested = hasAccordionElements;
        });
    }
    /**
     * Gets current CSSStyleDeclaration object for this.el (see styleDeclarationObserver)
     */
    detectStyleDeclaration() {
        this.styleDeclaration = window.getComputedStyle(this.el);
    }
    /**
     * Supports setting dynamic column sizes using CSS media queries by recalculating column width on table resize
     */
    initResizeObserver() {
        if (!this.observers.resize) {
            this.observers.resize = new ResizeObserver(() => {
                window.requestAnimationFrame(() => {
                    this.throttledDetectStyleDeclaration();
                });
            });
            this.observers.resize.observe(this.el);
        }
    }
    /**
     * Supports setting dynamic column widths by updating inline styles
     */
    initInlineStyleObserver() {
        if (!this.observers.inlineStyle) {
            this.observers.inlineStyle = new MutationObserver(() => this.detectStyleDeclaration());
            this.observers.inlineStyle.observe(this.el, {
                attributes: true,
                attributeFilter: ['style'],
            });
        }
    }
    /**
     * since onSlotchange only fires on changes to the <Host> node itself (not changes to the child slots of the
     * <market-table-area>s), we're using a mutation observer to listen for added rows or changes in row content
     * https://github.com/ionic-team/stencil/issues/232#issuecomment-397871813
     */
    initContentObserver() {
        if (!this.observers.content) {
            this.observers.content = new MutationObserver(() => this.handleSlotChange());
            this.observers.content.observe(this.el, {
                childList: true,
                subtree: true,
                characterData: true,
            });
        }
    }
    /* When the component loads, we need to check for a grid-template-columns
    CSS declaration on the table, and also read the column children
    Setting both of these will trigger watcher functions which forward these
    values to the row children */
    componentWillLoad() {
        this.detectStyleDeclaration();
        this.handleSlotChange();
    }
    componentDidLoad() {
        this.initResizeObserver();
        this.initInlineStyleObserver();
        this.initContentObserver();
    }
    render() {
        const MarketTableAreaTagName = getNamespacedTagFor('market-table-area');
        return (hAsync(Host, { key: '750ac6164e83749b5758c5f20c91f6a6d988af91', class: "market-table", role: "table", onSlotchange: () => this.handleSlotChange() }, hAsync(MarketTableAreaTagName, { key: '8bc1b426fbad9c7304f6bda63db8601b45f97b99', orientation: "horizontal", "stick-to": "top", active: this.rowsStuckTop.length > 0 }, hAsync("slot", { key: '2ab3c201d6e338fbb397cc36cfc6fbc9d038bcb6', name: "sticky-header" })), hAsync(MarketTableAreaTagName, { key: '07bfd6ecb2f17bb9e638c785f011da78f2b8862f', orientation: "horizontal", active: true }, hAsync("slot", { key: 'ca54212375991cbac6de49408d2f96f2c48da7ba', name: "header" }), hAsync("slot", { key: 'e94324ff706ca1c4042012ff1023b987afdc6f22' }), hAsync("slot", { key: '6cc3e5e907e99aae0da23475a78a0bde71b15a5f', name: "footer" })), hAsync(MarketTableAreaTagName, { key: '7f7a445262d602d1663ce17a6045757fc0120707', orientation: "horizontal", "stick-to": "bottom", active: this.rowsStuckBottom.length > 0 }, hAsync("slot", { key: 'fcc44e81dccc24f0eebbd83847628a92179df269', name: "sticky-footer" }))));
    }
    disconnectedCallback() {
        Object.values(this.observers).forEach((observer) => {
            observer === null || observer === void 0 ? void 0 : observer.disconnect();
        });
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "styleDeclaration": ["styleDeclarationObserver"],
        "gridColumnTemplate": ["gridTemplateObserver"],
        "allColumns": ["allColumnsObserver"],
        "visibleColumns": ["allColumnsObserver"],
        "allRows": ["allRowsObserver"],
        "rowsStuckTop": ["stuckRowsObserver"],
        "rowsStuckBottom": ["stuckRowsObserver"],
        "rowsUnstuck": ["stuckRowsObserver"]
    }; }
    static get style() { return MarketTableStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table",
        "$members$": {
            "styleDeclaration": [32],
            "gridColumnTemplate": [32],
            "allColumns": [32],
            "visibleColumns": [32],
            "columnsStuckLeft": [32],
            "columnsStuckRight": [32],
            "columnsUnstuck": [32],
            "allRows": [32],
            "rowsStuckTop": [32],
            "rowsStuckBottom": [32],
            "rowsUnstuck": [32],
            "hasAccordionRows": [32]
        },
        "$listeners$": [[0, "marketTableHeaderLoaded", "marketTableHeaderLoadedEventHandler"], [0, "marketTableRowStick", "marketTableRowStickEventHandler"], [0, "marketTableRowUnstick", "marketTableRowUnstickEventHandler"], [0, "marketTableColumnStick", "marketTableColumnStickEventHandler"], [0, "marketTableColumnUnstick", "marketTableColumnUnstickEventHandler"], [0, "marketTableColumnVisibilityChange", "marketTableColumnVisibilityChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const marketTableAreaCss = "/*!@:host*/.sc-market-table-area-h{position:relative;grid-column:1 / -1;background-color:var(--table-cell-state-normal-background-color, var(--core-surface-10-color))}/*!@:host(:not([active]))*/.sc-market-table-area-h:not([active]){display:none !important}/*!@:host([orientation=\"horizontal\"])*/[orientation=\"horizontal\"].sc-market-table-area-h{display:block}/*!@:host([orientation=\"vertical\"])*/[orientation=\"vertical\"].sc-market-table-area-h{display:grid;grid-auto-columns:1fr;grid-auto-flow:column}/*!@:host([orientation=\"vertical\"]) ::slotted(.market-table-row)*/.sc-market-table-area-h[orientation=\"vertical\"] .sc-market-table-area-s>.market-table-row{border-bottom:none}/*!@:host([stick-to])*/[stick-to].sc-market-table-area-h{position:sticky;z-index:1}/*!@:host([stick-to][orientation=\"horizontal\"])*/[stick-to][orientation=\"horizontal\"].sc-market-table-area-h{z-index:2}/*!@:host([stick-to=\"top\"])*/[stick-to=\"top\"].sc-market-table-area-h{top:0;border-bottom:var(--table-border-width, 1px) solid var(--table-heading-border-color, var(--core-divider-10-color))}/*!@:host([stick-to=\"bottom\"])*/[stick-to=\"bottom\"].sc-market-table-area-h{bottom:0}/*!@:host([stick-to=\"bottom\"]:not(:empty))*/[stick-to=\"bottom\"].sc-market-table-area-h:not(:empty){border-top:var(--table-border-width, 1px) solid var(--table-heading-border-color, var(--core-divider-10-color))}/*!@:host([stick-to=\"left\"])*/[stick-to=\"left\"].sc-market-table-area-h{left:0;justify-content:end;border-right:var(--table-border-width, 1px) solid var(--table-heading-border-color, var(--core-divider-10-color))}/*!@:host([stick-to=\"right\"])*/[stick-to=\"right\"].sc-market-table-area-h{right:0;justify-content:start;border-left:var(--table-border-width, 1px) solid var(--table-heading-border-color, var(--core-divider-10-color))}";
var MarketTableAreaStyle0 = marketTableAreaCss;

/**
 * This is an implementation component only and does not relfect any component in the
 * design spec for Market */
/**
 * @slot - Default slot
 */
class MarketTableArea {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.orientation = 'horizontal';
        this.stickTo = undefined;
        this.gridTemplate = undefined;
        this.active = false;
        this.placement = [1, -1];
        this.elements = undefined;
    }
    /* When the gridTemplate changes, we need to parse it and update this elements's
    grid-template-columns property, which defines the number and widths of columns
    within this area */
    assignGridTemplate(newValue, oldValue) {
        if (newValue && newValue !== oldValue) {
            if (newValue.length > 0 ||
                oldValue === undefined // shows content for tables w/o header row
            ) {
                this.active = true;
                this.el.style.gridTemplateColumns = newValue.join(' ');
            }
            else {
                this.active = false;
                this.el.style.gridTemplateColumns = undefined;
            }
        }
    }
    /* When the placement changes, we need to parse it and update this element's
    grid-column property in order to correctly place it within the parent grid.
    Used to support sticky areas */
    placementObserver(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.el.style.gridColumn = `${newValue[0]} / span ${newValue[1]}`;
        }
    }
    componentWillLoad() {
        this.assignGridTemplate(this.gridTemplate);
    }
    render() {
        return (hAsync(Host, { key: 'cef70d070c991957e4b65b0bc959ee6bc2deb8b8', class: "market-table-area" }, hAsync("slot", { key: 'be6981eae7a5e4ae5dd8753fb20542dbcfc2a072' })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "gridTemplate": ["assignGridTemplate"],
        "placement": ["placementObserver"]
    }; }
    static get style() { return MarketTableAreaStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-area",
        "$members$": {
            "orientation": [513],
            "stickTo": [513, "stick-to"],
            "gridTemplate": [16],
            "active": [1540],
            "placement": [16],
            "elements": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["orientation", "orientation"], ["stickTo", "stick-to"], ["active", "active"]]
    }; }
}

const marketTableCellCss = "/*!@:host*/.sc-market-table-cell-h{position:relative;display:flex;justify-content:flex-start;align-items:center;overflow:hidden;padding:var(--table-cell-vertical-padding-size, 12px) var(--table-cell-horizontal-padding-size, 8px);background-color:var(--table-cell-state-normal-background-color, var(--core-surface-10-color));font-weight:var(--table-cell-primary-text-font-weight, var(--core-type-paragraph-20-weight));font-size:var(--table-cell-primary-text-font-size, var(--core-type-paragraph-20-size));line-height:var(--table-cell-primary-text-line-height, var(--core-type-paragraph-20-leading));text-overflow:ellipsis}/*!@:host([align=\"right\"])*/[align=\"right\"].sc-market-table-cell-h{justify-content:flex-end}/*!@:host([align=\"right\"]) .sorting-caret*/[align=\"right\"].sc-market-table-cell-h .sorting-caret.sc-market-table-cell{order:-1;margin-right:var(--table-heading-sort-icon-space-size, 8px);margin-left:0}/*!@:host([stickTo=\"left\"])*/[stickTo=\"left\"].sc-market-table-cell-h{position:sticky;grid-area:left;border-right:var(--table-fixed-column-border-width, 1px)\n      solid\n      var(--table-fixed-column-border-color, var(--core-divider-20-color))}/*!@:host([stickTo=\"right\"])*/[stickTo=\"right\"].sc-market-table-cell-h{grid-area:right;border-left:var(--table-fixed-column-border-width, 1px)\n      solid\n      var(--table-fixed-column-border-color, var(--core-divider-20-color))}/*!@:host*/.sc-market-table-cell-h{--transition-duration:0.2s;transition:background-color var(--transition-duration)}@media (hover: hover){/*!@:host*//*!@:host([interactive]:hover)*/[interactive].sc-market-table-cell-h:hover{background-color:var(--table-cell-hover-state-background-color)}}/*!@:host([interactive])*/[interactive].sc-market-table-cell-h{cursor:pointer}/*!@:host([interactive]:focus)*/[interactive].sc-market-table-cell-h:focus{outline:none}/*!@:host([interactive]:not([disabled]):focus)*/[interactive].sc-market-table-cell-h:not([disabled]):focus{background-color:var(--table-cell-focus-state-background-color)}/*!@:host([active]), :host([interactive]:not([disabled]):active)*/[active].sc-market-table-cell-h,[interactive].sc-market-table-cell-h:not([disabled]):active{background-color:var(--table-cell-pressed-state-background-color)}/*!@:host([interactive][disabled])*/[interactive][disabled].sc-market-table-cell-h{pointer-events:none}/*!@:host([disabled])*/[disabled].sc-market-table-cell-h{background-color:transparent;color:var(--table-cell-disabled-state-text-color);pointer-events:none}/*!@:host([hidden])*/[hidden].sc-market-table-cell-h{display:none}/*!@:host(:first-of-type)*/.sc-market-table-cell-h:first-of-type{padding-left:var(--table-cell-padding, 8px)}/*!@:host(:first-of-type) ::slotted(button)*/.sc-market-table-cell-h:first-of-type .sc-market-table-cell-s>button{all:unset;display:flex;justify-content:space-between;align-items:center;padding-right:var(--core-metrics-spacing-100);padding-left:calc(\n        var(--cell-indent-level) *\n        var(--table-row-indentation-padding, 40px) +\n        var(--core-metrics-spacing-100)\n      );color:var(--table-cell-normal-state-content-color, var(--core-fill-black-color));cursor:pointer}/*!@:host(:first-of-type) ::slotted(button):focus-visible*/.sc-market-table-cell-h:first-of-type .sc-market-table-cell-s>button:focus-visible{outline:none}/*!@:host(:first-of-type) ::slotted(button):focus*/.sc-market-table-cell-h:first-of-type .sc-market-table-cell-s>button:focus{color:var(--table-accordion-focus-state-content-color, var(--core-fill-black-color))}/*!@:host(:first-of-type) ::slotted(button):hover*/.sc-market-table-cell-h:first-of-type .sc-market-table-cell-s>button:hover{color:var(--table-accordion-hover-state-content-color, var(--core-fill-black-color))}/*!@:host(:first-of-type) ::slotted(button):active*/.sc-market-table-cell-h:first-of-type .sc-market-table-cell-s>button:active{color:var(--table-accordion-pressed-state-content-color, var(--core-fill-black-color))}/*!@:host(:first-of-type) ::slotted([slot=\"nested-row-indicator\"])*/.sc-market-table-cell-h:first-of-type .sc-market-table-cell-s>[slot=\"nested-row-indicator\"]{height:100%}/*!@::slotted([slot=\"leading-accessory\"][size=\"image\"])*/.sc-market-table-cell-s>[slot=\"leading-accessory\"][size=\"image\"]{margin-right:16px;margin-left:12px}/*!@::slotted([slot=\"leading-accessory\"][size=\"icon\"])*/.sc-market-table-cell-s>[slot=\"leading-accessory\"][size=\"icon\"]{margin-right:16px;margin-left:16px}/*!@::slotted([slot=\"trailing-accessory\"][size=\"image\"])*/.sc-market-table-cell-s>[slot=\"trailing-accessory\"][size=\"image\"]{margin-right:12px;margin-left:16px}/*!@::slotted([slot=\"trailing-accessory\"][size=\"icon\"])*/.sc-market-table-cell-s>[slot=\"trailing-accessory\"][size=\"icon\"]{margin-right:16px;margin-left:16px}/*!@::slotted([slot=\"nested-row-indicator\"])*/.sc-market-table-cell-s>[slot=\"nested-row-indicator\"]{color:var(--table-cell-normal-state-content-color, var(--core-fill-black-color))}/*!@::slotted([slot=\"nested-row-indicator\"]:focus-visible)*/.sc-market-table-cell-s>[slot=\"nested-row-indicator\"]:focus-visible{outline:none}/*!@::slotted([slot=\"nested-row-indicator\"]:focus)*/.sc-market-table-cell-s>[slot=\"nested-row-indicator\"]:focus{color:var(--table-accordion-focus-state-content-color, var(--core-fill-black-color))}/*!@::slotted([slot=\"nested-row-indicator\"]:hover)*/.sc-market-table-cell-s>[slot=\"nested-row-indicator\"]:hover{color:var(--table-accordion-hover-state-content-color, var(--core-fill-black-color))}/*!@::slotted([slot=\"nested-row-indicator\"]:active)*/.sc-market-table-cell-s>[slot=\"nested-row-indicator\"]:active{color:var(--table-accordion-pressed-state-content-color, var(--core-fill-black-color))}";
var MarketTableCellStyle0 = marketTableCellCss;

/**
 * @slot - Default slot for content
 * @slot leading-accessory - Intended for use with a leading accessory.
 * @slot trailing-accessory - Intended for use with a trailing accessory.
 */
class MarketTableCell {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTableCellClicked = createEvent(this, "marketTableCellClicked", 7);
        this.align = false;
        this.column = undefined;
        this.leadingIndentation = 0;
        this.active = false;
        this.interactive = false;
        this.disabled = false;
        this.originalSlot = undefined;
        this.hidden = false;
    }
    /**
     * **INTERNAL [do not use directly]**
     * Forwards appropriate properties from matching header market-table-column element to this cell.
     */
    _updateColumnRelatedProperties(column) {
        if (!column) {
            return Promise.resolve();
        }
        this.column = column.name;
        this.align = column.align;
        this.hidden = column.hidden;
        if (column.stickTo) {
            this._stickSelf(column.stickTo);
        }
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Sets properties specified in the row element. Leading and trailing
     * accessories are best set on the first or last cell to not mess
     * with the grid structure
     * @param rowEl
     */
    _updateFirstCellProperties(rowEl) {
        this.leadingIndentation = rowEl.leadingIndentation || 0;
        // Sets leading accessory level of indentation on current row
        this.el.style.setProperty('--cell-indent-level', `${this.leadingIndentation}`);
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Moves this column into a slot inside the market-table-area
     * which is fixed to the provided edge (position), allowing
     * for fixed columns
     */
    _stickSelf(position) {
        if (position) {
            this.el.slot = `sticky-${position}`;
        }
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Moves this column back into it's original slot from a slot
     * within a fixed market-table-area
     */
    _unstickSelf() {
        if (!this.originalSlot) {
            this.el.removeAttribute('slot');
        }
        else {
            this.el.slot = this.originalSlot;
        }
        return Promise.resolve();
    }
    componentWillLoad() {
        this.originalSlot = this.el.getAttribute('slot');
    }
    handleClick() {
        if (this.interactive) {
            this.marketTableCellClicked.emit();
        }
    }
    handleKeydown(e) {
        // don't intercept keydown of descendant elements
        // e.g. when typing into nested input fields (gross)
        if (e.target !== this.el) {
            return;
        }
        switch (e.key) {
            case 'Enter':
                this.handleClick();
                break;
            case ' ':
                this.handleClick();
                e.preventDefault(); // spacebar should not scroll page
                break;
        }
    }
    render() {
        const { disabled, interactive, align, hidden } = this;
        return (hAsync(Host, { key: '1bb91d3a4d5fcf5d7a27b3fa9af90f548f5e5e68', class: "market-table-cell", role: "cell", align: align === 'right' && align, hidden: hidden, tabindex: interactive && !disabled ? '0' : null, onClick: () => this.handleClick(), onKeydown: (e) => this.handleKeydown(e) }, hAsync("slot", { key: 'e97ec19689f887c5e25949a69c28c41d56fd0e84', name: "nested-row-indicator" }), hAsync("slot", { key: 'b9c46c7522d68ee674fed3eb04195924215a78c9', name: "leading-accessory" }), hAsync("slot", { key: '9a15f89b0c3b4bd2939fcf713872a08978193400' }), hAsync("slot", { key: '8094c84e509ca8854f87d56d34268544090bee78', name: "trailing-accessory" })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketTableCellStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-cell",
        "$members$": {
            "align": [1032],
            "column": [1537],
            "leadingIndentation": [1026, "leading-indentation"],
            "active": [516],
            "interactive": [516],
            "disabled": [516],
            "originalSlot": [32],
            "hidden": [32],
            "_updateColumnRelatedProperties": [64],
            "_updateFirstCellProperties": [64],
            "_stickSelf": [64],
            "_unstickSelf": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["column", "column"], ["active", "active"], ["interactive", "interactive"], ["disabled", "disabled"]]
    }; }
}

const marketTableColumnCss = "/*!@:host*/.sc-market-table-column-h{position:relative;display:flex;justify-content:flex-start;align-items:center;overflow:hidden;padding:var(--table-cell-vertical-padding-size, 12px) var(--table-cell-horizontal-padding-size, 8px);background-color:var(--table-cell-state-normal-background-color, var(--core-surface-10-color));font-weight:var(--table-cell-primary-text-font-weight, var(--core-type-paragraph-20-weight));font-size:var(--table-cell-primary-text-font-size, var(--core-type-paragraph-20-size));line-height:var(--table-cell-primary-text-line-height, var(--core-type-paragraph-20-leading));text-overflow:ellipsis}/*!@:host([align=\"right\"])*/[align=\"right\"].sc-market-table-column-h{justify-content:flex-end}/*!@:host([align=\"right\"]) .sorting-caret*/[align=\"right\"].sc-market-table-column-h .sorting-caret.sc-market-table-column{order:-1;margin-right:var(--table-heading-sort-icon-space-size, 8px);margin-left:0}/*!@:host([stickTo=\"left\"])*/[stickTo=\"left\"].sc-market-table-column-h{position:sticky;grid-area:left;border-right:var(--table-fixed-column-border-width, 1px)\n      solid\n      var(--table-fixed-column-border-color, var(--core-divider-20-color))}/*!@:host([stickTo=\"right\"])*/[stickTo=\"right\"].sc-market-table-column-h{grid-area:right;border-left:var(--table-fixed-column-border-width, 1px)\n      solid\n      var(--table-fixed-column-border-color, var(--core-divider-20-color))}/*!@:host*/.sc-market-table-column-h{font-weight:var(--table-heading-primary-text-font-weight, 500);font-size:var(--table-heading-primary-text-font-size, var(--core-type-semibold-20-size));line-height:var(--table-heading-primary-text-line-height, var(--core-type-semibold-20-leading))}/*!@:host([sortable])*/[sortable].sc-market-table-column-h{cursor:pointer;transition:background-color\n      var(--core-animation-enter-transition-fast-speed-duration)\n      var(--core-animation-enter-transition-fast-speed-duration-easing)}/*!@:host([sortable]:hover)*/[sortable].sc-market-table-column-h:hover{background-color:var(--table-heading-hover-state-background-color, var(--core-fill-50-color))}/*!@:host([sortable]:active)*/[sortable].sc-market-table-column-h:active{background-color:var(--table-heading-active-state-background-color, var(--core-emphasis-40-color))}/*!@:host([sort-order]) .sorting-caret*/[sort-order].sc-market-table-column-h .sorting-caret.sc-market-table-column{fill:var(--table-heading-sortable-variant-active-state-caret-color, var(--core-text-10-color))}/*!@:host([sort-order=\"descending\"]) .sorting-caret*/[sort-order=\"descending\"].sc-market-table-column-h .sorting-caret.sc-market-table-column{transform:rotate(0deg)}/*!@:host([hidden])*/[hidden].sc-market-table-column-h{display:none}/*!@.sorting-caret*/.sorting-caret.sc-market-table-column{margin-left:var(--table-heading-sort-icon-space-size, 8px);fill:var(--table-heading-sortable-variant-normal-state-caret-color, var(--core-text-30-color));transition:color\n    var(--core-animation-enter-transition-fast-speed-duration)\n    var(--core-animation-enter-transition-fast-speed-duration-easing);transform:rotate(180deg)}/*!@::slotted([slot=\"leading-accessory\"][size=\"image\"])*/.sc-market-table-column-s>[slot=\"leading-accessory\"][size=\"image\"]{margin-right:16px;margin-left:12px}/*!@::slotted([slot=\"leading-accessory\"][size=\"icon\"])*/.sc-market-table-column-s>[slot=\"leading-accessory\"][size=\"icon\"]{margin-right:16px;margin-left:16px}/*!@::slotted([slot=\"trailing-accessory\"][size=\"image\"])*/.sc-market-table-column-s>[slot=\"trailing-accessory\"][size=\"image\"]{margin-right:12px;margin-left:16px}/*!@::slotted([slot=\"trailing-accessory\"][size=\"icon\"])*/.sc-market-table-column-s>[slot=\"trailing-accessory\"][size=\"icon\"]{margin-right:16px;margin-left:16px}/*!@button*/button.sc-market-table-column{display:flex;align-items:center;padding:0;border:inherit;background-color:transparent;font:inherit}";
var MarketTableColumnStyle0 = marketTableColumnCss;

/**
 * @slot - Default slot for all content
 */
class MarketTableColumn {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTableColumnStick = createEvent(this, "marketTableColumnStick", 7);
        this.marketTableColumnUnstick = createEvent(this, "marketTableColumnUnstick", 7);
        this.marketTableColumnSort = createEvent(this, "marketTableColumnSort", 7);
        this.marketTableColumnVisibilityChange = createEvent(this, "marketTableColumnVisibilityChange", 7);
        this.name = undefined;
        this.align = false;
        this.stickTo = undefined;
        this.sortable = false;
        this.sortOrder = undefined;
        this.hidden = false;
        this.index = 0;
        this.width = undefined;
        this.originalSlot = undefined;
    }
    emitVisibilityChangeEvent(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.marketTableColumnVisibilityChange.emit({
                columnName: this.name,
                hidden: newValue,
            });
        }
    }
    async emitStickyEvents(newValue, oldValue) {
        if (newValue && newValue !== oldValue) {
            await this.stick(newValue);
        }
        else {
            this.unstick(newValue);
        }
    }
    /**
     * Fixes this column to the provided table edge (position)
     */
    stick(position) {
        /* If our position is different than out current stickTo value,
        then we are probably calling stick() directly from javascript, rather
        than having it be triggered from the stickTo watcher, so we want to
        update that value, which will call this function again, the values will match
        and then the event will be emitted */
        if (position !== this.stickTo) {
            this.stickTo = position;
            /* Otherwise this function has been triggered from the stickTo watcher
          by someone updating the bound property so we want to emit the event */
        }
        else {
            this.marketTableColumnStick.emit({
                position,
                index: this.index,
            });
        }
        return Promise.resolve();
    }
    /**
     * Un-fixes this column from any table edge
     */
    unstick(position) {
        this.marketTableColumnUnstick.emit({
            position,
            index: this.index,
        });
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Moves this column into a slot inside the market-table-area
     * which is fixed to the provided edge (position), allowing
     * for fixed columns
     */
    _stickSelf(position) {
        if (position) {
            this.el.slot = `sticky-${position}`;
        }
        this.stickTo = position;
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Moves this column back into it's original slot from a slot
     * within a fixed market-table-area
     */
    _unstickSelf() {
        if (!this.originalSlot) {
            this.el.removeAttribute('slot');
        }
        else {
            this.el.slot = this.originalSlot;
        }
        this.el.removeAttribute('stick-to');
        return Promise.resolve();
    }
    clickHandler() {
        if (this.sortable) {
            this.marketTableColumnSort.emit({
                column: this.name,
                previousSortOrder: this.sortOrder,
            });
        }
    }
    componentWillLoad() {
        this.originalSlot = this.el.getAttribute('slot');
        if (!this.name) {
            console.warn('Please set a name on <market-table-column>. Tables may not work correctly without this.'); // eslint-disable-line no-console
        }
    }
    componentDidLoad() {
        // stickTo watcher does not fire on first component load
        if (this.stickTo) {
            this.stick(this.stickTo);
        }
    }
    render() {
        return (hAsync(Host, { key: 'de01f70eb5bef7de63a4cd77fc72d01adadbc2b5', class: "market-table-column", align: this.align === 'right' && this.align, role: "columnheader", "aria-sort": this.sortOrder, onClick: () => this.clickHandler() }, hAsync("slot", { key: 'cafa7ea4eb183281b723bd1acd4fcd6b1171bc43', name: "leading-accessory" }), this.sortable && (
        // A11Y: This button allows screen readers to access and click on the column header.
        hAsync("button", { key: 'eda26a17db04b3fad4ff4d0fe288195a6eeccc9c' }, hAsync("slot", { key: '37881dbd5b4e12c5b423ea9d0d0efc31b1de500a' }), hAsync("svg", { key: '1e210d74d75f0122fae652a4733c5f4d556a5eb8', width: "16", height: "15", viewBox: "0 0 16 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", class: "sorting-caret", "aria-hidden": "true" }, hAsync("path", { key: '95c1ac04ae00a822fbc484cbf05ee68358937add', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8.70709 14.7071C8.31657 15.0976 7.6834 15.0976 7.29288 14.7071L0.292879 7.7071L1.70709 6.29289L6.99999 11.5858L6.99999 -7.612e-07L8.99999 -5.86354e-07L8.99999 11.5858L14.2929 6.29289L15.7071 7.70711L8.70709 14.7071Z" })))), !this.sortable && hAsync("slot", { key: '56146bd9c9a751c9de482596423f5ff8e1f70484' }), hAsync("slot", { key: 'a9c0f4ae4ccd08a29c76272ac4e9717a89744a5e', name: "trailing-accessory" })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "hidden": ["emitVisibilityChangeEvent"],
        "stickTo": ["emitStickyEvents"]
    }; }
    static get style() { return MarketTableColumnStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-column",
        "$members$": {
            "name": [513],
            "align": [8],
            "stickTo": [1537, "stick-to"],
            "sortable": [516],
            "sortOrder": [513, "sort-order"],
            "hidden": [516],
            "index": [2],
            "width": [1],
            "originalSlot": [32],
            "stick": [64],
            "unstick": [64],
            "_stickSelf": [64],
            "_unstickSelf": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["name", "name"], ["stickTo", "stick-to"], ["sortable", "sortable"], ["sortOrder", "sort-order"], ["hidden", "hidden"]]
    }; }
}

const marketTableRowCss = "/*!@:host*/.sc-market-table-row-h{--transition-duration:0.2s;position:relative;display:grid;grid-column:1 / -1;grid-auto-columns:1fr;grid-auto-flow:column;border-bottom:var(--table-border-width, 1px) solid var(--table-row-border-color, var(--core-divider-20-color));transition:background-color var(--transition-duration)}@media (hover: hover){/*!@:host*//*!@:host([interactive]:hover) ::slotted(.market-table-cell)*/.sc-market-table-row-h[interactive]:hover .sc-market-table-row-s>.market-table-cell{background-color:var(--table-cell-hover-state-background-color, var(--core-fill-50-color))}}/*!@:host([header])*/[header].sc-market-table-row-h{border-bottom:var(--table-border-width, 1px) solid var(--table-heading-border-color, var(--core-divider-10-color))}/*!@:host([footer]) ::slotted(.market-table-cell)*/.sc-market-table-row-h[footer] .sc-market-table-row-s>.market-table-cell{border-bottom:none;font-weight:var(--table-footing-primary-text-font-weight, 500);font-size:var(--table-footing-primary-text-font-size, var(--core-type-semibold-20-size));line-height:var(--table-footing-primary-text-line-height, var(--core-type-semibold-20-leading))}/*!@:host([interactive]) ::slotted(.market-table-cell)*/.sc-market-table-row-h[interactive] .sc-market-table-row-s>.market-table-cell{cursor:pointer}/*!@:host([active]) ::slotted(.market-table-cell), :host([interactive]:active) ::slotted(.market-table-cell)*/.sc-market-table-row-h[active] .sc-market-table-row-s>.market-table-cell,.sc-market-table-row-h[interactive]:active.sc-market-table-row-s>.market-table-cell,.sc-market-table-row-h[interactive]:active .sc-market-table-row-s>.market-table-cell{background-color:var(--table-cell-pressed-state-background-color, var(--core-emphasis-40-color))}/*!@:host([interactive]:focus)*/[interactive].sc-market-table-row-h:focus{outline:none}/*!@:host([interactive]:not([disabled]):focus) ::slotted(.market-table-cell)*/.sc-market-table-row-h[interactive]:not([disabled]):focus .sc-market-table-row-s>.market-table-cell{background-color:var(--table-cell-focus-state-background-color, var(--core-fill-50-color))}/*!@:host([interactive][disabled])*/[interactive][disabled].sc-market-table-row-h{pointer-events:none}/*!@:host([disabled]) ::slotted(.market-table-cell)*/.sc-market-table-row-h[disabled] .sc-market-table-row-s>.market-table-cell{background-color:transparent;color:var(--table-cell-disabled-state-text-color, var(--core-text-30-color));pointer-events:none}/*!@:host([nested]) ::slotted(.market-table-cell:first-of-type)*/.sc-market-table-row-h[nested] .sc-market-table-row-s>.market-table-cell:first-of-type{padding-left:calc(\n        (\n          var(--cell-indent-level) *\n          var(--table-row-indentation-padding, 40px)\n        ) +\n        var(--table-cell-padding, 8px) +\n        var(--table-accordion-content-width, 30px)\n      )}/*!@:host([slot='custom-trigger']) ::slotted(.market-table-cell:first-of-type), :host([slot='header']) ::slotted(.market-table-cell:first-of-type), :host([slot='footer']) ::slotted(.market-table-cell:first-of-type)*/.sc-market-table-row-h[slot='custom-trigger'] .sc-market-table-row-s>.market-table-cell:first-of-type,.sc-market-table-row-h[slot='header'].sc-market-table-row-s>.market-table-cell:first-of-type,.sc-market-table-row-h[slot='header'] .sc-market-table-row-s>.market-table-cell:first-of-type,.sc-market-table-row-h[slot='footer'].sc-market-table-row-s>.market-table-cell:first-of-type,.sc-market-table-row-h[slot='footer'] .sc-market-table-row-s>.market-table-cell:first-of-type{padding-left:var(--table-cell-padding, 8px)}/*!@:host ::slotted(.market-table-cell:first-of-type)*/.sc-market-table-row-h .sc-market-table-row-s>.market-table-cell:first-of-type{padding-left:calc(\n      var(--table-cell-padding, 8px) +\n      (var(--cell-indent-level) * var(--table-row-indentation-padding, 40px))\n    )}";
var MarketTableRowStyle0 = marketTableRowCss;

/**
 * @slot - Default slot for all cells
 * @slot control - Intended for use with a market table cell or market table column that contain a control element.
 */
class MarketTableRow {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTableHeaderLoaded = createEvent(this, "marketTableHeaderLoaded", 7);
        this.marketTableRowClicked = createEvent(this, "marketTableRowClicked", 7);
        this.marketTableRowStick = createEvent(this, "marketTableRowStick", 7);
        this.marketTableRowUnstick = createEvent(this, "marketTableRowUnstick", 7);
        this.marketAccordionToggled = createEvent(this, "marketAccordionToggled", 7);
        this.marketNestedRowToggled = createEvent(this, "marketNestedRowToggled", 7);
        // prevents unstick events from being fired on the slotchange before componentDidLoad
        this.componentLoaded = false;
        this.leadingIndentation = 0;
        this.stickTo = false;
        this.sticky = undefined;
        this.active = false;
        this.interactive = false;
        this.disabled = false;
        this.selected = false;
        this.header = false;
        this.footer = false;
        this.originalSlot = undefined;
        this.index = 0;
        this.tableColumns = undefined;
        this.cells = undefined;
        this.gridTemplateMain = [];
        this.gridTemplateLeft = [];
        this.gridTemplateRight = [];
        this.expanded = false;
        this.nested = false;
        this.styleDeclaration = undefined;
        this.gridTemplate = [];
        this.nestedRowToggleButton = undefined;
    }
    formNewGridTemplate() {
        this.gridTemplate = [...this.gridTemplateLeft, ...this.gridTemplateMain, ...this.gridTemplateRight];
        if (this.tableAreaLeft) {
            this.tableAreaLeft.placement = [1, this.gridTemplateLeft.length];
        }
        if (this.tableAreaMain) {
            this.tableAreaMain.placement = [this.gridTemplateLeft.length + 1, this.gridTemplateMain.length];
        }
        if (this.tableAreaRight) {
            this.tableAreaRight.placement = [
                this.gridTemplateLeft.length + this.gridTemplateMain.length + 1,
                this.gridTemplateRight.length,
            ];
        }
    }
    gridTemplateObserver(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.el.style.gridTemplateColumns = newValue.join(' ');
        }
    }
    stickyObserver(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.emitStickyEvents();
        }
    }
    columnsObserver(columns) {
        this.setCellColumnProperties(columns);
    }
    updateCellProperties(oldCellList, newCellList) {
        if (oldCellList !== newCellList) {
            this.setCellColumnProperties(this.tableColumns);
        }
    }
    updateFirstCellProperties() {
        this._setFirstCellProperties();
    }
    updateNestedRowButton() {
        if (this.nestedRowToggleButton) {
            this.nestedRowToggleButton.ariaExpanded = `${this.expanded}`;
            // We cannot access the svg from the css files in the current state,
            // so we have to do it through JS. I figured this was the best place
            // to do it since the rotation depends on expansion for now. We should
            // find a better way to access this svg in the style sheets. -lindamr
            const svgElement = this.nestedRowToggleButton.querySelector('svg');
            if (svgElement) {
                if (this.expanded) {
                    svgElement.style.transform = 'rotate(-180deg)';
                }
                else {
                    svgElement.style.transform = 'rotate(0deg)';
                }
            }
        }
    }
    updateSlottedControlCheckedValue() {
        var _a;
        (_a = this.slottedControl) === null || _a === void 0 ? void 0 : _a.setSelection(this.selected);
    }
    updateSlottedControlDisabledValue() {
        var _a;
        (_a = this.slottedControl) === null || _a === void 0 ? void 0 : _a.setDisabled(this.disabled);
    }
    handleMarketCheckboxValueChange(event) {
        // Update selected value if event is triggered by slottedControl
        if (event.target !== this.slottedControl) {
            return;
        }
        this.selected = event.detail.current;
    }
    /**
     * Sticks this row to the provided edge (position) of the table
     */
    stick(position) {
        if (position) {
            this.stickTo = position;
        }
        else if (this.header || this.footer) {
            this.sticky = true;
        }
        return Promise.resolve();
    }
    /**
     * Unsticks this row from any edge of the table
     */
    unstick() {
        this.sticky = false;
        this.stickTo = false;
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Used by the parent table to support fixing columns to either side of the table
     */
    async _stickColumn(column, position) {
        const cell = this.el.querySelector(`[name="${column}"], [column="${column}"]`);
        if (cell) {
            await cell._stickSelf(position);
        }
        else {
            console.warn('cannot stick cell to unknown position'); // eslint-disable-line no-console
        }
    }
    /**
     * **INTERNAL [do not use directly]**
     * Used by the parent table to support fixing columns to either side of the table
     */
    async _unstickColumn(column) {
        const cell = this.el.querySelector(`[name="${column}"], [column="${column}"]`);
        if (cell) {
            await cell._unstickSelf();
        }
        else {
            console.warn('cannot unstick cell from unknown position'); // eslint-disable-line no-console
        }
    }
    /**
     * **INTERNAL [do not use directly]**
     * Sets the hidden prop on market-table-cell. Used by market-table to allow market-table-column
     * to control the hidden/visible state of its associated table cells.
     */
    _syncColumnVisibilityWithCells(columnName, hidden) {
        const cell = this.el.querySelector(`[name="${columnName}"], [column="${columnName}"]`);
        if (cell) {
            cell.hidden = hidden;
        }
        return Promise.resolve();
    }
    /**
     * **INTERNAL [do not use directly]**
     * Sets properties computed or specified on the row on the first
     * cell to keep the table rows from shifting
     */
    _setFirstCellProperties() {
        var _a, _b, _c;
        // Setting indentation on the first cell of the row to not mess
        // with the table grid
        if (((_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) && this.isStylableCell(this.cells[0])) {
            (_c = (_b = this.cells[0])._updateFirstCellProperties) === null || _c === void 0 ? void 0 : _c.call(_b, this.el);
        }
        return Promise.resolve();
    }
    /**
     * Sets the leadingIndentation
     * @param leadingIndentation
     */
    setLeadingIndentation(leadingIndentation) {
        this.leadingIndentation = leadingIndentation;
        return Promise.resolve();
    }
    /**
     * Sets expanded property and emits nested row toggle event
     */
    toggleNestedRow() {
        this.expanded = !this.expanded;
        this.marketAccordionToggled.emit({ expanded: this.expanded });
        this.marketNestedRowToggled.emit({ expanded: this.expanded });
        return Promise.resolve();
    }
    /**
     * Checks type of cell to make Typescript happy about using functions that are only on
     * HTMLMarketTableCellElement and not HTMLMarketTableColumnElement
     * @param cell
     * @returns
     */
    isStylableCell(cell) {
        return (cell._updateColumnRelatedProperties !== undefined &&
            cell._updateFirstCellProperties !== undefined);
    }
    setCellColumnProperties(columns) {
        if (this.cells && columns && columns.length > 0) {
            this.cells.forEach((cell, i) => {
                if (this.isStylableCell(cell)) {
                    const column = columns[i];
                    cell._updateColumnRelatedProperties(column);
                }
            });
        }
    }
    emitStickyEvents() {
        let position;
        if (this.stickTo) {
            position = this.stickTo;
        }
        else if (this.header) {
            position = 'top';
        }
        else if (this.footer) {
            position = 'bottom';
        }
        if (this.sticky || this.stickTo) {
            // emit a stick event
            this.marketTableRowStick.emit({
                position,
                index: this.index,
            });
        }
        else if (this.componentLoaded) {
            // Emit an unstick event
            this.marketTableRowUnstick.emit({
                position,
                index: this.index,
            });
        }
    }
    componentWillLoad() {
        // setting row properties based on whether row is using a named slot
        this.originalSlot = this.el.slot;
        this.header = this.originalSlot === 'header';
        this.footer = this.originalSlot === 'footer';
        // prettier wants (typeof this.cells)[0] but that change seems wrong
        // prettier-ignore
        this.cells = this.el.querySelectorAll(getNamespacedTagFor('market-table-cell'));
    }
    handleSlotChange() {
        this.cells = this.el.querySelectorAll(`${getNamespacedTagFor('market-table-cell')}, ${getNamespacedTagFor('market-table-column')}`);
        // If this is our header row, meaning we have column children, then emit an
        // event that sends the columns to the table parent
        if (this.header) {
            this.marketTableHeaderLoaded.emit({
                columns: this.el.querySelectorAll(getNamespacedTagFor('market-table-column')),
            });
        }
        this.emitStickyEvents();
    }
    _getMarketRowElement(element) {
        return element.querySelector(getNamespacedTagFor('market-table-row'));
    }
    _addCaretButtonToFirstCell() {
        if (this.cells && this.cells[0]) {
            this.nestedRowToggleButton = document.createElement('button');
            Object.assign(this.nestedRowToggleButton, {
                slot: 'nested-row-indicator',
                type: 'button',
                ariaExpanded: `${this.expanded}`,
                onclick: () => this.toggleNestedRow(),
            });
            this.nestedRowToggleButton.innerHTML = `<svg class="caret" width="14" height="8" viewBox="0 0 14 8" fill="none" style="transition-duration:300ms;" xmlns="http://www.w3.org/2000/svg">
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M7.70715 7.70711C7.31663 8.09763 6.68346 8.09763 6.29294 7.70711L0.29294 1.70711L1.70715 0.292892L7.00005 5.58579L12.2929 0.292893L13.7072 1.70711L7.70715 7.70711Z"
            fill="currentColor"
          />
        </svg>`;
            // Get the first table cell child element and append the this.nestedRowToggleButtonElement to it. Because it has the nested-row-indicator slot, it should appear in the correct place
            this.cells[0].append(this.nestedRowToggleButton);
        }
    }
    _registerSlottedControl() {
        this.slottedControl = this.el.querySelector([
            `[slot="control"] ${getNamespacedTagFor('market-checkbox')}`,
            `[slot="control"] ${getNamespacedTagFor('market-toggle')}`,
        ].join(','));
        if (this.slottedControl) {
            this.slottedControl.setDisabled(this.disabled);
            this.slottedControl.setSelection(this.selected);
        }
    }
    componentDidRender() {
        var _a, _b;
        // Get accordion parent
        const accordionElement = this.el.closest(getNamespacedTagFor('market-accordion-item'));
        if (accordionElement) {
            let parentRow;
            if (this.el.slot === 'custom-trigger') {
                // If current row has nested row, we need to look a level above for
                // the correct indentation.
                const parentAccordionElement = (_a = accordionElement.parentElement) === null || _a === void 0 ? void 0 : _a.closest(getNamespacedTagFor('market-accordion-item'));
                // If there is a parent accordion element, find the trigger row
                // to get previous level indentation and set the current one.
                // Otherwise, the current row is at top level and indentaion will
                // remain as 0.
                if (parentAccordionElement) {
                    parentRow = [...parentAccordionElement.children].find((child) => child.slot === 'custom-trigger');
                }
            }
            else {
                // Find the the trigger row within same level to set indentation
                parentRow = [...accordionElement.children].find((child) => child.slot === 'custom-trigger');
            }
            // Set indentation
            this.leadingIndentation = parentRow ? ((_b = parentRow.leadingIndentation) !== null && _b !== void 0 ? _b : 0) + 1 : 0;
        }
        // Set indentation on the first cell of the row to not mess
        // with the table grid
        this._setFirstCellProperties();
    }
    componentDidLoad() {
        this.componentLoaded = true;
        if (this.el.slot === 'custom-trigger') {
            // Add caret button
            this._addCaretButtonToFirstCell();
            // If accordion is expanded when component is loaded, we have to
            // we have to make sure the caret is facing the correct way
            const svgElement = this.nestedRowToggleButton.querySelector('svg');
            if (svgElement && this.expanded) {
                svgElement.style.transform = 'rotate(-180deg)';
            }
        }
    }
    handleClick(e) {
        const ignoredElementTagNames = [
            getNamespacedTagFor('market-accessory'),
            getNamespacedTagFor('market-button'),
            getNamespacedTagFor('market-button-dropdown'),
            getNamespacedTagFor('market-checkbox'),
            getNamespacedTagFor('market-link'),
            getNamespacedTagFor('market-toggle'),
            'button',
            'a',
            // add more interactive element tag names here
        ];
        // If the element clicked was one of the ignoredElementTagNames or anything inside of them,
        // do not trigger marketTableRowClicked
        const shouldIgnoreClick = ignoredElementTagNames.some((tagname) => e.target.closest(tagname));
        if (shouldIgnoreClick) {
            return;
        }
        if (this.interactive) {
            this.marketTableRowClicked.emit();
        }
    }
    handleKeydown(e) {
        // don't intercept keydown of descendant elements
        // e.g. when typing into nested input fields (gross)
        if (e.target !== this.el) {
            return;
        }
        switch (e.key) {
            case 'Enter':
                this.handleClick(e);
                break;
            case ' ':
                this.handleClick(e);
                e.preventDefault(); // spacebar should not scroll page
                break;
        }
    }
    render() {
        const { disabled, footer, gridTemplateLeft, gridTemplateMain, gridTemplateRight, header, interactive, selected, slottedControl, } = this;
        const MarketTableAreaTagName = getNamespacedTagFor('market-table-area');
        return (hAsync(Host, { key: 'b21f7e4205a1bdeedb0e5b954cca59fa929759b6', "aria-selected": slottedControl ? Boolean(selected).toString() : null, class: "market-table-row", role: "row", tabindex: interactive && !disabled ? '0' : null, header: header, footer: footer, onClick: (e) => this.handleClick(e), onKeydown: (e) => this.handleKeydown(e) }, hAsync(MarketTableAreaTagName, { key: '1ec156add1e9edfbc896c2bf4b4ed2dec6abc853', orientation: "vertical", "stick-to": "left", gridTemplate: gridTemplateLeft, ref: (el) => (this.tableAreaLeft = el) }, hAsync("slot", { key: 'cc0b2f616a2ce5ee5cff172f71cfa061c5a19d39', name: "sticky-left" })), hAsync(MarketTableAreaTagName, { key: '6c16c71570af888f249ed17e208cf7ba529ed408', orientation: "vertical", gridTemplate: gridTemplateMain, ref: (el) => (this.tableAreaMain = el), active: true }, hAsync("slot", { key: '3fa9a13284967ade7ca15968a9be73b097c2934e', name: "control", onSlotchange: () => this._registerSlottedControl() }), hAsync("slot", { key: '3ce80946bd17ff03315262bff77d728f92fc9fe0', onSlotchange: () => this.handleSlotChange() })), hAsync(MarketTableAreaTagName, { key: '8c37a017089cc05a86be2228bdb56d3ce7da6d5b', orientation: "vertical", "stick-to": "right", gridTemplate: gridTemplateRight, ref: (el) => (this.tableAreaRight = el) }, hAsync("slot", { key: '4144f5e42d7371d60733da1d8cc584a16f6d9eb0', name: "sticky-right" }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "gridTemplateMain": ["formNewGridTemplate"],
        "gridTemplateLeft": ["formNewGridTemplate"],
        "gridTemplateRight": ["formNewGridTemplate"],
        "gridTemplate": ["gridTemplateObserver"],
        "stickTo": ["stickyObserver"],
        "sticky": ["stickyObserver"],
        "tableColumns": ["columnsObserver"],
        "cells": ["updateCellProperties"],
        "leadingIndentation": ["updateFirstCellProperties"],
        "expanded": ["updateNestedRowButton"],
        "selected": ["updateSlottedControlCheckedValue"],
        "disabled": ["updateSlottedControlDisabledValue"]
    }; }
    static get style() { return MarketTableRowStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-row",
        "$members$": {
            "leadingIndentation": [1538, "leading-indentation"],
            "stickTo": [1544, "stick-to"],
            "sticky": [1540],
            "active": [516],
            "interactive": [516],
            "disabled": [516],
            "selected": [1540],
            "header": [1540],
            "footer": [1540],
            "originalSlot": [1025, "original-slot"],
            "index": [2],
            "tableColumns": [16],
            "cells": [1040],
            "gridTemplateMain": [16],
            "gridTemplateLeft": [16],
            "gridTemplateRight": [16],
            "expanded": [1028],
            "nested": [1540],
            "styleDeclaration": [32],
            "gridTemplate": [32],
            "nestedRowToggleButton": [32],
            "stick": [64],
            "unstick": [64],
            "_stickColumn": [64],
            "_unstickColumn": [64],
            "_syncColumnVisibilityWithCells": [64],
            "_setFirstCellProperties": [64],
            "setLeadingIndentation": [64],
            "toggleNestedRow": [64]
        },
        "$listeners$": [[0, "marketCheckboxValueChange", "handleMarketCheckboxValueChange"], [0, "marketToggleChange", "handleMarketCheckboxValueChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["leadingIndentation", "leading-indentation"], ["stickTo", "stick-to"], ["sticky", "sticky"], ["active", "active"], ["interactive", "interactive"], ["disabled", "disabled"], ["selected", "selected"], ["header", "header"], ["footer", "footer"], ["nested", "nested"]]
    }; }
}

const sortItems = ({ items, order, column, strategy, format, }) => {
    const sortedItems = [...items];
    sortedItems.sort((childA, childB) => {
        const rowA = isMarketTableV2Group(childA)
            ? childA.querySelector('[slot="parent"]')
            : childA;
        const rowB = isMarketTableV2Group(childB)
            ? childB.querySelector('[slot="parent"]')
            : childB;
        const params = { rowA, rowB, order, column };
        if (typeof strategy === 'function') {
            return strategy(params);
        }
        else if (strategy === 'number') {
            return sortByNumber(params);
        }
        else if (strategy === 'datetime' && format) {
            return sortByDateTime(Object.assign(Object.assign({}, params), { format }));
        }
        else {
            return sortByString(params);
        }
    });
    return sortedItems;
};
const sortByNumber = ({ rowA, rowB, order, column, }) => {
    var _a, _b, _c, _d;
    const numberA = Number.parseFloat((_b = (_a = rowA === null || rowA === void 0 ? void 0 : rowA.children[column]) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim());
    const numberB = Number.parseFloat((_d = (_c = rowB === null || rowB === void 0 ? void 0 : rowB.children[column]) === null || _c === void 0 ? void 0 : _c.textContent) === null || _d === void 0 ? void 0 : _d.trim());
    if (order === 'ascending') {
        return numberA - numberB;
    }
    else {
        return numberB - numberA;
    }
};
const sortByString = ({ rowA, rowB, order, column, }) => {
    var _a, _b, _c, _d, _e, _f;
    const contentA = (_c = (_b = (_a = rowA === null || rowA === void 0 ? void 0 : rowA.children[column]) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) === null || _c === void 0 ? void 0 : _c.toUpperCase();
    const contentB = (_f = (_e = (_d = rowB === null || rowB === void 0 ? void 0 : rowB.children[column]) === null || _d === void 0 ? void 0 : _d.textContent) === null || _e === void 0 ? void 0 : _e.trim()) === null || _f === void 0 ? void 0 : _f.toUpperCase();
    if (order === 'ascending') {
        if (contentA < contentB)
            return -1;
        if (contentA > contentB)
            return 1;
        return 0;
    }
    else {
        if (contentA < contentB)
            return 1;
        if (contentA > contentB)
            return -1;
        return 0;
    }
};
const sortByDateTime = ({ rowA, rowB, order, column, format, }) => {
    var _a, _b, _c, _d;
    const contentA = (_b = (_a = rowA === null || rowA === void 0 ? void 0 : rowA.children[column]) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim();
    const contentB = (_d = (_c = rowB === null || rowB === void 0 ? void 0 : rowB.children[column]) === null || _c === void 0 ? void 0 : _c.textContent) === null || _d === void 0 ? void 0 : _d.trim();
    const dateA = parse(contentA, format, new Date());
    const dateB = parse(contentB, format, new Date());
    if (order === 'ascending') {
        if (dateA < dateB)
            return -1;
        if (dateA > dateB)
            return 1;
        return 0;
    }
    else {
        if (dateA < dateB)
            return 1;
        if (dateA > dateB)
            return -1;
        return 0;
    }
};

const marketTableV2Css = "/*!@:host, **/.sc-market-table-v2-h,*.sc-market-table-v2{box-sizing:border-box}/*!@:host*/.sc-market-table-v2-h{--table-cell-state-normal-background-color:var(--core-surface-10-color);position:relative;display:block;overflow:auto;width:100%;background-color:var(--table-cell-state-normal-background-color);font-feature-settings:\"tnum\"}/*!@:host [role=\"table\"]*/.sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{display:table;vertical-align:middle;width:100%;height:100%;border-spacing:0;border-collapse:separate;table-layout:auto;text-align:left}/*!@:host slot*/.sc-market-table-v2-h slot.sc-market-table-v2{vertical-align:inherit;text-align:inherit}/*!@:host([layout=\"fixed\"]) [role=\"table\"]*/[layout=\"fixed\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{table-layout:fixed}/*!@:host([align=\"left\"]) [role=\"table\"]*/[align=\"left\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{text-align:left}/*!@:host([align=\"center\"]) [role=\"table\"]*/[align=\"center\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{text-align:center}/*!@:host([align=\"right\"]) [role=\"table\"]*/[align=\"right\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{text-align:right}/*!@:host([valign=\"top\"]) [role=\"table\"]*/[valign=\"top\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{vertical-align:top}/*!@:host([valign=\"middle\"]) [role=\"table\"]*/[valign=\"middle\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{vertical-align:middle}/*!@:host([valign=\"bottom\"]) [role=\"table\"]*/[valign=\"bottom\"].sc-market-table-v2-h [role=\"table\"].sc-market-table-v2{vertical-align:bottom}/*!@::slotted(.market-drag-cursor)*/.sc-market-table-v2-s>.market-drag-cursor{--drag-cursor-height:4px;position:absolute;right:0;left:0;display:block;height:0;outline:calc(var(--drag-cursor-height) / 2) solid var(--core-emphasis-fill-color);pointer-events:none}";
var MarketTableV2Style0 = marketTableV2Css;

/**
 * @slot - Default slot for all rows.
 * @part table - The inner table element.
 */
class MarketTableV2 {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTableV2RowsReordered = createEvent(this, "marketTableV2RowsReordered", 7);
        this.align = undefined;
        this.collapsible = false;
        this.layout = 'auto';
        this.reorderable = undefined;
        this.reorderMode = 'default';
        this.selected = 'false';
        this.valign = undefined;
    }
    async onMarketTableV2SelectionChange(e) {
        const { header, footer } = this;
        const { target, detail } = e;
        const eventSelected = detail.current;
        e.stopPropagation();
        if (target === header || target === footer) {
            // the target is the header or footer, so propagate values downward
            await this.setSelected(eventSelected, { silent: true });
        }
        else {
            // the target is a child, and it's complicated...
            await this.setSelectedFromChildEvent(e);
        }
    }
    onMarketTableV2CellSortClicked(e) {
        const { el, header, children, groups, footer } = this;
        const sortedCell = e.target;
        // only allow sorting from the header row
        if (sortedCell.parentElement !== header)
            return;
        const { current: newSortOrder } = e.detail;
        const headerChildren = [...header.children];
        const sortedColumnIndex = headerChildren.indexOf(sortedCell);
        const { sortStrategy, sortStrategyFormat } = sortedCell;
        // sort the children
        const sortedChildren = sortItems({
            items: children,
            order: newSortOrder,
            column: sortedColumnIndex,
            strategy: sortStrategy,
            format: sortStrategyFormat,
        });
        // sort the groups' children
        groups === null || groups === void 0 ? void 0 : groups.forEach((group) => {
            group.sort({
                order: newSortOrder,
                column: sortedColumnIndex,
                strategy: sortStrategy,
                format: sortStrategyFormat,
            });
        });
        // set the header sort values
        sortedCell.sortOrder = newSortOrder;
        headerChildren.forEach((cell) => {
            cell.sortOrder = cell === sortedCell ? newSortOrder : undefined;
        });
        // render the sorted rows
        sortedChildren.forEach((row) => {
            el.append(row);
        });
        if (footer)
            el.append(footer);
    }
    onDragMove(e) {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragMove(e);
    }
    onDragLeave() {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragLeave();
    }
    onDragEnd(e) {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragEnd(e);
    }
    onDragDrop(e) {
        var _a;
        (_a = this.reorder) === null || _a === void 0 ? void 0 : _a.dragDrop(e);
    }
    watchCollapsible() {
        const { rows, groups, collapsible } = this;
        groups.forEach((group) => {
            group.collapsible = collapsible;
            group.indent = 0;
        });
        rows.forEach((row) => {
            // per design, don't indent header or footer rows
            if (row.header || row.footer)
                return;
            // indent rows to line up with groups w/ carets
            row.indent = collapsible && groups.length > 0 ? 1 : 0;
        });
    }
    watchReorderable() {
        const { el, reorder, reorderable, reorderMode, marketTableV2RowsReordered } = this;
        reorder === null || reorder === void 0 ? void 0 : reorder.destroy();
        const reorderEnabled = ['internal', 'external'].includes(reorderable);
        if (reorderEnabled) {
            const rowTagName = getNamespacedTagFor('market-table-v2-row');
            const groupTagName = getNamespacedTagFor('market-table-v2-group');
            this.reorder = new Reorderable({
                el,
                accepts: [`${rowTagName}:not([header]):not([footer]):not([slot="parent"])`, groupTagName],
                event: marketTableV2RowsReordered,
                mode: reorderMode,
            });
        }
        this.syncDragEnabled();
    }
    /**
     * @internal
     * Sets selection on the table and propagates the value
     * downwards to its children rows and groups.
     */
    async setSelected(selected, { silent = false } = {}) {
        const { header, footer, children, selected: prevSelected } = this;
        // return if no values have changed
        if (prevSelected === selected)
            return Promise.resolve();
        // propagate the new values
        this.selected = selected;
        await (header === null || header === void 0 ? void 0 : header.setSelected(selected, { silent }));
        await (footer === null || footer === void 0 ? void 0 : footer.setSelected(selected, { silent }));
        children === null || children === void 0 ? void 0 : children.forEach(async (child) => {
            await child.setSelected(selected, { silent });
        });
        return Promise.resolve();
    }
    async setSelectedFromChildEvent(e) {
        const { header, footer, children, selected: prevSelected } = this;
        const { target, detail } = e;
        const { current: childSelected } = detail;
        // get an array of what the children's selected values would be AFTER this event
        const childrenSelected = children.map((child) => {
            // if the target was THIS child, it will be new event value (not .selected)
            if (target === child)
                return childSelected;
            // otherwise, get the current value directly from this child
            return child.selected;
        });
        // what the table's selected value would be AFTER this event
        const tableSelected = childrenSelected.every((val) => val === 'true')
            ? 'true'
            : childrenSelected.every((val) => val === 'false')
                ? 'false'
                : 'indeterminate';
        // return if no values have changed
        if (prevSelected === tableSelected)
            return;
        // propagate the new value
        this.selected = tableSelected;
        await (header === null || header === void 0 ? void 0 : header.setSelected(tableSelected, { silent: true }));
        await (footer === null || footer === void 0 ? void 0 : footer.setSelected(tableSelected, { silent: true }));
    }
    getElements() {
        this.rows = [...this.el.children].filter((child) => {
            return child.tagName === getNamespacedTagFor('market-table-v2-row').toUpperCase();
        });
        this.groups = [...this.el.children].filter((child) => {
            return child.tagName === getNamespacedTagFor('market-table-v2-group').toUpperCase();
        });
        this.header = this.rows.find((row) => row.header);
        this.footer = this.rows.find((row) => row.footer);
        this.children = [...this.groups, ...this.rows.filter((row) => !row.header && !row.footer)];
    }
    syncDragEnabled() {
        const { header, footer, rows, groups, reorderable, reorderMode } = this;
        const reorderEnabled = ['internal', 'external'].includes(reorderable);
        if (header)
            header.dragEnabled = reorderEnabled;
        if (footer)
            footer.dragEnabled = reorderEnabled;
        rows === null || rows === void 0 ? void 0 : rows.forEach((row) => {
            if (!isDraggable(row))
                return;
            row.dragEnabled = reorderEnabled;
        });
        groups === null || groups === void 0 ? void 0 : groups.forEach((group) => {
            group.dragEnabled = reorderEnabled;
            group.reorderable = reorderable;
            group.reorderMode = reorderMode;
        });
    }
    onSlotChange() {
        this.getElements();
        this.watchCollapsible();
        this.syncDragEnabled();
    }
    connectedCallback() {
        this.getElements();
        this.watchCollapsible();
        this.syncDragEnabled();
    }
    componentDidRender() {
        this.watchReorderable();
    }
    render() {
        return (hAsync(Host, { key: 'e149228f1e4d3e136f9571d5cb385c7e0f4670e9', class: "market-table-v2" }, hAsync("div", { key: 'b28e0fe40fbbd5e7dac970e3a5adce848f88c64c', role: "table", part: "table" }, hAsync("slot", { key: '555aa3b36f06ad72a913161c62169f6029fe3f3f', onSlotchange: () => this.onSlotChange() }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "collapsible": ["watchCollapsible"],
        "reorderable": ["watchReorderable"]
    }; }
    static get style() { return MarketTableV2Style0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-v2",
        "$members$": {
            "align": [513],
            "collapsible": [516],
            "layout": [513],
            "reorderable": [513],
            "reorderMode": [1, "reorder-mode"],
            "selected": [1025],
            "valign": [513],
            "setSelected": [64]
        },
        "$listeners$": [[0, "marketInternalTableV2RowSelectionChange", "onMarketTableV2SelectionChange"], [0, "marketInternalTableV2GroupSelectionChange", "onMarketTableV2SelectionChange"], [0, "marketTableV2CellSortClicked", "onMarketTableV2CellSortClicked"], [0, "marketDragMove", "onDragMove"], [0, "marketDragLeave", "onDragLeave"], [0, "marketDragEnd", "onDragEnd"], [0, "marketDragDrop", "onDragDrop"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["align", "align"], ["collapsible", "collapsible"], ["layout", "layout"], ["reorderable", "reorderable"], ["valign", "valign"]]
    }; }
}

function isMarketCheckbox(value) {
    var _a;
    const tagName = (_a = value === null || value === void 0 ? void 0 : value.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    return Boolean(value && tagName === getNamespacedTagFor('market-checkbox'));
}

function isMarketToggle(value) {
    var _a;
    const tagName = (_a = value === null || value === void 0 ? void 0 : value.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    return Boolean(value && tagName === getNamespacedTagFor('market-toggle'));
}

function isMarketTableV2ControlElement(value) {
    return isMarketCheckbox(value) || isMarketToggle(value);
}

const marketTableV2CellCss = "/*!@:host, **/.sc-market-table-v2-cell-h,*.sc-market-table-v2-cell{box-sizing:border-box}/*!@:host*/.sc-market-table-v2-cell-h{--table-cell-vertical-padding-size:var(--core-metrics-spacing-150);--table-cell-horizontal-padding-size:var(--core-metrics-spacing-100);--table-cell-horizontal-spacing-size:var(--core-metrics-spacing-150);--table-cell-border-width:1px;--table-cell-heading-border-color:var(--core-divider-10-color);--table-cell-state-normal-background-color:var(--core-surface-10-color);--table-cell-hover-state-background-color:var(--core-fill-50-color);--table-cell-focus-state-background-color:var(--core-fill-50-color);--table-cell-pressed-state-background-color:var(--core-emphasis-40-color);--table-cell-disabled-state-text-color:var(--core-text-30-color);--table-cell-indent-level:0;--table-cell-indent-size:var(--core-metrics-spacing-500);--table-cell-caret-size:var(--core-metrics-spacing-500);--table-cell-text-font-weight:var(--core-type-paragraph-20-weight);--table-cell-text-font-size:var(--core-type-paragraph-20-size);--table-cell-text-line-height:var(--core-type-paragraph-20-leading);--table-cell-focus-ring-color:color-mix(in srgb, var(--core-focus-ring-color) 50%, transparent);display:table-cell;vertical-align:inherit;width:auto;padding:var(--table-cell-vertical-padding-size) var(--table-cell-horizontal-padding-size);border-bottom:var(--table-cell-border-width) solid var(--table-cell-border-color);outline:none;font-weight:var(--table-cell-text-font-weight);font-size:var(--table-cell-text-font-size);line-height:var(--table-cell-text-line-height);text-align:inherit}/*!@:host .content-outer*/.sc-market-table-v2-cell-h .content-outer.sc-market-table-v2-cell{display:flex;gap:var(--table-cell-horizontal-spacing-size);justify-content:space-between;align-items:center;width:100%;transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:gap}/*!@:host .content-inner*/.sc-market-table-v2-cell-h .content-inner.sc-market-table-v2-cell{display:flex;gap:var(--table-cell-horizontal-spacing-size);align-items:center;width:100%}/*!@:host .default-slot*/.sc-market-table-v2-cell-h .default-slot.sc-market-table-v2-cell{width:100%}/*!@:host([indent]:not([indent=\"0\"]))*/[indent].sc-market-table-v2-cell-h:not([indent=\"0\"]){padding-left:calc(\n        var(--table-cell-horizontal-spacing-size) + var(--table-cell-indent-level) * var(--table-cell-indent-size)\n      )}/*!@:host([indent][caret]:not([indent=\"0\"]))*/[indent][caret].sc-market-table-v2-cell-h:not([indent=\"0\"]){padding-left:calc(\n        var(--table-cell-horizontal-padding-size) + var(--table-cell-indent-level) * var(--table-cell-indent-size)\n      )}/*!@:host([nowrap]) .default-slot*/[nowrap].sc-market-table-v2-cell-h .default-slot.sc-market-table-v2-cell{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}/*!@:host([align=\"left\"])*/[align=\"left\"].sc-market-table-v2-cell-h{text-align:left}/*!@:host([align=\"center\"])*/[align=\"center\"].sc-market-table-v2-cell-h{text-align:center}/*!@:host([align=\"right\"])*/[align=\"right\"].sc-market-table-v2-cell-h{text-align:right}/*!@:host([valign=\"top\"])*/[valign=\"top\"].sc-market-table-v2-cell-h{vertical-align:top}/*!@:host([valign=\"middle\"])*/[valign=\"middle\"].sc-market-table-v2-cell-h{vertical-align:middle}/*!@:host([valign=\"bottom\"])*/[valign=\"bottom\"].sc-market-table-v2-cell-h{vertical-align:bottom}/*!@:host([sticky])*/[sticky].sc-market-table-v2-cell-h{position:sticky;z-index:2;background-color:var(--table-cell-state-normal-background-color)}/*!@:host([sticky=\"left\"])*/[sticky=\"left\"].sc-market-table-v2-cell-h{left:0;border-right:var(--table-cell-border-width) solid var(--table-cell-heading-border-color)}/*!@:host([sticky=\"right\"])*/[sticky=\"right\"].sc-market-table-v2-cell-h{right:0;border-left:var(--table-cell-border-width) solid var(--table-cell-heading-border-color)}/*!@:host(.market-drag-clone-first-cell)*/.market-drag-clone-first-cell.sc-market-table-v2-cell-h{padding-left:var(--table-cell-horizontal-padding-size) !important}/*!@:host(.market-drag-clone-first-cell) .content-outer*/.market-drag-clone-first-cell.sc-market-table-v2-cell-h .content-outer.sc-market-table-v2-cell{gap:0}/*!@:host(.market-drag-clone-first-cell) .caret-button, :host(.market-drag-clone-first-cell) ::slotted([slot=\"control\"])*/.market-drag-clone-first-cell.sc-market-table-v2-cell-h .caret-button.sc-market-table-v2-cell,.sc-market-table-v2-cell-h.market-drag-clone-first-cell.sc-market-table-v2-cell-s>[slot=\"control\"],.sc-market-table-v2-cell-h.market-drag-clone-first-cell .sc-market-table-v2-cell-s>[slot=\"control\"]{width:0;height:0;opacity:0%}/*!@::slotted([slot=\"control\"]), ::slotted([slot=\"leading-accessory\"]), ::slotted([slot=\"trailing-accessory\"])*/.sc-market-table-v2-cell-s>[slot=\"control\"],.sc-market-table-v2-cell-s>[slot=\"leading-accessory\"],.sc-market-table-v2-cell-s>[slot=\"trailing-accessory\"]{flex-shrink:0}/*!@.caret-button, ::slotted([slot=\"control\"])*/.caret-button.sc-market-table-v2-cell,.sc-market-table-v2-cell-s>[slot=\"control\"]{transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:width, height, opacity}/*!@:host([interactive])*/[interactive].sc-market-table-v2-cell-h{cursor:pointer}@media (hover: hover){/*!@:host([sortable]:hover), :host([interactive]:hover)*/[sortable].sc-market-table-v2-cell-h:hover,[interactive].sc-market-table-v2-cell-h:hover{background-color:var(--table-cell-hover-state-background-color)}}/*!@:host([sortable]:focus), :host([interactive]:focus)*/[sortable].sc-market-table-v2-cell-h:focus,[interactive].sc-market-table-v2-cell-h:focus{background-color:var(--table-cell-focus-state-background-color)}/*!@:host([active]), :host([sortable]:active), :host([interactive]:active)*/[active].sc-market-table-v2-cell-h,[sortable].sc-market-table-v2-cell-h:active,[interactive].sc-market-table-v2-cell-h:active{background-color:var(--table-cell-pressed-state-background-color)}/*!@:host([disabled])*/[disabled].sc-market-table-v2-cell-h{color:var(--table-cell-disabled-state-text-color);pointer-events:none}/*!@.caret-button*/.caret-button.sc-market-table-v2-cell{display:flex;flex-shrink:0;justify-content:center;align-items:center;width:var(--table-cell-caret-size);height:var(--table-cell-caret-size);margin-top:calc(var(--table-cell-vertical-padding-size) * -1);margin-bottom:calc(var(--table-cell-vertical-padding-size) * -1);margin-left:calc(var(--table-cell-horizontal-padding-size) * -1);padding:0;border:none;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.caret-button svg*/.caret-button.sc-market-table-v2-cell svg.sc-market-table-v2-cell{display:block;fill:var(--core-fill-20-color);transition:0.2s transform ease}/*!@:host([caret=\"up\"]) .caret-button svg*/[caret=\"up\"].sc-market-table-v2-cell-h .caret-button.sc-market-table-v2-cell svg.sc-market-table-v2-cell{transform:rotate(-180deg)}/*!@.caret-button:focus-visible*/.caret-button.sc-market-table-v2-cell:focus-visible{border-radius:var(--core-radius-10);outline:var(--core-focus-ring-border-size) solid var(--table-cell-focus-ring-color);outline-offset:calc(var(--core-focus-ring-border-size) * -1)}/*!@.sort-button*/.sort-button.sc-market-table-v2-cell{display:flex;flex-shrink:0;gap:var(--core-metrics-spacing-50);align-items:center;width:100%;margin:0;padding:var(--table-cell-vertical-padding-size) var(--table-cell-horizontal-padding-size);border:none;background:transparent;outline:none;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;text-align:inherit;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.sort-button svg*/.sort-button.sc-market-table-v2-cell svg.sc-market-table-v2-cell{display:block;flex-shrink:0;fill:var(--core-text-30-color)}/*!@.sort-button:focus-visible*/.sort-button.sc-market-table-v2-cell:focus-visible{border-radius:var(--core-radius-10);outline:var(--core-focus-ring-border-size) solid var(--table-cell-focus-ring-color);outline-offset:calc(var(--core-focus-ring-border-size) * -1)}/*!@:host([align=\"left\"]) .sort-button*/[align=\"left\"].sc-market-table-v2-cell-h .sort-button.sc-market-table-v2-cell{justify-content:start}/*!@:host([align=\"center\"]) .sort-button*/[align=\"center\"].sc-market-table-v2-cell-h .sort-button.sc-market-table-v2-cell{justify-content:center}/*!@:host([align=\"right\"]) .sort-button*/[align=\"right\"].sc-market-table-v2-cell-h .sort-button.sc-market-table-v2-cell{justify-content:end}/*!@:host([sortable])*/[sortable].sc-market-table-v2-cell-h{padding:0}/*!@:host([sortable][sort-order=\"ascending\"]) .sort-button svg, :host([sortable][sort-order=\"descending\"]) .sort-button svg*/[sortable][sort-order=\"ascending\"].sc-market-table-v2-cell-h .sort-button.sc-market-table-v2-cell svg.sc-market-table-v2-cell,[sortable][sort-order=\"descending\"].sc-market-table-v2-cell-h .sort-button.sc-market-table-v2-cell svg.sc-market-table-v2-cell{fill:var(--core-text-10-color)}";
var MarketTableV2CellStyle0 = marketTableV2CellCss;

/**
 * @slot - Default slot for content.
 * @slot control - Intended for use with a form control element.
 * @slot leading-accessory - Intended for use with a leading accessory.
 * @slot trailing-accessory - Intended for use with a trailing accessory.
 */
class MarketTableV2Cell {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTableV2CellCaretClicked = createEvent(this, "marketTableV2CellCaretClicked", 7);
        this.marketTableV2CellSortClicked = createEvent(this, "marketTableV2CellSortClicked", 7);
        this.marketInternalTableV2CellSelectionChange = createEvent(this, "marketInternalTableV2CellSelectionChange", 7);
        this.active = false;
        this.align = undefined;
        this.caret = undefined;
        this.caretAriaLabelExpanded = 'Group of rows is expanded: click to collapse';
        this.caretAriaLabelCollapsed = 'Group of rows is collapsed: click to expand';
        this.disabled = false;
        this.indent = undefined;
        this.interactive = false;
        this.nowrap = false;
        this.selected = 'false';
        this.sticky = undefined;
        this.sortable = undefined;
        this.sortAriaLabelAscending = 'Sorted ascending: click to sort descending';
        this.sortAriaLabelDescending = 'Sorted descending: click to sort ascending';
        this.sortAriaLabelNone = 'Not sorted: click to sort ascending';
        this.sortOrder = 'none';
        this.sortStrategy = undefined;
        this.sortStrategyFormat = undefined;
        this.valign = undefined;
    }
    onKeydown(e) {
        const { target, key } = e;
        const { el, disabled, interactive } = this;
        if (disabled)
            return;
        if (!interactive)
            return;
        if (target !== el)
            return;
        if (key === 'Enter' || key === ' ') {
            e.preventDefault();
            el.click();
        }
    }
    async onMarketControlSelectionChange(e) {
        const { control } = this;
        const { target, detail } = e;
        // return if the target wasn't this cell's control
        if (target !== control)
            return;
        const selected = detail.current ? 'true' : 'false';
        await this.setSelected(selected);
    }
    /**
     * @internal
     * Sets selection on the cell and propagates value to its slotted control
     */
    async setSelected(selected, { silent = false } = {}) {
        const { marketInternalTableV2CellSelectionChange, selected: prevSelected } = this;
        // return if no values have changed
        if (prevSelected === selected)
            return Promise.resolve();
        // fire the internal selection event
        if (!silent) {
            marketInternalTableV2CellSelectionChange.emit({
                current: selected,
                previous: prevSelected,
            });
        }
        // save the state
        this.selected = selected;
        await this.setControlSelected(selected);
        return Promise.resolve();
    }
    async setControlSelected(selected) {
        const { control } = this;
        if (!control)
            return;
        await control.setSelection(selected === 'true', { silent: true });
        if (isMarketCheckbox(control))
            await control.setIndeterminate(selected === 'indeterminate');
    }
    getTabIndex() {
        const { disabled, interactive } = this;
        return interactive && !disabled ? '0' : null;
    }
    getStyles() {
        const { indent } = this;
        if (!indent || indent < 1)
            return {};
        return { '--table-cell-indent-level': indent.toString() };
    }
    getSortButtonLabel() {
        const { sortOrder, sortAriaLabelAscending, sortAriaLabelDescending, sortAriaLabelNone } = this;
        switch (sortOrder) {
            case 'ascending':
                return sortAriaLabelAscending;
            case 'descending':
                return sortAriaLabelDescending;
            default:
                return sortAriaLabelNone;
        }
    }
    onCaretClick(e) {
        e.stopPropagation();
        this.marketTableV2CellCaretClicked.emit();
    }
    onSortClick() {
        const { sortOrder, marketTableV2CellSortClicked } = this;
        const previous = sortOrder || 'none';
        const current = previous === 'ascending' ? 'descending' : 'ascending';
        const { defaultPrevented } = marketTableV2CellSortClicked.emit({
            current,
            previous,
        });
        if (!defaultPrevented)
            this.sortOrder = current;
    }
    async syncControlState() {
        const { el, selected } = this;
        const control = [...el.children].find((child) => child.slot === 'control');
        if (isMarketTableV2ControlElement(control)) {
            this.control = control;
            if (selected)
                await this.setControlSelected(selected);
        }
    }
    async connectedCallback() {
        await this.syncControlState();
    }
    renderCaretButton() {
        return (
        // Note: We would ideally also have aria-expanded and aria-controls attributes; however, this is not currently
        // possible (as of Mar 2024) due to the lack of support for referencing elements across shadow DOMs. Browser
        // support work is ongoing in this area, but it is insufficient at this time. We should revisit in the future.
        hAsync("button", { class: "caret-button", "aria-label": this.caret === 'down' ? this.caretAriaLabelCollapsed : this.caretAriaLabelExpanded, onClick: (e) => this.onCaretClick(e) }, hAsync("svg", { width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8.70715 11.7071C8.31663 12.0976 7.68346 12.0976 7.29294 11.7071L1.29294 5.70711L2.70715 4.29289L8.00005 9.58579L13.2929 4.29289L14.7072 5.70711L8.70715 11.7071Z" }))));
    }
    renderSortAscendingSvg() {
        return (hAsync("svg", { width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M7.52861 2.86177C7.78895 2.60142 8.21107 2.60142 8.47141 2.86177L13.1381 7.52843L12.1953 8.47124L8.66668 4.94265L8.66668 12.6665H7.33334V4.94265L3.80475 8.47124L2.86194 7.52843L7.52861 2.86177Z" })));
    }
    renderSortDecendingSvg() {
        return (hAsync("svg", { width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8.47129 13.1382C8.21094 13.3986 7.78883 13.3986 7.52848 13.1382L2.86182 8.47157L3.80463 7.52876L7.33322 11.0574L7.33322 3.3335L8.66655 3.3335L8.66655 11.0574L12.1952 7.52876L13.138 8.47157L8.47129 13.1382Z" })));
    }
    renderSortNoneSvg() {
        return (hAsync("svg", { width: "16", height: "17", viewBox: "0 0 16 17", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M10.8633 14.31L8.19664 11.6434L9.1433 10.7034L10.67 12.23L10.67 3.17002L12.0033 3.17002L12.0033 12.23L13.53 10.7034L14.47 11.6434L11.8033 14.31C11.5433 14.57 11.1233 14.57 10.8633 14.31ZM2.46997 6.30338L1.52997 5.36338L4.19664 2.69671C4.45664 2.43671 4.87664 2.43671 5.13664 2.69671L7.8033 5.36338L6.8633 6.30338L5.33664 4.77671L5.33664 13.8367L4.0033 13.8367L4.0033 4.77671L2.46997 6.30338Z" })));
    }
    renderSortSvg() {
        switch (this.sortOrder) {
            case 'ascending':
                return this.renderSortAscendingSvg();
            case 'descending':
                return this.renderSortDecendingSvg();
            default:
                return this.renderSortNoneSvg();
        }
    }
    render() {
        var _a;
        const { el, caret, sortable, sortOrder } = this;
        return (hAsync(Host, { key: '2d295a766cd4cb793b862dd91fc75268c2a87dd4', role: (_a = el.role) !== null && _a !== void 0 ? _a : 'cell', tabindex: this.getTabIndex(), style: this.getStyles(), class: "market-table-v2-cell", "sort-order": sortOrder !== 'none' ? sortOrder : null, "aria-sort": sortOrder !== 'none' ? sortOrder : null }, hAsync("div", { key: '906e275506a64e166a30803cfc82c62f777ed6d3', class: "content-outer" }, caret && this.renderCaretButton(), hAsync("slot", { key: 'ac57aa86c019e676af0bb682c62566edafd49ac9', name: "control", onSlotchange: () => this.syncControlState() }), hAsync("div", { key: '2a4230ff9f54efa8ee8cee84520d33dd825dde2c', class: "content-inner" }, hAsync("slot", { key: '99ed0e6392d5578d91f4241e327ff35b94f0b399', name: "leading-accessory" }), hAsync("div", { key: 'bfd35740621d1e2ae479b6a0f04f6f4d0cbe44bf', class: "default-slot" }, !sortable && hAsync("slot", { key: 'dd7101744adee33b83c23edd386ae2f5569a3b08' }), sortable && (hAsync("button", { key: 'b50edf4b821d5d7b558403069525a2094c7074fb', class: "sort-button", "aria-describedby": "sort-button-label", onClick: () => this.onSortClick() }, hAsync("slot", { key: '6b025eba66325233948b4049c8f4488811a5bd56' }), this.renderSortSvg(), hAsync("span", { key: 'd3fbf14b0b8cce540086ad7085ae39fc534c659d', id: "sort-button-label", hidden: true }, this.getSortButtonLabel())))), hAsync("slot", { key: 'ff30de7fc804ca8308dc6a997c22449fdc14307b', name: "trailing-accessory" })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketTableV2CellStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-v2-cell",
        "$members$": {
            "active": [516],
            "align": [513],
            "caret": [513],
            "caretAriaLabelExpanded": [1, "caret-aria-label-expanded"],
            "caretAriaLabelCollapsed": [1, "caret-aria-label-collapsed"],
            "disabled": [516],
            "indent": [514],
            "interactive": [516],
            "nowrap": [516],
            "selected": [1025],
            "sticky": [513],
            "sortable": [516],
            "sortAriaLabelAscending": [1, "sort-aria-label-ascending"],
            "sortAriaLabelDescending": [1, "sort-aria-label-descending"],
            "sortAriaLabelNone": [1, "sort-aria-label-none"],
            "sortOrder": [1025, "sort-order"],
            "sortStrategy": [1, "sort-strategy"],
            "sortStrategyFormat": [1, "sort-strategy-format"],
            "valign": [513],
            "setSelected": [64]
        },
        "$listeners$": [[0, "keydown", "onKeydown"], [0, "marketToggleChange", "onMarketControlSelectionChange"], [0, "marketCheckboxValueChange", "onMarketControlSelectionChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["align", "align"], ["caret", "caret"], ["disabled", "disabled"], ["indent", "indent"], ["interactive", "interactive"], ["nowrap", "nowrap"], ["sticky", "sticky"], ["sortable", "sortable"], ["valign", "valign"]]
    }; }
}

const marketTableV2GroupCss = "/*!@:host*/.sc-market-table-v2-group-h{--table-cell-horizontal-padding-size:8px;--table-cell-indent-size:40px;--drag-highlight-border-size:2px}/*!@:host, slot, .children*/.sc-market-table-v2-group-h,slot.sc-market-table-v2-group,.children.sc-market-table-v2-group{vertical-align:inherit;text-align:inherit}/*!@:host, .children*/.sc-market-table-v2-group-h,.children.sc-market-table-v2-group{display:contents}/*!@:host([collapsible][collapsed]) .children*/[collapsible][collapsed].sc-market-table-v2-group-h .children.sc-market-table-v2-group{display:none}/*!@:host(.market-drag-cursor-parent[collapsible][collapsed]) ::slotted([slot=\"parent\"])*/.sc-market-table-v2-group-h.market-drag-cursor-parent[collapsible][collapsed] .sc-market-table-v2-group-s>[slot=\"parent\"]{position:relative;border-radius:var(--core-radius-10);background-color:var(--core-emphasis-40-color);outline:var(--drag-highlight-border-size) solid var(--core-emphasis-fill-color);outline-offset:calc(var(--drag-highlight-border-size) * -1)}/*!@::slotted(.market-drag-cursor)*/.sc-market-table-v2-group-s>.market-drag-cursor{--drag-cursor-height:4px;position:absolute;right:0;left:calc(\n      var(--table-cell-horizontal-padding-size) +\n      (var(--drag-cursor-indent-level) + 1) * var(--table-cell-indent-size)\n    );display:block;height:0;outline:calc(var(--drag-cursor-height) / 2) solid var(--core-emphasis-fill-color);pointer-events:none}/*!@:host(.market-drag-placeholder) ::slotted(:not([slot=\"parent\"]))*/.sc-market-table-v2-group-h.market-drag-placeholder .sc-market-table-v2-group-s>:not([slot=\"parent\"]){display:none}";
var MarketTableV2GroupStyle0 = marketTableV2GroupCss;

/**
 * @slot - Default slot for children rows
 * @slot parent - Slot for for the parent row
 */
class MarketTableV2Group {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketInternalTableV2GroupSelectionChange = createEvent(this, "marketInternalTableV2GroupSelectionChange", 7);
        this.marketTableV2RowsReordered = createEvent(this, "marketTableV2RowsReordered", 7);
        this.marketTableV2GroupCollapsedChange = createEvent(this, "marketTableV2GroupCollapsedChange", 7);
        this.collapsible = false;
        this.collapsed = false;
        this.dragEnabled = false;
        this.indent = 0;
        this.reorderable = undefined;
        this.reorderMode = 'default';
        this.selected = 'false';
    }
    onMarketTableV2CellCaretClicked(e) {
        e.stopPropagation();
        this.setCollapsed(!this.collapsed);
    }
    async onMarketTableV2SelectionChange(e) {
        const { el, parent } = this;
        const { target, detail } = e;
        const { current } = detail;
        // oddly, a component's instance can catch its own event
        // before it bubbles, so prevent an infinite loop!
        if (target === el)
            return;
        e.stopImmediatePropagation();
        if (target === parent) {
            // if the target is the parent, propagate values downward
            await this.setSelected(current);
        }
        else {
            // the target is a child, and it's complicated...
            await this.setSelectedFromChildEvent(e);
        }
    }
    // These marketDragHandle listeners are for dragging this entire group,
    // which is triggered by dragging the handle of the parent row.
    // We ONLY want to listen for drag handle events on the parent,
    // so we return early if the target is NOT the parent.
    async onDragHandleStart(e) {
        e.stopImmediatePropagation();
        const { el, parent } = this;
        const { target, detail: coords } = e;
        if (parent !== target)
            return;
        const anchor = parent.dragHandlePosition === 'leading' ? 'left' : 'right';
        const drag = new Draggable(el, { anchor });
        this.drag = drag;
        await drag.start(coords);
        parent.classList.add('market-drag-placeholder');
    }
    onDragHandleMove(e) {
        e.stopImmediatePropagation();
        const { parent, drag } = this;
        const { target, detail: coords } = e;
        if (parent !== target)
            return;
        drag.move(coords);
    }
    async onDragHandleDragEnd(e) {
        e.stopImmediatePropagation();
        const { parent, drag } = this;
        const { target, detail: coords } = e;
        if (parent !== target)
            return;
        await drag.end(coords);
        parent.classList.remove('market-drag-placeholder');
        drag.destroy();
    }
    // These marketDrag listeners are for dragging WITHIN this group.
    // If the dragged element is the parent row, we return early.
    onDragMove(e) {
        const { parent, reorder } = this;
        const { el } = e.detail;
        if (parent === el)
            return;
        e.stopImmediatePropagation();
        reorder === null || reorder === void 0 ? void 0 : reorder.dragMove(e);
    }
    onDragLeave(e) {
        const { parent, reorder } = this;
        const { el } = e.detail;
        if (parent === el)
            return;
        e.stopImmediatePropagation();
        reorder === null || reorder === void 0 ? void 0 : reorder.dragLeave();
    }
    onDragEnd(e) {
        const { parent, reorder } = this;
        const { el } = e.detail;
        if (parent === el)
            return;
        reorder === null || reorder === void 0 ? void 0 : reorder.dragEnd(e);
    }
    onDragDrop(e) {
        const { parent, reorder } = this;
        const { el } = e.detail;
        if (parent === el)
            return;
        reorder === null || reorder === void 0 ? void 0 : reorder.dragDrop(e);
    }
    propagateNestedState() {
        const { parent, children, groups, rows, indent, collapsible, collapsed } = this;
        groups.forEach((group) => {
            group.collapsible = collapsible;
        });
        if (collapsible) {
            const hasChildren = children.length > 0;
            if (parent) {
                parent.caret = hasChildren ? (collapsed ? 'down' : 'up') : undefined;
                parent.indent = hasChildren ? indent : indent + 1;
            }
            groups.forEach((group) => {
                group.indent = indent + 1;
                group.collapsible = collapsible;
            });
            rows.forEach((row) => {
                // child rows get extra indentation to account for no caret
                row.indent = indent + 2;
            });
        }
        else {
            if (parent) {
                parent.caret = undefined;
                parent.indent = indent;
            }
            children.forEach((child) => {
                child.indent = indent + 1;
            });
            groups.forEach((group) => {
                group.collapsible = collapsible;
            });
        }
    }
    watchDragEnabled() {
        const { parent, children, dragEnabled } = this;
        if (parent)
            parent.dragEnabled = dragEnabled;
        children === null || children === void 0 ? void 0 : children.forEach((child) => {
            child.dragEnabled = dragEnabled;
        });
    }
    watchReorderable() {
        const { el, reorder, reorderable, reorderMode, marketTableV2RowsReordered } = this;
        reorder === null || reorder === void 0 ? void 0 : reorder.destroy();
        const reorderEnabled = ['internal', 'external'].includes(reorderable);
        if (reorderEnabled) {
            const rowTagName = getNamespacedTagFor('market-table-v2-row');
            const groupTagName = getNamespacedTagFor('market-table-v2-group');
            this.reorder = new Reorderable({
                el,
                accepts: [`${rowTagName}:not([header]):not([footer]):not([slot="parent"])`, groupTagName],
                event: marketTableV2RowsReordered,
                mode: reorderMode,
            });
        }
        this.syncDragEnabled();
    }
    /**
     * @internal
     * Sets selection on the group and propagates the value
     * downwards to its children rows and upwards to any parent groups or tables.
     */
    async setSelected(selected, { silent = false } = {}) {
        const { parent, children, marketInternalTableV2GroupSelectionChange, selected: prevSelected } = this;
        // return if no values have changed
        if (prevSelected === selected)
            return Promise.resolve();
        // fire the internal selection event
        if (!silent) {
            marketInternalTableV2GroupSelectionChange.emit({
                current: selected,
                previous: prevSelected,
            });
        }
        // propagate the new values
        this.selected = selected;
        // this direction is top -> down, so don't fire events to avoid infinite loop
        await (parent === null || parent === void 0 ? void 0 : parent.setSelected(selected, { silent: true }));
        children === null || children === void 0 ? void 0 : children.forEach(async (child) => {
            await child.setSelected(selected, { silent: true });
        });
        return Promise.resolve();
    }
    /**
     * @internal
     * Used internally by Reorderable utils.
     * Sets the group's collapsed state and fires the change event.
     * Normally you should set the `collapsed` prop directly.
     */
    async setCollapsed(collapsed, { silent = false } = {}) {
        const { collapsed: prevCollapsed, collapsible, marketTableV2GroupCollapsedChange } = this;
        if (!collapsible)
            return Promise.resolve();
        if (collapsed === prevCollapsed)
            return Promise.resolve();
        this.collapsed = collapsed;
        if (!silent) {
            const { defaultPrevented } = marketTableV2GroupCollapsedChange.emit({
                previous: prevCollapsed,
                current: collapsed,
            });
            if (defaultPrevented)
                this.collapsed = prevCollapsed;
        }
        return Promise.resolve();
    }
    /**
     * @internal
     * Recursively sorts the group's children rows and groups.
     */
    async sort({ order, column, strategy, format, }) {
        const { el, children, groups } = this;
        // sort the children
        const sortedChildren = sortItems({
            items: children,
            order,
            column,
            strategy,
            format,
        });
        // sort the groups' children
        groups === null || groups === void 0 ? void 0 : groups.forEach((group) => group.sort({
            order,
            column,
            strategy,
            format,
        }));
        // render the sorted rows
        sortedChildren.forEach((row) => {
            el.append(row);
        });
        return Promise.resolve();
    }
    async setSelectedFromChildEvent(e) {
        const { parent, children, marketInternalTableV2GroupSelectionChange, selected: prevSelected } = this;
        const { target, detail } = e;
        const { current: childSelected } = detail;
        // get an array of what the children's selected values would be AFTER this event
        const childrenSelected = children.map((child) => {
            // if the target was THIS child, it will be new event value (not .selected)
            if (target === child)
                return childSelected;
            // otherwise, get the current value directly from this child
            return child.selected;
        });
        // what this group's selected value would be AFTER this event
        const groupSelected = childrenSelected.every((val) => val === 'true')
            ? 'true'
            : childrenSelected.every((val) => val === 'false')
                ? 'false'
                : 'indeterminate';
        // return if no values have changed
        if (prevSelected === groupSelected)
            return;
        // fire the internal selection event
        marketInternalTableV2GroupSelectionChange.emit({
            current: groupSelected,
            previous: prevSelected,
        });
        // propagate the new values
        this.selected = groupSelected;
        await parent.setSelected(groupSelected, { silent: true });
    }
    getElements() {
        this.parent = [...this.el.children].find((child) => {
            return child.tagName === getNamespacedTagFor('market-table-v2-row').toUpperCase() && child.slot === 'parent';
        });
        this.rows = [...this.el.children].filter((child) => {
            return child.tagName === getNamespacedTagFor('market-table-v2-row').toUpperCase() && child.slot !== 'parent';
        });
        this.groups = [...this.el.children].filter((child) => {
            return child.tagName === getNamespacedTagFor('market-table-v2-group').toUpperCase() && child.slot !== 'parent';
        });
        this.children = [...this.groups, ...this.rows];
    }
    getStyles() {
        const { indent } = this;
        return { '--drag-cursor-indent-level': indent.toString() };
    }
    syncDragEnabled() {
        const { parent, rows, groups, reorderable, reorderMode } = this;
        const reorderEnabled = ['internal', 'external'].includes(reorderable);
        if (parent)
            parent.dragEnabled = reorderEnabled;
        rows === null || rows === void 0 ? void 0 : rows.forEach((row) => {
            if (!isDraggable(row))
                return;
            row.dragEnabled = reorderEnabled;
        });
        groups === null || groups === void 0 ? void 0 : groups.forEach((group) => {
            group.dragEnabled = reorderEnabled;
            group.reorderable = reorderable;
            group.reorderMode = reorderMode;
        });
    }
    onSlotChange() {
        this.getElements();
        this.propagateNestedState();
        this.syncDragEnabled();
    }
    connectedCallback() {
        this.getElements();
        this.propagateNestedState();
        this.syncDragEnabled();
    }
    componentDidRender() {
        this.watchReorderable();
    }
    render() {
        return (hAsync(Host, { key: 'dabd9bc7e9c87046618544958c5fea00a375c631', class: "market-table-v2-group", style: this.getStyles() }, hAsync("slot", { key: 'd5893440e44dc0014fd3921e5eb46f8e31a32813', name: "parent", onSlotchange: () => this.onSlotChange() }), hAsync("div", { key: '876dbab692978351ceb9f70358fe82b76d80d174', class: "children" }, hAsync("slot", { key: '11071473d3ca6f7b7619258c2bef6bcd987a4a95', onSlotchange: () => this.onSlotChange() }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "indent": ["propagateNestedState"],
        "collapsed": ["propagateNestedState"],
        "collapsible": ["propagateNestedState"],
        "dragEnabled": ["watchDragEnabled"],
        "reorderable": ["watchReorderable"]
    }; }
    static get style() { return MarketTableV2GroupStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-v2-group",
        "$members$": {
            "collapsible": [516],
            "collapsed": [1540],
            "dragEnabled": [516, "drag-enabled"],
            "indent": [514],
            "reorderable": [513],
            "reorderMode": [1, "reorder-mode"],
            "selected": [1025],
            "setSelected": [64],
            "setCollapsed": [64],
            "sort": [64]
        },
        "$listeners$": [[0, "marketTableV2CellCaretClicked", "onMarketTableV2CellCaretClicked"], [0, "marketInternalTableV2RowSelectionChange", "onMarketTableV2SelectionChange"], [0, "marketInternalTableV2GroupSelectionChange", "onMarketTableV2SelectionChange"], [0, "marketDragHandleDragStart", "onDragHandleStart"], [0, "marketDragHandleDragMove", "onDragHandleMove"], [0, "marketDragHandleDragEnd", "onDragHandleDragEnd"], [0, "marketDragMove", "onDragMove"], [0, "marketDragLeave", "onDragLeave"], [0, "marketDragEnd", "onDragEnd"], [0, "marketDragDrop", "onDragDrop"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["collapsible", "collapsible"], ["collapsed", "collapsed"], ["dragEnabled", "drag-enabled"], ["indent", "indent"], ["reorderable", "reorderable"]]
    }; }
}

const marketTableV2RowCss = "/*!@:host, **/.sc-market-table-v2-row-h,*.sc-market-table-v2-row{box-sizing:border-box}/*!@:host*/.sc-market-table-v2-row-h{--table-cell-border-width:1px;--table-cell-border-color:var(--core-divider-20-color);--table-cell-horizontal-spacing:var(--core-metrics-spacing-150);--table-cell-heading-border-color:var(--core-divider-10-color);--table-cell-heading-font-weight:var(--core-type-medium-weight);--table-cell-state-normal-background-color:var(--core-surface-10-color);display:table-row;vertical-align:inherit;width:100%;outline:none;text-align:inherit}/*!@:host slot*/.sc-market-table-v2-row-h slot.sc-market-table-v2-row{vertical-align:inherit;text-align:inherit}/*!@:host([align=\"left\"])*/[align=\"left\"].sc-market-table-v2-row-h{text-align:left}/*!@:host([align=\"center\"])*/[align=\"center\"].sc-market-table-v2-row-h{text-align:center}/*!@:host([align=\"right\"])*/[align=\"right\"].sc-market-table-v2-row-h{text-align:right}/*!@:host([valign=\"top\"])*/[valign=\"top\"].sc-market-table-v2-row-h{vertical-align:top}/*!@:host([valign=\"middle\"])*/[valign=\"middle\"].sc-market-table-v2-row-h{vertical-align:middle}/*!@:host([valign=\"bottom\"])*/[valign=\"bottom\"].sc-market-table-v2-row-h{vertical-align:bottom}/*!@:host([header]) .market-table-v2-cell, :host([header]) ::slotted(.market-table-v2-cell), :host([footer]) .market-table-v2-cell, :host([footer]) ::slotted(.market-table-v2-cell)*/[header].sc-market-table-v2-row-h .market-table-v2-cell.sc-market-table-v2-row,.sc-market-table-v2-row-h[header].sc-market-table-v2-row-s>.market-table-v2-cell,.sc-market-table-v2-row-h[header] .sc-market-table-v2-row-s>.market-table-v2-cell,[footer].sc-market-table-v2-row-h .market-table-v2-cell.sc-market-table-v2-row,.sc-market-table-v2-row-h[footer].sc-market-table-v2-row-s>.market-table-v2-cell,.sc-market-table-v2-row-h[footer] .sc-market-table-v2-row-s>.market-table-v2-cell{font-weight:var(--table-cell-heading-font-weight)}/*!@:host([header]) .market-drag-handle, :host([footer]) .market-drag-handle*/[header].sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row,[footer].sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row{visibility:hidden}/*!@:host([header]) .market-table-v2-cell, :host([header]) ::slotted(.market-table-v2-cell), :host([sticky=\"top\"]) .market-table-v2-cell, :host([sticky=\"top\"]) ::slotted(.market-table-v2-cell)*/[header].sc-market-table-v2-row-h .market-table-v2-cell.sc-market-table-v2-row,.sc-market-table-v2-row-h[header].sc-market-table-v2-row-s>.market-table-v2-cell,.sc-market-table-v2-row-h[header] .sc-market-table-v2-row-s>.market-table-v2-cell,[sticky=\"top\"].sc-market-table-v2-row-h .market-table-v2-cell.sc-market-table-v2-row,.sc-market-table-v2-row-h[sticky=\"top\"].sc-market-table-v2-row-s>.market-table-v2-cell,.sc-market-table-v2-row-h[sticky=\"top\"] .sc-market-table-v2-row-s>.market-table-v2-cell{border-bottom:var(--table-cell-border-width) solid var(--table-cell-heading-border-color)}/*!@:host([footer]) .market-table-v2-cell, :host([footer]) ::slotted(.market-table-v2-cell), :host([sticky=\"bottom\"]) .market-table-v2-cell, :host([sticky=\"bottom\"]) ::slotted(.market-table-v2-cell)*/[footer].sc-market-table-v2-row-h .market-table-v2-cell.sc-market-table-v2-row,.sc-market-table-v2-row-h[footer].sc-market-table-v2-row-s>.market-table-v2-cell,.sc-market-table-v2-row-h[footer] .sc-market-table-v2-row-s>.market-table-v2-cell,[sticky=\"bottom\"].sc-market-table-v2-row-h .market-table-v2-cell.sc-market-table-v2-row,.sc-market-table-v2-row-h[sticky=\"bottom\"].sc-market-table-v2-row-s>.market-table-v2-cell,.sc-market-table-v2-row-h[sticky=\"bottom\"] .sc-market-table-v2-row-s>.market-table-v2-cell{border-top:var(--table-cell-border-width) solid var(--table-cell-heading-border-color);border-bottom:none}/*!@:host([sticky])*/[sticky].sc-market-table-v2-row-h{position:sticky;z-index:3;background-color:var(--table-cell-state-normal-background-color)}/*!@:host([sticky=\"top\"])*/[sticky=\"top\"].sc-market-table-v2-row-h{top:0}/*!@:host([sticky=\"bottom\"])*/[sticky=\"bottom\"].sc-market-table-v2-row-h{bottom:0}/*!@:host([interactive])*/[interactive].sc-market-table-v2-row-h{cursor:pointer}@media (hover: hover){/*!@:host([interactive]:hover)*/[interactive].sc-market-table-v2-row-h:hover{background-color:var(--table-cell-hover-state-background-color)}}/*!@:host([interactive]:focus)*/[interactive].sc-market-table-v2-row-h:focus{background-color:var(--table-cell-focus-state-background-color)}/*!@:host([active]), :host([interactive]:active)*/[active].sc-market-table-v2-row-h,[interactive].sc-market-table-v2-row-h:active{background-color:var(--table-cell-pressed-state-background-color)}/*!@:host([disabled])*/[disabled].sc-market-table-v2-row-h{color:var(--table-cell-disabled-state-text-color);pointer-events:none}/*!@.drag-handle-cell*/.drag-handle-cell.sc-market-table-v2-row{width:var(--core-metrics-spacing-500)}@media (hover: hover){/*!@:host([drag-handle-visibility=\"hover\"]) .market-drag-handle*/[drag-handle-visibility=\"hover\"].sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row{opacity:0%}/*!@:host([drag-handle-visibility=\"hover\"]:hover) .market-drag-handle*/[drag-handle-visibility=\"hover\"].sc-market-table-v2-row-h:hover .market-drag-handle.sc-market-table-v2-row{opacity:100%}}/*!@:host(.market-drag-placeholder), :host(.market-drag-placeholder[interactive])*/.market-drag-placeholder.sc-market-table-v2-row-h,.market-drag-placeholder[interactive].sc-market-table-v2-row-h{background-color:var(--core-fill-50-color)}/*!@:host(.market-drag-placeholder) *, :host(.market-drag-placeholder) ::slotted(*), :host(.market-drag-placeholder[interactive]) *, :host(.market-drag-placeholder[interactive]) ::slotted(*)*/.market-drag-placeholder.sc-market-table-v2-row-h *.sc-market-table-v2-row,.sc-market-table-v2-row-h.market-drag-placeholder.sc-market-table-v2-row-s>*,.sc-market-table-v2-row-h.market-drag-placeholder .sc-market-table-v2-row-s>*,.market-drag-placeholder[interactive].sc-market-table-v2-row-h *.sc-market-table-v2-row,.sc-market-table-v2-row-h.market-drag-placeholder[interactive].sc-market-table-v2-row-s>*,.sc-market-table-v2-row-h.market-drag-placeholder[interactive] .sc-market-table-v2-row-s>*{opacity:0%}/*!@:host(.market-drag-placeholder) .market-drag-handle, :host(.market-drag-placeholder[interactive]) .market-drag-handle*/.market-drag-placeholder.sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row,.market-drag-placeholder[interactive].sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row{pointer-events:none}/*!@:host(.market-drag-clone), :host(.market-drag-clone[interactive])*/.market-drag-clone.sc-market-table-v2-row-h,.market-drag-clone[interactive].sc-market-table-v2-row-h{--table-row-dragged-width:240px;display:flex;justify-content:space-between;align-items:center;width:var(--table-row-dragged-width);border-bottom:var(--table-cell-border-width) solid var(--table-cell-border-color);border-radius:var(--core-radius-10);background-color:var(--core-surface-20-color);cursor:grabbing;transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:top, width, height}/*!@:host(.market-drag-clone)::after, :host(.market-drag-clone[interactive])::after*/.market-drag-clone.sc-market-table-v2-row-h::after,.market-drag-clone[interactive].sc-market-table-v2-row-h::after{content:\"\";position:absolute;inset:0;display:block;border-radius:var(--core-radius-10);box-shadow:var(--elevation-20-shadow);opacity:var(--market-drag-clone-shadow-opacity, 0%);transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:opacity}/*!@:host(.market-drag-clone) .market-drag-handle, :host(.market-drag-clone[interactive]) .market-drag-handle*/.market-drag-clone.sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row,.market-drag-clone[interactive].sc-market-table-v2-row-h .market-drag-handle.sc-market-table-v2-row{cursor:grabbing}/*!@:host(.market-drag-clone) ::slotted(.market-table-v2-cell:first-child), :host(.market-drag-clone[interactive]) ::slotted(.market-table-v2-cell:first-child)*/.sc-market-table-v2-row-h.market-drag-clone .sc-market-table-v2-row-s>.market-table-v2-cell:first-child,.sc-market-table-v2-row-h.market-drag-clone[interactive].sc-market-table-v2-row-s>.market-table-v2-cell:first-child,.sc-market-table-v2-row-h.market-drag-clone[interactive] .sc-market-table-v2-row-s>.market-table-v2-cell:first-child{overflow:hidden;width:100%;border:none;text-overflow:ellipsis;white-space:nowrap;transition-timing-function:var(--core-animation-move-transition-easing);transition-duration:var(--core-animation-move-transition-moderate-speed-duration);transition-property:padding-left}/*!@:host(.market-drag-clone) ::slotted(.market-table-v2-cell:not(:first-child)), :host(.market-drag-clone[interactive]) ::slotted(.market-table-v2-cell:not(:first-child))*/.sc-market-table-v2-row-h.market-drag-clone .sc-market-table-v2-row-s>.market-table-v2-cell:not(:first-child),.sc-market-table-v2-row-h.market-drag-clone[interactive].sc-market-table-v2-row-s>.market-table-v2-cell:not(:first-child),.sc-market-table-v2-row-h.market-drag-clone[interactive] .sc-market-table-v2-row-s>.market-table-v2-cell:not(:first-child){display:none}/*!@:host(.market-drag-clone) .drag-handle-cell, :host(.market-drag-clone[interactive]) .drag-handle-cell*/.market-drag-clone.sc-market-table-v2-row-h .drag-handle-cell.sc-market-table-v2-row,.market-drag-clone[interactive].sc-market-table-v2-row-h .drag-handle-cell.sc-market-table-v2-row{border:none}/*!@:host(.market-drag-clone[drag-handle-position=\"leading\"])*/.market-drag-clone[drag-handle-position=\"leading\"].sc-market-table-v2-row-h{justify-content:flex-start}/*!@:host(.market-drag-released)*/.market-drag-released.sc-market-table-v2-row-h{pointer-events:none;transition-property:opacity, width, height, transform, scale}/*!@:host(.market-drag-into-collapsed-group)*/.market-drag-into-collapsed-group.sc-market-table-v2-row-h{opacity:0%;scale:0}";
var MarketTableV2RowStyle0 = marketTableV2RowCss;

/**
 * @slot - Default slot for table cells.
 * @part drag-handle - the drag handle when `dragEnabled` is true.
 */
class MarketTableV2Row {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketInternalTableV2RowSelectionChange = createEvent(this, "marketInternalTableV2RowSelectionChange", 7);
        this.marketTableV2RowSelectionChange = createEvent(this, "marketTableV2RowSelectionChange", 7);
        this.active = false;
        this.align = undefined;
        this.caret = undefined;
        this.disabled = false;
        this.dragEnabled = false;
        this.dragHandleVisibility = undefined;
        this.dragHandlePosition = undefined;
        this.footer = false;
        this.header = false;
        this.indent = undefined;
        this.interactive = false;
        this.selected = 'false';
        this.sticky = undefined;
        this.valign = undefined;
    }
    onKeydown(e) {
        const { target, key } = e;
        const { el, disabled, interactive } = this;
        if (disabled)
            return;
        if (!interactive)
            return;
        if (target !== el)
            return;
        if (key === 'Enter' || key === ' ') {
            e.preventDefault();
            el.click();
        }
    }
    async onMarketInternalTableV2CellSelectionChange(e) {
        const { detail, target } = e;
        const { current } = detail;
        const { firstCell } = this;
        if (target !== firstCell)
            return;
        e.stopPropagation();
        await this.setSelected(current);
    }
    async onDragStart(e) {
        const { el, dragHandlePosition } = this;
        if (el.slot === 'parent')
            return;
        e.stopPropagation();
        const coords = e.detail;
        const anchor = dragHandlePosition === 'leading' ? 'left' : 'right';
        const drag = new Draggable(el, { anchor });
        this.drag = drag;
        await drag.start(coords);
    }
    onDragMove(e) {
        if (this.el.slot === 'parent')
            return;
        e.stopPropagation();
        const coords = e.detail;
        this.drag.move(coords);
    }
    async onDragEnd(e) {
        if (this.el.slot === 'parent')
            return;
        e.stopPropagation();
        const coords = e.detail;
        await this.drag.end(coords);
        this.drag.destroy();
    }
    watchCaret() {
        const { firstCell, caret } = this;
        if (firstCell)
            firstCell.caret = caret;
    }
    watchIndent() {
        const { firstCell, indent } = this;
        if (firstCell)
            firstCell.indent = indent;
    }
    /**
     * Sets selection on the row and propagates the value
     * downwards to the slotted control in its first cell
     * and upwards to any parent groups or tables.
     */
    async setSelected(selected, { silent = false } = {}) {
        const { firstCell, selected: prevSelected, marketTableV2RowSelectionChange, marketInternalTableV2RowSelectionChange, } = this;
        // return if no values have changed
        if (prevSelected === selected)
            return Promise.resolve();
        // always fire the external selection event
        const { defaultPrevented } = marketTableV2RowSelectionChange.emit({
            current: selected,
            previous: prevSelected,
        });
        // if default was prevented, reset the cell & control
        if (defaultPrevented) {
            await (firstCell === null || firstCell === void 0 ? void 0 : firstCell.setSelected(prevSelected, { silent: true }));
            return Promise.resolve();
        }
        // fire the internal selection event
        if (!silent) {
            marketInternalTableV2RowSelectionChange.emit({
                current: selected,
                previous: prevSelected,
            });
        }
        // save the state
        this.selected = selected;
        await (firstCell === null || firstCell === void 0 ? void 0 : firstCell.setSelected(selected, { silent }));
        return Promise.resolve();
    }
    getTabIndex() {
        const { disabled, interactive } = this;
        return interactive && !disabled ? '0' : null;
    }
    async initFirstCell() {
        const { el, selected } = this;
        const MarketTableV2CellTagName = getNamespacedTagFor('market-table-v2-cell');
        const firstCell = el.querySelector(`${MarketTableV2CellTagName}`);
        if (firstCell) {
            this.firstCell = firstCell;
            if (selected)
                await (firstCell === null || firstCell === void 0 ? void 0 : firstCell.setSelected(selected));
        }
        this.watchCaret();
        this.watchIndent();
    }
    async connectedCallBack() {
        await this.initFirstCell();
    }
    renderDragHandleCell() {
        const MarketDragHandleTagName = getNamespacedTagFor('market-drag-handle');
        const MarketTableV2CellTagName = getNamespacedTagFor('market-table-v2-cell');
        return (hAsync(MarketTableV2CellTagName, { class: "drag-handle-cell" }, hAsync(MarketDragHandleTagName, { part: "drag-handle" })));
    }
    render() {
        const { dragEnabled, dragHandlePosition } = this;
        return (hAsync(Host, { key: '6adae61ab707d2a6d4a73dd244855cf75d91ddb9', role: "row", class: "market-table-v2-row", tabindex: this.getTabIndex(), onMarketDragHandleDragStart: (e) => this.onDragStart(e), onMarketDragHandleDragMove: (e) => this.onDragMove(e), onMarketDragHandleDragEnd: (e) => this.onDragEnd(e) }, dragEnabled && dragHandlePosition === 'leading' && this.renderDragHandleCell(), hAsync("slot", { key: '734bcabee33118c8368a332e8de4287099f1d1fa', onSlotchange: () => this.initFirstCell() }), dragEnabled && dragHandlePosition !== 'leading' && this.renderDragHandleCell()));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "caret": ["watchCaret"],
        "indent": ["watchIndent"]
    }; }
    static get style() { return MarketTableV2RowStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-table-v2-row",
        "$members$": {
            "active": [516],
            "align": [513],
            "caret": [513],
            "disabled": [516],
            "dragEnabled": [516, "drag-enabled"],
            "dragHandleVisibility": [513, "drag-handle-visibility"],
            "dragHandlePosition": [513, "drag-handle-position"],
            "footer": [516],
            "header": [516],
            "indent": [514],
            "interactive": [516],
            "selected": [1025],
            "sticky": [513],
            "valign": [513],
            "setSelected": [64]
        },
        "$listeners$": [[0, "keydown", "onKeydown"], [0, "marketInternalTableV2CellSelectionChange", "onMarketInternalTableV2CellSelectionChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["align", "align"], ["caret", "caret"], ["disabled", "disabled"], ["dragEnabled", "drag-enabled"], ["dragHandleVisibility", "drag-handle-visibility"], ["dragHandlePosition", "drag-handle-position"], ["footer", "footer"], ["header", "header"], ["indent", "indent"], ["interactive", "interactive"], ["sticky", "sticky"], ["valign", "valign"]]
    }; }
}

const marketTabsCss = "/*!@:host*/.sc-market-tabs-h{display:block}";
var MarketTabsStyle0 = marketTabsCss;

class MarketTabs {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.selectedTab = undefined;
        this.defaultTab = undefined;
    }
    marketTabSelectedChangedEventHandler(e) {
        e.stopPropagation();
        const { panelId, tabId, value } = e.detail;
        if (!value) {
            return;
        }
        else if (this.selectedTab !== tabId) {
            this.selectedTab = tabId;
        }
        this.showPanelWithId(panelId);
    }
    tabWatcher(newTabId) {
        this.setTab(newTabId);
    }
    setTab(tabId) {
        if (this.tabListEl) {
            this.tabListEl.selectedTab = tabId;
        }
    }
    showPanelWithId(panelId) {
        var _a;
        (_a = this.panelEls) === null || _a === void 0 ? void 0 : _a.forEach((panelEl) => {
            panelEl.hidden = panelEl.id !== panelId;
        });
    }
    handleSlotChange() {
        /**
         * `market-tab-panel`s aren't hidden by default,
         * but once they become a descendant of `<market-tabs>`, they will be hidden by default.
         * Later on, one will be shown depending on which tab gets selected by default.
         */
        this.panelEls = [...this.el.querySelectorAll(getNamespacedTagFor('market-tab-panel'))].map((panelEl) => {
            panelEl.hidden = true;
            return panelEl;
        });
        this.tabListEl = this.el.querySelector(getNamespacedTagFor('market-tab-list'));
    }
    componentWillLoad() {
        var _a;
        this.handleSlotChange();
        this.setTab((_a = this.selectedTab) !== null && _a !== void 0 ? _a : this.defaultTab);
    }
    render() {
        return (hAsync(Host, { key: '7c5ad53149c7116722902b21b7c678e83a4f98ce', class: "market-tabs" }, hAsync("slot", { key: 'bdfd6785cd3debc36c36b7ac05b167e684b49874', onSlotchange: () => this.handleSlotChange() })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectedTab": ["tabWatcher"]
    }; }
    static get style() { return MarketTabsStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tabs",
        "$members$": {
            "selectedTab": [1537, "selected-tab"],
            "defaultTab": [1, "default-tab"]
        },
        "$listeners$": [[0, "marketTabSelectedChanged", "marketTabSelectedChangedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selectedTab", "selected-tab"]]
    }; }
}

const marketTagCss = "/*!@:host, ::slotted(*), **/.sc-market-tag-h,.sc-market-tag-s>*,*.sc-market-tag{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-tag-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-tag-h *.sc-market-tag,.sc-market-tag-h[disabled].sc-market-tag-s>*,.sc-market-tag-h[disabled] .sc-market-tag-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-tag-h{--tag-small-size-minimum-height:var(--core-metrics-spacing-400);--tag-small-size-horizontal-spacing:var(--core-metrics-spacing-50);--tag-small-size-text-weight:var(--core-type-paragraph-10-weight);--tag-small-size-text-size:var(--core-type-paragraph-10-size);--tag-small-size-text-leading:var(--core-type-paragraph-10-leading);--tag-small-size-text-tracking:var(--core-type-paragraph-10-tracking);--tag-small-size-text-case:var(--core-type-paragraph-10-case);--tag-small-size-basic-format-top-padding:7px;--tag-small-size-basic-format-right-padding:8px;--tag-small-size-basic-format-bottom-padding:7px;--tag-small-size-basic-format-left-padding:12px;--tag-small-size-with-icon-format-top-padding:7px;--tag-small-size-with-icon-format-right-padding:8px;--tag-small-size-with-icon-format-bottom-padding:7px;--tag-small-size-with-icon-format-left-padding:8px;--tag-medium-size-minimum-height:var(--core-metrics-spacing-500);--tag-medium-size-horizontal-spacing:var(--core-metrics-spacing-50);--tag-medium-size-text-weight:var(--core-type-paragraph-20-weight);--tag-medium-size-text-size:var(--core-type-paragraph-20-size);--tag-medium-size-text-leading:var(--core-type-paragraph-20-leading);--tag-medium-size-text-tracking:var(--core-type-paragraph-20-tracking);--tag-medium-size-text-case:var(--core-type-paragraph-20-case);--tag-medium-size-basic-format-top-padding:9px;--tag-medium-size-basic-format-right-padding:8px;--tag-medium-size-basic-format-bottom-padding:9px;--tag-medium-size-basic-format-left-padding:12px;--tag-medium-size-with-icon-format-top-padding:9px;--tag-medium-size-with-icon-format-right-padding:8px;--tag-medium-size-with-icon-format-bottom-padding:9px;--tag-medium-size-with-icon-format-left-padding:8px;display:inline-flex;align-items:center;background-color:var(--tag-normal-state-background-color);color:var(--tag-normal-state-label-color);cursor:pointer}/*!@:host .icon*/.sc-market-tag-h .icon.sc-market-tag{display:none}/*!@:host(.has-icon) .icon*/.has-icon.sc-market-tag-h .icon.sc-market-tag{display:inline-block}/*!@:host([size=\"small\"])*/[size=\"small\"].sc-market-tag-h{gap:var(--tag-small-size-horizontal-spacing);min-height:var(--tag-small-size-minimum-height);padding:var(--tag-small-size-basic-format-top-padding)\n      var(--tag-small-size-basic-format-right-padding)\n      var(--tag-small-size-basic-format-bottom-padding)\n      var(--tag-small-size-basic-format-left-padding);border-radius:calc(var(--tag-small-size-minimum-height) / 2);font-weight:var(--tag-small-size-text-weight);font-size:var(--tag-small-size-text-size);line-height:var(--tag-small-size-text-leading);letter-spacing:var(--tag-small-size-text-tracking);text-transform:var(--tag-small-size-text-case)}/*!@:host([size=\"small\"],.has-icon)*/[size=\"small\"].sc-market-tag-h,.has-icon.sc-market-tag-h{padding:var(--tag-small-size-with-icon-format-top-padding)\n        var(--tag-small-size-with-icon-format-right-padding)\n        var(--tag-small-size-with-icon-format-bottom-padding)\n        var(--tag-small-size-with-icon-format-left-padding)}/*!@:host([size=\"medium\"])*/[size=\"medium\"].sc-market-tag-h{gap:var(--tag-medium-size-horizontal-spacing);min-height:var(--tag-medium-size-minimum-height);padding:var(--tag-medium-size-basic-format-top-padding)\n      var(--tag-medium-size-basic-format-right-padding)\n      var(--tag-medium-size-basic-format-bottom-padding)\n      var(--tag-medium-size-basic-format-left-padding);border-radius:calc(var(--tag-medium-size-minimum-height) / 2);font-weight:var(--tag-medium-size-text-weight);font-size:var(--tag-medium-size-text-size);line-height:var(--tag-medium-size-text-leading);letter-spacing:var(--tag-medium-size-text-tracking);text-transform:var(--tag-medium-size-text-case)}/*!@:host([size=\"medium\"],.has-icon)*/[size=\"medium\"].sc-market-tag-h,.has-icon.sc-market-tag-h{padding:var(--tag-medium-size-with-icon-format-top-padding)\n        var(--tag-medium-size-with-icon-format-right-padding)\n        var(--tag-medium-size-with-icon-format-bottom-padding)\n        var(--tag-medium-size-with-icon-format-left-padding)}/*!@svg.remove-indicator, ::slotted([slot=\"icon\"])*/svg.remove-indicator.sc-market-tag,.sc-market-tag-s>[slot=\"icon\"]{flex-shrink:0}/*!@::slotted([slot=\"icon\"])*/.sc-market-tag-s>[slot=\"icon\"]{fill:var(--tag-normal-state-icon-color)}/*!@svg.remove-indicator*/svg.remove-indicator.sc-market-tag{fill:var(--tag-normal-state-remove-indicator-color)}@media (hover: hover){/*!@:host(:hover)*/.sc-market-tag-h:hover{background-color:var(--tag-hover-state-background-color);color:var(--tag-hover-state-label-color)}/*!@:host(:hover) ::slotted([slot=\"icon\"])*/.sc-market-tag-h:hover .sc-market-tag-s>[slot=\"icon\"]{fill:var(--tag-hover-state-icon-color)}/*!@:host(:hover) svg.remove-indicator*/.sc-market-tag-h:hover svg.remove-indicator.sc-market-tag{fill:var(--tag-hover-state-remove-indicator-color)}}/*!@:host(:active)*/.sc-market-tag-h:active{background-color:var(--tag-pressed-state-background-color);color:var(--tag-pressed-state-label-color)}/*!@:host(:active) ::slotted([slot=\"icon\"])*/.sc-market-tag-h:active .sc-market-tag-s>[slot=\"icon\"]{fill:var(--tag-pressed-state-icon-color)}/*!@:host(:active) svg.remove-indicator*/.sc-market-tag-h:active svg.remove-indicator.sc-market-tag{fill:var(--tag-pressed-state-remove-indicator-color)}/*!@:host(:focus), :host([focused])*/.sc-market-tag-h:focus,[focused].sc-market-tag-h{background-color:var(--tag-focus-state-background-color);color:var(--tag-focus-state-label-color)}/*!@:host(:focus) ::slotted([slot=\"icon\"]), :host([focused]) ::slotted([slot=\"icon\"])*/.sc-market-tag-h:focus .sc-market-tag-s>[slot=\"icon\"],.sc-market-tag-h[focused].sc-market-tag-s>[slot=\"icon\"],.sc-market-tag-h[focused] .sc-market-tag-s>[slot=\"icon\"]{fill:var(--tag-focus-state-icon-color)}/*!@:host(:focus) svg.remove-indicator, :host([focused]) svg.remove-indicator*/.sc-market-tag-h:focus svg.remove-indicator.sc-market-tag,[focused].sc-market-tag-h svg.remove-indicator.sc-market-tag{fill:var(--tag-focus-state-remove-indicator-color)}/*!@:host([disabled])*/[disabled].sc-market-tag-h{background-color:var(--tag-disabled-state-background-color);color:var(--tag-disabled-state-label-color)}/*!@:host([disabled]) ::slotted([slot=\"icon\"])*/.sc-market-tag-h[disabled] .sc-market-tag-s>[slot=\"icon\"]{fill:var(--tag-disabled-state-icon-color)}/*!@:host([disabled]) svg.remove-indicator*/[disabled].sc-market-tag-h svg.remove-indicator.sc-market-tag{fill:var(--tag-disabled-state-remove-indicator-color)}";
var MarketTagStyle0 = marketTagCss;

/**
 * @slot - The text used for the tag label
 * @slot icon - an icon that is to the left of tag text
 */
class MarketTag {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTagDismissed = createEvent(this, "marketTagDismissed", 7);
        this.disabled = false;
        this.focused = false;
        this.size = 'small';
        this.hasIcon = false;
    }
    /* handles click and unclick in tag */
    onFocus() {
        if (this.disabled) {
            return;
        }
        if (!this.focused) {
            this.focused = true;
        }
        else {
            this.focused = false;
        }
    }
    handleDismissTagEvent(e) {
        this.marketTagDismissed.emit();
        e.stopPropagation();
        this.el.remove();
    }
    componentWillLoad() {
        this.hasIcon = Boolean(this.el.querySelector('[slot="icon"]'));
    }
    render() {
        return (hAsync(Host, { key: '9588fafee1306f4e8fd89988093e4fb13afe38a5', class: `market-tag ${this.hasIcon ? 'has-icon' : ''}`, onClick: () => {
                this.onFocus();
            }, onFocus: () => {
                this.onFocus();
            }, "aria-disabled": this.disabled }, hAsync("span", { key: '1499efc8496c40be712260fdcd91d23715aec3ab', class: "icon" }, hAsync("slot", { key: 'e96de4aeb44f76d18c76daad4e847a6df4a60b2c', name: "icon" })), hAsync("slot", { key: '037db2c8139ae0286ad1aded9f7ac7b35855c21d' }), hAsync("svg", { key: '49798505faaf489b65a409e3caaf213480555eba', class: "remove-indicator", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", onClick: (e) => this.handleDismissTagEvent(e) }, hAsync("path", { key: '1b0443049e52349ed740a3afba862645f38a7745', d: "M4.4734 12.4734L8.00007 8.94002L11.5267 12.4734L12.4734 11.5267L8.94007 8.00002L12.4734 4.47335L11.5267 3.52669L8.00007 7.06002L4.4734 3.52669L3.52673 4.47335L7.06007 8.00002L3.52673 11.5267L4.4734 12.4734Z" }))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketTagStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tag",
        "$members$": {
            "disabled": [516],
            "focused": [1540],
            "size": [513],
            "hasIcon": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["focused", "focused"], ["size", "size"]]
    }; }
}

const marketTextareaCss = "/*!@:host, ::slotted(*), **/.sc-market-textarea-h,.sc-market-textarea-s>*,*.sc-market-textarea{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-textarea-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-textarea-h *.sc-market-textarea,.sc-market-textarea-h[disabled].sc-market-textarea-s>*,.sc-market-textarea-h[disabled] .sc-market-textarea-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-textarea-h{position:relative;outline:none;font-weight:var(--field-input-weight);font-size:var(--field-input-size);line-height:var(--field-input-leading);cursor:text}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-textarea-h input.sc-market-textarea,.sc-market-textarea-h.sc-market-textarea-s>input,.sc-market-textarea-h .sc-market-textarea-s>input,.sc-market-textarea-h textarea.sc-market-textarea,.sc-market-textarea-h.sc-market-textarea-s>textarea,.sc-market-textarea-h .sc-market-textarea-s>textarea{width:100%;margin:0;padding:0;border:none;background-color:transparent;color:inherit;font-weight:inherit;font-size:inherit;font-family:inherit;line-height:inherit;letter-spacing:inherit;cursor:inherit}/*!@:host ::slotted(label)*/.sc-market-textarea-h .sc-market-textarea-s>label{cursor:inherit}/*!@:host input:focus, :host ::slotted(input:focus), :host textarea:focus, :host ::slotted(textarea:focus)*/.sc-market-textarea-h input.sc-market-textarea:focus,.sc-market-textarea-h.sc-market-textarea-s>input,.sc-market-textarea-h.sc-market-textarea-s>input:focus,.sc-market-textarea-h .sc-market-textarea-s>input:focus,.sc-market-textarea-h textarea.sc-market-textarea:focus,.sc-market-textarea-h.sc-market-textarea-s>textarea,.sc-market-textarea-h.sc-market-textarea-s>textarea:focus,.sc-market-textarea-h .sc-market-textarea-s>textarea:focus{outline:none}/*!@:host input::-moz-placeholder, :host textarea::-moz-placeholder*/.sc-market-textarea-h input.sc-market-textarea::-moz-placeholder,.sc-market-textarea-h textarea.sc-market-textarea::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host input::placeholder, :host textarea::placeholder*/.sc-market-textarea-h input.sc-market-textarea::placeholder,.sc-market-textarea-h textarea.sc-market-textarea::placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::-moz-placeholder, :host ::slotted(textarea)::-moz-placeholder*/.sc-market-textarea-h.sc-market-textarea-s>input,.sc-market-textarea-h .sc-market-textarea-s>input::-moz-placeholder,.sc-market-textarea-h.sc-market-textarea-s>textarea,.sc-market-textarea-h.sc-market-textarea-s>textarea::-moz-placeholder,.sc-market-textarea-h .sc-market-textarea-s>textarea::-moz-placeholder{color:var(--field-placeholder-text-color)}/*!@:host ::slotted(input)::placeholder, :host ::slotted(textarea)::placeholder*/.sc-market-textarea-h.sc-market-textarea-s>input,.sc-market-textarea-h .sc-market-textarea-s>input::placeholder,.sc-market-textarea-h.sc-market-textarea-s>textarea,.sc-market-textarea-h.sc-market-textarea-s>textarea::placeholder,.sc-market-textarea-h .sc-market-textarea-s>textarea::placeholder{color:var(--field-placeholder-text-color)}/*!@:host([size='small'])*/[size='small'].sc-market-textarea-h{font-size:var(--core-type-paragraph-20-size);line-height:var(--core-type-paragraph-20-leading)}/*!@:host*/.sc-market-textarea-h{border-radius:var(--field-border-radius);background-color:var(--field-normal-state-background-color);color:var(--field-normal-state-input-color)}/*!@:host::after*/.sc-market-textarea-h::after{content:\"\";position:absolute;inset:0;border-radius:var(--field-border-radius);box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color);pointer-events:none}/*!@:host([invalid])::after*/[invalid].sc-market-textarea-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-invalid-validity-border-color)}/*!@:host(:hover)*/.sc-market-textarea-h:hover{background-color:var(--field-hover-state-background-color);color:var(--field-hover-state-input-color)}/*!@:host(:hover)::after*/.sc-market-textarea-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-normal-validity-border-color)}/*!@:host([invalid]:hover)::after*/[invalid].sc-market-textarea-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-hover-state-invalid-validity-border-color)}/*!@:host([focused])*/[focused].sc-market-textarea-h{color:var(--field-focus-state-input-color)}/*!@:host([focused])::after*/[focused].sc-market-textarea-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size)\n        var(--field-focus-state-normal-validity-border-color)}/*!@:host([focused][invalid])::after*/[focused][invalid].sc-market-textarea-h::after{box-shadow:inset 0 0 0 var(--field-focus-state-border-size) var(--field-focus-state-invalid-validity-border-color)}/*!@:host([readonly]:hover)::after*/[readonly].sc-market-textarea-h:hover::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-normal-state-normal-validity-border-color)}/*!@:host([disabled])*/[disabled].sc-market-textarea-h{background-color:var(--field-disabled-state-background-color) !important;color:var(--field-disabled-state-input-color) !important;cursor:not-allowed !important}/*!@:host([disabled])::after*/[disabled].sc-market-textarea-h::after{box-shadow:inset 0 0 0 var(--field-border-size) var(--field-disabled-state-border-color) !important}/*!@:host([disabled]) ::slotted(.market-accessory), :host([disabled]) ::slotted(img[slot*=\"accessory\"]), :host([disabled]) ::slotted(svg[slot*=\"accessory\"]), :host([disabled]) ::slotted(div[slot*=\"accessory\"])*/.sc-market-textarea-h[disabled] .sc-market-textarea-s>.market-accessory,.sc-market-textarea-h[disabled].sc-market-textarea-s>img[slot*=\"accessory\"],.sc-market-textarea-h[disabled] .sc-market-textarea-s>img[slot*=\"accessory\"],.sc-market-textarea-h[disabled].sc-market-textarea-s>svg[slot*=\"accessory\"],.sc-market-textarea-h[disabled] .sc-market-textarea-s>svg[slot*=\"accessory\"],.sc-market-textarea-h[disabled].sc-market-textarea-s>div[slot*=\"accessory\"],.sc-market-textarea-h[disabled] .sc-market-textarea-s>div[slot*=\"accessory\"]{--field-disabled-state-accessory-opacity:var(--row-disabled-state-leading-accessory-opacity);opacity:var(--field-disabled-state-accessory-opacity)}/*!@:host([value=\"\"]) ::slotted(label)*/.sc-market-textarea-h[value=\"\"] .sc-market-textarea-s>label{color:var(--field-normal-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"][autofilled]) ::slotted(label)*/.sc-market-textarea-h:not([value=\"\"]) .sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"][autofilled].sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"][autofilled] .sc-market-textarea-s>label{color:var(--field-normal-state-float-phase-label-color)}/*!@:host(:hover) ::slotted(label)*/.sc-market-textarea-h:hover .sc-market-textarea-s>label{color:var(--field-hover-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"]):hover) ::slotted(label), :host([value=\"\"][autofilled]:hover) ::slotted(label)*/.sc-market-textarea-h:not([value=\"\"]):hover .sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"][autofilled]:hover.sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"][autofilled]:hover .sc-market-textarea-s>label{color:var(--field-hover-state-float-phase-label-color)}/*!@:host([focused]) ::slotted(label)*/.sc-market-textarea-h[focused].sc-market-textarea-s>label,.sc-market-textarea-h[focused] .sc-market-textarea-s>label{color:var(--field-focus-state-float-phase-label-color)}/*!@:host([value=\"\"][disabled]) ::slotted(label)*/.sc-market-textarea-h[value=\"\"][disabled] .sc-market-textarea-s>label{color:var(--field-disabled-state-empty-phase-label-color)}/*!@:host(:not([value=\"\"])[disabled]) ::slotted(label), :host([value=\"\"][autofilled][disabled]) ::slotted(label)*/.sc-market-textarea-h:not([value=\"\"])[disabled] .sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"][autofilled][disabled].sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"][autofilled][disabled] .sc-market-textarea-s>label{color:var(--field-disabled-state-float-phase-label-color)}/*!@:host*/.sc-market-textarea-h{--field-input-animation-speed:0.2s;--field-input-label-translate:12px;--field-empty-phase-label-text-size-unitless:16;--field-float-phase-label-text-size-unitless:14;--field-size-medium-float-phase-vertical-padding-size:12px;--field-size-medium-float-phase-horizontal-padding-size:16px;--field-size-small-float-phase-vertical-padding-size:9px;--field-size-small-float-phase-horizontal-padding-size:12px;display:flex;align-items:center}/*!@:host .label-input-container, :host([value='']:not([focused]):not([autofilled])) .label-input-container*/.sc-market-textarea-h .label-input-container.sc-market-textarea,[value=''].sc-market-textarea-h:not([focused]):not([autofilled]) .label-input-container.sc-market-textarea{flex-grow:1;padding:var(--field-float-phase-vertical-padding-size) var(--field-float-phase-horizontal-padding-size)}/*!@:host([size='medium']) .label-input-container, :host([size='medium'][value='']:not([focused]):not([autofilled])) .label-input-container*/[size='medium'].sc-market-textarea-h .label-input-container.sc-market-textarea,[size='medium'][value=''].sc-market-textarea-h:not([focused]):not([autofilled]) .label-input-container.sc-market-textarea{padding:var(--field-size-medium-float-phase-vertical-padding-size)\n      var(--field-size-medium-float-phase-horizontal-padding-size)}/*!@:host([size='small']) .label-input-container, :host([size='small'][value='']:not([focused]):not([autofilled])) .label-input-container*/[size='small'].sc-market-textarea-h .label-input-container.sc-market-textarea,[size='small'][value=''].sc-market-textarea-h:not([focused]):not([autofilled]) .label-input-container.sc-market-textarea{padding:var(--field-size-small-float-phase-vertical-padding-size)\n      var(--field-size-small-float-phase-horizontal-padding-size)}/*!@:host ::slotted(label)*/.sc-market-textarea-h .sc-market-textarea-s>label{display:block;min-height:var(--field-empty-phase-label-text-leading);font-weight:var(--field-empty-phase-label-text-weight);font-size:var(--field-empty-phase-label-text-size);line-height:var(--field-empty-phase-label-text-leading);letter-spacing:var(--field-empty-phase-label-text-tracking);transition:all var(--field-input-animation-speed);transform:translateY(var(--field-input-label-translate));transform-origin:0 0}/*!@:host(:not([value=\"\"])) ::slotted(label), :host([value=\"\"]:not([focused])[autofilled]) ::slotted(label), :host([focused]) ::slotted(label)*/.sc-market-textarea-h:not([value=\"\"]) .sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"]:not([focused])[autofilled].sc-market-textarea-s>label,.sc-market-textarea-h[value=\"\"]:not([focused])[autofilled] .sc-market-textarea-s>label,.sc-market-textarea-h[focused].sc-market-textarea-s>label,.sc-market-textarea-h[focused] .sc-market-textarea-s>label{font-weight:var(--field-float-phase-label-text-weight);transform:scale(\n        calc(var(--field-float-phase-label-text-size-unitless) / var(--field-empty-phase-label-text-size-unitless))\n      )}/*!@:host input, :host ::slotted(input), :host textarea, :host ::slotted(textarea)*/.sc-market-textarea-h input.sc-market-textarea,.sc-market-textarea-h.sc-market-textarea-s>input,.sc-market-textarea-h .sc-market-textarea-s>input,.sc-market-textarea-h textarea.sc-market-textarea,.sc-market-textarea-h.sc-market-textarea-s>textarea,.sc-market-textarea-h .sc-market-textarea-s>textarea{opacity:0%}/*!@:host([focused]) input, :host([focused]) ::slotted(input), :host([focused]) textarea, :host([focused]) ::slotted(textarea), :host(:not([value=''])) input, :host(:not([value=''])) ::slotted(input), :host(:not([value=''])) textarea, :host(:not([value=''])) ::slotted(textarea)*/[focused].sc-market-textarea-h input.sc-market-textarea,.sc-market-textarea-h[focused].sc-market-textarea-s>input,.sc-market-textarea-h[focused] .sc-market-textarea-s>input,[focused].sc-market-textarea-h textarea.sc-market-textarea,.sc-market-textarea-h[focused].sc-market-textarea-s>textarea,.sc-market-textarea-h[focused] .sc-market-textarea-s>textarea,.sc-market-textarea-h:not([value='']) input.sc-market-textarea,.sc-market-textarea-h:not([value='']).sc-market-textarea-s>input,.sc-market-textarea-h:not([value='']) .sc-market-textarea-s>input,.sc-market-textarea-h:not([value='']) textarea.sc-market-textarea,.sc-market-textarea-h:not([value='']).sc-market-textarea-s>textarea,.sc-market-textarea-h:not([value='']) .sc-market-textarea-s>textarea{opacity:100%}/*!@:host([size='small']) ::slotted(label), :host([size='medium']) ::slotted(label)*/.sc-market-textarea-h[size='small'] .sc-market-textarea-s>label,.sc-market-textarea-h[size='medium'].sc-market-textarea-s>label,.sc-market-textarea-h[size='medium'] .sc-market-textarea-s>label{position:absolute;overflow:hidden;clip:rect(0 0 0 0);width:1px;height:1px;white-space:nowrap;-webkit-clip-path:inset(50%);clip-path:inset(50%)}/*!@:host([size='small']) input, :host([size='small']) ::slotted(input), :host([size='small']) textarea, :host([size='small']) ::slotted(textarea), :host([size='medium']) input, :host([size='medium']) ::slotted(input), :host([size='medium']) textarea, :host([size='medium']) ::slotted(textarea)*/[size='small'].sc-market-textarea-h input.sc-market-textarea,.sc-market-textarea-h[size='small'].sc-market-textarea-s>input,.sc-market-textarea-h[size='small'] .sc-market-textarea-s>input,[size='small'].sc-market-textarea-h textarea.sc-market-textarea,.sc-market-textarea-h[size='small'].sc-market-textarea-s>textarea,.sc-market-textarea-h[size='small'] .sc-market-textarea-s>textarea,[size='medium'].sc-market-textarea-h input.sc-market-textarea,.sc-market-textarea-h[size='medium'].sc-market-textarea-s>input,.sc-market-textarea-h[size='medium'] .sc-market-textarea-s>input,[size='medium'].sc-market-textarea-h textarea.sc-market-textarea,.sc-market-textarea-h[size='medium'].sc-market-textarea-s>textarea,.sc-market-textarea-h[size='medium'] .sc-market-textarea-s>textarea{opacity:100%}/*!@:host*/.sc-market-textarea-h{--textarea-height:120px;--textarea-minimum-height:120px;--textarea-label-bottom-padding:16px;flex-direction:column;overflow:hidden;min-height:var(--textarea-minimum-height);max-height:var(--textarea-maximum-height);resize:vertical}/*!@:host .label-input-container, :host([value='']:not([focused]):not([autofilled])) .label-input-container*/.sc-market-textarea-h .label-input-container.sc-market-textarea,[value=''].sc-market-textarea-h:not([focused]):not([autofilled]) .label-input-container.sc-market-textarea{display:flex;flex-direction:column;width:100%;padding-bottom:var(--textarea-label-bottom-padding);font-weight:var(--textarea-font-weight);font-size:var(--textarea-font-size);line-height:var(--textarea-font-leading);letter-spacing:var(--textarea-font-tracking)}/*!@:host([disabled]) textarea, :host([disabled]) ::slotted(textarea)*/[disabled].sc-market-textarea-h textarea.sc-market-textarea,.sc-market-textarea-h[disabled].sc-market-textarea-s>textarea,.sc-market-textarea-h[disabled] .sc-market-textarea-s>textarea{pointer-events:auto !important}/*!@textarea, ::slotted(textarea)*/textarea.sc-market-textarea,.sc-market-textarea-s>textarea{flex-grow:1;resize:none}";
var MarketTextareaStyle0 = marketTextareaCss;

/**
 * @slot - The main label for the textarea.
 * @slot textarea - Can be used to slot your own custom textarea element.
 * @part container - The containing div for the textarea and label.
 */
class MarketTextarea {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTextareaValueChange = createEvent(this, "marketTextareaValueChange", 7);
        this.onMutationObserved = (ariaAttributes) => {
            this.ariaAttributes = ariaAttributes;
        };
        this.placeholder = undefined;
        this.name = undefined;
        this.value = '';
        this.maxlength = undefined;
        this.readonly = false;
        this.disabled = false;
        this.focused = false;
        this.invalid = false;
        this.maxHeight = `${cjs.TEXTAREA_MAXIMUM_HEIGHT}px`;
        this.autofocus = false;
        this.inputmode = undefined;
        this.ariaAttributes = undefined;
    }
    handleMarketDialogLoaded() {
        if (this.autofocus) {
            this.setFocus();
        }
    }
    /**
     * Allows passing an alternative light DOM textarea.
     * Sets the this.slottedTextarea value to undefined if there is no slotted element.
     */
    registerSlottedTextarea(slottedTextarea) {
        var _a;
        this.slottedTextarea =
            slottedTextarea ||
                // textarea slotted into market-textarea
                this.el.querySelector('textarea[slot=textarea]') ||
                (
                // textarea slotted into a higher-level component that uses market-textarea
                (_a = this.el.getRootNode().host) === null || _a === void 0 ? void 0 : _a.querySelector('textarea[slot=textarea]'));
        if (this.slottedTextarea) {
            this.slottedTextarea.addEventListener('input', (e) => this.textareaValueDidChange(e));
            this.slottedTextarea.addEventListener('focus', () => this.setFocus());
            this.slottedTextarea.addEventListener('blur', () => (this.focused = false));
        }
        return Promise.resolve();
    }
    syncSharedPropsToSlottedTextarea(prevSharedProps) {
        // sync component props to slotted input, if one exists
        if (this.slottedTextarea) {
            const modifiedPropKeys = [...new Set([...Object.keys(prevSharedProps), ...Object.keys(this.sharedProps)])];
            modifiedPropKeys.forEach((key) => {
                if (!(key in this.sharedProps)) {
                    // remove properties that have been unset
                    this.slottedTextarea.removeAttribute(key);
                }
                else {
                    // boolean attributes can be set using empty strings
                    // https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#javascript
                    const attributeValue = this.sharedProps[key] !== true ? this.sharedProps[key] : '';
                    this.slottedTextarea.setAttribute(key, attributeValue);
                }
            });
        }
    }
    updateSharedPropsAndSyncSlottedTextarea() {
        const prevSharedProps = Object.assign({}, this.sharedProps);
        // used by the default shadow DOM native input and to copy component properties to slotted inputs
        // conditionally adding key/value pairs based on whether we want to set them on the <input>
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#individual_attributes
        this.sharedProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (this.name && { name: this.name })), (this.placeholder && { placeholder: this.placeholder })), (this.maxlength !== undefined && Number.parseInt(this.maxlength, 10) >= 0 && { maxlength: this.maxlength })), (this.value !== undefined && { value: this.value })), (this.readonly && { readonly: this.readonly })), (this.disabled && { disabled: this.disabled })), (this.autofocus && { autofocus: this.autofocus })), (this.inputmode && { inputmode: this.inputmode })), this.ariaAttributes), { 'aria-label': getTextInputAriaLabel(this.el) });
        this.syncSharedPropsToSlottedTextarea(prevSharedProps);
    }
    componentWillLoad() {
        this.mutationObserver = observeAriaAttributes(this.el, this.onMutationObserved);
        this.registerSlottedTextarea();
        this.updateSharedPropsAndSyncSlottedTextarea();
    }
    componentDidLoad() {
        if (this.maxHeight) {
            // Set the passed max height on the input container, since that's where
            // the drag handle will actually be visible.
            // This will be removed until `maxHeight` prop is fully deprecated.
            this.el.style.maxHeight = this.maxHeight;
        }
    }
    componentWillUpdate() {
        this.updateSharedPropsAndSyncSlottedTextarea();
    }
    textareaValueDidChange(e) {
        // Need to update value for the label, which floats if this value exists.
        this.value = e.target.value;
        this.marketTextareaValueChange.emit({
            value: e.target.value,
            originalEvent: e,
        });
    }
    setFocus(value = true) {
        var _a, _b, _c, _d, _e;
        if (this.readonly || this.disabled) {
            return;
        }
        const shouldSetElementFocus = value && !this.focused;
        this.focused = value;
        // Set focus on element if not already focused
        if (shouldSetElementFocus) {
            this.slottedTextarea ? this.slottedTextarea.focus() : (_e = (_d = (_c = (_b = (_a = this.el) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector) === null || _c === void 0 ? void 0 : _c.call(_b, 'textarea')) === null || _d === void 0 ? void 0 : _d.focus) === null || _e === void 0 ? void 0 : _e.call(_d);
        }
    }
    render() {
        return (hAsync(Host, { key: 'd3eff93de852f0b1f33bf7da766488313b423d8c', class: "market-textarea", onBlur: () => {
                this.focused = false;
            }, onClick: () => {
                this.setFocus();
            }, onFocus: () => {
                this.setFocus();
            } }, hAsync("div", { key: '5e7d80d8934e0b29295db282f9e8df4a8543ce74', class: "label-input-container", part: "container" }, hAsync("slot", { key: '52a6e3cdb68cef92a0b56d85aca22a3309ff3ad2' }), hAsync("slot", { key: '2cc037b3ea0a349a61182804b3e5ecde4b8e9242', name: "textarea", onSlotchange: () => this.registerSlottedTextarea() }, !this.slottedTextarea && (hAsync("textarea", Object.assign({ key: 'ab1a6abef98069da1f03b8d8e424e9450573a785' }, this.ariaAttributes, { id: this.name, onInput: (e) => this.textareaValueDidChange(e) }, this.sharedProps)))))));
    }
    disconnectedCallback() {
        var _a;
        (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    get el() { return getElement(this); }
    static get style() { return MarketTextareaStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-textarea",
        "$members$": {
            "placeholder": [1],
            "name": [1],
            "value": [1537],
            "maxlength": [1],
            "readonly": [516],
            "disabled": [516],
            "focused": [1540],
            "invalid": [516],
            "maxHeight": [1, "max-height"],
            "autofocus": [4],
            "inputmode": [1],
            "ariaAttributes": [32],
            "registerSlottedTextarea": [64]
        },
        "$listeners$": [[8, "marketDialogLoaded", "handleMarketDialogLoaded"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["value", "value"], ["readonly", "readonly"], ["disabled", "disabled"], ["focused", "focused"], ["invalid", "invalid"]]
    }; }
}

const marketTileCss = "/*!@::slotted([slot=\"hint\"])*/.sc-market-tile-s>[slot=\"hint\"]{font-weight:var(--core-type-display-10-weight);font-size:var(--core-type-display-10-size);font-family:var(--core-type-display-10-font-family);line-height:var(--core-type-display-10-leading);letter-spacing:var(--core-type-display-10-tracking);text-transform:var(--core-type-display-10-case)}/*!@::slotted([slot=\"subtext\"])*/.sc-market-tile-s>[slot=\"subtext\"]{font-weight:var(--core-type-paragraph-10-weight);font-size:var(--core-type-paragraph-10-size);font-family:var(--core-type-paragraph-10-font-family);line-height:var(--core-type-paragraph-10-leading);letter-spacing:var(--core-type-paragraph-10-tracking);text-transform:var(--core-type-paragraph-10-case)}/*!@::slotted([slot=\"subtext\"]) b, ::slotted([slot=\"subtext\"]) strong*/.sc-market-tile-s>[slot=\"subtext\"] b,.sc-market-tile-s>[slot=\"subtext\"] strong{font-weight:var(--core-type-semibold-10-weight)}/*!@::slotted([slot=\"label\"])*/.sc-market-tile-s>[slot=\"label\"]{font-weight:var(--core-type-medium-30-weight);font-size:var(--core-type-medium-30-size);font-family:var(--core-type-medium-30-font-family);line-height:var(--core-type-medium-30-leading);letter-spacing:var(--core-type-medium-30-tracking);text-transform:var(--core-type-medium-30-case)}/*!@::slotted([slot=\"indicator\"])*/.sc-market-tile-s>[slot=\"indicator\"]{font-weight:var(--core-type-semibold-10-weight);font-size:var(--core-type-semibold-10-size);font-family:var(--core-type-semibold-10-font-family);line-height:var(--core-type-semibold-10-leading);letter-spacing:var(--core-type-semibold-10-tracking);text-transform:var(--core-type-semibold-10-case)}/*!@:host*/.sc-market-tile-h{--item-tile-text-color:black;--focus-ring-color:color-mix(\n      in srgb,\n      var(--item-tile-focus-ring-color, var(--core-focus-ring-color)) 100%,\n      transparent\n    );position:relative;z-index:1;display:grid;grid-template-areas:\"leading-accessory _ trailing-accessory\"\n    \"content content content\";grid-template-columns:minmax(0, max-content) 1fr auto;box-sizing:border-box;width:var(--item-tile-width, 200px);height:var(--item-tile-medium-height, 124px);padding:var(--item-tile-medium-padding, var(--core-metrics-spacing-150));border-radius:var(--item-tile-border-radius, 6px);background:var(--item-tile-fill-color, var(--core-fill-40-color));-webkit-user-select:none;-moz-user-select:none;user-select:none}/*!@:host([interactive])*/[interactive].sc-market-tile-h{cursor:pointer}/*!@:host([size=\"small\"])*/[size=\"small\"].sc-market-tile-h{grid-template-areas:\"leading-accessory content trailing-accessory\";grid-template-columns:max-content 1fr minmax(0, max-content);height:var(--item-tile-small-height, 56px);padding:var(--item-tile-small-padding-vertical, var(--core-metrics-spacing-50))\n      var(--item-tile-small-padding-horizontal, var(--core-metrics-spacing-150));-moz-column-gap:var(--core-metrics-spacing-100);column-gap:var(--core-metrics-spacing-100)}/*!@:host([size=\"small\"]) ::slotted([slot=\"leading-accessory\"]), :host([size=\"small\"]) .trailing-accessory-container*/.sc-market-tile-h[size=\"small\"] .sc-market-tile-s>[slot=\"leading-accessory\"],[size=\"small\"].sc-market-tile-h .trailing-accessory-container.sc-market-tile{align-items:center}/*!@:host([size=\"small\"]) .content*/[size=\"small\"].sc-market-tile-h .content.sc-market-tile{justify-content:center;align-items:start}/*!@:host([size=\"small\"]) .remove-button*/[size=\"small\"].sc-market-tile-h .remove-button.sc-market-tile{position:relative}/*!@:host([aria-disabled])*/[aria-disabled].sc-market-tile-h{opacity:20%;cursor:not-allowed}/*!@:host([aria-disabled]) .remove-button*/[aria-disabled].sc-market-tile-h .remove-button.sc-market-tile{cursor:not-allowed}/*!@:host([aria-disabled]) .remove-button:hover*/[aria-disabled].sc-market-tile-h .remove-button.sc-market-tile:hover{background:var(--item-tile-remove-button-fill, #fff)}/*!@:host([aria-selected=\"true\"])*/[aria-selected=\"true\"].sc-market-tile-h{box-shadow:inset 0 0 0 var(--item-tile-selected-value-border-width, 2px)\n      var(--item-tile-selected-value-border-color, var(--core-emphasis-fill-color))}/*!@:host(:focus-visible)*/.sc-market-tile-h:focus-visible{outline:var(--item-tile-focus-ring-border-size, var(--core-focus-ring-border-size)) solid var(--focus-ring-color);outline-offset:var(--item-tile-focus-ring-buffer-size, var(--core-focus-ring-buffer-size))}/*!@.background-image*/.background-image.sc-market-tile{display:none}/*!@.background-image.has-slotted-media, .background-image ::slotted([slot=\"media\"])*/.background-image.has-slotted-media.sc-market-tile,.background-image.sc-market-tile-s>[slot=\"media\"],.background-image .sc-market-tile-s>[slot=\"media\"]{--item-tile-text-color:white;position:absolute;top:0;left:0;z-index:-1;display:block;-o-object-fit:cover;object-fit:cover;width:100%;height:100%;border-radius:var(--item-tile-border-radius, 6px)}/*!@.background-image.has-slotted-media::before, .background-image ::slotted([slot=\"media\"])::before*/.background-image.has-slotted-media.sc-market-tile::before,.background-image.sc-market-tile-s>[slot=\"media\"],.background-image.sc-market-tile-s>[slot=\"media\"]::before,.background-image .sc-market-tile-s>[slot=\"media\"]::before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:var(--item-tile-border-radius, 6px);background-image:var(\n        --item-tile-background-image-gradient,\n        linear-gradient(180.98deg, rgb(0 0 0 / 4%) 0.84%, rgb(0 0 0 / 40%) 99.16%)\n      )}/*!@::slotted([slot=\"leading-accessory\"])*/.sc-market-tile-s>[slot=\"leading-accessory\"]{z-index:2;display:flex;grid-area:leading-accessory;align-items:flex-start}/*!@.trailing-accessory-container*/.trailing-accessory-container.sc-market-tile{z-index:3;display:flex;grid-area:trailing-accessory;justify-content:flex-end}/*!@.trailing-accessory-container .remove-button*/.trailing-accessory-container.sc-market-tile .remove-button.sc-market-tile{position:absolute;width:var(--item-tile-remove-button-width, 24px);height:var(--item-tile-remove-button-height, 24px);border:none;border-radius:100px;background:var(--item-tile-remove-button-fill, var(--core-surface-30-color));box-shadow:var(--elevation-10-shadow);cursor:pointer}/*!@.trailing-accessory-container .remove-button:hover*/.trailing-accessory-container.sc-market-tile .remove-button.sc-market-tile:hover{background:var(--item-tile-remove-button-hover-state-background-color, #ffe5ea)}/*!@.trailing-accessory-container .remove-button:active*/.trailing-accessory-container.sc-market-tile .remove-button.sc-market-tile:active{background:var(--item-time-remove-button-active-state-background-color, #ffccd5)}/*!@.trailing-accessory-container .remove-button svg*/.trailing-accessory-container.sc-market-tile .remove-button.sc-market-tile svg.sc-market-tile{position:absolute;top:0;left:0;padding:var(--core-metrics-spacing-50)}/*!@.trailing-accessory-container ::slotted([slot=\"indicator\"])*/.trailing-accessory-container .sc-market-tile-s>[slot=\"indicator\"]{height:var(--core-metrics-spacing-200);padding:0 var(--core-metrics-spacing-100);border-radius:100px;background:var(--core-fill-10-dark-mode-color);color:black;box-shadow:var(--elevation-10-shadow)}/*!@.content*/.content.sc-market-tile{z-index:2;display:flex;flex-direction:column;grid-area:content;justify-content:flex-end;min-width:0}/*!@::slotted([slot=\"label\"])*/.sc-market-tile-s>[slot=\"label\"]{display:-webkit-box;overflow-y:hidden;min-width:0;-webkit-line-clamp:var(--item-tile-label-line-clamp, 1);-webkit-box-orient:vertical}/*!@::slotted([slot=\"subtext\"])*/.sc-market-tile-s>[slot=\"subtext\"]{display:-webkit-box;overflow-y:hidden;min-width:0;-webkit-line-clamp:1;-webkit-box-orient:vertical}";
var MarketTileStyle0 = marketTileCss;

/**
 * @slot media - When provided, replaces the solid color background with a background image and applies a slight gradient.
 * @slot leading-accessory - An icon set on the top-left corner of the tile.
 * @slot actions - Optional slot to customize action(s) in the top-right corner of the tile. Renders a remove button by default.
 * @slot indicator - Text to render in a pill-like element on the top-right corner of the slot.
 * Is overridden by `actions`.
 * @slot hint - Large text set in the center of a medium-sized tile. Intended to be one or two letters.
 * @slot label - Text set beneath the hint slot.
 * @slot subtext - Smaller text set beneath the label slot.
 */
class MarketTile {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTileSelectedChanged = createEvent(this, "marketTileSelectedChanged", 7);
        this.marketTileRemoveClicked = createEvent(this, "marketTileRemoveClicked", 7);
        this.hasTrailingAccessorySlot = false;
        this.hasIndicatorTextSlot = false;
        this.disabled = false;
        this.interactive = false;
        this.showActions = false;
        this.size = 'medium';
        this.value = undefined;
        this.selected = false;
        this.hasSlottedMedia = false;
    }
    onSizeChange() {
        this.adjustSlottedLabels();
    }
    /**
     * Allows external elements to set selected value.
     */
    setSelected(newValue) {
        if (typeof newValue !== 'boolean') {
            return Promise.resolve();
        }
        if (this.selected !== newValue) {
            const { defaultPrevented } = this.marketTileSelectedChanged.emit({
                selected: this.selected,
                value: this.value,
            });
            if (!defaultPrevented) {
                this.selected = newValue;
            }
        }
        return Promise.resolve();
    }
    handleClick(event) {
        if (this.disabled || !this.interactive) {
            return;
        }
        this.selected = !this.selected;
        event.preventDefault();
        this.marketTileSelectedChanged.emit({ selected: this.selected, value: this.value });
    }
    handleRemoveActionKeydown(event) {
        switch (event.key) {
            case 'Enter':
            case ' ':
                this.handleRemoveActionClick(event);
                break;
        }
    }
    handleRemoveActionClick(event) {
        if (this.disabled || !this.interactive) {
            return;
        }
        event.stopPropagation();
        this.marketTileRemoveClicked.emit();
    }
    renderDefaultRemoveAction() {
        const { disabled, handleRemoveActionClick, handleRemoveActionKeydown } = this;
        return (hAsync("button", { class: "remove-button", disabled: disabled, onClick: handleRemoveActionClick.bind(this), onKeyUp: handleRemoveActionKeydown.bind(this) }, hAsync("svg", { slot: "icon", width: "16", height: "16", viewBox: "0 0 16 16", fill: "var(--core-critical-text-color)", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { d: "M12.8318 7.3335V7.1685H12.6668H3.3335H3.1685V7.3335V8.66683V8.83183H3.3335H12.6668H12.8318V8.66683V7.3335Z", fill: "var(--core-critical-text-color)", stroke: "var(--core-critical-text-color)", "stroke-width": "0.33" }))));
    }
    handleKeydown(event) {
        // don't intercept keydown of descendant elements
        // e.g. remove button
        if (event.target !== this.el) {
            return;
        }
        switch (event.key) {
            case 'Enter':
            case ' ':
                this.handleClick(event);
                break;
        }
    }
    /**
     * This function determines the number of lines the `label` slot text should clamp to.
     * It should clamp to a single line if the hint slot exists or if the subtext slot exists
     * and the element `size` prop is set to "small".
     */
    adjustSlottedLabels() {
        const { size, el } = this;
        const hint = el.querySelector('[slot="hint"]');
        const label = el.querySelector('[slot="label"]');
        const subtext = el.querySelector('[slot="subtext"]');
        if (!label) {
            return;
        }
        const labelLineClamp = hint || (subtext && size === 'small') ? 1 : 2;
        el.style.setProperty('--item-tile-label-line-clamp', labelLineClamp.toString());
    }
    checkSlottedMedia() {
        this.hasSlottedMedia = Boolean(this.el.querySelector('[slot="media"]'));
    }
    componentWillLoad() {
        this.checkSlottedMedia();
        this.hasIndicatorTextSlot = Boolean(this.el.querySelector('[slot="indicator"]'));
    }
    render() {
        const { disabled, size, hasSlottedMedia, hasIndicatorTextSlot, interactive, showActions, selected } = this;
        const tabindex = interactive && !disabled ? '0' : null;
        return (hAsync(Host, { key: 'd517f7cb075bd6646ca3490faf7d0eeb127ffa82', class: "market-tile", tabindex: tabindex, "aria-selected": selected.toString(), onClick: (e) => this.handleClick(e), onKeydown: (e) => this.handleKeydown(e) }, hAsync("div", { key: '4e8acbe5ef8c493e5b7dcdab61fe78aeb46a3058', class: classNames('background-image', { 'has-slotted-media': hasSlottedMedia }) }, hAsync("slot", { key: 'ef14bfbc08c9cb408f3f6c778599af3a00857413', onSlotchange: () => this.checkSlottedMedia(), name: "media" })), hAsync("slot", { key: '6f138c2dd2c724ed94d783971d5e61e690f3b204', name: "leading-accessory" }), hAsync("div", { key: 'eb504c07a85e0888d6dc9e3cf691b4497428d185', class: "trailing-accessory-container" }, showActions && hAsync("slot", { key: '5ad694873bbaea565bb629f48101311c52e5d5b1', name: "actions" }, this.renderDefaultRemoveAction()), !showActions && hasIndicatorTextSlot && hAsync("slot", { key: '2e4922b851b506583bad374382a86751f263d575', name: "indicator" })), hAsync("div", { key: '0ac231a58c9f189f38740ab5d2a97ae06e82386e', class: "content" }, size !== 'small' && hAsync("slot", { key: 'ae24177ef72c114e1801f9baa06b656139efa4c1', onSlotchange: () => this.adjustSlottedLabels(), name: "hint" }), hAsync("slot", { key: 'b99fe24dd8cf51110ca3276777ff36c1a416046f', onSlotchange: () => this.adjustSlottedLabels(), name: "label" }), hAsync("slot", { key: 'ae3e99ca54cdfcfd1e8e0feb48e276b2c131d037', onSlotchange: () => this.adjustSlottedLabels(), name: "subtext" }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "size": ["onSizeChange"]
    }; }
    static get style() { return MarketTileStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tile",
        "$members$": {
            "disabled": [516, "aria-disabled"],
            "interactive": [4],
            "showActions": [4, "show-actions"],
            "size": [513],
            "value": [513],
            "selected": [1540],
            "hasSlottedMedia": [32],
            "setSelected": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "aria-disabled"], ["size", "size"], ["value", "value"], ["selected", "selected"]]
    }; }
}

const marketToastCss = "/*!@:host, ::slotted(*), **/.sc-market-toast-h,.sc-market-toast-s>*,*.sc-market-toast{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-toast-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-toast-h *.sc-market-toast,.sc-market-toast-h[disabled].sc-market-toast-s>*,.sc-market-toast-h[disabled] .sc-market-toast-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-toast-h{display:flex;flex-direction:column;align-items:flex-start;overflow:hidden;width:100%;max-width:var(--toast-maximum-width);border-radius:var(--toast-radius);box-shadow:var(--elevation-30-shadow);font-weight:var(--toast-text-weight);font-size:var(--toast-text-size);line-height:var(--toast-text-leading);letter-spacing:var(--toast-text-tracking);text-transform:var(--toast-text-case)}/*!@.icon-container, .dismiss-container*/.icon-container.sc-market-toast,.dismiss-container.sc-market-toast{display:flex;flex-shrink:0;align-items:center}/*!@.dismiss-container button*/.dismiss-container.sc-market-toast button.sc-market-toast{display:flex;justify-content:center;align-items:center;margin:0;padding:0;border:none;background-color:transparent;color:inherit;cursor:pointer;transition:opacity 0.2s;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.content*/.content.sc-market-toast{display:flex;align-items:flex-start;width:100%;padding:var(--toast-vertical-padding-size) var(--toast-horizontal-padding-size);-moz-column-gap:var(--toast-icon-spacing);column-gap:var(--toast-icon-spacing)}/*!@.main*/.main.sc-market-toast{display:flex;flex-grow:1;flex-wrap:wrap;row-gap:var(--toast-text-multiline-spacing);-moz-column-gap:var(--toast-content-spacing);column-gap:var(--toast-content-spacing)}/*!@section*/section.sc-market-toast{flex-grow:1}/*!@nav*/nav.sc-market-toast{display:flex;flex-wrap:wrap;justify-content:flex-end}/*!@nav.hidden*/nav.hidden.sc-market-toast{display:none}/*!@::slotted(button), ::slotted(a)*/.sc-market-toast-s>button,.sc-market-toast-s>a{margin:0;padding:0;border:none;background-color:transparent;color:inherit;font-weight:var(--toast-button-text-weight);font-size:var(--toast-button-text-size);font-family:inherit;line-height:var(--toast-button-text-leading);letter-spacing:var(--toast-button-text-tracking);text-decoration:none;text-transform:var(--toast-button-text-case);cursor:pointer;transition:opacity 0.2s}/*!@::slotted(button:hover), ::slotted(a:hover)*/.sc-market-toast-s>button:hover,.sc-market-toast-s>a:hover{opacity:var(--text-link-hover-state-opacity)}/*!@::slotted(button:active), ::slotted(a:active)*/.sc-market-toast-s>button:active,.sc-market-toast-s>a:active{opacity:var(--text-link-pressed-state-opacity)}/*!@::slotted([slot=\"action\"])*/.sc-market-toast-s>[slot=\"action\"]{display:flex;justify-content:center;align-items:center}/*!@::slotted([slot=\"action\"]:not(:last-child))*/.sc-market-toast-s>[slot=\"action\"]:not(:last-child){margin-right:calc(var(--toast-button-spacing) * 2 + var(--toast-separator-width))}/*!@::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-toast-s>[slot=\"action\"]:not(:last-child)::after{content:\"\";display:inline-block;width:var(--toast-separator-width);height:var(--toast-separator-height);margin-right:calc(-1 * var(--toast-button-spacing) - var(--toast-separator-width));margin-left:var(--toast-button-spacing);opacity:var(--toast-separator-opacity);pointer-events:none}/*!@progress-bar*/progress-bar.sc-market-toast{height:var(--toast-progress-bar-height)}/*!@:host([variant=\"info\"])*/[variant=\"info\"].sc-market-toast-h{background-color:var(--toast-info-variant-background-color);color:var(--toast-info-variant-text-color)}/*!@:host([variant=\"info\"]) .icon-container*/[variant=\"info\"].sc-market-toast-h .icon-container.sc-market-toast{color:var(--toast-info-variant-icon-color)}/*!@:host([variant=\"info\"]) .dismiss-container*/[variant=\"info\"].sc-market-toast-h .dismiss-container.sc-market-toast{color:var(--toast-info-variant-dismiss-button-color)}/*!@:host([variant=\"info\"]) progress-bar*/[variant=\"info\"].sc-market-toast-h progress-bar.sc-market-toast{background-color:var(--toast-info-variant-progress-bar-color)}/*!@:host([variant=\"info\"]) ::slotted(a)*/.sc-market-toast-h[variant=\"info\"] .sc-market-toast-s>a{color:var(--toast-info-variant-text-link-text-color)}/*!@:host([variant=\"info\"]) ::slotted(button)*/.sc-market-toast-h[variant=\"info\"] .sc-market-toast-s>button{color:var(--toast-info-variant-button-text-color)}/*!@:host([variant=\"info\"]) ::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-toast-h[variant=\"info\"] .sc-market-toast-s>[slot=\"action\"]:not(:last-child)::after{background-color:var(--toast-info-variant-separator-color)}/*!@:host([variant=\"success\"])*/[variant=\"success\"].sc-market-toast-h{background-color:var(--toast-success-variant-background-color);color:var(--toast-success-variant-text-color)}/*!@:host([variant=\"success\"]) .icon-container*/[variant=\"success\"].sc-market-toast-h .icon-container.sc-market-toast{color:var(--toast-success-variant-icon-color)}/*!@:host([variant=\"success\"]) .dismiss-container*/[variant=\"success\"].sc-market-toast-h .dismiss-container.sc-market-toast{color:var(--toast-success-variant-dismiss-button-color)}/*!@:host([variant=\"success\"]) progress-bar*/[variant=\"success\"].sc-market-toast-h progress-bar.sc-market-toast{background-color:var(--toast-success-variant-progress-bar-color)}/*!@:host([variant=\"success\"]) ::slotted(a)*/.sc-market-toast-h[variant=\"success\"] .sc-market-toast-s>a{color:var(--toast-success-variant-text-link-text-color)}/*!@:host([variant=\"success\"]) ::slotted(button)*/.sc-market-toast-h[variant=\"success\"] .sc-market-toast-s>button{color:var(--toast-success-variant-button-text-color)}/*!@:host([variant=\"success\"]) ::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-toast-h[variant=\"success\"] .sc-market-toast-s>[slot=\"action\"]:not(:last-child)::after{background-color:var(--toast-success-variant-separator-color)}/*!@:host([variant=\"warning\"])*/[variant=\"warning\"].sc-market-toast-h{background-color:var(--toast-warning-variant-background-color);color:var(--toast-warning-variant-text-color)}/*!@:host([variant=\"warning\"]) .icon-container*/[variant=\"warning\"].sc-market-toast-h .icon-container.sc-market-toast{color:var(--toast-warning-variant-icon-color)}/*!@:host([variant=\"warning\"]) .dismiss-container*/[variant=\"warning\"].sc-market-toast-h .dismiss-container.sc-market-toast{color:var(--toast-warning-variant-dismiss-button-color)}/*!@:host([variant=\"warning\"]) progress-bar*/[variant=\"warning\"].sc-market-toast-h progress-bar.sc-market-toast{background-color:var(--toast-warning-variant-progress-bar-color)}/*!@:host([variant=\"warning\"]) ::slotted(a)*/.sc-market-toast-h[variant=\"warning\"] .sc-market-toast-s>a{color:var(--toast-warning-variant-text-link-text-color)}/*!@:host([variant=\"warning\"]) ::slotted(button)*/.sc-market-toast-h[variant=\"warning\"] .sc-market-toast-s>button{color:var(--toast-warning-variant-button-text-color)}/*!@:host([variant=\"warning\"]) ::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-toast-h[variant=\"warning\"] .sc-market-toast-s>[slot=\"action\"]:not(:last-child)::after{background-color:var(--toast-warning-variant-separator-color)}/*!@:host([variant=\"critical\"])*/[variant=\"critical\"].sc-market-toast-h{background-color:var(--toast-critical-variant-background-color);color:var(--toast-critical-variant-text-color)}/*!@:host([variant=\"critical\"]) .icon-container*/[variant=\"critical\"].sc-market-toast-h .icon-container.sc-market-toast{color:var(--toast-critical-variant-icon-color)}/*!@:host([variant=\"critical\"]) .dismiss-container*/[variant=\"critical\"].sc-market-toast-h .dismiss-container.sc-market-toast{color:var(--toast-critical-variant-dismiss-button-color)}/*!@:host([variant=\"critical\"]) progress-bar*/[variant=\"critical\"].sc-market-toast-h progress-bar.sc-market-toast{background-color:var(--toast-critical-variant-progress-bar-color)}/*!@:host([variant=\"critical\"]) ::slotted(a)*/.sc-market-toast-h[variant=\"critical\"] .sc-market-toast-s>a{color:var(--toast-critical-variant-text-link-text-color)}/*!@:host([variant=\"critical\"]) ::slotted(button)*/.sc-market-toast-h[variant=\"critical\"] .sc-market-toast-s>button{color:var(--toast-critical-variant-button-text-color)}/*!@:host([variant=\"critical\"]) ::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-toast-h[variant=\"critical\"] .sc-market-toast-s>[slot=\"action\"]:not(:last-child)::after{background-color:var(--toast-critical-variant-separator-color)}/*!@:host([variant=\"insight\"])*/[variant=\"insight\"].sc-market-toast-h{background-color:var(--toast-insight-variant-background-color);color:var(--toast-insight-variant-text-color)}/*!@:host([variant=\"insight\"]) .icon-container*/[variant=\"insight\"].sc-market-toast-h .icon-container.sc-market-toast{color:var(--toast-insight-variant-icon-color)}/*!@:host([variant=\"insight\"]) .dismiss-container*/[variant=\"insight\"].sc-market-toast-h .dismiss-container.sc-market-toast{color:var(--toast-insight-variant-dismiss-button-color)}/*!@:host([variant=\"insight\"]) progress-bar*/[variant=\"insight\"].sc-market-toast-h progress-bar.sc-market-toast{background-color:var(--toast-insight-variant-progress-bar-color)}/*!@:host([variant=\"insight\"]) ::slotted(a)*/.sc-market-toast-h[variant=\"insight\"] .sc-market-toast-s>a{color:var(--toast-insight-variant-text-link-text-color)}/*!@:host([variant=\"insight\"]) ::slotted(button)*/.sc-market-toast-h[variant=\"insight\"] .sc-market-toast-s>button{color:var(--toast-insight-variant-button-text-color)}/*!@:host([variant=\"insight\"]) ::slotted([slot=\"action\"]:not(:last-child))::after*/.sc-market-toast-h[variant=\"insight\"] .sc-market-toast-s>[slot=\"action\"]:not(:last-child)::after{background-color:var(--toast-insight-variant-separator-color)}";
var MarketToastStyle0 = marketToastCss;

/**
 * @slot - The text for the toast
 * @slot action - for `<a href>` or `<button>` (not a `<market-button>`)
 */
class MarketToast {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketToastAutoDismissed = createEvent(this, "marketToastAutoDismissed", 7);
        this.marketToastManuallyDismissed = createEvent(this, "marketToastManuallyDismissed", 7);
        this.variant = 'info';
        this.persistent = false;
        this.dismissButtonAriaLabel = 'Dismiss';
        this.progress = -1;
        this.durationTilAutoDismiss = 5000;
        this.showActionsNav = false;
    }
    /**
     * Set toast to disappear after the autodismiss timeout has passed
     */
    startAutoDismissTimer() {
        if (!this.persistent) {
            setTimeout(() => {
                this.marketToastAutoDismissed.emit();
            }, this.durationTilAutoDismiss);
        }
        return Promise.resolve();
    }
    handleManualDismiss() {
        this.marketToastManuallyDismissed.emit();
    }
    componentWillLoad() {
        this.checkIfActionsArePresent();
    }
    checkIfActionsArePresent() {
        const actions = this.el.querySelector('[slot="action"]');
        this.showActionsNav = actions ? true : false;
    }
    // TODO: replace with design token references after they are added (UI-6241)
    getVariantIcon() {
        switch (this.variant) {
            case 'success':
                return 'success';
            case 'info':
                return 'info';
            case 'warning':
                return 'attention';
            case 'insight':
                return 'recommendation';
            default:
                return 'warning';
        }
    }
    render() {
        const MarketIconTagName = getNamespacedTagFor('market-icon');
        const progress = Math.min(this.progress, 100);
        const progressStyle = {
            width: `${progress}%`,
        };
        return (hAsync(Host, { key: 'fdf10e65a44f11b6e9c7c2ad76562888a9142b39', class: "market-toast", role: "alert" }, hAsync("div", { key: '7a5d3cdc63b1cb3f5cde06f0b94427aca548d7ad', class: "content" }, hAsync("span", { key: 'e359a579c7a0d155a5547ce2bfb6c723dcfd936b', class: "icon-container" }, hAsync(MarketIconTagName, { key: '4947d2fe92bb868612d02b19d4c29189d9a9065a', name: this.getVariantIcon() })), hAsync("div", { key: '1a8fdb2cdd9abcf85ca03b2374ed4f1c22ef0075', class: "main" }, hAsync("section", { key: 'fa3335da51befad1ab399425d1f2161e86998c74' }, hAsync("slot", { key: 'ff628bab0db6dcbdb0469e00e86b78e756d67121' })), hAsync("nav", { key: 'd7a1f6203f81a1e4988abc5149770cdea2841628', "aria-label": "toast-actions", class: this.showActionsNav ? '' : 'hidden' }, hAsync("slot", { key: 'f3cf89137e0234b85a604939004ad36ffd0631d1', name: "action", onSlotchange: () => this.checkIfActionsArePresent() }))), hAsync("nav", { key: '9e115d8b1035d6cbab8004babfb445bd3165b192', "aria-label": "dismiss-container", class: "dismiss-container" }, hAsync("button", { key: 'e4d1d6b5cc356bc8938b2fcd857d19f425c2cc0f', type: "button", "aria-label": this.dismissButtonAriaLabel, onClick: () => this.handleManualDismiss() }, hAsync(MarketIconTagName, { key: '222a7a53bf9e260aa975f2cd8c5119381e59a994', name: "close" })))), this.progress >= 0 && (hAsync("progress-bar", { key: '2050f45b9e54927cbe415c90e99a13f85e142142', role: "progressbar", "aria-valuenow": progress, "aria-valuemin": "0", "aria-valuemax": "100", style: progressStyle }))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketToastStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-toast",
        "$members$": {
            "variant": [513],
            "persistent": [4],
            "dismissButtonAriaLabel": [513, "dismiss-button-aria-label"],
            "progress": [514],
            "durationTilAutoDismiss": [32],
            "showActionsNav": [32],
            "startAutoDismissTimer": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["variant", "variant"], ["dismissButtonAriaLabel", "dismiss-button-aria-label"], ["progress", "progress"]]
    }; }
}

const marketToasterCss = "/*!@:host, ::slotted(*), **/.sc-market-toaster-h,.sc-market-toaster-s>*,*.sc-market-toaster{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-toaster-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-toaster-h *.sc-market-toaster,.sc-market-toaster-h[disabled].sc-market-toaster-s>*,.sc-market-toaster-h[disabled] .sc-market-toaster-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-toaster-h{position:fixed;right:0;bottom:0;left:0;z-index:1010;padding:0 0 var(--toast-bottom-margin, 24px);pointer-events:none}/*!@:host ::slotted(.market-toast)*/.sc-market-toaster-h .sc-market-toaster-s>.market-toast{width:calc(100% - var(--toast-horizontal-margin, 16px) * 2);margin:var(--toast-vertical-spacing, 16px) auto 0;pointer-events:auto}/*!@:host ::slotted(.use-transitions)*/.sc-market-toaster-h .sc-market-toaster-s>.use-transitions{position:absolute;top:100%;left:50%;margin:0;transition:transform var(--toast-animation-transition-duration, 200ms) ease-in-out;transform:translate(-50%, 0)}";
var MarketToasterStyle0 = marketToasterCss;

// TODO(UI-1153): add design tokens for these
const TOAST_VERTICAL_SPACING = 16;
const TOAST_BOTTOM_MARGIN = 24;
const TOAST_ANIMATION_TRANSITION_DURATION = 200;
class MarketToaster {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.toasts = [];
    }
    /**
     * Add the passed toastEl to market-toaster and make it visible
     **/
    async show(toastEl) {
        this.toasts.unshift(toastEl);
        toastEl.classList.add('use-transitions');
        this.el.appendChild(toastEl);
        window.requestAnimationFrame(this.positionToasts.bind(this));
        await new Promise((resolve) => setTimeout(resolve, TOAST_ANIMATION_TRANSITION_DURATION));
        toastEl.startAutoDismissTimer();
    }
    positionToasts() {
        let offset = TOAST_BOTTOM_MARGIN;
        this.toasts.forEach((toast) => {
            toast.style.transform = `translate(-50%, calc(-100% - ${offset}px))`;
            offset += toast.offsetHeight + TOAST_VERTICAL_SPACING;
        });
    }
    /**
     * Remove the passed toastEl from market-toaster
     **/
    async hide(toastEl) {
        const index = this.toasts.indexOf(toastEl);
        this.toasts.splice(index, 1);
        window.requestAnimationFrame(() => {
            toastEl.style.transform = '';
            this.positionToasts();
        });
        await new Promise((resolve) => setTimeout(resolve, TOAST_ANIMATION_TRANSITION_DURATION));
        toastEl.remove();
    }
    /**
     * Remove all market-toasts from market-toaster
     **/
    removeAll() {
        const allActiveToasts = [...this.toasts];
        return Promise.all(allActiveToasts.map((toast) => this.hide(toast)));
    }
    toastAutoDismissedEventHandler({ target: toast }) {
        this.hide(toast);
    }
    toastManuallyDismissedEventHandler({ target: toast }) {
        this.hide(toast);
    }
    render() {
        return (hAsync(Host, { key: '0ff23d72f29449393173f717b060818de032de23', class: "market-toaster" }, hAsync("slot", { key: '5f0ab526f9f5c704cb1d92e8c02d5a1eae5936b1' })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketToasterStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-toaster",
        "$members$": {
            "show": [64],
            "hide": [64],
            "removeAll": [64]
        },
        "$listeners$": [[0, "marketToastAutoDismissed", "toastAutoDismissedEventHandler"], [0, "marketToastManuallyDismissed", "toastManuallyDismissedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const marketToggleCss = "/*!@:host, ::slotted(*), **/.sc-market-toggle-h,.sc-market-toggle-s>*,*.sc-market-toggle{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-toggle-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-toggle-h *.sc-market-toggle,.sc-market-toggle-h[disabled].sc-market-toggle-s>*,.sc-market-toggle-h[disabled] .sc-market-toggle-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-toggle-h{--focus-ring-color:color-mix(in srgb, var(--toggle-focus-ring-color) 100%, transparent);position:relative;display:inline-block;height:var(--toggle-height)}/*!@input*/input.sc-market-toggle{position:absolute;top:0;left:0;width:100%;height:100%;margin:0;border-radius:var(--toggle-border-radius);background:transparent;outline:none;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@input:focus-visible*/input.sc-market-toggle:focus-visible{outline:var(--toggle-focus-ring-border-size) solid var(--focus-ring-color);outline-offset:var(--core-focus-ring-buffer-size)}/*!@circle, rect*/circle.sc-market-toggle,rect.sc-market-toggle{transition:var(--row-slotted-control-transition, cx 0.3s)}/*!@circle*/circle.sc-market-toggle{fill:var(--toggle-normal-state-unselected-value-thumb-color)}/*!@rect*/rect.sc-market-toggle{fill:var(--toggle-normal-state-unselected-value-track-color);stroke:var(--toggle-normal-state-unselected-value-border-color)}/*!@:host([checked]) circle*/[checked].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-normal-state-selected-value-thumb-color);cx:28px}/*!@:host([checked]) rect*/[checked].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-normal-state-selected-value-track-color);stroke:var(--toggle-normal-state-selected-value-border-color)}/*!@:host(:hover) circle, :host([hovered]) circle*/.sc-market-toggle-h:hover circle.sc-market-toggle,[hovered].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-hover-state-unselected-value-thumb-color)}/*!@:host(:hover) rect, :host([hovered]) rect*/.sc-market-toggle-h:hover rect.sc-market-toggle,[hovered].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-hover-state-unselected-value-track-color);stroke:var(--toggle-hover-state-unselected-value-border-color)}/*!@:host([checked]:hover) circle, :host([checked][hovered]) circle*/[checked].sc-market-toggle-h:hover circle.sc-market-toggle,[checked][hovered].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-hover-state-selected-value-thumb-color)}/*!@:host([checked]:hover) rect, :host([checked][hovered]) rect*/[checked].sc-market-toggle-h:hover rect.sc-market-toggle,[checked][hovered].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-hover-state-selected-value-track-color);stroke:var(--toggle-hover-state-selected-value-border-color)}/*!@:host([focused]) circle*/[focused].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-focus-state-unselected-value-thumb-color)}/*!@:host([focused]) rect*/[focused].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-focus-state-unselected-value-track-color);stroke:var(--toggle-focus-state-unselected-value-border-color)}/*!@:host([checked][focused]) circle*/[checked][focused].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-focus-state-selected-value-thumb-color)}/*!@:host([checked][focused]) rect*/[checked][focused].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-focus-state-selected-value-track-color);stroke:var(--toggle-focus-state-selected-value-border-color)}/*!@:host(:active) circle, :host([active]) circle*/.sc-market-toggle-h:active circle.sc-market-toggle,[active].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-pressed-state-unselected-value-thumb-color)}/*!@:host(:active) rect, :host([active]) rect*/.sc-market-toggle-h:active rect.sc-market-toggle,[active].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-pressed-state-unselected-value-track-color);stroke:var(--toggle-pressed-state-unselected-value-border-color)}/*!@:host([checked]:active) circle, :host([checked][active]) circle*/[checked].sc-market-toggle-h:active circle.sc-market-toggle,[checked][active].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-pressed-state-selected-value-thumb-color)}/*!@:host([checked]:active) rect, :host([checked][active]) rect*/[checked].sc-market-toggle-h:active rect.sc-market-toggle,[checked][active].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-pressed-state-selected-value-track-color);stroke:var(--toggle-pressed-state-selected-value-border-color)}/*!@:host([disabled]) input*/[disabled].sc-market-toggle-h input.sc-market-toggle{cursor:not-allowed}/*!@:host([disabled]) circle*/[disabled].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-disabled-state-unselected-value-thumb-color)}/*!@:host([disabled]) rect*/[disabled].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-disabled-state-unselected-value-track-color);stroke:var(--toggle-disabled-state-unselected-value-border-color)}/*!@:host([disabled][checked]) circle*/[disabled][checked].sc-market-toggle-h circle.sc-market-toggle{fill:var(--toggle-disabled-state-selected-value-thumb-color)}/*!@:host([disabled][checked]) rect*/[disabled][checked].sc-market-toggle-h rect.sc-market-toggle{fill:var(--toggle-disabled-state-selected-value-track-color);stroke:var(--toggle-disabled-state-selected-value-border-color)}";
var MarketToggleStyle0 = marketToggleCss;

class MarketToggle {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketToggleChange = createEvent(this, "marketToggleChange", 7);
        this.checked = false;
        this.disabled = false;
        this.focused = false;
        this.hovered = false;
        this.active = false;
    }
    /**
     * Toggles `checked` prop, and emits a change event accordingly.
     * Used by `market-row` to sync its selected state w/ slotted toggles.
     */
    setSelection(newValue, { silent = false } = {}) {
        const { marketToggleChange, checked: prevValue, innerInput } = this;
        if (typeof newValue !== 'boolean')
            return Promise.resolve();
        if (prevValue === newValue)
            return Promise.resolve();
        if (!silent) {
            const { defaultPrevented } = marketToggleChange.emit({
                current: newValue,
                previous: prevValue,
            });
            if (defaultPrevented) {
                return Promise.resolve();
            }
        }
        this.checked = newValue;
        // When using the non-lazy output target, this method sometimes gets called
        // from market-row's watcher after innerInput is removed, hence this check.
        if (innerInput) {
            innerInput.checked = newValue;
        }
        return Promise.resolve();
    }
    /**
     * DEPRECATED (3.x): Toggles `selected` state (unrelated to the HTML attribute `value`).
     */
    setValue(newValue) {
        /* eslint-disable-next-line no-console */
        console.warn("market-toggle's setValue() method has been deprecated. Use setSelection() instead.", this.el);
        this.setSelection(newValue);
        return Promise.resolve();
    }
    /**
     * Sets `active` state. Allows external elements to programmatically
     * trigger active styling, ex. when slotted as a control into `market-row`.
     */
    setActive(value) {
        this.active = value;
        return Promise.resolve();
    }
    /**
     * Sets `hovered` state. Allows external elements to programmatically
     * trigger hover styling, ex. when slotted as a control into `market-row`.
     */
    setHover(value) {
        this.hovered = value;
        return Promise.resolve();
    }
    /**
     * Sets `disabled` state. Allows external elements to programmatically
     * trigger disabled styling, ex. when slotted as a control into `market-row`.
     */
    setDisabled(value) {
        this.disabled = value;
        return Promise.resolve();
    }
    /**
     * Sets `focused` state, except when disabled.
     * Allows external consumers to programmatically
     * trigger focused styling.
     */
    setFocus(value = true) {
        // We don't want to set focus to true if the toggle is disabled,
        // but we do want to allow setting focus to false when disabled,
        // since disabling the toggle causes it to lose browser focus,
        // triggering the onBlur event and calling this method.
        if (this.disabled && value) {
            return Promise.resolve();
        }
        this.focused = value;
        return Promise.resolve();
    }
    handleClick(event) {
        // Always prevent default so we can manually control the selection
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        this.setFocus();
        this.setSelection(!this.checked);
    }
    render() {
        return (hAsync(Host, { key: '951c262c523b48e73f7eac8a34f466946a2f7daa', class: "market-toggle", onBlur: () => {
                this.setFocus(false);
            }, onClick: this.handleClick, onFocus: () => {
                this.setFocus();
            } }, hAsync("input", { key: '4ab242da6a76ba4472ad14478d8f07f4d82c3a77', ref: (el) => (this.innerInput = el), type: "checkbox", role: "switch", "aria-label": getControlInputAriaLabel(this.el), checked: this.checked, disabled: this.disabled }), hAsync("svg", { key: 'f990289d9d5d1f06609c1b4e065e34525ea4e11f', width: "40", height: "24", viewBox: "0 0 40 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true" }, hAsync("rect", { key: '88fcdb713db813a007e1cc07fa9a2562136e1134', x: "1", y: "1", width: "38", height: "22", rx: "11", "stroke-width": "2" }), hAsync("circle", { key: '10e6d92b7936078bc9a2f7a43253c58448c126ca', cx: "12", cy: "12", r: "7" }))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketToggleStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-toggle",
        "$members$": {
            "checked": [1540],
            "disabled": [1540],
            "focused": [1540],
            "hovered": [1540],
            "active": [1540],
            "setSelection": [64],
            "setValue": [64],
            "setActive": [64],
            "setHover": [64],
            "setDisabled": [64],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["checked", "checked"], ["disabled", "disabled"], ["focused", "focused"], ["hovered", "hovered"], ["active", "active"]]
    }; }
}

const marketTooltipCss = "/*!@:host*/.sc-market-tooltip-h{display:inline-block}/*!@:host .market-dropdown*/.sc-market-tooltip-h .market-dropdown.sc-market-tooltip{padding-bottom:0}/*!@:host .market-dropdown .trigger-tap-target*/.sc-market-tooltip-h .market-dropdown.sc-market-tooltip .trigger-tap-target.sc-market-tooltip{display:flex;justify-content:center;align-items:center;min-width:var(--tooltip-minimum-width);min-height:var(--tooltip-minimum-height)}/*!@:host svg, :host ::slotted(svg[slot=\"trigger\"])*/.sc-market-tooltip-h svg.sc-market-tooltip,.sc-market-tooltip-h.sc-market-tooltip-s>svg[slot=\"trigger\"],.sc-market-tooltip-h .sc-market-tooltip-s>svg[slot=\"trigger\"]{fill:var(--tooltip-trigger-icon-normal-state-color);transition:fill\n      var(\n        --tooltip-animation-move-transition-duration,\n        0.3s\n      )\n      ease-out}/*!@:host ::slotted([slot=\"trigger\"]:not(svg))*/.sc-market-tooltip-h .sc-market-tooltip-s>[slot=\"trigger\"]:not(svg){color:var(--tooltip-trigger-text-normal-state-color);transition:color\n      border-bottom\n      var(\n        --tooltip-trigger-animation-fade-transition-duration,\n        0.3s\n      )\n      ease-out;text-decoration-line:underline;text-decoration-style:dashed;text-decoration-color:var(--tooltip-trigger-text-normal-state-color);text-decoration-thickness:var(--tooltip-trigger-text-underline-size);text-underline-position:under;text-underline-offset:2px}/*!@:host([aria-expanded]) svg, :host([aria-expanded]) ::slotted(svg[slot=\"trigger\"])*/[aria-expanded].sc-market-tooltip-h svg.sc-market-tooltip,.sc-market-tooltip-h[aria-expanded].sc-market-tooltip-s>svg[slot=\"trigger\"],.sc-market-tooltip-h[aria-expanded] .sc-market-tooltip-s>svg[slot=\"trigger\"]{fill:var(--tooltip-trigger-icon-active-state-color)}/*!@:host([aria-expanded]) ::slotted([slot=\"trigger\"]:not(svg))*/.sc-market-tooltip-h[aria-expanded] .sc-market-tooltip-s>[slot=\"trigger\"]:not(svg){color:var(--tooltip-trigger-text-active-state-color);text-decoration-color:var(--tooltip-trigger-text-active-state-color)}/*!@:host([disabled]) svg, :host([disabled]) ::slotted(svg[slot=\"trigger\"])*/[disabled].sc-market-tooltip-h svg.sc-market-tooltip,.sc-market-tooltip-h[disabled].sc-market-tooltip-s>svg[slot=\"trigger\"],.sc-market-tooltip-h[disabled] .sc-market-tooltip-s>svg[slot=\"trigger\"]{fill:var(--tooltip-trigger-icon-disabled-state-color)}/*!@:host([disabled]) ::slotted([slot=\"trigger\"]:not(svg))*/.sc-market-tooltip-h[disabled] .sc-market-tooltip-s>[slot=\"trigger\"]:not(svg){color:var(--tooltip-trigger-text-disabled-state-color);text-decoration-color:var(--tooltip-trigger-text-disabled-state-color)}/*!@:host aside*/.sc-market-tooltip-h aside.sc-market-tooltip{max-width:var(--tooltip-maximum-width);padding:var(--tooltip-padding-vertical-size) var(--tooltip-padding-horizontal-size);border-radius:var(--tooltip-radius);background-color:var(--tooltip-background-color);color:var(--tooltip-text-color);box-shadow:var(--elevation-30-shadow);font-weight:var(--tooltip-text-weight);font-size:var(--tooltip-text-size);line-height:var(--tooltip-text-leading);letter-spacing:var(--tooltip-text-tracking);text-transform:var(--tooltip-text-case)}";
var MarketTooltipStyle0 = marketTooltipCss;

/**
 * @slot trigger - The text or icon used for the tooltip trigger. Interacting with the
 * slotted content will serve as the trigger that opens the popover. Defaults to
 * an  icon.
 * @slot content - Content slotted here will appear in `market-popover`, which
 * becomes visible when the slotted trigger content is interacted with.
 * @part dropdown - the market-dropdown element.
 * @part trigger - the trigger element.
 * @part popover - the popover element.
 */
class MarketTooltip {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.marketTooltipOpened = createEvent(this, "marketTooltipOpened", 7);
        this.marketTooltipClosed = createEvent(this, "marketTooltipClosed", 7);
        this.interaction = 'hover';
        this.disabled = false;
        this.popoverPlacement = 'bottom';
        this.popoverStrategy = 'absolute';
        this.popoverSkidding = undefined;
        this.popoverDistance = 0;
        this.expanded = false;
    }
    dropdownOpenedEventHandler(e) {
        if (e.target !== this.el)
            return;
        this.expanded = true;
        this.marketTooltipOpened.emit();
    }
    dropdownClosedEventHandler(e) {
        if (e.target !== this.el)
            return;
        this.expanded = false;
        this.marketTooltipClosed.emit();
    }
    /**
     * Opens the tooltip
     */
    openTooltip() {
        return this.innerDropdown.openDropdown();
    }
    /**
     * Closes the tooltip
     */
    closeTooltip() {
        return this.innerDropdown.closeDropdown();
    }
    styleLinks() {
        // since it isn't possible to style slotted child elements, we need to add
        // inline styles to slotted links in order to style them correctly
        // https://github.com/WICG/webcomponents/issues/594
        // https://github.com/WICG/webcomponents/issues/331
        var _a;
        const slottedLinks = (_a = [...this.el.children]
            .find((child) => child.slot === 'content')) === null || _a === void 0 ? void 0 : _a.querySelectorAll(`a, ${getNamespacedTagFor('market-link')}`);
        slottedLinks.forEach((link) => {
            link.style.color = 'var(--tooltip-link-color)';
            link.style.fontSize = 'var(--tooltip-link-size)';
            link.style.fontWeight = 'var(--tooltip-link-weight)';
            link.style.lineHeight = 'var(--tooltip-link-leading)';
            link.style.letterSpacing = 'var(--tooltip-link-tracking)';
            link.style.textTransform = 'var(--tooltip-link-case)';
            link.style.textDecoration = 'none';
        });
    }
    componentWillRender() {
        this.styleLinks();
    }
    render() {
        const MarketDropdownTagName = getNamespacedTagFor('market-dropdown');
        return (hAsync(Host, { key: '0e12f461ff0600e9e2cc8834e60ca40c9a0fe22c', "aria-expanded": this.expanded, class: "market-tooltip" }, hAsync(MarketDropdownTagName, { key: 'e341826a86a06bc913f13dac950b73222f171055', interaction: this.interaction, "popover-placement": this.popoverPlacement, "popover-strategy": this.popoverStrategy, "popover-distance": this.popoverDistance, "popover-skidding": this.popoverSkidding, disabled: this.disabled, "aria-expanded": this.expanded, part: "dropdown", ref: (el) => (this.innerDropdown = el) }, hAsync("div", { key: '32040d64d0bc3d7b6ba307bf33345b62603728bf', slot: "trigger", part: "trigger", class: "trigger-tap-target" }, hAsync("slot", { key: '8c38a213e0df82c40722fcd9397605904b0b4ca0', name: "trigger" }, hAsync("svg", { key: '64b67d47579f65e4895c266f95610e5ac6133de3', width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { key: '5b6b8cc068c12a938fdb9bc1f83884edd6dbec2b', "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M9 0C4.04 0 0 4.04 0 9C0 13.96 4.04 18 9 18C13.96 18 18 13.96 18 9C18 4.04 13.96 0 9 0ZM9 16C5.14 16 2 12.86 2 9C2 5.14 5.14 2 9 2C12.86 2 16 5.14 16 9C16 12.86 12.86 16 9 16ZM8 7.5V14H10V7.5H8ZM10.25 5.25C10.25 5.94036 9.69036 6.5 9 6.5C8.30964 6.5 7.75 5.94036 7.75 5.25C7.75 4.55964 8.30964 4 9 4C9.69036 4 10.25 4.55964 10.25 5.25Z" })))), hAsync("aside", { key: 'a7b7504162d6d667d7363fdafec7ac9dc3fcac55', slot: "popover", part: "popover" }, hAsync("slot", { key: '4c85381d41b0c8ea63cfc3678c3be2b6e68c05bc', name: "content", onSlotchange: () => this.styleLinks() })))));
    }
    get el() { return getElement(this); }
    static get style() { return MarketTooltipStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-tooltip",
        "$members$": {
            "interaction": [1],
            "disabled": [516],
            "popoverPlacement": [1, "popover-placement"],
            "popoverStrategy": [1, "popover-strategy"],
            "popoverSkidding": [2, "popover-skidding"],
            "popoverDistance": [2, "popover-distance"],
            "expanded": [516],
            "openTooltip": [64],
            "closeTooltip": [64]
        },
        "$listeners$": [[0, "marketDropdownOpened", "dropdownOpenedEventHandler"], [0, "marketDropdownClosed", "dropdownClosedEventHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["expanded", "expanded"]]
    }; }
}

const marketPopoverCss = "/*!@:host, ::slotted(*), **/.sc-market-popover-h,.sc-market-popover-s>*,*.sc-market-popover{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-market-popover-h{cursor:not-allowed !important}/*!@:host([disabled]) *, :host([disabled]) ::slotted(*)*/[disabled].sc-market-popover-h *.sc-market-popover,.sc-market-popover-h[disabled].sc-market-popover-s>*,.sc-market-popover-h[disabled] .sc-market-popover-s>*{cursor:not-allowed !important;pointer-events:none !important}/*!@:host*/.sc-market-popover-h{display:inline-block;overflow-y:auto;min-width:var(--modal-popover-wide-viewport-min-width-size);max-height:var(--modal-popover-wide-viewport-max-height-size);padding:var(--modal-popover-wide-viewport-padding-right-size)\n    var(--modal-popover-wide-viewport-padding-right-size)\n    var(--modal-popover-wide-viewport-padding-right-size)\n    var(--modal-popover-wide-viewport-padding-left-size);border-radius:var(--modal-popover-border-radius);background-color:var(--modal-popover-background-color);box-shadow:var(--elevation-30-shadow)}@media (min-width: 600px){/*!@:host*/.sc-market-popover-h{width:auto}}/*!@::slotted(.market-list)*/.sc-market-popover-s>.market-list{display:block;width:100%;height:100%;margin-bottom:calc(var(--modal-popover-wide-viewport-padding-bottom-size) - var(--popover-padding, 24px))}/*!@::slotted(.market-list:not([has-search]))*/.sc-market-popover-s>.market-list:not([has-search]){margin:calc(var(--popover-content-vertical-padding, 8px) - var(--popover-padding, 24px)) 0}";
var MarketPopoverStyle0 = marketPopoverCss;

/**
 * @slot - Displays whatever you put between `<market-popover>` and `</market-popover>`
 * (can be string literals, Market component(s), HTML element(s), or any combination)
 *
 * If slot contains `<market-list>` elements, `initInteractiveList()` will set the
 * `interactive` property on each instance of `<market-list>` to `true`.
 */
class Popover {
    constructor(hostRef) {
        registerInstance(this, hostRef);
    }
    /* Don't want to force consumers to have to remember to put 'interactive' attribute
      on a <market-list> slotted into this options list, so just set the property on the child
      element here because lists should always be interactive when inside this component */
    initInteractiveList() {
        /* We could just do el.querySelectorAll('market-list') here, but to handle elements that may be multi-slotted
        such as when using this popover inside of a select/filterable element and forwarding the slotted contents into
        the popover, we need to use this assignedElements() method */
        const slot = this.el.querySelector('slot');
        let lists;
        if (slot) {
            lists = slot.assignedElements().filter((el) => el.localName === getNamespacedTagFor('market-list'));
        }
        else {
            /* .querySelectorAll() returns a NodeList and not an array so we need to convert it
             in order to use .map() below */
            lists = [].slice.call(this.el.querySelectorAll(getNamespacedTagFor('market-list')));
        }
        if (lists) {
            lists.forEach((list) => {
                list.interactive = true;
            });
        }
    }
    render() {
        this.initInteractiveList();
        return (hAsync(Host, { key: '8eabe587b426e91c81a0739af9800955a5c31640', class: "market-popover" }, hAsync("slot", { key: 'a7f140e994d37aac481bbde312d2cd2604ab3e12' })));
    }
    get el() { return getElement(this); }
    static get style() { return MarketPopoverStyle0; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "market-popover",
        "$members$": undefined,
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

registerComponents([
  InputText$1,
  InputText,
  MarketAccessory,
  MarketAccordionItem,
  MarketActionCard,
  MarketActivityIndicator,
  MarketActivityIndicatorBar,
  MarketBanner,
  MarketBlade,
  MarketButton,
  MarketButtonDropdown,
  MarketButtonGroup,
  MarketCheckbox,
  MarketChoiceButton,
  MarketCodeDisplay,
  MarketCodeInput,
  MarketColorPicker,
  MarketColorPickerGradient,
  MarketColorPickerInput,
  MarketColorSwatch,
  MarketColorSwatchList,
  MarketContentCard,
  MarketContext,
  MarketContextManager,
  MarketDateInputDate,
  MarketDatePicker,
  MarketDatePickerDate,
  MarketDatePickerMenu,
  MarketDialog,
  MarketDivider,
  MarketDragHandle,
  MarketDropdown,
  MarketEmptyState,
  MarketField,
  MarketFileUpload,
  MarketFilter,
  MarketFilterButton,
  MarketFilterDropdownMenu,
  MarketFilterGroup,
  MarketFooter,
  MarketHeader,
  MarketIcon,
  MarketInlineSectionHeader,
  MarketInlineStatus,
  MarketInputPassword,
  MarketLink,
  MarketList,
  MarketModalFull,
  MarketModalPartial,
  MarketPagination,
  MarketPaginationNav,
  MarketPaginationPageSize,
  MarketPill,
  MarketProgressTracker,
  MarketProgressTrackerStep,
  MarketQrcode,
  MarketRadio,
  MarketRow,
  MarketSegment,
  MarketSegmentedControl,
  MarketSelect,
  MarketSheet,
  MarketStepper,
  MarketTab,
  MarketTabList,
  MarketTabPanel,
  MarketTable,
  MarketTableArea,
  MarketTableCell,
  MarketTableColumn,
  MarketTableRow,
  MarketTableV2,
  MarketTableV2Cell,
  MarketTableV2Group,
  MarketTableV2Row,
  MarketTabs,
  MarketTag,
  MarketTextarea,
  MarketTile,
  MarketToast,
  MarketToaster,
  MarketToggle,
  MarketTooltip,
  Popover,
]);

exports.hydrateApp = hydrateApp;


    /*hydrateAppClosure end*/
    hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
  }

  hydrateAppClosure($stencilWindow);
}

/*
 Stencil Hydrate Runner v4.18.0 | MIT Licensed | https://stenciljs.com
 */
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/runtime/runtime-constants.ts
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var XLINK_NS = "http://www.w3.org/1999/xlink";

// src/mock-doc/attribute.ts
var attrHandler = {
  get(obj, prop) {
    if (prop in obj) {
      return obj[prop];
    }
    if (typeof prop !== "symbol" && !isNaN(prop)) {
      return obj.__items[prop];
    }
    return void 0;
  }
};
var createAttributeProxy = (caseInsensitive) => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
var MockAttributeMap = class {
  constructor(caseInsensitive = false) {
    this.caseInsensitive = caseInsensitive;
    this.__items = [];
  }
  get length() {
    return this.__items.length;
  }
  item(index) {
    return this.__items[index] || null;
  }
  setNamedItem(attr) {
    attr.namespaceURI = null;
    this.setNamedItemNS(attr);
  }
  setNamedItemNS(attr) {
    if (attr != null && attr.value != null) {
      attr.value = String(attr.value);
    }
    const existingAttr = this.__items.find((a) => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
    if (existingAttr != null) {
      existingAttr.value = attr.value;
    } else {
      this.__items.push(attr);
    }
  }
  getNamedItem(attrName) {
    if (this.caseInsensitive) {
      attrName = attrName.toLowerCase();
    }
    return this.getNamedItemNS(null, attrName);
  }
  getNamedItemNS(namespaceURI, attrName) {
    namespaceURI = getNamespaceURI(namespaceURI);
    return this.__items.find((attr) => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null;
  }
  removeNamedItem(attr) {
    this.removeNamedItemNS(attr);
  }
  removeNamedItemNS(attr) {
    for (let i = 0, ii = this.__items.length; i < ii; i++) {
      if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
        this.__items.splice(i, 1);
        break;
      }
    }
  }
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => ({
        done: i === this.length,
        value: this.item(i++)
      })
    };
  }
  get [Symbol.toStringTag]() {
    return "MockAttributeMap";
  }
};
function getNamespaceURI(namespaceURI) {
  return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
  const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
  if (srcAttrs != null) {
    const attrLen = srcAttrs.length;
    if (sortByName && attrLen > 1) {
      const sortedAttrs = [];
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        sortedAttrs.push(dstAttr);
      }
      sortedAttrs.sort(sortAttributes).forEach((attr) => {
        dstAttrs.setNamedItemNS(attr);
      });
    } else {
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        dstAttrs.setNamedItemNS(dstAttr);
      }
    }
  }
  return dstAttrs;
}
function sortAttributes(a, b) {
  if (a.name < b.name)
    return -1;
  if (a.name > b.name)
    return 1;
  return 0;
}
var MockAttr = class {
  constructor(attrName, attrValue, namespaceURI = null) {
    this._name = attrName;
    this._value = String(attrValue);
    this._namespaceURI = namespaceURI;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = String(value);
  }
  get nodeName() {
    return this._name;
  }
  set nodeName(value) {
    this._name = value;
  }
  get nodeValue() {
    return this._value;
  }
  set nodeValue(value) {
    this._value = String(value);
  }
  get namespaceURI() {
    return this._namespaceURI;
  }
  set namespaceURI(namespaceURI) {
    this._namespaceURI = namespaceURI;
  }
};

// src/mock-doc/class-list.ts
var MockClassList = class {
  constructor(elm) {
    this.elm = elm;
  }
  add(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach((className) => {
      className = String(className);
      validateClass(className);
      if (clsNames.includes(className) === false) {
        clsNames.push(className);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, "class", clsNames.join(" "));
    }
  }
  remove(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach((className) => {
      className = String(className);
      validateClass(className);
      const index = clsNames.indexOf(className);
      if (index > -1) {
        clsNames.splice(index, 1);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, "class", clsNames.filter((c) => c.length > 0).join(" "));
    }
  }
  contains(className) {
    className = String(className);
    return getItems(this.elm).includes(className);
  }
  toggle(className) {
    className = String(className);
    if (this.contains(className) === true) {
      this.remove(className);
    } else {
      this.add(className);
    }
  }
  get length() {
    return getItems(this.elm).length;
  }
  item(index) {
    return getItems(this.elm)[index];
  }
  toString() {
    return getItems(this.elm).join(" ");
  }
};
function validateClass(className) {
  if (className === "") {
    throw new Error("The token provided must not be empty.");
  }
  if (/\s/.test(className)) {
    throw new Error(
      `The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`
    );
  }
}
function getItems(elm) {
  const className = elm.getAttribute("class");
  if (typeof className === "string" && className.length > 0) {
    return className.trim().split(" ").filter((c) => c.length > 0);
  }
  return [];
}

// src/mock-doc/css-style-declaration.ts
var MockCSSStyleDeclaration = class {
  constructor() {
    this._styles = /* @__PURE__ */ new Map();
  }
  setProperty(prop, value) {
    prop = jsCaseToCssCase(prop);
    if (value == null || value === "") {
      this._styles.delete(prop);
    } else {
      this._styles.set(prop, String(value));
    }
  }
  getPropertyValue(prop) {
    prop = jsCaseToCssCase(prop);
    return String(this._styles.get(prop) || "");
  }
  removeProperty(prop) {
    prop = jsCaseToCssCase(prop);
    this._styles.delete(prop);
  }
  get length() {
    return this._styles.size;
  }
  get cssText() {
    const cssText = [];
    this._styles.forEach((value, prop) => {
      cssText.push(`${prop}: ${value};`);
    });
    return cssText.join(" ").trim();
  }
  set cssText(cssText) {
    if (cssText == null || cssText === "") {
      this._styles.clear();
      return;
    }
    cssText.split(";").forEach((rule) => {
      rule = rule.trim();
      if (rule.length > 0) {
        const splt = rule.split(":");
        if (splt.length > 1) {
          const prop = splt[0].trim();
          const value = splt.slice(1).join(":").trim();
          if (prop !== "" && value !== "") {
            this._styles.set(jsCaseToCssCase(prop), value);
          }
        }
      }
    });
  }
};
function createCSSStyleDeclaration() {
  return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
var cssProxyHandler = {
  get(cssStyle, prop) {
    if (prop in cssStyle) {
      return cssStyle[prop];
    }
    prop = cssCaseToJsCase(prop);
    return cssStyle.getPropertyValue(prop);
  },
  set(cssStyle, prop, value) {
    if (prop in cssStyle) {
      cssStyle[prop] = value;
    } else {
      cssStyle.setProperty(prop, value);
    }
    return true;
  }
};
function cssCaseToJsCase(str) {
  if (str.length > 1 && str.includes("-") === true) {
    str = str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
    str = str.slice(0, 1).toLowerCase() + str.slice(1);
  }
  return str;
}
function jsCaseToCssCase(str) {
  if (str.length > 1 && str.includes("-") === false && /[A-Z]/.test(str) === true) {
    str = str.replace(/([A-Z])/g, (g) => " " + g[0]).trim().replace(/ /g, "-").toLowerCase();
  }
  return str;
}

// src/mock-doc/custom-element-registry.ts
var MockCustomElementRegistry = class {
  constructor(win) {
    this.win = win;
  }
  define(tagName, cstr, options) {
    if (tagName.toLowerCase() !== tagName) {
      throw new Error(
        `Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`
      );
    }
    if (this.__registry == null) {
      this.__registry = /* @__PURE__ */ new Map();
    }
    this.__registry.set(tagName, { cstr, options });
    if (this.__whenDefined != null) {
      const whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns != null) {
        whenDefinedResolveFns.forEach((whenDefinedResolveFn) => {
          whenDefinedResolveFn();
        });
        whenDefinedResolveFns.length = 0;
        this.__whenDefined.delete(tagName);
      }
    }
    const doc = this.win.document;
    if (doc != null) {
      const hosts = doc.querySelectorAll(tagName);
      hosts.forEach((host) => {
        if (upgradedElements.has(host) === false) {
          tempDisableCallbacks.add(doc);
          const upgradedCmp = createCustomElement(this, doc, tagName);
          for (let i = 0; i < host.childNodes.length; i++) {
            const childNode = host.childNodes[i];
            childNode.remove();
            upgradedCmp.appendChild(childNode);
          }
          tempDisableCallbacks.delete(doc);
          if (proxyElements.has(host)) {
            proxyElements.set(host, upgradedCmp);
          }
        }
        fireConnectedCallback(host);
      });
    }
  }
  get(tagName) {
    if (this.__registry != null) {
      const def = this.__registry.get(tagName.toLowerCase());
      if (def != null) {
        return def.cstr;
      }
    }
    return void 0;
  }
  getName(cstr) {
    for (const [tagName, def] of this.__registry.entries()) {
      if (def.cstr === cstr) {
        return tagName;
      }
    }
    return void 0;
  }
  upgrade(_rootNode) {
  }
  clear() {
    if (this.__registry != null) {
      this.__registry.clear();
    }
    if (this.__whenDefined != null) {
      this.__whenDefined.clear();
    }
  }
  whenDefined(tagName) {
    tagName = tagName.toLowerCase();
    if (this.__registry != null && this.__registry.has(tagName) === true) {
      return Promise.resolve(this.__registry.get(tagName).cstr);
    }
    return new Promise((resolve) => {
      if (this.__whenDefined == null) {
        this.__whenDefined = /* @__PURE__ */ new Map();
      }
      let whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns == null) {
        whenDefinedResolveFns = [];
        this.__whenDefined.set(tagName, whenDefinedResolveFns);
      }
      whenDefinedResolveFns.push(resolve);
    });
  }
};
function createCustomElement(customElements, ownerDocument, tagName) {
  const Cstr = customElements.get(tagName);
  if (Cstr != null) {
    const cmp = new Cstr(ownerDocument);
    cmp.nodeName = tagName.toUpperCase();
    upgradedElements.add(cmp);
    return cmp;
  }
  const host = new Proxy(
    {},
    {
      get(obj, prop) {
        const elm2 = proxyElements.get(host);
        if (elm2 != null) {
          return elm2[prop];
        }
        return obj[prop];
      },
      set(obj, prop, val) {
        const elm2 = proxyElements.get(host);
        if (elm2 != null) {
          elm2[prop] = val;
        } else {
          obj[prop] = val;
        }
        return true;
      },
      has(obj, prop) {
        const elm2 = proxyElements.get(host);
        if (prop in elm2) {
          return true;
        }
        if (prop in obj) {
          return true;
        }
        return false;
      }
    }
  );
  const elm = new MockHTMLElement(ownerDocument, tagName);
  proxyElements.set(host, elm);
  return host;
}
var proxyElements = /* @__PURE__ */ new WeakMap();
var upgradedElements = /* @__PURE__ */ new WeakSet();
function connectNode(ownerDocument, node) {
  node.ownerDocument = ownerDocument;
  if (node.nodeType === 1 /* ELEMENT_NODE */) {
    if (ownerDocument != null && node.nodeName.includes("-")) {
      const win = ownerDocument.defaultView;
      if (win != null && typeof node.connectedCallback === "function" && node.isConnected) {
        fireConnectedCallback(node);
      }
      const shadowRoot = node.shadowRoot;
      if (shadowRoot != null) {
        shadowRoot.childNodes.forEach((childNode) => {
          connectNode(ownerDocument, childNode);
        });
      }
    }
    node.childNodes.forEach((childNode) => {
      connectNode(ownerDocument, childNode);
    });
  } else {
    node.childNodes.forEach((childNode) => {
      childNode.ownerDocument = ownerDocument;
    });
  }
}
function fireConnectedCallback(node) {
  if (typeof node.connectedCallback === "function") {
    if (tempDisableCallbacks.has(node.ownerDocument) === false) {
      try {
        node.connectedCallback();
      } catch (e) {
        console.error(e);
      }
    }
  }
}
function disconnectNode(node) {
  if (node.nodeType === 1 /* ELEMENT_NODE */) {
    if (node.nodeName.includes("-") === true && typeof node.disconnectedCallback === "function") {
      if (tempDisableCallbacks.has(node.ownerDocument) === false) {
        try {
          node.disconnectedCallback();
        } catch (e) {
          console.error(e);
        }
      }
    }
    node.childNodes.forEach(disconnectNode);
  }
}
function attributeChanged(node, attrName, oldValue, newValue) {
  attrName = attrName.toLowerCase();
  const observedAttributes = node.constructor.observedAttributes;
  if (Array.isArray(observedAttributes) === true && observedAttributes.some((obs) => obs.toLowerCase() === attrName) === true) {
    try {
      node.attributeChangedCallback(attrName, oldValue, newValue);
    } catch (e) {
      console.error(e);
    }
  }
}
function checkAttributeChanged(node) {
  return node.nodeName.includes("-") === true && typeof node.attributeChangedCallback === "function";
}
var tempDisableCallbacks = /* @__PURE__ */ new Set();

// src/mock-doc/dataset.ts
function dataset(elm) {
  const ds = {};
  const attributes = elm.attributes;
  const attrLen = attributes.length;
  for (let i = 0; i < attrLen; i++) {
    const attr = attributes.item(i);
    const nodeName = attr.nodeName;
    if (nodeName.startsWith("data-")) {
      ds[dashToPascalCase(nodeName)] = attr.nodeValue;
    }
  }
  return new Proxy(ds, {
    get(_obj, camelCaseProp) {
      return ds[camelCaseProp];
    },
    set(_obj, camelCaseProp, value) {
      const dataAttr = toDataAttribute(camelCaseProp);
      elm.setAttribute(dataAttr, value);
      return true;
    }
  });
}
function toDataAttribute(str) {
  return "data-" + String(str).replace(/([A-Z0-9])/g, (g) => " " + g[0]).trim().replace(/ /g, "-").toLowerCase();
}
function dashToPascalCase(str) {
  str = String(str).slice(5);
  return str.split("-").map((segment, index) => {
    if (index === 0) {
      return segment.charAt(0).toLowerCase() + segment.slice(1);
    }
    return segment.charAt(0).toUpperCase() + segment.slice(1);
  }).join("");
}

// src/mock-doc/event.ts
var MockEvent = class {
  constructor(type, eventInitDict) {
    this.bubbles = false;
    this.cancelBubble = false;
    this.cancelable = false;
    this.composed = false;
    this.currentTarget = null;
    this.defaultPrevented = false;
    this.srcElement = null;
    this.target = null;
    if (typeof type !== "string") {
      throw new Error(`Event type required`);
    }
    this.type = type;
    this.timeStamp = Date.now();
    if (eventInitDict != null) {
      Object.assign(this, eventInitDict);
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.cancelBubble = true;
  }
  /**
   * @ref https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath
   * @returns a composed path of the event
   */
  composedPath() {
    const composedPath = [];
    let currentElement = this.target;
    while (currentElement) {
      composedPath.push(currentElement);
      if (!currentElement.parentElement && currentElement.nodeName === "#document" /* DOCUMENT_NODE */) {
        composedPath.push(currentElement.defaultView);
        break;
      }
      if (currentElement.parentElement == null && currentElement.tagName === "HTML") {
        currentElement = currentElement.ownerDocument;
      } else {
        currentElement = currentElement.parentElement;
      }
    }
    return composedPath;
  }
};
var MockCustomEvent = class extends MockEvent {
  constructor(type, customEventInitDic) {
    super(type);
    this.detail = null;
    if (customEventInitDic != null) {
      Object.assign(this, customEventInitDic);
    }
  }
};
var MockKeyboardEvent = class extends MockEvent {
  constructor(type, keyboardEventInitDic) {
    super(type);
    this.code = "";
    this.key = "";
    this.altKey = false;
    this.ctrlKey = false;
    this.metaKey = false;
    this.shiftKey = false;
    this.location = 0;
    this.repeat = false;
    if (keyboardEventInitDic != null) {
      Object.assign(this, keyboardEventInitDic);
    }
  }
};
var MockMouseEvent = class extends MockEvent {
  constructor(type, mouseEventInitDic) {
    super(type);
    this.screenX = 0;
    this.screenY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.altKey = false;
    this.metaKey = false;
    this.button = 0;
    this.buttons = 0;
    this.relatedTarget = null;
    if (mouseEventInitDic != null) {
      Object.assign(this, mouseEventInitDic);
    }
  }
};
var MockUIEvent = class extends MockEvent {
  constructor(type, uiEventInitDic) {
    super(type);
    this.detail = null;
    this.view = null;
    if (uiEventInitDic != null) {
      Object.assign(this, uiEventInitDic);
    }
  }
};
var MockFocusEvent = class extends MockUIEvent {
  constructor(type, focusEventInitDic) {
    super(type);
    this.relatedTarget = null;
    if (focusEventInitDic != null) {
      Object.assign(this, focusEventInitDic);
    }
  }
};
var MockEventListener = class {
  constructor(type, handler) {
    this.type = type;
    this.handler = handler;
  }
};
function addEventListener(elm, type, handler) {
  const target = elm;
  if (target.__listeners == null) {
    target.__listeners = [];
  }
  target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
  const target = elm;
  if (target != null && Array.isArray(target.__listeners) === true) {
    const elmListener = target.__listeners.find((e) => e.type === type && e.handler === handler);
    if (elmListener != null) {
      const index = target.__listeners.indexOf(elmListener);
      target.__listeners.splice(index, 1);
    }
  }
}
function resetEventListeners(target) {
  if (target != null && target.__listeners != null) {
    target.__listeners = null;
  }
}
function triggerEventListener(elm, ev) {
  if (elm == null || ev.cancelBubble === true) {
    return;
  }
  const target = elm;
  ev.currentTarget = elm;
  if (Array.isArray(target.__listeners) === true) {
    const listeners = target.__listeners.filter((e) => e.type === ev.type);
    listeners.forEach((listener) => {
      try {
        listener.handler.call(target, ev);
      } catch (err2) {
        console.error(err2);
      }
    });
  }
  if (ev.bubbles === false) {
    return;
  }
  if (elm.nodeName === "#document" /* DOCUMENT_NODE */) {
    triggerEventListener(elm.defaultView, ev);
  } else if (elm.parentElement == null && elm.tagName === "HTML") {
    triggerEventListener(elm.ownerDocument, ev);
  } else {
    triggerEventListener(elm.parentElement, ev);
  }
}
function dispatchEvent(currentTarget, ev) {
  ev.target = currentTarget;
  triggerEventListener(currentTarget, ev);
  return true;
}

// node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var REPLACEMENT_CHARACTER = "\uFFFD";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
  CODE_POINTS2[CODE_POINTS2["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
})(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

// node_modules/parse5/dist/common/error-codes.js
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR = ERR || (ERR = {}));

// node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code) {
    const { line, col, offset } = this;
    return {
      code,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset
    };
  }
  _err(code) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 32;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code = this.html.charCodeAt(pos);
    return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};

// node_modules/parse5/dist/common/token.js
var token_exports = {};
__export(token_exports, {
  TokenType: () => TokenType,
  getTokenAttr: () => getTokenAttr
});
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType = TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
}

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/parse5/dist/common/html.js
var html_exports = {};
__export(html_exports, {
  ATTRS: () => ATTRS,
  DOCUMENT_MODE: () => DOCUMENT_MODE,
  NS: () => NS,
  SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
  TAG_ID: () => TAG_ID,
  TAG_NAMES: () => TAG_NAMES,
  getTagID: () => getTagID,
  hasUnescapedText: () => hasUnescapedText,
  isNumberedHeader: () => isNumberedHeader
});
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS = NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS = ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
  TAG_ID2[TAG_ID2["U"] = 117] = "U";
  TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
})(TAG_ID = TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a2;
  return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
var $ = TAG_ID;
var SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([
    $.ADDRESS,
    $.APPLET,
    $.AREA,
    $.ARTICLE,
    $.ASIDE,
    $.BASE,
    $.BASEFONT,
    $.BGSOUND,
    $.BLOCKQUOTE,
    $.BODY,
    $.BR,
    $.BUTTON,
    $.CAPTION,
    $.CENTER,
    $.COL,
    $.COLGROUP,
    $.DD,
    $.DETAILS,
    $.DIR,
    $.DIV,
    $.DL,
    $.DT,
    $.EMBED,
    $.FIELDSET,
    $.FIGCAPTION,
    $.FIGURE,
    $.FOOTER,
    $.FORM,
    $.FRAME,
    $.FRAMESET,
    $.H1,
    $.H2,
    $.H3,
    $.H4,
    $.H5,
    $.H6,
    $.HEAD,
    $.HEADER,
    $.HGROUP,
    $.HR,
    $.HTML,
    $.IFRAME,
    $.IMG,
    $.INPUT,
    $.LI,
    $.LINK,
    $.LISTING,
    $.MAIN,
    $.MARQUEE,
    $.MENU,
    $.META,
    $.NAV,
    $.NOEMBED,
    $.NOFRAMES,
    $.NOSCRIPT,
    $.OBJECT,
    $.OL,
    $.P,
    $.PARAM,
    $.PLAINTEXT,
    $.PRE,
    $.SCRIPT,
    $.SECTION,
    $.SELECT,
    $.SOURCE,
    $.STYLE,
    $.SUMMARY,
    $.TABLE,
    $.TBODY,
    $.TD,
    $.TEMPLATE,
    $.TEXTAREA,
    $.TFOOT,
    $.TH,
    $.THEAD,
    $.TITLE,
    $.TR,
    $.TRACK,
    $.UL,
    $.WBR,
    $.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
function isNumberedHeader(tn) {
  return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
}
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}

// node_modules/parse5/dist/tokenizer/index.js
var C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var State;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
  State2[State2["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
  State2[State2["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
  State2[State2["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State || (State = {}));
var TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric2(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd2(nextCp) {
  return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric2(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
var Tokenizer = class {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code) {
    var _a2, _b;
    (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count) {
    this.consumedAfterSnapshot -= count;
    this.preprocessor.retreat(count);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i = 0; i < count; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a2;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = getTagID(ct.tagName);
    if (ct.type === TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location2 = this.getCurrentLocation(0);
    if (location2) {
      location2.endLine = location2.startLine;
      location2.endCol = location2.startCol;
      location2.endOffset = location2.startOffset;
    }
    this._emitCurrentCharacterToken(location2);
    this.handler.onEof({ type: TokenType.EOF, location: location2 });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i = 0, current = decode_data_html_default[0]; i >= 0; cp = this._consume()) {
      i = determineBranch(decode_data_html_default, current, i + 1, cp);
      if (i < 0)
        break;
      excess += 1;
      current = decode_data_html_default[i];
      const masked = current & BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (cp !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd2(this.preprocessor.peek(1))) {
          result = [CODE_POINTS.AMPERSAND];
          i += valueLength;
        } else {
          result = valueLength === 0 ? [decode_data_html_default[i] & ~BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_data_html_default[++i]] : [decode_data_html_default[++i], decode_data_html_default[++i]];
          excess = 0;
          withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(ERR.missingSemicolonAfterCharacterReference);
    }
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.DATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.RCDATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default:
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === CODE_POINTS.NUMBER_SIGN) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric2(cp)) {
      this.state = State.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    if (this._ensureHibernation()) {
    } else if (matchResult) {
      for (let i = 0; i < matchResult.length; i++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = State.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric2(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;
    } else if (isAsciiDigit(cp)) {
      this.state = State.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 55;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 87;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === CODE_POINTS.NULL) {
      this._err(ERR.nullCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isSurrogate(this.charRefCode)) {
      this._err(ERR.surrogateCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isUndefinedCodePoint(this.charRefCode)) {
      this._err(ERR.noncharacterCharacterReference);
    } else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
      this._err(ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      if (replacement !== void 0) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};

// node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
var SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
  [TAG_ID.APPLET, NS.HTML],
  [TAG_ID.CAPTION, NS.HTML],
  [TAG_ID.HTML, NS.HTML],
  [TAG_ID.MARQUEE, NS.HTML],
  [TAG_ID.OBJECT, NS.HTML],
  [TAG_ID.TABLE, NS.HTML],
  [TAG_ID.TD, NS.HTML],
  [TAG_ID.TEMPLATE, NS.HTML],
  [TAG_ID.TH, NS.HTML],
  [TAG_ID.ANNOTATION_XML, NS.MATHML],
  [TAG_ID.MI, NS.MATHML],
  [TAG_ID.MN, NS.MATHML],
  [TAG_ID.MO, NS.MATHML],
  [TAG_ID.MS, NS.MATHML],
  [TAG_ID.MTEXT, NS.MATHML],
  [TAG_ID.DESC, NS.SVG],
  [TAG_ID.FOREIGN_OBJECT, NS.SVG],
  [TAG_ID.TITLE, NS.SVG]
]);
var NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6];
var TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
var OpenElementStack = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document;
  }
  //Index of element
  _indexOf(element) {
    return this.items.lastIndexOf(element, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element;
    this.current = element;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element) {
    const idx = this._indexOf(element);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element) {
    const idx = this._indexOf(element);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    const elementIdx = this._indexOf(element) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (isNumberedHeader(tn) && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (tn === TAG_ID.BUTTON && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};

// node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType = EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i = 0; i < this.entries.length; i++) {
      const entry = this.entries[i];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element } = entry;
      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.unshift({
      type: EntryType.Element,
      element,
      token
    });
  }
  insertElementAfterBookmark(element, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex >= 0) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx >= 0) {
      this.entries.splice(0, markerIdx + 1);
    } else {
      this.entries.length = 0;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
  }
};

// node_modules/parse5/dist/tree-adapters/default.js
function createTextNode(value) {
  return {
    nodeName: "#text",
    value,
    parentNode: null
  };
}
var defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data) {
    return {
      nodeName: "#comment",
      data,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document, name, publicId, systemId) {
    const doctypeNode = document.childNodes.find((node) => node.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node = {
        nodeName: "#documentType",
        name,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(document, node);
    }
  },
  setDocumentMode(document, mode) {
    document.mode = mode;
  },
  getDocumentMode(document) {
    return document.mode;
  },
  detachNode(node) {
    if (node.parentNode) {
      const idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  insertText(parentNode, text) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, createTextNode(text));
  },
  insertTextBefore(parentNode, text, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text;
    } else {
      defaultTreeAdapter.insertBefore(parentNode, createTextNode(text), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
    for (let j = 0; j < attrs.length; j++) {
      if (!recipientAttrsMap.has(attrs[j].name)) {
        recipient.attrs.push(attrs[j]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.childNodes[0];
  },
  getChildNodes(node) {
    return node.childNodes;
  },
  getParentNode(node) {
    return node.parentNode;
  },
  getAttrList(element) {
    return element.attrs;
  },
  //Node data
  getTagName(element) {
    return element.tagName;
  },
  getNamespaceURI(element) {
    return element.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node) {
    return node.nodeName === "#text";
  },
  isCommentNode(node) {
    return node.nodeName === "#comment";
  },
  isDocumentTypeNode(node) {
    return node.nodeName === "#documentType";
  },
  isElementNode(node) {
    return Object.prototype.hasOwnProperty.call(node, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node, location2) {
    node.sourceCodeLocation = location2;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
  }
};

// node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = "html";
var VALID_SYSTEM_ID = "about:legacy-compat";
var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

// node_modules/parse5/dist/common/foreign-content.js
var foreign_content_exports = {};
__export(foreign_content_exports, {
  SVG_TAG_NAMES_ADJUSTMENT_MAP: () => SVG_TAG_NAMES_ADJUSTMENT_MAP,
  adjustTokenMathMLAttrs: () => adjustTokenMathMLAttrs,
  adjustTokenSVGAttrs: () => adjustTokenSVGAttrs,
  adjustTokenSVGTagName: () => adjustTokenSVGTagName,
  adjustTokenXMLAttrs: () => adjustTokenXMLAttrs,
  causesExit: () => causesExit,
  isIntegrationPoint: () => isIntegrationPoint
});
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl";
var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr) => [attr.toLowerCase(), attr]));
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: NS.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrName != null) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === ATTRS.ENCODING) {
        const value = attrs[i].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}

// node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
var Parser = class {
  constructor(options, document, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html, options) {
    const parser = new this(options);
    parser.tokenizer.write(html, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token, code, beforeToken) {
    var _a2;
    if (!this.onParseError)
      return;
    const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
    const err2 = {
      code,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err2);
  }
  //Stack events
  onItemPush(node, tid, isTop) {
    var _a2, _b;
    (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node, tid);
  }
  onItemPop(node, isTop) {
    var _a2, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node, this.currentToken);
    }
    (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    while (node) {
      if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      default:
    }
  }
  //Tree mutation
  _setDocumentType(token) {
    const name = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  _attachElementToTree(element, location2) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location2 && {
        ...location2,
        startTag: location2
      };
      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent, element);
    }
  }
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
  }
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
    this.openElements.push(element, token.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element, null);
    this.openElements.push(element, tagID);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element, null);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element, TAG_ID.HTML);
  }
  _appendCommentNode(token, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  _insertCharacters(token) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token.chars);
    }
    if (!token.location)
      return;
    const siblings = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
    const textNode = siblings[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: { ...ctLoc },
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
    );
  }
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent = this.treeAdapter.getParentNode(openElement);
          if (parent) {
            return { parent, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i - 1], beforeElement: null };
        }
        default:
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element) {
    const location2 = this._findFosterParentingLocation();
    if (location2.beforeElement) {
      this.treeAdapter.insertBefore(location2.parent, element, location2.beforeElement);
    } else {
      this.treeAdapter.appendChild(location2.parent, element);
    }
  }
  //Special elements
  _isSpecialElement(element, id) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    return SPECIAL_ELEMENTS[ns].has(id);
  }
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      default:
    }
  }
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      default:
    }
  }
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      default:
    }
  }
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      default:
    }
  }
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      default:
    }
  }
};
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element = p.openElements.items[idx];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p, token) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
  p.stopped = true;
  if (token.location) {
    const target = p.fragmentContext ? 0 : 2;
    for (let i = p.openElements.stackTop; i >= target; i--) {
      p._setEndLocation(p.openElements.items[i], token);
    }
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p._err(token, ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
  p._err(token, ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
function startTagBeforeHtml(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
function startTagBeforeHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.HEAD: {
      p._insertElement(token, NS.HTML);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p, token);
    }
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
    tokenBeforeHead(p, token);
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p._insertTemplate(token);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_TEMPLATE;
      p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p, token);
    }
  }
}
function endTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p, token);
    }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BODY: {
      p._insertElement(token, NS.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p._err(token, ERR.abandonedHeadElementChild);
      p.openElements.push(p.headElement, TAG_ID.HEAD);
      startTagInHead(p, token);
      p.openElements.remove(p.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p, token);
    }
  }
}
function endTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function modeInBody(p, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p, token);
      break;
    }
    default:
  }
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  if (isNumberedHeader(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const elementId = p.openElements.tagIDs[i];
    if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.tokenizer.state = TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody(p, token) {
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagId === TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.MATHML);
  } else {
    p._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.SVG);
  } else {
    p._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function startTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOEMBED: {
      noembedStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        noembedStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p, token);
    }
  }
}
function bodyEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p, token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const { formElement } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    const elementId = p.openElements.tagIDs[i];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i)
        p.openElements.shortenToLength(i);
      break;
    }
    if (p._isSpecialElement(element, elementId)) {
      break;
    }
  }
}
function endTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      genericEndTagInBody(p, token);
    }
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p, token);
  } else {
    stopParsing(p, token);
  }
}
function endTagInText(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(token, ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
function characterInTable(p, token) {
  if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p, token);
        break;
      }
    }
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p, token);
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function endTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable(p, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.COL: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function endTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
function startTagInTableBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p.openElements.clearBackToTableBodyContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableBodyContext();
      p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableRowContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_CELL;
      p.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInCell(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
      p._closeTableCell();
      startTagInRow(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(tn)) {
        p._closeTableCell();
        endTagInRow(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default:
  }
}
function startTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}
function startTagInTemplate(p, token) {
  switch (token.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
      break;
    }
    case TAG_ID.COL: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p, token);
      break;
    }
    case TAG_ID.TR: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    default: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p, token);
    }
  }
}
function endTagInTemplate(p, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing(p, token);
  }
}
function startTagAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
      p._setEndLocation(p.openElements.items[0], token);
      const bodyElement = p.openElements.items[1];
      if (bodyElement && !((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagInFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInFrameset(p, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagAfterAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function nullCharacterInForeignContent(p, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
    p.openElements.pop();
  }
}
function startTagInForeignContent(p, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p.openElements.shortenToLength(i);
      break;
    }
  }
}

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function getEscaper(regex, map2) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);

// node_modules/parse5/dist/index.js
function parse(html, options) {
  return Parser.parse(html, options);
}
function parseFragment(fragmentContext, html, options) {
  if (typeof fragmentContext === "string") {
    options = html;
    html = fragmentContext;
    fragmentContext = null;
  }
  const parser = Parser.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html, true);
  return parser.getFragment();
}

// src/mock-doc/parse-util.ts
var docParser = /* @__PURE__ */ new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
  const doc = parse(html.trim(), getParser(ownerDocument));
  doc.documentElement = doc.firstElementChild;
  doc.head = doc.documentElement.firstElementChild;
  doc.body = doc.head.nextElementSibling;
  return doc;
}
function parseFragmentUtil(ownerDocument, html) {
  if (typeof html === "string") {
    html = html.trim();
  } else {
    html = "";
  }
  const frag = parseFragment(html, getParser(ownerDocument));
  return frag;
}
function getParser(ownerDocument) {
  let parseOptions = docParser.get(ownerDocument);
  if (parseOptions != null) {
    return parseOptions;
  }
  const treeAdapter = {
    createDocument() {
      const doc = ownerDocument.createElement("#document" /* DOCUMENT_NODE */);
      doc["x-mode"] = "no-quirks";
      return doc;
    },
    setNodeSourceCodeLocation(node, location2) {
      node.sourceCodeLocation = location2;
    },
    getNodeSourceCodeLocation(node) {
      return node.sourceCodeLocation;
    },
    createDocumentFragment() {
      return ownerDocument.createDocumentFragment();
    },
    createElement(tagName, namespaceURI, attrs) {
      const elm = ownerDocument.createElementNS(namespaceURI, tagName);
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.namespace == null || attr.namespace === "http://www.w3.org/1999/xhtml") {
          elm.setAttribute(attr.name, attr.value);
        } else {
          elm.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
      return elm;
    },
    createCommentNode(data) {
      return ownerDocument.createComment(data);
    },
    appendChild(parentNode, newNode) {
      parentNode.appendChild(newNode);
    },
    insertBefore(parentNode, newNode, referenceNode) {
      parentNode.insertBefore(newNode, referenceNode);
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(doc, name, publicId, systemId) {
      let doctypeNode = doc.childNodes.find((n) => n.nodeType === 10 /* DOCUMENT_TYPE_NODE */);
      if (doctypeNode == null) {
        doctypeNode = ownerDocument.createDocumentTypeNode();
        doc.insertBefore(doctypeNode, doc.firstChild);
      }
      doctypeNode.nodeValue = "!DOCTYPE";
      doctypeNode["x-name"] = name;
      doctypeNode["x-publicId"] = publicId;
      doctypeNode["x-systemId"] = systemId;
    },
    setDocumentMode(doc, mode) {
      doc["x-mode"] = mode;
    },
    getDocumentMode(doc) {
      return doc["x-mode"];
    },
    detachNode(node) {
      node.remove();
    },
    insertText(parentNode, text) {
      const lastChild = parentNode.lastChild;
      if (lastChild != null && lastChild.nodeType === 3 /* TEXT_NODE */) {
        lastChild.nodeValue += text;
      } else {
        parentNode.appendChild(ownerDocument.createTextNode(text));
      }
    },
    insertTextBefore(parentNode, text, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode != null && prevNode.nodeType === 3 /* TEXT_NODE */) {
        prevNode.nodeValue += text;
      } else {
        parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
          recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
    },
    getFirstChild(node) {
      return node.childNodes[0];
    },
    getChildNodes(node) {
      return node.childNodes;
    },
    getParentNode(node) {
      return node.parentNode;
    },
    getAttrList(element) {
      const attrs = element.attributes.__items.map((attr) => {
        return {
          name: attr.name,
          value: attr.value,
          namespace: attr.namespaceURI,
          prefix: null
        };
      });
      return attrs;
    },
    getTagName(element) {
      if (element.namespaceURI === "http://www.w3.org/1999/xhtml") {
        return element.nodeName.toLowerCase();
      } else {
        return element.nodeName;
      }
    },
    getNamespaceURI(element) {
      return element.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.nodeValue;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.nodeValue;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode["x-name"];
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode["x-publicId"];
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode["x-systemId"];
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['text']`. As a result, we cannot
    // complete this function signature
    isTextNode(node) {
      return node.nodeType === 3 /* TEXT_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['comment']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isCommentNode(node) {
      return node.nodeType === 8 /* COMMENT_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['document']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isDocumentTypeNode(node) {
      return node.nodeType === 10 /* DOCUMENT_TYPE_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['element']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isElementNode(node) {
      return node.nodeType === 1 /* ELEMENT_NODE */;
    }
  };
  parseOptions = {
    treeAdapter
  };
  docParser.set(ownerDocument, parseOptions);
  return parseOptions;
}

// src/mock-doc/third-party/jquery.ts
var jquery_default = (
  /*!
  * jQuery JavaScript Library v4.0.0-pre+9352011a7.dirty +selector
  * https://jquery.com/
  *
  * Copyright OpenJS Foundation and other contributors
  * Released under the MIT license
  * https://jquery.org/license
  *
  * Date: 2023-12-11T17:55Z
  */
  function(global2, factory) {
    "use strict";
    if (true) {
      return factory(global2, true);
    } else {
      factory(global2);
    }
  }({
    document: {
      createElement() {
        return {};
      },
      nodeType: 9,
      documentElement: {
        nodeType: 1,
        nodeName: "HTML"
      }
    }
  }, function(window, noGlobal) {
    "use strict";
    if (!window.document) {
      throw new Error("jQuery requires a window with a document");
    }
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = arr.flat ? function(array) {
      return arr.flat.call(array);
    } : function(array) {
      return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    function isWindow(obj) {
      return obj != null && obj === obj.window;
    }
    function isArrayLike(obj) {
      var length = !!obj && obj.length, type = toType(obj);
      if (typeof obj === "function" || isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var document = window.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node, doc) {
      doc = doc || document;
      var i2, script = doc.createElement("script");
      script.text = code;
      if (node) {
        for (i2 in preservedScriptAttributes) {
          if (node[i2]) {
            script[i2] = node[i2];
          }
        }
      }
      doc.head.appendChild(script).parentNode.removeChild(script);
    }
    const jQuery = {};
    var version = "4.0.0-pre+9352011a7.dirty +selector", rhtmlSuffix = /HTML$/i, jQueryOrig = function(selector, context) {
      return new jQuery.fn.init(selector, context);
    };
    jQuery.fn = jQuery.prototype = {
      // The current version of jQuery being used
      jquery: version,
      constructor: jQuery,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(num) {
        if (num == null) {
          return slice.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(elems) {
        var ret = jQuery.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function(callback) {
        return jQuery.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery.map(this, function(elem, i2) {
          return callback.call(elem, i2, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i2) {
          return (i2 + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i2) {
          return i2 % 2;
        }));
      },
      eq: function(i2) {
        var len = this.length, j = +i2 + (i2 < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      }
    };
    jQuery.extend = jQuery.fn.extend = function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i2] || {};
        i2++;
      }
      if (typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      if (i2 === length) {
        target = this;
        i2--;
      }
      for (; i2 < length; i2++) {
        if ((options = arguments[i2]) != null) {
          for (name in options) {
            copy = options[name];
            if (name === "__proto__" || target === copy) {
              continue;
            }
            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              src = target[name];
              if (copyIsArray && !Array.isArray(src)) {
                clone = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                clone = {};
              } else {
                clone = src;
              }
              copyIsArray = false;
              target[name] = jQuery.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name;
        for (name in obj) {
          return false;
        }
        return true;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function(code, options, doc) {
        DOMEval(code, { nonce: options && options.nonce }, doc);
      },
      each: function(obj, callback) {
        var length, i2 = 0;
        if (isArrayLike(obj)) {
          length = obj.length;
          for (; i2 < length; i2++) {
            if (callback.call(obj[i2], i2, obj[i2]) === false) {
              break;
            }
          }
        } else {
          for (i2 in obj) {
            if (callback.call(obj[i2], i2, obj[i2]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      // Retrieve the text value of an array of DOM nodes
      text: function(elem) {
        var node, ret = "", i2 = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          while (node = elem[i2++]) {
            ret += jQuery.text(node);
          }
        }
        if (nodeType === 1 || nodeType === 11) {
          return elem.textContent;
        }
        if (nodeType === 9) {
          return elem.documentElement.textContent;
        }
        if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      },
      // results is for internal usage only
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike(Object(arr2))) {
            jQuery.merge(
              ret,
              typeof arr2 === "string" ? [arr2] : arr2
            );
          } else {
            push.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i2) {
        return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
      },
      isXMLDoc: function(elem) {
        var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
        return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
      },
      // Note: an element does not contain itself
      contains: function(a, b) {
        var bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      },
      merge: function(first, second) {
        var len = +second.length, j = 0, i2 = first.length;
        for (; j < len; j++) {
          first[i2++] = second[j];
        }
        first.length = i2;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches3 = [], i2 = 0, length = elems.length, callbackExpect = !invert;
        for (; i2 < length; i2++) {
          callbackInverse = !callback(elems[i2], i2);
          if (callbackInverse !== callbackExpect) {
            matches3.push(elems[i2]);
          }
        }
        return matches3;
      },
      // arg is for internal usage only
      map: function(elems, callback, arg) {
        var length, value, i2 = 0, ret = [];
        if (isArrayLike(elems)) {
          length = elems.length;
          for (; i2 < length; i2++) {
            value = callback(elems[i2], i2, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i2 in elems) {
            value = callback(elems[i2], i2, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support
    });
    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      }
    );
    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var pop = arr.pop;
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var isIE = document.documentMode;
    try {
      document.querySelector(":has(*,:jqfake)");
      support.cssHas = false;
    } catch (e) {
      support.cssHas = true;
    }
    var rbuggyQSA = [];
    if (isIE) {
      rbuggyQSA.push(
        // Support: IE 9 - 11+
        // IE's :disabled selector does not pick up the children of disabled fieldsets
        ":enabled",
        ":disabled",
        // Support: IE 11+
        // IE 11 doesn't find elements on a `[name='']` query in some cases.
        // Adding a temporary attribute to the document before the selection works
        // around the issue.
        "\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`
      );
    }
    if (!support.cssHas) {
      rbuggyQSA.push(":has");
    }
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    var rtrimCSS = new RegExp(
      "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
      "g"
    );
    var identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+";
    var booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped";
    var rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*");
    var rdescend = new RegExp(whitespace + "|>");
    var rsibling = /[+~]/;
    var documentElement = document.documentElement;
    var matches2 = documentElement.matches || documentElement.msMatchesSelector;
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > jQuery.expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key + " "] = value;
      }
      return cache;
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    var attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]";
    var pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)";
    var filterMatchExpr = {
      ID: new RegExp("^#(" + identifier + ")"),
      CLASS: new RegExp("^\\.(" + identifier + ")"),
      TAG: new RegExp("^(" + identifier + "|[*])"),
      ATTR: new RegExp("^" + attributes),
      PSEUDO: new RegExp("^" + pseudos),
      CHILD: new RegExp(
        "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
        "i"
      )
    };
    var rpseudo = new RegExp(pseudos);
    var runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
      var high = "0x" + escape.slice(1) - 65536;
      if (nonHex) {
        return nonHex;
      }
      return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
    };
    function unescapeSelector(sel) {
      return sel.replace(runescape, funescape);
    }
    function selectorError(msg) {
      jQuery.error("Syntax error, unrecognized expression: " + msg);
    }
    var rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*");
    var tokenCache = createCache();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = jQuery.expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rleadingCombinator.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrimCSS, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in filterMatchExpr) {
          if ((match = jQuery.expr.match[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      if (parseOnly) {
        return soFar.length;
      }
      return soFar ? selectorError(selector) : (
        // Cache the tokens
        tokenCache(selector, groups).slice(0)
      );
    }
    var preFilter = {
      ATTR: function(match) {
        match[1] = unescapeSelector(match[1]);
        match[3] = unescapeSelector(match[3] || match[4] || match[5] || "");
        if (match[2] === "~=") {
          match[3] = " " + match[3] + " ";
        }
        return match.slice(0, 4);
      },
      CHILD: function(match) {
        match[1] = match[1].toLowerCase();
        if (match[1].slice(0, 3) === "nth") {
          if (!match[3]) {
            selectorError(match[0]);
          }
          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
          match[5] = +(match[7] + match[8] || match[3] === "odd");
        } else if (match[3]) {
          selectorError(match[0]);
        }
        return match;
      },
      PSEUDO: function(match) {
        var excess, unquoted = !match[6] && match[2];
        if (filterMatchExpr.CHILD.test(match[0])) {
          return null;
        }
        if (match[3]) {
          match[2] = match[4] || match[5] || "";
        } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
        (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
        (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        }
        return match.slice(0, 3);
      }
    };
    function toSelector(tokens) {
      var i2 = 0, len = tokens.length, selector = "";
      for (; i2 < len; i2++) {
        selector += tokens[i2].value;
      }
      return selector;
    }
    var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
    function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        if (ch === "\0") {
          return "\uFFFD";
        }
        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      }
      return "\\" + ch;
    }
    jQuery.escapeSelector = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    var sort = arr.sort;
    var splice = arr.splice;
    var hasDuplicate;
    function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }
      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
      if (compare) {
        return compare;
      }
      compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
        // Otherwise we know they are disconnected
        1
      );
      if (compare & 1) {
        if (a == document || a.ownerDocument == document && jQuery.contains(document, a)) {
          return -1;
        }
        if (b == document || b.ownerDocument == document && jQuery.contains(document, b)) {
          return 1;
        }
        return 0;
      }
      return compare & 4 ? -1 : 1;
    }
    jQuery.uniqueSort = function(results) {
      var elem, duplicates = [], j = 0, i2 = 0;
      hasDuplicate = false;
      sort.call(results, sortOrder);
      if (hasDuplicate) {
        while (elem = results[i2++]) {
          if (elem === results[i2]) {
            j = duplicates.push(i2);
          }
        }
        while (j--) {
          splice.call(results, duplicates[j], 1);
        }
      }
      return results;
    };
    jQuery.fn.uniqueSort = function() {
      return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
    };
    var i, outermostContext, document$1, documentElement$1, documentIsHTML, dirruns = 0, done = 0, classCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), rwhitespace = new RegExp(whitespace + "+", "g"), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = jQuery.extend({
      bool: new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    }, filterMatchExpr), rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, unloadHandler = function() {
      setDocument();
    }, inDisabledFieldset = addCombinator(
      function(elem) {
        return elem.disabled === true && nodeName(elem, "fieldset");
      },
      { dir: "parentNode", next: "legend" }
    );
    function find(selector, context, results, seed) {
      var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (false) {
        setDocument(context);
        context = context || document$1;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if (m = match[1]) {
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  push.call(results, elem);
                }
                return results;
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && jQuery.contains(context, elem)) {
                  push.call(results, elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            newSelector = selector;
            newContext = context;
            if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              if (newContext != context || isIE) {
                if (nid = context.getAttribute("id")) {
                  nid = jQuery.escapeSelector(nid);
                } else {
                  context.setAttribute("id", nid = jQuery.expando);
                }
              }
              groups = tokenize(selector);
              i2 = groups.length;
              while (i2--) {
                groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
              }
              newSelector = groups.join(",");
            }
            try {
              push.apply(
                results,
                newContext.querySelectorAll(newSelector)
              );
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === jQuery.expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
    }
    function markFunction(fn) {
      fn[jQuery.expando] = true;
      return fn;
    }
    function createInputPseudo(type) {
      return function(elem) {
        return nodeName(elem, "input") && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function(elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches3) {
          var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
          while (i2--) {
            if (seed[j = matchIndexes[i2]]) {
              seed[j] = !(matches3[j] = seed[j]);
            }
          }
        });
      });
    }
    function setDocument(node) {
      var subWindow, doc = node ? node.ownerDocument || node : document;
      if (doc == document$1 || doc.nodeType !== 9) {
        return;
      }
      document$1 = doc;
      documentElement$1 = document$1.documentElement;
      documentIsHTML = !jQuery.isXMLDoc(document$1);
      if (isIE && document != document$1 && (subWindow = document$1.defaultView) && subWindow.top !== subWindow) {
        subWindow.addEventListener("unload", unloadHandler);
      }
    }
    find.matches = function(expr, elements) {
      return find(expr, null, null, elements);
    };
    find.matchesSelector = function(elem, expr) {
      setDocument(elem);
      if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          return matches2.call(elem, expr);
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }
      return find(expr, document$1, null, [elem]).length > 0;
    };
    jQuery.expr = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      find: {
        ID: function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        },
        TAG: function(tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag);
          } else {
            return context.querySelectorAll(tag);
          }
        },
        CLASS: function(className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        }
      },
      relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
      },
      preFilter,
      filter: {
        ID: function(id) {
          var attrId = unescapeSelector(id);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        },
        TAG: function(nodeNameSelector) {
          var expectedNodeName = unescapeSelector(nodeNameSelector).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return nodeName(elem, expectedNodeName);
          };
        },
        CLASS: function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(
              typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
            );
          });
        },
        ATTR: function(name, operator, check) {
          return function(elem) {
            var result = elem.getAttribute(name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            if (operator === "=") {
              return result === check;
            }
            if (operator === "!=") {
              return result !== check;
            }
            if (operator === "^=") {
              return check && result.indexOf(check) === 0;
            }
            if (operator === "*=") {
              return check && result.indexOf(check) > -1;
            }
            if (operator === "$=") {
              return check && result.slice(-check.length) === check;
            }
            if (operator === "~=") {
              return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
            }
            if (operator === "|=") {
              return result === check || result.slice(0, check.length + 1) === check + "-";
            }
            return false;
          };
        },
        CHILD: function(type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
          return first === 1 && last === 0 ? (
            // Shortcut for :nth-*(n)
            function(elem) {
              return !!elem.parentNode;
            }
          ) : function(elem, _context, xml) {
            var cache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[jQuery.expando] || (parent[jQuery.expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start
                (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  outerCache = elem[jQuery.expando] || (elem[jQuery.expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[jQuery.expando] || (node[jQuery.expando] = {});
                        outerCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        PSEUDO: function(pseudo, argument) {
          var fn = jQuery.expr.pseudos[pseudo] || jQuery.expr.setFilters[pseudo.toLowerCase()] || selectorError("unsupported pseudo: " + pseudo);
          if (fn[jQuery.expando]) {
            return fn(argument);
          }
          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        not: markFunction(function(selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
          return matcher[jQuery.expando] ? markFunction(function(seed, matches3, _context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
            while (i2--) {
              if (elem = unmatched[i2]) {
                seed[i2] = !(matches3[i2] = elem);
              }
            }
          }) : function(elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        has: markFunction(function(selector) {
          return function(elem) {
            return find(selector, elem).length > 0;
          };
        }),
        contains: markFunction(function(text) {
          text = unescapeSelector(text);
          return function(elem) {
            return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // https://www.w3.org/TR/selectors/#lang-pseudo
        lang: markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            selectorError("unsupported lang: " + lang);
          }
          lang = unescapeSelector(lang).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        // Miscellaneous
        target: function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        root: function(elem) {
          return elem === documentElement$1;
        },
        focus: function(elem) {
          return elem === document$1.activeElement && document$1.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        enabled: createDisabledPseudo(false),
        disabled: createDisabledPseudo(true),
        checked: function(elem) {
          return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
        },
        selected: function(elem) {
          if (isIE && elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        // Contents
        empty: function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        parent: function(elem) {
          return !jQuery.expr.pseudos.empty(elem);
        },
        // Element/input types
        header: function(elem) {
          return rheader.test(elem.nodeName);
        },
        input: function(elem) {
          return rinputs.test(elem.nodeName);
        },
        button: function(elem) {
          return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
        },
        text: function(elem) {
          return nodeName(elem, "input") && elem.type === "text";
        },
        // Position-in-collection
        first: createPositionalPseudo(function() {
          return [0];
        }),
        last: createPositionalPseudo(function(_matchIndexes, length) {
          return [length - 1];
        }),
        eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        even: createPositionalPseudo(function(matchIndexes, length) {
          var i2 = 0;
          for (; i2 < length; i2 += 2) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        }),
        odd: createPositionalPseudo(function(matchIndexes, length) {
          var i2 = 1;
          for (; i2 < length; i2 += 2) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        }),
        lt: createPositionalPseudo(function(matchIndexes, length, argument) {
          var i2;
          if (argument < 0) {
            i2 = argument + length;
          } else if (argument > length) {
            i2 = length;
          } else {
            i2 = argument;
          }
          for (; --i2 >= 0; ) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        }),
        gt: createPositionalPseudo(function(matchIndexes, length, argument) {
          var i2 = argument < 0 ? argument + length : argument;
          for (; ++i2 < length; ) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        })
      }
    };
    jQuery.expr.pseudos.nth = jQuery.expr.pseudos.eq;
    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
      jQuery.expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in { submit: true, reset: true }) {
      jQuery.expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = jQuery.expr.filters = jQuery.expr.pseudos;
    jQuery.expr.setFilters = new setFilters();
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
      return combinator.first ? (
        // Check against closest ancestor/preceding element
        function(elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }
          return false;
        }
      ) : (
        // Check against all ancestor/preceding elements
        function(elem, context, xml) {
          var oldCache, outerCache, newCache = [dirruns, doneName];
          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[jQuery.expando] || (elem[jQuery.expando] = {});
                if (skip && nodeName(elem, skip)) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  return newCache[2] = oldCache[2];
                } else {
                  outerCache[key] = newCache;
                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        }
      );
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i2 = matchers.length;
        while (i2--) {
          if (!matchers[i2](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i2 = 0, len = contexts.length;
      for (; i2 < len; i2++) {
        find(selector, contexts[i2], results);
      }
      return results;
    }
    function condense(unmatched, map2, filter, context, xml) {
      var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
      for (; i2 < len; i2++) {
        if (elem = unmatched[i2]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map2.push(i2);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter2, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[jQuery.expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[jQuery.expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
          selector || "*",
          context.nodeType ? [context] : context,
          []
        ), matcherIn = preFilter2 && (seed || !selector) ? condense(elems, preMap, preFilter2, context, xml) : elems;
        if (matcher) {
          matcherOut = postFinder || (seed ? preFilter2 : preexisting || postFilter) ? (
            // ...intermediate processing is necessary
            []
          ) : (
            // ...otherwise use results directly
            results
          );
          matcher(matcherIn, matcherOut, context, xml);
        } else {
          matcherOut = matcherIn;
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i2 = temp.length;
          while (i2--) {
            if (elem = temp[i2]) {
              matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter2) {
            if (postFinder) {
              temp = [];
              i2 = matcherOut.length;
              while (i2--) {
                if (elem = matcherOut[i2]) {
                  temp.push(matcherIn[i2] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i2 = matcherOut.length;
            while (i2--) {
              if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i2]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(
            matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
          );
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = jQuery.expr.relative[tokens[0].type], implicitRelative = leadingRelative || jQuery.expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
        return elem === checkContext;
      }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
        return indexOf.call(checkContext, elem) > -1;
      }, implicitRelative, true), matchers = [function(elem, context, xml) {
        var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
        checkContext = null;
        return ret;
      }];
      for (; i2 < len; i2++) {
        if (matcher = jQuery.expr.relative[tokens[i2].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = jQuery.expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
          if (matcher[jQuery.expando]) {
            j = ++i2;
            for (; j < len; j++) {
              if (jQuery.expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(
              i2 > 1 && elementMatcher(matchers),
              i2 > 1 && toSelector(
                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
              ).replace(rtrimCSS, "$1"),
              matcher,
              i2 < j && matcherFromTokens(tokens.slice(i2, j)),
              j < len && matcherFromTokens(tokens = tokens.slice(j)),
              j < len && toSelector(tokens)
            );
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
        var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && jQuery.expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
        if (outermost) {
          outermostContext = context == document$1 || context || outermost;
        }
        for (; (elem = elems[i2]) != null; i2++) {
          if (byElement && elem) {
            j = 0;
            if (!context && elem.ownerDocument != document$1) {
              setDocument(elem);
              xml = !documentIsHTML;
            }
            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document$1, xml)) {
                push.call(results, elem);
                break;
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
            }
          }
          if (bySet) {
            if (elem = !matcher && elem) {
              matchedCount--;
            }
            if (seed) {
              unmatched.push(elem);
            }
          }
        }
        matchedCount += i2;
        if (bySet && i2 !== matchedCount) {
          j = 0;
          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }
          if (seed) {
            if (matchedCount > 0) {
              while (i2--) {
                if (!(unmatched[i2] || setMatched[i2])) {
                  setMatched[i2] = pop.call(results);
                }
              }
            }
            setMatched = condense(setMatched);
          }
          push.apply(results, setMatched);
          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            jQuery.uniqueSort(results);
          }
        }
        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }
        return unmatched;
      };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    function compile(selector, match) {
      var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i2 = match.length;
        while (i2--) {
          cached = matcherFromTokens(match[i2]);
          if (cached[jQuery.expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(
          selector,
          matcherFromGroupMatchers(elementMatchers, setMatchers)
        );
        cached.selector = selector;
      }
      return cached;
    }
    function select(selector, context, results, seed) {
      var i2, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && jQuery.expr.relative[tokens[1].type]) {
          context = (jQuery.expr.find.ID(
            unescapeSelector(token.matches[0]),
            context
          ) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
        while (i2--) {
          token = tokens[i2];
          if (jQuery.expr.relative[type = token.type]) {
            break;
          }
          if (find2 = jQuery.expr.find[type]) {
            if (seed = find2(
              unescapeSelector(token.matches[0]),
              rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
            )) {
              tokens.splice(i2, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(
        seed,
        context,
        !documentIsHTML,
        results,
        !context || rsibling.test(selector) && testContext(context.parentNode) || context
      );
      return results;
    }
    setDocument();
    jQuery.find = find;
    find.compile = compile;
    find.select = select;
    find.setDocument = setDocument;
    find.tokenize = tokenize;
    return jQuery;
  })
);

// src/mock-doc/selector.ts
function matches(selector, elm) {
  try {
    const r = jquery_default.find(selector, void 0, void 0, [elm]);
    return r.length > 0;
  } catch (e) {
    updateSelectorError(selector, e);
    throw e;
  }
}
function selectOne(selector, elm) {
  try {
    const r = jquery_default.find(selector, elm, void 0, void 0);
    return r[0] || null;
  } catch (e) {
    updateSelectorError(selector, e);
    throw e;
  }
}
function selectAll(selector, elm) {
  try {
    return jquery_default.find(selector, elm, void 0, void 0);
  } catch (e) {
    updateSelectorError(selector, e);
    throw e;
  }
}
var PROBLEMATIC_SELECTORS = [":scope", ":where", ":is"];
function updateSelectorError(selector, e) {
  const selectorsPresent = PROBLEMATIC_SELECTORS.filter((s) => selector.includes(s));
  if (selectorsPresent.length > 0 && e.message) {
    e.message = `At present jQuery does not support the ${humanReadableList(selectorsPresent)} ${selectorsPresent.length === 1 ? "selector" : "selectors"}.
If you need this in your test, consider writing an end-to-end test instead.
` + e.message;
  }
}
function humanReadableList(items) {
  if (items.length <= 1) {
    return items.join("");
  }
  return `${items.slice(0, items.length - 1).join(", ")} and ${items[items.length - 1]}`;
}

// src/mock-doc/serialize-node.ts
function serializeNodeToHtml(elm, opts = {}) {
  const output = {
    currentLineWidth: 0,
    indent: 0,
    isWithinBody: false,
    text: []
  };
  if (opts.prettyHtml) {
    if (typeof opts.indentSpaces !== "number") {
      opts.indentSpaces = 2;
    }
    if (typeof opts.newLines !== "boolean") {
      opts.newLines = true;
    }
    opts.approximateLineWidth = -1;
  } else {
    opts.prettyHtml = false;
    if (typeof opts.newLines !== "boolean") {
      opts.newLines = false;
    }
    if (typeof opts.indentSpaces !== "number") {
      opts.indentSpaces = 0;
    }
  }
  if (typeof opts.approximateLineWidth !== "number") {
    opts.approximateLineWidth = -1;
  }
  if (typeof opts.removeEmptyAttributes !== "boolean") {
    opts.removeEmptyAttributes = true;
  }
  if (typeof opts.removeAttributeQuotes !== "boolean") {
    opts.removeAttributeQuotes = false;
  }
  if (typeof opts.removeBooleanAttributeQuotes !== "boolean") {
    opts.removeBooleanAttributeQuotes = false;
  }
  if (typeof opts.removeHtmlComments !== "boolean") {
    opts.removeHtmlComments = false;
  }
  if (typeof opts.serializeShadowRoot !== "boolean") {
    opts.serializeShadowRoot = false;
  }
  if (opts.outerHtml) {
    serializeToHtml(elm, opts, output, false);
  } else {
    for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
      serializeToHtml(elm.childNodes[i], opts, output, false);
    }
  }
  if (output.text[0] === "\n") {
    output.text.shift();
  }
  if (output.text[output.text.length - 1] === "\n") {
    output.text.pop();
  }
  return output.text.join("");
}
function serializeToHtml(node, opts, output, isShadowRoot) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  if (node.nodeType === 1 /* ELEMENT_NODE */ || isShadowRoot) {
    const tagName = isShadowRoot ? "mock:shadow-root" : getTagName(node);
    if (tagName === "body") {
      output.isWithinBody = true;
    }
    const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
    if (ignoreTag === false) {
      const isWithinWhitespaceSensitiveNode = opts.newLines || ((_a2 = opts.indentSpaces) != null ? _a2 : 0) > 0 ? isWithinWhitespaceSensitive(node) : false;
      if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
        output.text.push("\n");
        output.currentLineWidth = 0;
      }
      if (((_b = opts.indentSpaces) != null ? _b : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
        for (let i = 0; i < output.indent; i++) {
          output.text.push(" ");
        }
        output.currentLineWidth += output.indent;
      }
      output.text.push("<" + tagName);
      output.currentLineWidth += tagName.length + 1;
      const attrsLength = node.attributes.length;
      const attributes = opts.prettyHtml && attrsLength > 1 ? cloneAttributes(node.attributes, true) : node.attributes;
      for (let i = 0; i < attrsLength; i++) {
        const attr = attributes.item(i);
        const attrName = attr.name;
        if (attrName === "style") {
          continue;
        }
        let attrValue = attr.value;
        if (opts.removeEmptyAttributes && attrValue === "" && REMOVE_EMPTY_ATTR.has(attrName)) {
          continue;
        }
        const attrNamespaceURI = attr.namespaceURI;
        if (attrNamespaceURI == null) {
          output.currentLineWidth += attrName.length + 1;
          if (opts.approximateLineWidth && opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            output.text.push("\n" + attrName);
            output.currentLineWidth = 0;
          } else {
            output.text.push(" " + attrName);
          }
        } else if (attrNamespaceURI === "http://www.w3.org/XML/1998/namespace") {
          output.text.push(" xml:" + attrName);
          output.currentLineWidth += attrName.length + 5;
        } else if (attrNamespaceURI === "http://www.w3.org/2000/xmlns/") {
          if (attrName !== "xmlns") {
            output.text.push(" xmlns:" + attrName);
            output.currentLineWidth += attrName.length + 7;
          } else {
            output.text.push(" " + attrName);
            output.currentLineWidth += attrName.length + 1;
          }
        } else if (attrNamespaceURI === XLINK_NS) {
          output.text.push(" xlink:" + attrName);
          output.currentLineWidth += attrName.length + 7;
        } else {
          output.text.push(" " + attrNamespaceURI + ":" + attrName);
          output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
        }
        if (opts.prettyHtml && attrName === "class") {
          attrValue = attr.value = attrValue.split(" ").filter((t) => t !== "").sort().join(" ").trim();
        }
        if (attrValue === "") {
          if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
            continue;
          }
          if (opts.removeEmptyAttributes && attrName.startsWith("data-")) {
            continue;
          }
        }
        if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
          output.text.push("=" + escapeString(attrValue, true));
          output.currentLineWidth += attrValue.length + 1;
        } else {
          output.text.push('="' + escapeString(attrValue, true) + '"');
          output.currentLineWidth += attrValue.length + 3;
        }
      }
      if (node.hasAttribute("style")) {
        const cssText = node.style.cssText;
        if (opts.approximateLineWidth && opts.approximateLineWidth > 0 && output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth) {
          output.text.push(`
style="${cssText}">`);
          output.currentLineWidth = 0;
        } else {
          output.text.push(` style="${cssText}">`);
          output.currentLineWidth += cssText.length + 10;
        }
      } else {
        output.text.push(">");
        output.currentLineWidth += 1;
      }
    }
    if (EMPTY_ELEMENTS.has(tagName) === false) {
      if (opts.serializeShadowRoot && node.shadowRoot != null) {
        output.indent = output.indent + ((_c = opts.indentSpaces) != null ? _c : 0);
        serializeToHtml(node.shadowRoot, opts, output, true);
        output.indent = output.indent - ((_d = opts.indentSpaces) != null ? _d : 0);
        if (opts.newLines && (node.childNodes.length === 0 || node.childNodes.length === 1 && node.childNodes[0].nodeType === 3 /* TEXT_NODE */ && ((_e = node.childNodes[0].nodeValue) == null ? void 0 : _e.trim()) === "")) {
          output.text.push("\n");
          output.currentLineWidth = 0;
          for (let i = 0; i < output.indent; i++) {
            output.text.push(" ");
          }
          output.currentLineWidth += output.indent;
        }
      }
      if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
        const childNodes = tagName === "template" ? node.content.childNodes : node.childNodes;
        const childNodeLength = childNodes.length;
        if (childNodeLength > 0) {
          if (childNodeLength === 1 && childNodes[0].nodeType === 3 /* TEXT_NODE */ && (typeof childNodes[0].nodeValue !== "string" || childNodes[0].nodeValue.trim() === "")) {
          } else {
            const isWithinWhitespaceSensitiveNode = opts.newLines || ((_f = opts.indentSpaces) != null ? _f : 0) > 0 ? isWithinWhitespaceSensitive(node) : false;
            if (!isWithinWhitespaceSensitiveNode && ((_g = opts.indentSpaces) != null ? _g : 0) > 0 && ignoreTag === false) {
              output.indent = output.indent + ((_h = opts.indentSpaces) != null ? _h : 0);
            }
            for (let i = 0; i < childNodeLength; i++) {
              serializeToHtml(childNodes[i], opts, output, false);
            }
            if (ignoreTag === false) {
              if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                output.text.push("\n");
                output.currentLineWidth = 0;
              }
              if (((_i = opts.indentSpaces) != null ? _i : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
                output.indent = output.indent - ((_j = opts.indentSpaces) != null ? _j : 0);
                for (let i = 0; i < output.indent; i++) {
                  output.text.push(" ");
                }
                output.currentLineWidth += output.indent;
              }
            }
          }
        }
        if (ignoreTag === false) {
          output.text.push("</" + tagName + ">");
          output.currentLineWidth += tagName.length + 3;
        }
      }
    }
    if (((_k = opts.approximateLineWidth) != null ? _k : 0) > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
      output.text.push("\n");
      output.currentLineWidth = 0;
    }
    if (tagName === "body") {
      output.isWithinBody = false;
    }
  } else if (node.nodeType === 3 /* TEXT_NODE */) {
    let textContent = node.nodeValue;
    if (typeof textContent === "string") {
      const trimmedTextContent = textContent.trim();
      if (trimmedTextContent === "") {
        if (isWithinWhitespaceSensitive(node)) {
          output.text.push(textContent);
          output.currentLineWidth += textContent.length;
        } else if (((_l = opts.approximateLineWidth) != null ? _l : 0) > 0 && !output.isWithinBody) {
        } else if (!opts.prettyHtml) {
          output.currentLineWidth += 1;
          if (opts.approximateLineWidth && opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            output.text.push("\n");
            output.currentLineWidth = 0;
          } else {
            output.text.push(" ");
          }
        }
      } else {
        const isWithinWhitespaceSensitiveNode = opts.newLines || ((_m = opts.indentSpaces) != null ? _m : 0) > 0 || opts.prettyHtml ? isWithinWhitespaceSensitive(node) : false;
        if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
          output.text.push("\n");
          output.currentLineWidth = 0;
        }
        if (((_n = opts.indentSpaces) != null ? _n : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
          for (let i = 0; i < output.indent; i++) {
            output.text.push(" ");
          }
          output.currentLineWidth += output.indent;
        }
        let textContentLength = textContent.length;
        if (textContentLength > 0) {
          const parentTagName = node.parentNode != null && node.parentNode.nodeType === 1 /* ELEMENT_NODE */ ? node.parentNode.nodeName : null;
          if (typeof parentTagName === "string" && NON_ESCAPABLE_CONTENT.has(parentTagName)) {
            if (isWithinWhitespaceSensitive(node)) {
              output.text.push(textContent);
            } else {
              output.text.push(trimmedTextContent);
              textContentLength = trimmedTextContent.length;
            }
            output.currentLineWidth += textContentLength;
          } else {
            if (opts.prettyHtml && !isWithinWhitespaceSensitiveNode) {
              output.text.push(escapeString(textContent.replace(/\s\s+/g, " ").trim(), false));
              output.currentLineWidth += textContentLength;
            } else {
              if (isWithinWhitespaceSensitive(node)) {
                output.currentLineWidth += textContentLength;
              } else {
                if (/\s/.test(textContent.charAt(0))) {
                  textContent = " " + textContent.trimLeft();
                }
                textContentLength = textContent.length;
                if (textContentLength > 1) {
                  if (/\s/.test(textContent.charAt(textContentLength - 1))) {
                    if (opts.approximateLineWidth && opts.approximateLineWidth > 0 && output.currentLineWidth + textContentLength > opts.approximateLineWidth) {
                      textContent = textContent.trimRight() + "\n";
                      output.currentLineWidth = 0;
                    } else {
                      textContent = textContent.trimRight() + " ";
                    }
                  }
                }
                output.currentLineWidth += textContentLength;
              }
              output.text.push(escapeString(textContent, false));
            }
          }
        }
      }
    }
  } else if (node.nodeType === 8 /* COMMENT_NODE */) {
    const nodeValue = node.nodeValue;
    if (opts.removeHtmlComments) {
      const isHydrateAnnotation = (nodeValue == null ? void 0 : nodeValue.startsWith(CONTENT_REF_ID + ".")) || (nodeValue == null ? void 0 : nodeValue.startsWith(ORG_LOCATION_ID + ".")) || (nodeValue == null ? void 0 : nodeValue.startsWith(SLOT_NODE_ID + ".")) || (nodeValue == null ? void 0 : nodeValue.startsWith(TEXT_NODE_ID + "."));
      if (!isHydrateAnnotation) {
        return;
      }
    }
    const isWithinWhitespaceSensitiveNode = opts.newLines || ((_o = opts.indentSpaces) != null ? _o : 0) > 0 ? isWithinWhitespaceSensitive(node) : false;
    if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
      output.text.push("\n");
      output.currentLineWidth = 0;
    }
    if (((_p = opts.indentSpaces) != null ? _p : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
      for (let i = 0; i < output.indent; i++) {
        output.text.push(" ");
      }
      output.currentLineWidth += output.indent;
    }
    output.text.push("<!--" + nodeValue + "-->");
    output.currentLineWidth += nodeValue.length + 7;
  } else if (node.nodeType === 10 /* DOCUMENT_TYPE_NODE */) {
    output.text.push("<!doctype html>");
  }
}
var AMP_REGEX = /&/g;
var NBSP_REGEX = /\u00a0/g;
var DOUBLE_QUOTE_REGEX = /"/g;
var LT_REGEX = /</g;
var GT_REGEX = />/g;
var CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
  if (element.namespaceURI === "http://www.w3.org/1999/xhtml") {
    return element.nodeName.toLowerCase();
  } else {
    return element.nodeName;
  }
}
function escapeString(str, attrMode) {
  str = str.replace(AMP_REGEX, "&amp;").replace(NBSP_REGEX, "&nbsp;");
  if (attrMode) {
    return str.replace(DOUBLE_QUOTE_REGEX, "&quot;");
  }
  return str.replace(LT_REGEX, "&lt;").replace(GT_REGEX, "&gt;");
}
function isWithinWhitespaceSensitive(node) {
  let _node = node;
  while (_node != null) {
    if (WHITESPACE_SENSITIVE.has(_node.nodeName)) {
      return true;
    }
    _node = _node.parentNode;
  }
  return false;
}
var NON_ESCAPABLE_CONTENT = /* @__PURE__ */ new Set([
  "STYLE",
  "SCRIPT",
  "IFRAME",
  "NOSCRIPT",
  "XMP",
  "NOEMBED",
  "NOFRAMES",
  "PLAINTEXT"
]);
var WHITESPACE_SENSITIVE = /* @__PURE__ */ new Set([
  "CODE",
  "OUTPUT",
  "PLAINTEXT",
  "PRE",
  "SCRIPT",
  "TEMPLATE",
  "TEXTAREA"
]);
var EMPTY_ELEMENTS = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "trace",
  "track",
  "wbr"
]);
var REMOVE_EMPTY_ATTR = /* @__PURE__ */ new Set(["class", "dir", "id", "lang", "name", "title"]);
var BOOLEAN_ATTR = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "compact",
  "controls",
  "declare",
  "default",
  "defaultchecked",
  "defaultmuted",
  "defaultselected",
  "defer",
  "disabled",
  "enabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nohref",
  "nomodule",
  "noresize",
  "noshade",
  "novalidate",
  "nowrap",
  "open",
  "pauseonexit",
  "readonly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  "selected",
  "sortable",
  "truespeed",
  "typemustmatch",
  "visible"
]);
var STRUCTURE_ELEMENTS = /* @__PURE__ */ new Set([
  "html",
  "body",
  "head",
  "iframe",
  "meta",
  "link",
  "base",
  "title",
  "script",
  "style"
]);

// src/mock-doc/node.ts
var MockNode2 = class {
  constructor(ownerDocument, nodeType, nodeName, nodeValue) {
    this.ownerDocument = ownerDocument;
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this._nodeValue = nodeValue;
    this.parentNode = null;
    this.childNodes = [];
  }
  appendChild(newNode) {
    if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
      const nodes = newNode.childNodes.slice();
      for (const child of nodes) {
        this.appendChild(child);
      }
    } else {
      newNode.remove();
      newNode.parentNode = this;
      this.childNodes.push(newNode);
      connectNode(this.ownerDocument, newNode);
    }
    return newNode;
  }
  append(...items) {
    items.forEach((item) => {
      const isNode = typeof item === "object" && item !== null && "nodeType" in item;
      this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
    });
  }
  prepend(...items) {
    const firstChild = this.firstChild;
    items.forEach((item) => {
      const isNode = typeof item === "object" && item !== null && "nodeType" in item;
      if (firstChild) {
        this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
      }
    });
  }
  cloneNode(deep) {
    throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
  }
  compareDocumentPosition(_other) {
    return -1;
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  insertBefore(newNode, referenceNode) {
    if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
      for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
        insertBefore(this, newNode.childNodes[i], referenceNode);
      }
    } else {
      insertBefore(this, newNode, referenceNode);
    }
    return newNode;
  }
  get isConnected() {
    let node = this;
    while (node != null) {
      if (node.nodeType === 9 /* DOCUMENT_NODE */) {
        return true;
      }
      node = node.parentNode;
      if (node != null && node.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
        node = node.host;
      }
    }
    return false;
  }
  isSameNode(node) {
    return this === node;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  get nextSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) + 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  get nodeValue() {
    var _a2;
    return (_a2 = this._nodeValue) != null ? _a2 : "";
  }
  set nodeValue(value) {
    this._nodeValue = value;
  }
  get parentElement() {
    return this.parentNode || null;
  }
  set parentElement(value) {
    this.parentNode = value;
  }
  get previousSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) - 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  contains(otherNode) {
    if (otherNode === this) {
      return true;
    }
    const childNodes = Array.from(this.childNodes);
    if (childNodes.includes(otherNode)) {
      return true;
    }
    return childNodes.some((node) => this.contains.bind(node)(otherNode));
  }
  removeChild(childNode) {
    const index = this.childNodes.indexOf(childNode);
    if (index > -1) {
      this.childNodes.splice(index, 1);
      if (this.nodeType === 1 /* ELEMENT_NODE */) {
        const wasConnected = this.isConnected;
        childNode.parentNode = null;
        if (wasConnected === true) {
          disconnectNode(childNode);
        }
      } else {
        childNode.parentNode = null;
      }
    } else {
      throw new Error(`node not found within childNodes during removeChild`);
    }
    return childNode;
  }
  remove() {
    if (this.parentNode != null) {
      this.parentNode.removeChild(this);
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode === this) {
      this.insertBefore(newChild, oldChild);
      oldChild.remove();
      return newChild;
    }
    return null;
  }
  get textContent() {
    var _a2;
    return (_a2 = this._nodeValue) != null ? _a2 : "";
  }
  set textContent(value) {
    this._nodeValue = String(value);
  }
};
MockNode2.ELEMENT_NODE = 1;
MockNode2.TEXT_NODE = 3;
MockNode2.PROCESSING_INSTRUCTION_NODE = 7;
MockNode2.COMMENT_NODE = 8;
MockNode2.DOCUMENT_NODE = 9;
MockNode2.DOCUMENT_TYPE_NODE = 10;
MockNode2.DOCUMENT_FRAGMENT_NODE = 11;
var MockNodeList = class {
  constructor(ownerDocument, childNodes, length) {
    this.ownerDocument = ownerDocument;
    this.childNodes = childNodes;
    this.length = length;
  }
};
var MockElement = class extends MockNode2 {
  attachInternals() {
    return new Proxy({}, {
      get: function(_target, prop, _receiver) {
        console.error(
          `NOTE: Property ${String(prop)} was accessed on ElementInternals, but this property is not implemented.
Testing components with ElementInternals is fully supported in e2e tests.`
        );
      }
    });
  }
  constructor(ownerDocument, nodeName, namespaceURI = null) {
    super(ownerDocument, 1 /* ELEMENT_NODE */, typeof nodeName === "string" ? nodeName : null, null);
    this.__namespaceURI = namespaceURI;
    this.__shadowRoot = null;
    this.__attributeMap = null;
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  attachShadow(_opts) {
    const shadowRoot = this.ownerDocument.createDocumentFragment();
    this.shadowRoot = shadowRoot;
    return shadowRoot;
  }
  blur() {
    dispatchEvent(
      this,
      new MockFocusEvent("blur", { relatedTarget: null, bubbles: true, cancelable: true, composed: true })
    );
  }
  get localName() {
    if (!this.nodeName) {
      throw new Error(`Can't compute elements localName without nodeName`);
    }
    return this.nodeName.toLocaleLowerCase();
  }
  get namespaceURI() {
    return this.__namespaceURI;
  }
  get shadowRoot() {
    return this.__shadowRoot || null;
  }
  set shadowRoot(shadowRoot) {
    if (shadowRoot != null) {
      shadowRoot.host = this;
      this.__shadowRoot = shadowRoot;
    } else {
      delete this.__shadowRoot;
    }
  }
  get attributes() {
    if (this.__attributeMap == null) {
      const attrMap = createAttributeProxy(false);
      this.__attributeMap = attrMap;
      return attrMap;
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
  get children() {
    return this.childNodes.filter((n) => n.nodeType === 1 /* ELEMENT_NODE */);
  }
  get childElementCount() {
    return this.childNodes.filter((n) => n.nodeType === 1 /* ELEMENT_NODE */).length;
  }
  get className() {
    return this.getAttributeNS(null, "class") || "";
  }
  set className(value) {
    this.setAttributeNS(null, "class", value);
  }
  get classList() {
    return new MockClassList(this);
  }
  click() {
    dispatchEvent(this, new MockEvent("click", { bubbles: true, cancelable: true, composed: true }));
  }
  cloneNode(_deep) {
    return null;
  }
  closest(selector) {
    let elm = this;
    while (elm != null) {
      if (elm.matches(selector)) {
        return elm;
      }
      elm = elm.parentNode;
    }
    return null;
  }
  get dataset() {
    return dataset(this);
  }
  get dir() {
    return this.getAttributeNS(null, "dir") || "";
  }
  set dir(value) {
    this.setAttributeNS(null, "dir", value);
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get firstElementChild() {
    return this.children[0] || null;
  }
  focus(_options) {
    dispatchEvent(
      this,
      new MockFocusEvent("focus", { relatedTarget: null, bubbles: true, cancelable: true, composed: true })
    );
  }
  getAttribute(attrName) {
    if (attrName === "style") {
      if (this.__style != null && this.__style.length > 0) {
        return this.style.cssText;
      }
      return null;
    }
    const attr = this.attributes.getNamedItem(attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getAttributeNode(attrName) {
    if (!this.hasAttribute(attrName)) {
      return null;
    }
    return new MockAttr(attrName, this.getAttribute(attrName));
  }
  getBoundingClientRect() {
    return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
  }
  getRootNode(opts) {
    const isComposed = opts != null && opts.composed === true;
    let node = this;
    while (node.parentNode != null) {
      node = node.parentNode;
      if (isComposed === true && node.parentNode == null && node.host != null) {
        node = node.host;
      }
    }
    return node;
  }
  get draggable() {
    return this.getAttributeNS(null, "draggable") === "true";
  }
  set draggable(value) {
    this.setAttributeNS(null, "draggable", value);
  }
  hasChildNodes() {
    return this.childNodes.length > 0;
  }
  get id() {
    return this.getAttributeNS(null, "id") || "";
  }
  set id(value) {
    this.setAttributeNS(null, "id", value);
  }
  get innerHTML() {
    if (this.childNodes.length === 0) {
      return "";
    }
    return serializeNodeToHtml(this, {
      newLines: false,
      indentSpaces: 0
    });
  }
  set innerHTML(html) {
    var _a2;
    if (NON_ESCAPABLE_CONTENT.has((_a2 = this.nodeName) != null ? _a2 : "") === true) {
      setTextContent(this, html);
    } else {
      for (let i = this.childNodes.length - 1; i >= 0; i--) {
        this.removeChild(this.childNodes[i]);
      }
      if (typeof html === "string") {
        const frag = parseFragmentUtil(this.ownerDocument, html);
        while (frag.childNodes.length > 0) {
          this.appendChild(frag.childNodes[0]);
        }
      }
    }
  }
  get innerText() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join("");
  }
  set innerText(value) {
    setTextContent(this, value);
  }
  insertAdjacentElement(position, elm) {
    if (position === "beforebegin") {
      insertBefore(this.parentNode, elm, this);
    } else if (position === "afterbegin") {
      this.prepend(elm);
    } else if (position === "beforeend") {
      this.appendChild(elm);
    } else if (position === "afterend") {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
    return elm;
  }
  insertAdjacentHTML(position, html) {
    const frag = parseFragmentUtil(this.ownerDocument, html);
    if (position === "beforebegin") {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[0], this);
      }
    } else if (position === "afterbegin") {
      while (frag.childNodes.length > 0) {
        this.prepend(frag.childNodes[frag.childNodes.length - 1]);
      }
    } else if (position === "beforeend") {
      while (frag.childNodes.length > 0) {
        this.appendChild(frag.childNodes[0]);
      }
    } else if (position === "afterend") {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
      }
    }
  }
  insertAdjacentText(position, text) {
    const elm = this.ownerDocument.createTextNode(text);
    if (position === "beforebegin") {
      insertBefore(this.parentNode, elm, this);
    } else if (position === "afterbegin") {
      this.prepend(elm);
    } else if (position === "beforeend") {
      this.appendChild(elm);
    } else if (position === "afterend") {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
  }
  hasAttribute(attrName) {
    if (attrName === "style") {
      return this.__style != null && this.__style.length > 0;
    }
    return this.getAttribute(attrName) !== null;
  }
  hasAttributeNS(namespaceURI, name) {
    return this.getAttributeNS(namespaceURI, name) !== null;
  }
  get hidden() {
    return this.hasAttributeNS(null, "hidden");
  }
  set hidden(isHidden) {
    if (isHidden === true) {
      this.setAttributeNS(null, "hidden", "");
    } else {
      this.removeAttributeNS(null, "hidden");
    }
  }
  get lang() {
    return this.getAttributeNS(null, "lang") || "";
  }
  set lang(value) {
    this.setAttributeNS(null, "lang", value);
  }
  get lastElementChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  matches(selector) {
    return matches(selector, this);
  }
  get nextElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null && (parentElement.nodeType === 1 /* ELEMENT_NODE */ || parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ || parentElement.nodeType === 9 /* DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) + 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  get outerHTML() {
    return serializeNodeToHtml(this, {
      newLines: false,
      outerHtml: true,
      indentSpaces: 0
    });
  }
  get previousElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null && (parentElement.nodeType === 1 /* ELEMENT_NODE */ || parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ || parentElement.nodeType === 9 /* DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) - 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  getElementsByClassName(classNames) {
    const classes = classNames.trim().split(" ").filter((c) => c.length > 0);
    const results = [];
    getElementsByClassName(this, classes, results);
    return results;
  }
  getElementsByTagName(tagName) {
    const results = [];
    getElementsByTagName(this, tagName.toLowerCase(), results);
    return results;
  }
  querySelector(selector) {
    return selectOne(selector, this);
  }
  querySelectorAll(selector) {
    return selectAll(selector, this);
  }
  removeAttribute(attrName) {
    if (attrName === "style") {
      delete this.__style;
    } else {
      const attr = this.attributes.getNamedItem(attrName);
      if (attr != null) {
        this.attributes.removeNamedItemNS(attr);
        if (checkAttributeChanged(this) === true) {
          attributeChanged(this, attrName, attr.value, null);
        }
      }
    }
  }
  removeAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      this.attributes.removeNamedItemNS(attr);
      if (checkAttributeChanged(this) === true) {
        attributeChanged(this, attrName, attr.value, null);
      }
    }
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  setAttribute(attrName, value) {
    if (attrName === "style") {
      this.style = value;
    } else {
      const attributes = this.attributes;
      let attr = attributes.getNamedItem(attrName);
      const checkAttrChanged = checkAttributeChanged(this);
      if (attr != null) {
        if (checkAttrChanged === true) {
          const oldValue = attr.value;
          attr.value = value;
          if (oldValue !== attr.value) {
            attributeChanged(this, attr.name, oldValue, attr.value);
          }
        } else {
          attr.value = value;
        }
      } else {
        if (attributes.caseInsensitive) {
          attrName = attrName.toLowerCase();
        }
        attr = new MockAttr(attrName, value);
        attributes.__items.push(attr);
        if (checkAttrChanged === true) {
          attributeChanged(this, attrName, null, attr.value);
        }
      }
    }
  }
  setAttributeNS(namespaceURI, attrName, value) {
    const attributes = this.attributes;
    let attr = attributes.getNamedItemNS(namespaceURI, attrName);
    const checkAttrChanged = checkAttributeChanged(this);
    if (attr != null) {
      if (checkAttrChanged === true) {
        const oldValue = attr.value;
        attr.value = value;
        if (oldValue !== attr.value) {
          attributeChanged(this, attr.name, oldValue, attr.value);
        }
      } else {
        attr.value = value;
      }
    } else {
      attr = new MockAttr(attrName, value, namespaceURI);
      attributes.__items.push(attr);
      if (checkAttrChanged === true) {
        attributeChanged(this, attrName, null, attr.value);
      }
    }
  }
  get style() {
    if (this.__style == null) {
      this.__style = createCSSStyleDeclaration();
    }
    return this.__style;
  }
  set style(val) {
    if (typeof val === "string") {
      if (this.__style == null) {
        this.__style = createCSSStyleDeclaration();
      }
      this.__style.cssText = val;
    } else {
      this.__style = val;
    }
  }
  get tabIndex() {
    return parseInt(this.getAttributeNS(null, "tabindex") || "-1", 10);
  }
  set tabIndex(value) {
    this.setAttributeNS(null, "tabindex", value);
  }
  get tagName() {
    var _a2;
    return (_a2 = this.nodeName) != null ? _a2 : "";
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get textContent() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join("");
  }
  set textContent(value) {
    setTextContent(this, value);
  }
  get title() {
    return this.getAttributeNS(null, "title") || "";
  }
  set title(value) {
    this.setAttributeNS(null, "title", value);
  }
  animate() {
  }
  onanimationstart() {
  }
  onanimationend() {
  }
  onanimationiteration() {
  }
  onabort() {
  }
  onauxclick() {
  }
  onbeforecopy() {
  }
  onbeforecut() {
  }
  onbeforepaste() {
  }
  onblur() {
  }
  oncancel() {
  }
  oncanplay() {
  }
  oncanplaythrough() {
  }
  onchange() {
  }
  onclick() {
  }
  onclose() {
  }
  oncontextmenu() {
  }
  oncopy() {
  }
  oncuechange() {
  }
  oncut() {
  }
  ondblclick() {
  }
  ondrag() {
  }
  ondragend() {
  }
  ondragenter() {
  }
  ondragleave() {
  }
  ondragover() {
  }
  ondragstart() {
  }
  ondrop() {
  }
  ondurationchange() {
  }
  onemptied() {
  }
  onended() {
  }
  onerror() {
  }
  onfocus() {
  }
  onfocusin() {
  }
  onfocusout() {
  }
  onformdata() {
  }
  onfullscreenchange() {
  }
  onfullscreenerror() {
  }
  ongotpointercapture() {
  }
  oninput() {
  }
  oninvalid() {
  }
  onkeydown() {
  }
  onkeypress() {
  }
  onkeyup() {
  }
  onload() {
  }
  onloadeddata() {
  }
  onloadedmetadata() {
  }
  onloadstart() {
  }
  onlostpointercapture() {
  }
  onmousedown() {
  }
  onmouseenter() {
  }
  onmouseleave() {
  }
  onmousemove() {
  }
  onmouseout() {
  }
  onmouseover() {
  }
  onmouseup() {
  }
  onmousewheel() {
  }
  onpaste() {
  }
  onpause() {
  }
  onplay() {
  }
  onplaying() {
  }
  onpointercancel() {
  }
  onpointerdown() {
  }
  onpointerenter() {
  }
  onpointerleave() {
  }
  onpointermove() {
  }
  onpointerout() {
  }
  onpointerover() {
  }
  onpointerup() {
  }
  onprogress() {
  }
  onratechange() {
  }
  onreset() {
  }
  onresize() {
  }
  onscroll() {
  }
  onsearch() {
  }
  onseeked() {
  }
  onseeking() {
  }
  onselect() {
  }
  onselectstart() {
  }
  onstalled() {
  }
  onsubmit() {
  }
  onsuspend() {
  }
  ontimeupdate() {
  }
  ontoggle() {
  }
  onvolumechange() {
  }
  onwaiting() {
  }
  onwebkitfullscreenchange() {
  }
  onwebkitfullscreenerror() {
  }
  onwheel() {
  }
  requestFullscreen() {
  }
  scrollBy() {
  }
  scrollTo() {
  }
  scrollIntoView() {
  }
  toString(opts) {
    return serializeNodeToHtml(this, opts);
  }
};
function getElementsByClassName(elm, classNames, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    for (let j = 0, jj = classNames.length; j < jj; j++) {
      if (childElm.classList.contains(classNames[j])) {
        foundElms.push(childElm);
      }
    }
    getElementsByClassName(childElm, classNames, foundElms);
  }
}
function getElementsByTagName(elm, tagName, foundElms) {
  var _a2;
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (tagName === "*" || ((_a2 = childElm.nodeName) != null ? _a2 : "").toLowerCase() === tagName) {
      foundElms.push(childElm);
    }
    getElementsByTagName(childElm, tagName, foundElms);
  }
}
function resetElement(elm) {
  resetEventListeners(elm);
  delete elm.__attributeMap;
  delete elm.__shadowRoot;
  delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
  if (newNode !== referenceNode) {
    newNode.remove();
    newNode.parentNode = parentNode;
    newNode.ownerDocument = parentNode.ownerDocument;
    if (referenceNode != null) {
      const index = parentNode.childNodes.indexOf(referenceNode);
      if (index > -1) {
        parentNode.childNodes.splice(index, 0, newNode);
      } else {
        throw new Error(`referenceNode not found in parentNode.childNodes`);
      }
    } else {
      parentNode.childNodes.push(newNode);
    }
    connectNode(parentNode.ownerDocument, newNode);
  }
  return newNode;
}
var MockHTMLElement = class extends MockElement {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, typeof nodeName === "string" ? nodeName.toUpperCase() : null);
    this.__namespaceURI = "http://www.w3.org/1999/xhtml";
  }
  get tagName() {
    var _a2;
    return (_a2 = this.nodeName) != null ? _a2 : "";
  }
  set tagName(value) {
    this.nodeName = value;
  }
  /**
   * A nodes parent of type Element is known as its parent element.
   * If the node has a parent of a different type, its parent element
   * is null.
   * @returns MockElement
   */
  get parentElement() {
    if (this.nodeName === "HTML") {
      return null;
    }
    return super.parentElement;
  }
  get attributes() {
    if (this.__attributeMap == null) {
      const attrMap = createAttributeProxy(true);
      this.__attributeMap = attrMap;
      return attrMap;
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
};
var MockTextNode = class _MockTextNode extends MockNode2 {
  constructor(ownerDocument, text) {
    super(ownerDocument, 3 /* TEXT_NODE */, "#text" /* TEXT_NODE */, text);
  }
  cloneNode(_deep) {
    return new _MockTextNode(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
  get data() {
    return this.nodeValue;
  }
  set data(text) {
    this.nodeValue = text;
  }
  get wholeText() {
    if (this.parentNode != null) {
      const text = [];
      for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
        const childNode = this.parentNode.childNodes[i];
        if (childNode.nodeType === 3 /* TEXT_NODE */) {
          text.push(childNode.nodeValue);
        }
      }
      return text.join("");
    }
    return this.nodeValue;
  }
};
function getTextContent(childNodes, text) {
  for (let i = 0, ii = childNodes.length; i < ii; i++) {
    const childNode = childNodes[i];
    if (childNode.nodeType === 3 /* TEXT_NODE */) {
      text.push(childNode.nodeValue);
    } else if (childNode.nodeType === 1 /* ELEMENT_NODE */) {
      getTextContent(childNode.childNodes, text);
    }
  }
}
function setTextContent(elm, text) {
  for (let i = elm.childNodes.length - 1; i >= 0; i--) {
    elm.removeChild(elm.childNodes[i]);
  }
  const textNode = new MockTextNode(elm.ownerDocument, text);
  elm.appendChild(textNode);
}

// src/mock-doc/comment-node.ts
var MockComment = class _MockComment extends MockNode2 {
  constructor(ownerDocument, data) {
    super(ownerDocument, 8 /* COMMENT_NODE */, "#comment" /* COMMENT_NODE */, data);
  }
  cloneNode(_deep) {
    return new _MockComment(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
};

// src/mock-doc/document-fragment.ts
var MockDocumentFragment = class _MockDocumentFragment extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, null);
    this.nodeName = "#document-fragment" /* DOCUMENT_FRAGMENT_NODE */;
    this.nodeType = 11 /* DOCUMENT_FRAGMENT_NODE */;
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  cloneNode(deep) {
    const cloned = new _MockDocumentFragment(null);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const childNode = this.childNodes[i];
        if (childNode.nodeType === 1 /* ELEMENT_NODE */ || childNode.nodeType === 3 /* TEXT_NODE */ || childNode.nodeType === 8 /* COMMENT_NODE */) {
          const clonedChildNode = this.childNodes[i].cloneNode(true);
          cloned.appendChild(clonedChildNode);
        }
      }
    }
    return cloned;
  }
};

// src/mock-doc/document-type-node.ts
var MockDocumentTypeNode = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "!DOCTYPE");
    this.nodeType = 10 /* DOCUMENT_TYPE_NODE */;
    this.setAttribute("html", "");
  }
};

// src/mock-doc/css-style-sheet.ts
var MockCSSRule = class {
  constructor(parentStyleSheet) {
    this.parentStyleSheet = parentStyleSheet;
    this.cssText = "";
    this.type = 0;
  }
};
var MockCSSStyleSheet = class {
  constructor(ownerNode) {
    this.type = "text/css";
    this.parentStyleSheet = null;
    this.cssRules = [];
    this.ownerNode = ownerNode;
  }
  get rules() {
    return this.cssRules;
  }
  set rules(rules) {
    this.cssRules = rules;
  }
  deleteRule(index) {
    if (index >= 0 && index < this.cssRules.length) {
      this.cssRules.splice(index, 1);
      updateStyleTextNode(this.ownerNode);
    }
  }
  insertRule(rule, index = 0) {
    if (typeof index !== "number") {
      index = 0;
    }
    if (index < 0) {
      index = 0;
    }
    if (index > this.cssRules.length) {
      index = this.cssRules.length;
    }
    const cssRule = new MockCSSRule(this);
    cssRule.cssText = rule;
    this.cssRules.splice(index, 0, cssRule);
    updateStyleTextNode(this.ownerNode);
    return index;
  }
};
function getStyleElementText(styleElm) {
  const output = [];
  for (let i = 0; i < styleElm.childNodes.length; i++) {
    output.push(styleElm.childNodes[i].nodeValue);
  }
  return output.join("");
}
function setStyleElementText(styleElm, text) {
  const sheet = styleElm.sheet;
  sheet.cssRules.length = 0;
  sheet.insertRule(text);
  updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
  const childNodeLen = styleElm.childNodes.length;
  if (childNodeLen > 1) {
    for (let i = childNodeLen - 1; i >= 1; i--) {
      styleElm.removeChild(styleElm.childNodes[i]);
    }
  } else if (childNodeLen < 1) {
    styleElm.appendChild(styleElm.ownerDocument.createTextNode(""));
  }
  const textNode = styleElm.childNodes[0];
  textNode.nodeValue = styleElm.sheet.cssRules.map((r) => r.cssText).join("\n");
}

// src/mock-doc/element.ts
function createElement(ownerDocument, tagName) {
  if (typeof tagName !== "string" || tagName === "" || !/^[a-z0-9-_:]+$/i.test(tagName)) {
    throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
  }
  tagName = tagName.toLowerCase();
  switch (tagName) {
    case "a":
      return new MockAnchorElement(ownerDocument);
    case "base":
      return new MockBaseElement(ownerDocument);
    case "button":
      return new MockButtonElement(ownerDocument);
    case "canvas":
      return new MockCanvasElement(ownerDocument);
    case "form":
      return new MockFormElement(ownerDocument);
    case "img":
      return new MockImageElement(ownerDocument);
    case "input":
      return new MockInputElement(ownerDocument);
    case "link":
      return new MockLinkElement(ownerDocument);
    case "meta":
      return new MockMetaElement(ownerDocument);
    case "script":
      return new MockScriptElement(ownerDocument);
    case "style":
      return new MockStyleElement(ownerDocument);
    case "template":
      return new MockTemplateElement(ownerDocument);
    case "title":
      return new MockTitleElement(ownerDocument);
    case "ul":
      return new MockUListElement(ownerDocument);
  }
  if (ownerDocument != null && tagName.includes("-")) {
    const win = ownerDocument.defaultView;
    if (win != null && win.customElements != null) {
      return createCustomElement(win.customElements, ownerDocument, tagName);
    }
  }
  return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
  if (namespaceURI === "http://www.w3.org/1999/xhtml") {
    return createElement(ownerDocument, tagName);
  } else if (namespaceURI === "http://www.w3.org/2000/svg") {
    switch (tagName.toLowerCase()) {
      case "text":
      case "tspan":
      case "tref":
      case "altglyph":
      case "textpath":
        return new MockSVGTextContentElement(ownerDocument, tagName);
      case "circle":
      case "ellipse":
      case "image":
      case "line":
      case "path":
      case "polygon":
      case "polyline":
      case "rect":
      case "use":
        return new MockSVGGraphicsElement(ownerDocument, tagName);
      case "svg":
        return new MockSVGSVGElement(ownerDocument, tagName);
      default:
        return new MockSVGElement(ownerDocument, tagName);
    }
  } else {
    return new MockElement(ownerDocument, tagName, namespaceURI);
  }
}
var MockAnchorElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "a");
  }
  get href() {
    return fullUrl(this, "href");
  }
  set href(value) {
    this.setAttribute("href", value);
  }
  get pathname() {
    return new URL(this.href).pathname;
  }
};
var MockButtonElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "button");
  }
};
patchPropAttributes(
  MockButtonElement.prototype,
  {
    type: String
  },
  {
    type: "submit"
  }
);
var MockImageElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "img");
  }
  get draggable() {
    return this.getAttributeNS(null, "draggable") !== "false";
  }
  set draggable(value) {
    this.setAttributeNS(null, "draggable", value);
  }
  get src() {
    return fullUrl(this, "src");
  }
  set src(value) {
    this.setAttribute("src", value);
  }
};
patchPropAttributes(MockImageElement.prototype, {
  height: Number,
  width: Number
});
var MockInputElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "input");
  }
  get list() {
    const listId = this.getAttribute("list");
    if (listId) {
      return this.ownerDocument.getElementById(listId);
    }
    return null;
  }
};
patchPropAttributes(
  MockInputElement.prototype,
  {
    accept: String,
    autocomplete: String,
    autofocus: Boolean,
    capture: String,
    checked: Boolean,
    disabled: Boolean,
    form: String,
    formaction: String,
    formenctype: String,
    formmethod: String,
    formnovalidate: String,
    formtarget: String,
    height: Number,
    inputmode: String,
    max: String,
    maxLength: Number,
    min: String,
    minLength: Number,
    multiple: Boolean,
    name: String,
    pattern: String,
    placeholder: String,
    required: Boolean,
    readOnly: Boolean,
    size: Number,
    spellCheck: Boolean,
    src: String,
    step: String,
    type: String,
    value: String,
    width: Number
  },
  {
    type: "text"
  }
);
var MockFormElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "form");
  }
};
patchPropAttributes(MockFormElement.prototype, {
  name: String
});
var MockLinkElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "link");
  }
  get href() {
    return fullUrl(this, "href");
  }
  set href(value) {
    this.setAttribute("href", value);
  }
};
patchPropAttributes(MockLinkElement.prototype, {
  crossorigin: String,
  media: String,
  rel: String,
  type: String
});
var MockMetaElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "meta");
  }
};
patchPropAttributes(MockMetaElement.prototype, {
  charset: String,
  content: String,
  name: String
});
var MockScriptElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "script");
  }
  get src() {
    return fullUrl(this, "src");
  }
  set src(value) {
    this.setAttribute("src", value);
  }
};
patchPropAttributes(MockScriptElement.prototype, {
  type: String
});
var MockDOMMatrix = class _MockDOMMatrix {
  constructor() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;
    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;
    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;
    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
    this.is2D = true;
    this.isIdentity = true;
  }
  static fromMatrix() {
    return new _MockDOMMatrix();
  }
  inverse() {
    return new _MockDOMMatrix();
  }
  flipX() {
    return new _MockDOMMatrix();
  }
  flipY() {
    return new _MockDOMMatrix();
  }
  multiply() {
    return new _MockDOMMatrix();
  }
  rotate() {
    return new _MockDOMMatrix();
  }
  rotateAxisAngle() {
    return new _MockDOMMatrix();
  }
  rotateFromVector() {
    return new _MockDOMMatrix();
  }
  scale() {
    return new _MockDOMMatrix();
  }
  scaleNonUniform() {
    return new _MockDOMMatrix();
  }
  skewX() {
    return new _MockDOMMatrix();
  }
  skewY() {
    return new _MockDOMMatrix();
  }
  toJSON() {
  }
  toString() {
  }
  transformPoint() {
    return new MockDOMPoint();
  }
  translate() {
    return new _MockDOMMatrix();
  }
};
var MockDOMPoint = class {
  constructor() {
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
  }
  toJSON() {
  }
  matrixTransform() {
    return new MockDOMMatrix();
  }
};
var MockSVGRect = class {
  constructor() {
    this.height = 10;
    this.width = 10;
    this.x = 0;
    this.y = 0;
  }
};
var MockStyleElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "style");
    this.sheet = new MockCSSStyleSheet(this);
  }
  get innerHTML() {
    return getStyleElementText(this);
  }
  set innerHTML(value) {
    setStyleElementText(this, value);
  }
  get innerText() {
    return getStyleElementText(this);
  }
  set innerText(value) {
    setStyleElementText(this, value);
  }
  get textContent() {
    return getStyleElementText(this);
  }
  set textContent(value) {
    setStyleElementText(this, value);
  }
};
var MockSVGElement = class extends MockElement {
  constructor() {
    super(...arguments);
    this.__namespaceURI = "http://www.w3.org/2000/svg";
  }
  // SVGElement properties and methods
  get ownerSVGElement() {
    return null;
  }
  get viewportElement() {
    return null;
  }
  onunload() {
  }
  // SVGGeometryElement properties and methods
  get pathLength() {
    return 0;
  }
  isPointInFill(_pt) {
    return false;
  }
  isPointInStroke(_pt) {
    return false;
  }
  getTotalLength() {
    return 0;
  }
};
var MockSVGGraphicsElement = class extends MockSVGElement {
  getBBox(_options) {
    return new MockSVGRect();
  }
  getCTM() {
    return new MockDOMMatrix();
  }
  getScreenCTM() {
    return new MockDOMMatrix();
  }
};
var MockSVGSVGElement = class extends MockSVGGraphicsElement {
  createSVGPoint() {
    return new MockDOMPoint();
  }
};
var MockSVGTextContentElement = class extends MockSVGGraphicsElement {
  getComputedTextLength() {
    return 0;
  }
};
var MockBaseElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "base");
  }
  get href() {
    return fullUrl(this, "href");
  }
  set href(value) {
    this.setAttribute("href", value);
  }
};
var MockTemplateElement = class _MockTemplateElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "template");
    this.content = new MockDocumentFragment(ownerDocument);
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  set innerHTML(html) {
    this.content.innerHTML = html;
  }
  cloneNode(deep) {
    const cloned = new _MockTemplateElement(null);
    cloned.attributes = cloneAttributes(this.attributes);
    const styleCssText = this.getAttribute("style");
    if (styleCssText != null && styleCssText.length > 0) {
      cloned.setAttribute("style", styleCssText);
    }
    cloned.content = this.content.cloneNode(deep);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const clonedChildNode = this.childNodes[i].cloneNode(true);
        cloned.appendChild(clonedChildNode);
      }
    }
    return cloned;
  }
};
var MockTitleElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "title");
  }
  get text() {
    return this.textContent;
  }
  set text(value) {
    this.textContent = value;
  }
};
var MockUListElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "ul");
  }
};
var MockCanvasElement = class extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, "canvas");
  }
  getContext() {
    return {
      fillRect() {
        return;
      },
      clearRect() {
      },
      getImageData: function(_, __, w, h) {
        return {
          data: new Array(w * h * 4)
        };
      },
      putImageData() {
      },
      createImageData: function() {
        return [];
      },
      setTransform() {
      },
      drawImage() {
      },
      save() {
      },
      fillText() {
      },
      restore() {
      },
      beginPath() {
      },
      moveTo() {
      },
      lineTo() {
      },
      closePath() {
      },
      stroke() {
      },
      translate() {
      },
      scale() {
      },
      rotate() {
      },
      arc() {
      },
      fill() {
      },
      measureText() {
        return { width: 0 };
      },
      transform() {
      },
      rect() {
      },
      clip() {
      }
    };
  }
};
function fullUrl(elm, attrName) {
  const val = elm.getAttribute(attrName) || "";
  if (elm.ownerDocument != null) {
    const win = elm.ownerDocument.defaultView;
    if (win != null) {
      const loc = win.location;
      if (loc != null) {
        try {
          const url = new URL(val, loc.href);
          return url.href;
        } catch (e) {
        }
      }
    }
  }
  return val.replace(/\'|\"/g, "").trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
  Object.keys(attrs).forEach((propName) => {
    const attr = attrs[propName];
    const defaultValue = defaults[propName];
    if (attr === Boolean) {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName);
        },
        set(value) {
          if (value) {
            this.setAttribute(propName, "");
          } else {
            this.removeAttribute(propName);
          }
        }
      });
    } else if (attr === Number) {
      Object.defineProperty(prototype, propName, {
        get() {
          const value = this.getAttribute(propName);
          return value ? parseInt(value, 10) : defaultValue === void 0 ? 0 : defaultValue;
        },
        set(value) {
          this.setAttribute(propName, value);
        }
      });
    } else {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || "";
        },
        set(value) {
          this.setAttribute(propName, value);
        }
      });
    }
  });
}
MockElement.prototype.cloneNode = function(deep) {
  const cloned = createElement(this.ownerDocument, this.nodeName);
  cloned.attributes = cloneAttributes(this.attributes);
  const styleCssText = this.getAttribute("style");
  if (styleCssText != null && styleCssText.length > 0) {
    cloned.setAttribute("style", styleCssText);
  }
  if (deep) {
    for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
      const clonedChildNode = this.childNodes[i].cloneNode(true);
      cloned.appendChild(clonedChildNode);
    }
  }
  return cloned;
};

// src/mock-doc/parse-html.ts
var sharedDocument;
function parseHtmlToDocument(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseDocumentUtil(ownerDocument, html);
}

// src/mock-doc/console.ts
var consoleNoop = () => {
};
function createConsole() {
  return {
    debug: consoleNoop,
    error: consoleNoop,
    info: consoleNoop,
    log: consoleNoop,
    warn: consoleNoop,
    dir: consoleNoop,
    dirxml: consoleNoop,
    table: consoleNoop,
    trace: consoleNoop,
    group: consoleNoop,
    groupCollapsed: consoleNoop,
    groupEnd: consoleNoop,
    clear: consoleNoop,
    count: consoleNoop,
    countReset: consoleNoop,
    assert: consoleNoop,
    profile: consoleNoop,
    profileEnd: consoleNoop,
    time: consoleNoop,
    timeLog: consoleNoop,
    timeEnd: consoleNoop,
    timeStamp: consoleNoop,
    context: consoleNoop,
    memory: consoleNoop
  };
}

// src/mock-doc/headers.ts
var MockHeaders = class {
  constructor(init) {
    this._values = [];
    if (typeof init === "object") {
      if (typeof init[Symbol.iterator] === "function") {
        const kvs = [];
        for (const kv of init) {
          if (typeof kv[Symbol.iterator] === "function") {
            kvs.push([...kv]);
          }
        }
        for (const kv of kvs) {
          this.append(kv[0], kv[1]);
        }
      } else {
        for (const key in init) {
          this.append(key, init[key]);
        }
      }
    }
  }
  append(key, value) {
    this._values.push([key, value + ""]);
  }
  delete(key) {
    key = key.toLowerCase();
    for (let i = this._values.length - 1; i >= 0; i--) {
      if (this._values[i][0].toLowerCase() === key) {
        this._values.splice(i, 1);
      }
    }
  }
  entries() {
    const entries = [];
    for (const kv of this.keys()) {
      entries.push([kv, this.get(kv)]);
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: entries[index],
          done: !entries[index]
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  forEach(cb) {
    for (const kv of this.entries()) {
      cb(kv[1], kv[0]);
    }
  }
  get(key) {
    const rtn = [];
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        rtn.push(kv[1]);
      }
    }
    return rtn.length > 0 ? rtn.join(", ") : null;
  }
  has(key) {
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        return true;
      }
    }
    return false;
  }
  keys() {
    const keys = [];
    for (const kv of this._values) {
      const key = kv[0].toLowerCase();
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: keys[index],
          done: !keys[index]
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  set(key, value) {
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key.toLowerCase()) {
        kv[1] = value + "";
        return;
      }
    }
    this.append(key, value);
  }
  values() {
    const values = this._values;
    let index = -1;
    return {
      next() {
        index++;
        const done = !values[index];
        return {
          value: done ? void 0 : values[index][1],
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};

// src/mock-doc/parser.ts
var MockDOMParser = class {
  parseFromString(htmlToParse, mimeType) {
    if (mimeType !== "text/html") {
      console.error("XML parsing not implemented yet, continuing as html");
    }
    return parseHtmlToDocument(htmlToParse);
  }
};

// src/mock-doc/request-response.ts
var MockRequest = class _MockRequest {
  constructor(input, init = {}) {
    this._method = "GET";
    this._url = "/";
    this.bodyUsed = false;
    this.cache = "default";
    this.credentials = "same-origin";
    this.integrity = "";
    this.keepalive = false;
    this.mode = "cors";
    this.redirect = "follow";
    this.referrer = "about:client";
    this.referrerPolicy = "";
    if (typeof input === "string") {
      this.url = input;
    } else if (input) {
      Object.assign(this, input);
      this.headers = new MockHeaders(input.headers);
    }
    Object.assign(this, init);
    if (init.headers) {
      this.headers = new MockHeaders(init.headers);
    }
    if (!this.headers) {
      this.headers = new MockHeaders();
    }
  }
  get url() {
    if (typeof this._url === "string") {
      return new URL(this._url, location.href).href;
    }
    return new URL("/", location.href).href;
  }
  set url(value) {
    this._url = value;
  }
  get method() {
    if (typeof this._method === "string") {
      return this._method.toUpperCase();
    }
    return "GET";
  }
  set method(value) {
    this._method = value;
  }
  clone() {
    const clone = { ...this };
    clone.headers = new MockHeaders(this.headers);
    return new _MockRequest(clone);
  }
};
var MockResponse = class _MockResponse {
  constructor(body, init = {}) {
    this.ok = true;
    this.status = 200;
    this.statusText = "";
    this.type = "default";
    this.url = "";
    this._body = body;
    if (init) {
      Object.assign(this, init);
    }
    this.headers = new MockHeaders(init.headers);
  }
  async json() {
    return JSON.parse(this._body);
  }
  async text() {
    return this._body;
  }
  clone() {
    const initClone = { ...this };
    initClone.headers = new MockHeaders(this.headers);
    return new _MockResponse(this._body, initClone);
  }
};

// src/mock-doc/global.ts
function patchWindow(winToBePatched) {
  const mockWin = new MockWindow(false);
  WINDOW_FUNCTIONS.forEach((fnName) => {
    if (typeof winToBePatched[fnName] !== "function") {
      winToBePatched[fnName] = mockWin[fnName].bind(mockWin);
    }
  });
  WINDOW_PROPS.forEach((propName) => {
    if (winToBePatched === void 0) {
      Object.defineProperty(winToBePatched, propName, {
        get() {
          return mockWin[propName];
        },
        set(val) {
          mockWin[propName] = val;
        },
        configurable: true,
        enumerable: true
      });
    }
  });
}
function addGlobalsToWindowPrototype(mockWinPrototype) {
  GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
    Object.defineProperty(mockWinPrototype, cstrName, {
      get() {
        return this["__" + cstrName] || Cstr;
      },
      set(cstr) {
        this["__" + cstrName] = cstr;
      },
      configurable: true,
      enumerable: true
    });
  });
}
var WINDOW_FUNCTIONS = [
  "addEventListener",
  "alert",
  "blur",
  "cancelAnimationFrame",
  "cancelIdleCallback",
  "clearInterval",
  "clearTimeout",
  "close",
  "confirm",
  "dispatchEvent",
  "focus",
  "getComputedStyle",
  "matchMedia",
  "open",
  "prompt",
  "removeEventListener",
  "requestAnimationFrame",
  "requestIdleCallback",
  "URL"
];
var WINDOW_PROPS = [
  "customElements",
  "devicePixelRatio",
  "document",
  "history",
  "innerHeight",
  "innerWidth",
  "localStorage",
  "location",
  "navigator",
  "pageXOffset",
  "pageYOffset",
  "performance",
  "screenLeft",
  "screenTop",
  "screenX",
  "screenY",
  "scrollX",
  "scrollY",
  "sessionStorage",
  "CSS",
  "CustomEvent",
  "Event",
  "Element",
  "HTMLElement",
  "Node",
  "NodeList",
  "FocusEvent",
  "KeyboardEvent",
  "MouseEvent"
];
var GLOBAL_CONSTRUCTORS = [
  ["CustomEvent", MockCustomEvent],
  ["Event", MockEvent],
  ["Headers", MockHeaders],
  ["FocusEvent", MockFocusEvent],
  ["KeyboardEvent", MockKeyboardEvent],
  ["MouseEvent", MockMouseEvent],
  ["Request", MockRequest],
  ["Response", MockResponse],
  ["DOMParser", MockDOMParser],
  ["HTMLAnchorElement", MockAnchorElement],
  ["HTMLBaseElement", MockBaseElement],
  ["HTMLButtonElement", MockButtonElement],
  ["HTMLCanvasElement", MockCanvasElement],
  ["HTMLFormElement", MockFormElement],
  ["HTMLImageElement", MockImageElement],
  ["HTMLInputElement", MockInputElement],
  ["HTMLLinkElement", MockLinkElement],
  ["HTMLMetaElement", MockMetaElement],
  ["HTMLScriptElement", MockScriptElement],
  ["HTMLStyleElement", MockStyleElement],
  ["HTMLTemplateElement", MockTemplateElement],
  ["HTMLTitleElement", MockTitleElement],
  ["HTMLUListElement", MockUListElement]
];

// src/mock-doc/history.ts
var MockHistory = class {
  constructor() {
    this.items = [];
  }
  get length() {
    return this.items.length;
  }
  back() {
    this.go(-1);
  }
  forward() {
    this.go(1);
  }
  go(_value) {
  }
  pushState(_state, _title, _url) {
  }
  replaceState(_state, _title, _url) {
  }
};

// src/mock-doc/intersection-observer.ts
var MockIntersectionObserver = class {
  constructor() {
  }
  disconnect() {
  }
  observe() {
  }
  takeRecords() {
    return [];
  }
  unobserve() {
  }
};

// src/mock-doc/location.ts
var MockLocation = class {
  constructor() {
    this.ancestorOrigins = null;
    this.protocol = "";
    this.host = "";
    this.hostname = "";
    this.port = "";
    this.pathname = "";
    this.search = "";
    this.hash = "";
    this.username = "";
    this.password = "";
    this.origin = "";
    this._href = "";
  }
  get href() {
    return this._href;
  }
  set href(value) {
    const url = new URL(value, "http://mockdoc.stenciljs.com");
    this._href = url.href;
    this.protocol = url.protocol;
    this.host = url.host;
    this.hostname = url.hostname;
    this.port = url.port;
    this.pathname = url.pathname;
    this.search = url.search;
    this.hash = url.hash;
    this.username = url.username;
    this.password = url.password;
    this.origin = url.origin;
  }
  assign(_url) {
  }
  reload(_forcedReload) {
  }
  replace(_url) {
  }
  toString() {
    return this.href;
  }
};

// src/mock-doc/navigator.ts
var MockNavigator = class {
  constructor() {
    this.appCodeName = "MockNavigator";
    this.appName = "MockNavigator";
    this.appVersion = "MockNavigator";
    this.platform = "MockNavigator";
    this.userAgent = "MockNavigator";
  }
};

// src/mock-doc/performance.ts
var MockPerformance = class {
  constructor() {
    this.timeOrigin = Date.now();
    this.eventCounts = /* @__PURE__ */ new Map();
  }
  addEventListener() {
  }
  clearMarks() {
  }
  clearMeasures() {
  }
  clearResourceTimings() {
  }
  dispatchEvent() {
    return true;
  }
  getEntries() {
    return [];
  }
  getEntriesByName() {
    return [];
  }
  getEntriesByType() {
    return [];
  }
  // Stencil's implementation of `mark` is non-compliant with the `Performance` interface. Because Stencil will
  // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
  // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
  // associated errors returned by the type checker)
  // @ts-ignore
  mark() {
  }
  // Stencil's implementation of `measure` is non-compliant with the `Performance` interface. Because Stencil will
  // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
  // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
  // associated errors returned by the type checker)
  // @ts-ignore
  measure() {
  }
  get navigation() {
    return {};
  }
  now() {
    return Date.now() - this.timeOrigin;
  }
  get onresourcetimingbufferfull() {
    return null;
  }
  removeEventListener() {
  }
  setResourceTimingBufferSize() {
  }
  get timing() {
    return {};
  }
  toJSON() {
  }
};
function resetPerformance(perf) {
  if (perf != null) {
    try {
      perf.timeOrigin = Date.now();
    } catch (e) {
    }
  }
}

// src/mock-doc/storage.ts
var MockStorage = class {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  key(_value) {
  }
  getItem(key) {
    key = String(key);
    if (this.items.has(key)) {
      return this.items.get(key);
    }
    return null;
  }
  setItem(key, value) {
    if (value == null) {
      value = "null";
    }
    this.items.set(String(key), String(value));
  }
  removeItem(key) {
    this.items.delete(String(key));
  }
  clear() {
    this.items.clear();
  }
};

// src/mock-doc/window.ts
var nativeClearInterval = clearInterval;
var nativeClearTimeout = clearTimeout;
var nativeSetInterval = setInterval;
var nativeSetTimeout = setTimeout;
var nativeURL = URL;
var MockWindow = class {
  constructor(html = null) {
    if (html !== false) {
      this.document = new MockDocument(html, this);
    } else {
      this.document = null;
    }
    this.performance = new MockPerformance();
    this.customElements = new MockCustomElementRegistry(this);
    this.console = createConsole();
    resetWindowDefaults(this);
    resetWindowDimensions(this);
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  alert(msg) {
    if (this.console) {
      this.console.debug(msg);
    } else {
      console.debug(msg);
    }
  }
  blur() {
  }
  cancelAnimationFrame(id) {
    this.__clearTimeout(id);
  }
  cancelIdleCallback(id) {
    this.__clearTimeout(id);
  }
  get CharacterData() {
    if (this.__charDataCstr == null) {
      const ownerDocument = this.document;
      this.__charDataCstr = class extends MockNode2 {
        constructor() {
          super(ownerDocument, 0, "test", "");
          throw new Error("Illegal constructor: cannot construct CharacterData");
        }
      };
    }
    return this.__charDataCstr;
  }
  set CharacterData(charDataCstr) {
    this.__charDataCstr = charDataCstr;
  }
  clearInterval(id) {
    this.__clearInterval(id);
  }
  clearTimeout(id) {
    this.__clearTimeout(id);
  }
  close() {
    resetWindow(this);
  }
  confirm() {
    return false;
  }
  get CSS() {
    return {
      supports: () => true
    };
  }
  get Document() {
    if (this.__docCstr == null) {
      const win = this;
      this.__docCstr = class extends MockDocument {
        constructor() {
          super(false, win);
          throw new Error("Illegal constructor: cannot construct Document");
        }
      };
    }
    return this.__docCstr;
  }
  set Document(docCstr) {
    this.__docCstr = docCstr;
  }
  get DocumentFragment() {
    if (this.__docFragCstr == null) {
      const ownerDocument = this.document;
      this.__docFragCstr = class extends MockDocumentFragment {
        constructor() {
          super(ownerDocument);
          throw new Error("Illegal constructor: cannot construct DocumentFragment");
        }
      };
    }
    return this.__docFragCstr;
  }
  set DocumentFragment(docFragCstr) {
    this.__docFragCstr = docFragCstr;
  }
  get DocumentType() {
    if (this.__docTypeCstr == null) {
      const ownerDocument = this.document;
      this.__docTypeCstr = class extends MockNode2 {
        constructor() {
          super(ownerDocument, 0, "test", "");
          throw new Error("Illegal constructor: cannot construct DocumentType");
        }
      };
    }
    return this.__docTypeCstr;
  }
  set DocumentType(docTypeCstr) {
    this.__docTypeCstr = docTypeCstr;
  }
  get DOMTokenList() {
    if (this.__domTokenListCstr == null) {
      this.__domTokenListCstr = class MockDOMTokenList {
      };
    }
    return this.__domTokenListCstr;
  }
  set DOMTokenList(domTokenListCstr) {
    this.__domTokenListCstr = domTokenListCstr;
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get Element() {
    if (this.__elementCstr == null) {
      const ownerDocument = this.document;
      this.__elementCstr = class extends MockElement {
        constructor() {
          super(ownerDocument, "");
          throw new Error("Illegal constructor: cannot construct Element");
        }
      };
    }
    return this.__elementCstr;
  }
  fetch(input, init) {
    if (typeof fetch === "function") {
      return fetch(input, init);
    }
    throw new Error(`fetch() not implemented`);
  }
  focus() {
  }
  getComputedStyle(_) {
    return {
      cssText: "",
      length: 0,
      parentRule: null,
      getPropertyPriority() {
        return null;
      },
      getPropertyValue() {
        return "";
      },
      item() {
        return null;
      },
      removeProperty() {
        return null;
      },
      setProperty() {
        return null;
      }
    };
  }
  get globalThis() {
    return this;
  }
  get history() {
    if (this.__history == null) {
      this.__history = new MockHistory();
    }
    return this.__history;
  }
  set history(hsty) {
    this.__history = hsty;
  }
  get JSON() {
    return JSON;
  }
  get HTMLElement() {
    if (this.__htmlElementCstr == null) {
      const ownerDocument = this.document;
      this.__htmlElementCstr = class extends MockHTMLElement {
        constructor() {
          super(ownerDocument, "");
          const observedAttributes = this.constructor.observedAttributes;
          if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === "function") {
            observedAttributes.forEach((attrName) => {
              const attrValue = this.getAttribute(attrName);
              if (attrValue != null) {
                this.attributeChangedCallback(attrName, null, attrValue);
              }
            });
          }
        }
      };
    }
    return this.__htmlElementCstr;
  }
  set HTMLElement(htmlElementCstr) {
    this.__htmlElementCstr = htmlElementCstr;
  }
  get IntersectionObserver() {
    return MockIntersectionObserver;
  }
  get localStorage() {
    if (this.__localStorage == null) {
      this.__localStorage = new MockStorage();
    }
    return this.__localStorage;
  }
  set localStorage(locStorage) {
    this.__localStorage = locStorage;
  }
  get location() {
    if (this.__location == null) {
      this.__location = new MockLocation();
    }
    return this.__location;
  }
  set location(val) {
    if (typeof val === "string") {
      if (this.__location == null) {
        this.__location = new MockLocation();
      }
      this.__location.href = val;
    } else {
      this.__location = val;
    }
  }
  matchMedia(media) {
    return {
      media,
      matches: false,
      addListener: (_handler) => {
      },
      removeListener: (_handler) => {
      },
      addEventListener: (_type, _handler) => {
      },
      removeEventListener: (_type, _handler) => {
      },
      dispatchEvent: (_ev) => {
      },
      onchange: null
    };
  }
  get Node() {
    if (this.__nodeCstr == null) {
      const ownerDocument = this.document;
      this.__nodeCstr = class extends MockNode2 {
        constructor() {
          super(ownerDocument, 0, "test", "");
          throw new Error("Illegal constructor: cannot construct Node");
        }
      };
    }
    return this.__nodeCstr;
  }
  get NodeList() {
    if (this.__nodeListCstr == null) {
      const ownerDocument = this.document;
      this.__nodeListCstr = class extends MockNodeList {
        constructor() {
          super(ownerDocument, [], 0);
          throw new Error("Illegal constructor: cannot construct NodeList");
        }
      };
    }
    return this.__nodeListCstr;
  }
  get navigator() {
    if (this.__navigator == null) {
      this.__navigator = new MockNavigator();
    }
    return this.__navigator;
  }
  set navigator(nav) {
    this.__navigator = nav;
  }
  get parent() {
    return null;
  }
  prompt() {
    return "";
  }
  open() {
    return null;
  }
  get origin() {
    return this.location.origin;
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  requestAnimationFrame(callback) {
    return this.setTimeout(() => {
      callback(Date.now());
    }, 0);
  }
  requestIdleCallback(callback) {
    return this.setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => 0
      });
    }, 0);
  }
  scroll(_x, _y) {
  }
  scrollBy(_x, _y) {
  }
  scrollTo(_x, _y) {
  }
  get self() {
    return this;
  }
  get sessionStorage() {
    if (this.__sessionStorage == null) {
      this.__sessionStorage = new MockStorage();
    }
    return this.__sessionStorage;
  }
  set sessionStorage(locStorage) {
    this.__sessionStorage = locStorage;
  }
  setInterval(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = /* @__PURE__ */ new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    if (this.__allowInterval) {
      const intervalId = this.__setInterval(() => {
        if (this.__timeouts) {
          this.__timeouts.delete(intervalId);
          try {
            callback(...args);
          } catch (e) {
            if (this.console) {
              this.console.error(e);
            } else {
              console.error(e);
            }
          }
        }
      }, ms);
      if (this.__timeouts) {
        this.__timeouts.add(intervalId);
      }
      return intervalId;
    }
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        } catch (e) {
          if (this.console) {
            this.console.error(e);
          } else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  setTimeout(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = /* @__PURE__ */ new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        } catch (e) {
          if (this.console) {
            this.console.error(e);
          } else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  get top() {
    return this;
  }
  get window() {
    return this;
  }
  onanimationstart() {
  }
  onanimationend() {
  }
  onanimationiteration() {
  }
  onabort() {
  }
  onauxclick() {
  }
  onbeforecopy() {
  }
  onbeforecut() {
  }
  onbeforepaste() {
  }
  onblur() {
  }
  oncancel() {
  }
  oncanplay() {
  }
  oncanplaythrough() {
  }
  onchange() {
  }
  onclick() {
  }
  onclose() {
  }
  oncontextmenu() {
  }
  oncopy() {
  }
  oncuechange() {
  }
  oncut() {
  }
  ondblclick() {
  }
  ondrag() {
  }
  ondragend() {
  }
  ondragenter() {
  }
  ondragleave() {
  }
  ondragover() {
  }
  ondragstart() {
  }
  ondrop() {
  }
  ondurationchange() {
  }
  onemptied() {
  }
  onended() {
  }
  onerror() {
  }
  onfocus() {
  }
  onfocusin() {
  }
  onfocusout() {
  }
  onformdata() {
  }
  onfullscreenchange() {
  }
  onfullscreenerror() {
  }
  ongotpointercapture() {
  }
  oninput() {
  }
  oninvalid() {
  }
  onkeydown() {
  }
  onkeypress() {
  }
  onkeyup() {
  }
  onload() {
  }
  onloadeddata() {
  }
  onloadedmetadata() {
  }
  onloadstart() {
  }
  onlostpointercapture() {
  }
  onmousedown() {
  }
  onmouseenter() {
  }
  onmouseleave() {
  }
  onmousemove() {
  }
  onmouseout() {
  }
  onmouseover() {
  }
  onmouseup() {
  }
  onmousewheel() {
  }
  onpaste() {
  }
  onpause() {
  }
  onplay() {
  }
  onplaying() {
  }
  onpointercancel() {
  }
  onpointerdown() {
  }
  onpointerenter() {
  }
  onpointerleave() {
  }
  onpointermove() {
  }
  onpointerout() {
  }
  onpointerover() {
  }
  onpointerup() {
  }
  onprogress() {
  }
  onratechange() {
  }
  onreset() {
  }
  onresize() {
  }
  onscroll() {
  }
  onsearch() {
  }
  onseeked() {
  }
  onseeking() {
  }
  onselect() {
  }
  onselectstart() {
  }
  onstalled() {
  }
  onsubmit() {
  }
  onsuspend() {
  }
  ontimeupdate() {
  }
  ontoggle() {
  }
  onvolumechange() {
  }
  onwaiting() {
  }
  onwebkitfullscreenchange() {
  }
  onwebkitfullscreenerror() {
  }
  onwheel() {
  }
};
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win) {
  win.__clearInterval = nativeClearInterval;
  win.__clearTimeout = nativeClearTimeout;
  win.__setInterval = nativeSetInterval;
  win.__setTimeout = nativeSetTimeout;
  win.__maxTimeout = 3e4;
  win.__allowInterval = true;
  win.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
  if (srcWin == null) {
    return null;
  }
  const clonedWin = new MockWindow(false);
  if (!opts.customElementProxy) {
    srcWin.customElements = null;
  }
  if (srcWin.document != null) {
    const clonedDoc = new MockDocument(false, clonedWin);
    clonedWin.document = clonedDoc;
    clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
  } else {
    clonedWin.document = new MockDocument(null, clonedWin);
  }
  return clonedWin;
}
function constrainTimeouts(win) {
  win.__allowInterval = false;
  win.__maxTimeout = 0;
}
function resetWindow(win) {
  if (win != null) {
    if (win.__timeouts) {
      win.__timeouts.forEach((timeoutId) => {
        nativeClearInterval(timeoutId);
        nativeClearTimeout(timeoutId);
      });
      win.__timeouts.clear();
    }
    if (win.customElements && win.customElements.clear) {
      win.customElements.clear();
    }
    resetDocument(win.document);
    resetPerformance(win.performance);
    for (const key in win) {
      if (win.hasOwnProperty(key) && key !== "document" && key !== "performance" && key !== "customElements") {
        delete win[key];
      }
    }
    resetWindowDefaults(win);
    resetWindowDimensions(win);
    resetEventListeners(win);
    if (win.document != null) {
      try {
        win.document.defaultView = win;
      } catch (e) {
      }
    }
    win.fetch = null;
    win.Headers = null;
    win.Request = null;
    win.Response = null;
    win.FetchError = null;
  }
}
function resetWindowDimensions(win) {
  try {
    win.devicePixelRatio = 1;
    win.innerHeight = 768;
    win.innerWidth = 1366;
    win.pageXOffset = 0;
    win.pageYOffset = 0;
    win.screenLeft = 0;
    win.screenTop = 0;
    win.screenX = 0;
    win.screenY = 0;
    win.scrollX = 0;
    win.scrollY = 0;
    win.screen = {
      availHeight: win.innerHeight,
      availLeft: 0,
      availTop: 0,
      availWidth: win.innerWidth,
      colorDepth: 24,
      height: win.innerHeight,
      keepAwake: false,
      orientation: {
        angle: 0,
        type: "portrait-primary"
      },
      pixelDepth: 24,
      width: win.innerWidth
    };
  } catch (e) {
  }
}

// src/mock-doc/document.ts
var MockDocument = class _MockDocument extends MockHTMLElement {
  constructor(html = null, win = null) {
    super(null, null);
    this.nodeName = "#document" /* DOCUMENT_NODE */;
    this.nodeType = 9 /* DOCUMENT_NODE */;
    this.defaultView = win;
    this.cookie = "";
    this.referrer = "";
    this.appendChild(this.createDocumentTypeNode());
    if (typeof html === "string") {
      const parsedDoc = parseDocumentUtil(this, html);
      const documentElement = parsedDoc.children.find((elm) => elm.nodeName === "HTML");
      if (documentElement != null) {
        this.appendChild(documentElement);
        setOwnerDocument(documentElement, this);
      }
    } else if (html !== false) {
      const documentElement = new MockHTMLElement(this, "html");
      this.appendChild(documentElement);
      documentElement.appendChild(new MockHTMLElement(this, "head"));
      documentElement.appendChild(new MockHTMLElement(this, "body"));
    }
  }
  get dir() {
    return this.documentElement.dir;
  }
  set dir(value) {
    this.documentElement.dir = value;
  }
  get localName() {
    throw new Error("Unimplemented");
  }
  get location() {
    if (this.defaultView != null) {
      return this.defaultView.location;
    }
    return null;
  }
  set location(val) {
    if (this.defaultView != null) {
      this.defaultView.location = val;
    }
  }
  get baseURI() {
    const baseNode = this.head.childNodes.find((node) => node.nodeName === "BASE");
    if (baseNode) {
      return baseNode.href;
    }
    return this.URL;
  }
  get URL() {
    return this.location.href;
  }
  get styleSheets() {
    return this.querySelectorAll("style");
  }
  get scripts() {
    return this.querySelectorAll("script");
  }
  get forms() {
    return this.querySelectorAll("form");
  }
  get images() {
    return this.querySelectorAll("img");
  }
  get scrollingElement() {
    return this.documentElement;
  }
  get documentElement() {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeName === "HTML") {
        return this.childNodes[i];
      }
    }
    const documentElement = new MockHTMLElement(this, "html");
    this.appendChild(documentElement);
    return documentElement;
  }
  set documentElement(documentElement) {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeType !== 10 /* DOCUMENT_TYPE_NODE */) {
        this.childNodes[i].remove();
      }
    }
    if (documentElement != null) {
      this.appendChild(documentElement);
      setOwnerDocument(documentElement, this);
    }
  }
  get head() {
    const documentElement = this.documentElement;
    for (let i = 0; i < documentElement.childNodes.length; i++) {
      if (documentElement.childNodes[i].nodeName === "HEAD") {
        return documentElement.childNodes[i];
      }
    }
    const head = new MockHTMLElement(this, "head");
    documentElement.insertBefore(head, documentElement.firstChild);
    return head;
  }
  set head(head) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === "HEAD") {
        documentElement.childNodes[i].remove();
      }
    }
    if (head != null) {
      documentElement.insertBefore(head, documentElement.firstChild);
      setOwnerDocument(head, this);
    }
  }
  get body() {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === "BODY") {
        return documentElement.childNodes[i];
      }
    }
    const body = new MockHTMLElement(this, "body");
    documentElement.appendChild(body);
    return body;
  }
  set body(body) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === "BODY") {
        documentElement.childNodes[i].remove();
      }
    }
    if (body != null) {
      documentElement.appendChild(body);
      setOwnerDocument(body, this);
    }
  }
  appendChild(newNode) {
    newNode.remove();
    newNode.parentNode = this;
    this.childNodes.push(newNode);
    return newNode;
  }
  createComment(data) {
    return new MockComment(this, data);
  }
  createAttribute(attrName) {
    return new MockAttr(attrName.toLowerCase(), "");
  }
  createAttributeNS(namespaceURI, attrName) {
    return new MockAttr(attrName, "", namespaceURI);
  }
  createElement(tagName) {
    if (tagName === "#document" /* DOCUMENT_NODE */) {
      const doc = new _MockDocument(false);
      doc.nodeName = tagName;
      doc.parentNode = null;
      return doc;
    }
    return createElement(this, tagName);
  }
  createElementNS(namespaceURI, tagName) {
    const elmNs = createElementNS(this, namespaceURI, tagName);
    return elmNs;
  }
  createTextNode(text) {
    return new MockTextNode(this, text);
  }
  createDocumentFragment() {
    return new MockDocumentFragment(this);
  }
  createDocumentTypeNode() {
    return new MockDocumentTypeNode(this);
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  getElementsByName(elmName) {
    return getElementsByName(this, elmName.toLowerCase());
  }
  get title() {
    const title = this.head.childNodes.find((elm) => elm.nodeName === "TITLE");
    if (title != null && typeof title.textContent === "string") {
      return title.textContent.trim();
    }
    return "";
  }
  set title(value) {
    const head = this.head;
    let title = head.childNodes.find((elm) => elm.nodeName === "TITLE");
    if (title == null) {
      title = this.createElement("title");
      head.appendChild(title);
    }
    title.textContent = value;
  }
};
function resetDocument(doc) {
  if (doc != null) {
    resetEventListeners(doc);
    const documentElement = doc.documentElement;
    if (documentElement != null) {
      resetElement(documentElement);
      for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
        const childNode = documentElement.childNodes[i];
        resetElement(childNode);
        childNode.childNodes.length = 0;
      }
    }
    for (const key in doc) {
      if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
        delete doc[key];
      }
    }
    try {
      doc.nodeName = "#document" /* DOCUMENT_NODE */;
    } catch (e) {
    }
    try {
      doc.nodeType = 9 /* DOCUMENT_NODE */;
    } catch (e) {
    }
    try {
      doc.cookie = "";
    } catch (e) {
    }
    try {
      doc.referrer = "";
    } catch (e) {
    }
  }
}
var DOC_KEY_KEEPERS = /* @__PURE__ */ new Set([
  "nodeName",
  "nodeType",
  "nodeValue",
  "ownerDocument",
  "parentNode",
  "childNodes",
  "_shadowRoot"
]);
function getElementById(elm, id) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.id === id) {
      return childElm;
    }
    const childElmFound = getElementById(childElm, id);
    if (childElmFound != null) {
      return childElmFound;
    }
  }
  return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.name && childElm.name.toLowerCase() === elmName) {
      foundElms.push(childElm);
    }
    getElementsByName(childElm, elmName, foundElms);
  }
  return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
  for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
    elm.childNodes[i].ownerDocument = ownerDocument;
    if (elm.childNodes[i].nodeType === 1 /* ELEMENT_NODE */) {
      setOwnerDocument(elm.childNodes[i], ownerDocument);
    }
  }
}

// src/hydrate/runner/create-window.ts
var templateWindows = /* @__PURE__ */ new Map();
function createWindowFromHtml(templateHtml, uniqueId) {
  let templateWindow = templateWindows.get(uniqueId);
  if (templateWindow == null) {
    templateWindow = new MockWindow(templateHtml);
    templateWindows.set(uniqueId, templateWindow);
  }
  const win = cloneWindow(templateWindow);
  return win;
}

// src/utils/helpers.ts
var isString = (v) => typeof v === "string";
var isPromise = (v) => !!v && (typeof v === "object" || typeof v === "function") && typeof v.then === "function";

// src/utils/message-utils.ts
var catchError = (diagnostics, err2, msg) => {
  const diagnostic = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    lines: []
  };
  if (isString(msg)) {
    diagnostic.messageText = msg.length ? msg : "UNKNOWN ERROR";
  } else if (err2 != null) {
    if (err2.stack != null) {
      diagnostic.messageText = err2.stack.toString();
    } else {
      if (err2.message != null) {
        diagnostic.messageText = err2.message.length ? err2.message : "UNKNOWN ERROR";
      } else {
        diagnostic.messageText = err2.toString();
      }
    }
  }
  if (diagnostics != null && !shouldIgnoreError(diagnostic.messageText)) {
    diagnostics.push(diagnostic);
  }
  return diagnostic;
};
var hasError = (diagnostics) => {
  if (diagnostics == null || diagnostics.length === 0) {
    return false;
  }
  return diagnostics.some((d) => d.level === "error" && d.type !== "runtime");
};
var shouldIgnoreError = (msg) => {
  return msg === TASK_CANCELED_MSG;
};
var TASK_CANCELED_MSG = `task canceled`;

// src/utils/result.ts
var result_exports = {};
__export(result_exports, {
  err: () => err,
  map: () => map,
  ok: () => ok,
  unwrap: () => unwrap,
  unwrapErr: () => unwrapErr
});
var ok = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map(result, fn) {
  if (result.isOk) {
    const val = fn(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
var unwrap = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};

// src/compiler/html/canonical-link.ts
var updateCanonicalLink = (doc, href) => {
  let canonicalLinkElm = doc.head.querySelector('link[rel="canonical"]');
  if (typeof href === "string") {
    if (canonicalLinkElm == null) {
      canonicalLinkElm = doc.createElement("link");
      canonicalLinkElm.setAttribute("rel", "canonical");
      doc.head.appendChild(canonicalLinkElm);
    }
    canonicalLinkElm.setAttribute("href", href);
  } else {
    if (canonicalLinkElm != null) {
      const existingHref = canonicalLinkElm.getAttribute("href");
      if (!existingHref) {
        canonicalLinkElm.parentNode.removeChild(canonicalLinkElm);
      }
    }
  }
};

// src/compiler/html/relocate-meta-charset.ts
var relocateMetaCharset = (doc) => {
  const head = doc.head;
  let charsetElm = head.querySelector("meta[charset]");
  if (charsetElm == null) {
    charsetElm = doc.createElement("meta");
    charsetElm.setAttribute("charset", "utf-8");
  } else {
    charsetElm.remove();
  }
  head.insertBefore(charsetElm, head.firstChild);
};

// src/compiler/style/css-parser/parse-css.ts
var parseCss = (css, filePath) => {
  let lineno = 1;
  let column = 1;
  const diagnostics = [];
  const updatePosition = (str) => {
    const lines = str.match(/\n/g);
    if (lines)
      lineno += lines.length;
    const i = str.lastIndexOf("\n");
    column = ~i ? str.length - i : column + str.length;
  };
  const position = () => {
    const start = { line: lineno, column };
    return (node) => {
      node.position = new ParsePosition(start);
      whitespace();
      return node;
    };
  };
  const error = (msg) => {
    const srcLines = css.split("\n");
    const d = {
      level: "error",
      type: "css",
      language: "css",
      header: "CSS Parse",
      messageText: msg,
      absFilePath: filePath,
      lines: [
        {
          lineIndex: lineno - 1,
          lineNumber: lineno,
          errorCharStart: column,
          text: css[lineno - 1]
        }
      ]
    };
    if (lineno > 1) {
      const previousLine = {
        lineIndex: lineno - 1,
        lineNumber: lineno - 1,
        text: css[lineno - 2],
        errorCharStart: -1,
        errorLength: -1
      };
      d.lines.unshift(previousLine);
    }
    if (lineno + 2 < srcLines.length) {
      const nextLine = {
        lineIndex: lineno,
        lineNumber: lineno + 1,
        text: srcLines[lineno],
        errorCharStart: -1,
        errorLength: -1
      };
      d.lines.push(nextLine);
    }
    diagnostics.push(d);
    return null;
  };
  const stylesheet = () => {
    const rulesList = rules();
    return {
      type: 14 /* StyleSheet */,
      stylesheet: {
        source: filePath,
        rules: rulesList
      }
    };
  };
  const open = () => match(/^{\s*/);
  const close = () => match(/^}/);
  const match = (re) => {
    const m = re.exec(css);
    if (!m)
      return;
    const str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  };
  const rules = () => {
    let node;
    const rules2 = [];
    whitespace();
    comments(rules2);
    while (css.length && css.charAt(0) !== "}" && (node = atrule() || rule())) {
      rules2.push(node);
      comments(rules2);
    }
    return rules2;
  };
  const whitespace = () => match(/^\s*/);
  const comments = (rules2) => {
    let c;
    rules2 = rules2 || [];
    while (c = comment()) {
      rules2.push(c);
    }
    return rules2;
  };
  const comment = () => {
    const pos = position();
    if ("/" !== css.charAt(0) || "*" !== css.charAt(1))
      return null;
    let i = 2;
    while ("" !== css.charAt(i) && ("*" !== css.charAt(i) || "/" !== css.charAt(i + 1)))
      ++i;
    i += 2;
    if ("" === css.charAt(i - 1)) {
      return error("End of comment missing");
    }
    const comment2 = css.slice(2, i - 2);
    column += 2;
    updatePosition(comment2);
    css = css.slice(i);
    column += 2;
    return pos({
      type: 1 /* Comment */,
      comment: comment2
    });
  };
  const selector = () => {
    const m = match(/^([^{]+)/);
    if (!m)
      return null;
    return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m2) {
      return m2.replace(/,/g, "\u200C");
    }).split(/\s*(?![^(]*\)),\s*/).map(function(s) {
      return s.replace(/\u200C/g, ",");
    });
  };
  const declaration = () => {
    const pos = position();
    let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop)
      return null;
    prop = trim(prop[0]);
    if (!match(/^:\s*/))
      return error(`property missing ':'`);
    const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    const ret = pos({
      type: 4 /* Declaration */,
      property: prop.replace(commentre, ""),
      value: val ? trim(val[0]).replace(commentre, "") : ""
    });
    match(/^[;\s]*/);
    return ret;
  };
  const declarations = () => {
    const decls = [];
    if (!open())
      return error(`missing '{'`);
    comments(decls);
    let decl;
    while (decl = declaration()) {
      decls.push(decl);
      comments(decls);
    }
    if (!close())
      return error(`missing '}'`);
    return decls;
  };
  const keyframe = () => {
    let m;
    const values = [];
    const pos = position();
    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      values.push(m[1]);
      match(/^,\s*/);
    }
    if (!values.length)
      return null;
    return pos({
      type: 9 /* KeyFrame */,
      values,
      declarations: declarations()
    });
  };
  const atkeyframes = () => {
    const pos = position();
    let m = match(/^@([-\w]+)?keyframes\s*/);
    if (!m)
      return null;
    const vendor = m[1];
    m = match(/^([-\w]+)\s*/);
    if (!m)
      return error(`@keyframes missing name`);
    const name = m[1];
    if (!open())
      return error(`@keyframes missing '{'`);
    let frame;
    let frames = comments();
    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }
    if (!close())
      return error(`@keyframes missing '}'`);
    return pos({
      type: 8 /* KeyFrames */,
      name,
      vendor,
      keyframes: frames
    });
  };
  const atsupports = () => {
    const pos = position();
    const m = match(/^@supports *([^{]+)/);
    if (!m)
      return null;
    const supports = trim(m[1]);
    if (!open())
      return error(`@supports missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@supports missing '}'`);
    return pos({
      type: 15 /* Supports */,
      supports,
      rules: style
    });
  };
  const athost = () => {
    const pos = position();
    const m = match(/^@host\s*/);
    if (!m)
      return null;
    if (!open())
      return error(`@host missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@host missing '}'`);
    return pos({
      type: 6 /* Host */,
      rules: style
    });
  };
  const atmedia = () => {
    const pos = position();
    const m = match(/^@media *([^{]+)/);
    if (!m)
      return null;
    const media = trim(m[1]);
    if (!open())
      return error(`@media missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@media missing '}'`);
    return pos({
      type: 10 /* Media */,
      media,
      rules: style
    });
  };
  const atcustommedia = () => {
    const pos = position();
    const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (!m)
      return null;
    return pos({
      type: 2 /* CustomMedia */,
      name: trim(m[1]),
      media: trim(m[2])
    });
  };
  const atpage = () => {
    const pos = position();
    const m = match(/^@page */);
    if (!m)
      return null;
    const sel = selector() || [];
    if (!open())
      return error(`@page missing '{'`);
    let decls = comments();
    let decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }
    if (!close())
      return error(`@page missing '}'`);
    return pos({
      type: 12 /* Page */,
      selectors: sel,
      declarations: decls
    });
  };
  const atdocument = () => {
    const pos = position();
    const m = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m)
      return null;
    const vendor = trim(m[1]);
    const doc = trim(m[2]);
    if (!open())
      return error(`@document missing '{'`);
    const style = comments().concat(rules());
    if (!close())
      return error(`@document missing '}'`);
    return pos({
      type: 3 /* Document */,
      document: doc,
      vendor,
      rules: style
    });
  };
  const atfontface = () => {
    const pos = position();
    const m = match(/^@font-face\s*/);
    if (!m)
      return null;
    if (!open())
      return error(`@font-face missing '{'`);
    let decls = comments();
    let decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }
    if (!close())
      return error(`@font-face missing '}'`);
    return pos({
      type: 5 /* FontFace */,
      declarations: decls
    });
  };
  const compileAtrule = (nodeName, nodeType) => {
    const re = new RegExp("^@" + nodeName + "\\s*([^;]+);");
    return () => {
      const pos = position();
      const m = match(re);
      if (!m)
        return null;
      const node = {
        type: nodeType
      };
      node[nodeName] = m[1].trim();
      return pos(node);
    };
  };
  const atimport = compileAtrule("import", 7 /* Import */);
  const atcharset = compileAtrule("charset", 0 /* Charset */);
  const atnamespace = compileAtrule("namespace", 11 /* Namespace */);
  const atrule = () => {
    if (css[0] !== "@")
      return null;
    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  };
  const rule = () => {
    const pos = position();
    const sel = selector();
    if (!sel)
      return error("selector missing");
    comments();
    return pos({
      type: 13 /* Rule */,
      selectors: sel,
      declarations: declarations()
    });
  };
  class ParsePosition {
    constructor(start) {
      this.start = start;
      this.end = { line: lineno, column };
      this.source = filePath;
    }
  }
  ParsePosition.prototype.content = css;
  return {
    diagnostics,
    ...addParent(stylesheet())
  };
};
var trim = (str) => str ? str.trim() : "";
var addParent = (obj, parent) => {
  const isNode = obj && typeof obj.type === "string";
  const childParent = isNode ? obj : parent;
  for (const k in obj) {
    const value = obj[k];
    if (Array.isArray(value)) {
      value.forEach(function(v) {
        addParent(v, childParent);
      });
    } else if (value && typeof value === "object") {
      addParent(value, childParent);
    }
  }
  if (isNode) {
    Object.defineProperty(obj, "parent", {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }
  return obj;
};
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

// src/compiler/style/css-parser/get-css-selectors.ts
var getCssSelectors = (sel) => {
  SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
  sel = sel.replace(/\./g, " .").replace(/\#/g, " #").replace(/\[/g, " [").replace(/\>/g, " > ").replace(/\+/g, " + ").replace(/\~/g, " ~ ").replace(/\*/g, " * ").replace(/\:not\((.*?)\)/g, " ");
  const items = sel.split(" ");
  for (let i = 0, l = items.length; i < l; i++) {
    items[i] = items[i].split(":")[0];
    if (items[i].length === 0)
      continue;
    if (items[i].charAt(0) === ".") {
      SELECTORS.classNames.push(items[i].slice(1));
    } else if (items[i].charAt(0) === "#") {
      SELECTORS.ids.push(items[i].slice(1));
    } else if (items[i].charAt(0) === "[") {
      items[i] = items[i].slice(1).split("=")[0].split("]")[0].trim();
      SELECTORS.attrs.push(items[i].toLowerCase());
    } else if (/[a-z]/g.test(items[i].charAt(0))) {
      SELECTORS.tags.push(items[i].toLowerCase());
    }
  }
  SELECTORS.classNames = SELECTORS.classNames.sort((a, b) => {
    if (a.length < b.length)
      return -1;
    if (a.length > b.length)
      return 1;
    return 0;
  });
  return SELECTORS;
};
var SELECTORS = {
  all: [],
  tags: [],
  classNames: [],
  ids: [],
  attrs: []
};

// src/compiler/style/css-parser/serialize-css.ts
var serializeCss = (stylesheet, serializeOpts) => {
  const usedSelectors = serializeOpts.usedSelectors || null;
  const opts = {
    usedSelectors: usedSelectors || null,
    hasUsedAttrs: !!usedSelectors && usedSelectors.attrs.size > 0,
    hasUsedClassNames: !!usedSelectors && usedSelectors.classNames.size > 0,
    hasUsedIds: !!usedSelectors && usedSelectors.ids.size > 0,
    hasUsedTags: !!usedSelectors && usedSelectors.tags.size > 0
  };
  const rules = stylesheet.rules;
  if (!rules) {
    return "";
  }
  const rulesLen = rules.length;
  const out = [];
  for (let i = 0; i < rulesLen; i++) {
    out.push(serializeCssVisitNode(opts, rules[i], i, rulesLen));
  }
  return out.join("");
};
var serializeCssVisitNode = (opts, node, index, len) => {
  var _a2;
  const nodeType = node.type;
  if (nodeType === 4 /* Declaration */) {
    return serializeCssDeclaration(node, index, len);
  }
  if (nodeType === 13 /* Rule */) {
    return serializeCssRule(opts, node);
  }
  if (nodeType === 1 /* Comment */) {
    if (((_a2 = node.comment) == null ? void 0 : _a2[0]) === "!") {
      return `/*${node.comment}*/`;
    } else {
      return "";
    }
  }
  if (nodeType === 10 /* Media */) {
    return serializeCssMedia(opts, node);
  }
  if (nodeType === 8 /* KeyFrames */) {
    return serializeCssKeyframes(opts, node);
  }
  if (nodeType === 9 /* KeyFrame */) {
    return serializeCssKeyframe(opts, node);
  }
  if (nodeType === 5 /* FontFace */) {
    return serializeCssFontFace(opts, node);
  }
  if (nodeType === 15 /* Supports */) {
    return serializeCssSupports(opts, node);
  }
  if (nodeType === 7 /* Import */) {
    return "@import " + node.import + ";";
  }
  if (nodeType === 0 /* Charset */) {
    return "@charset " + node.charset + ";";
  }
  if (nodeType === 12 /* Page */) {
    return serializeCssPage(opts, node);
  }
  if (nodeType === 6 /* Host */) {
    return "@host{" + serializeCssMapVisit(opts, node.rules) + "}";
  }
  if (nodeType === 2 /* CustomMedia */) {
    return "@custom-media " + node.name + " " + node.media + ";";
  }
  if (nodeType === 3 /* Document */) {
    return serializeCssDocument(opts, node);
  }
  if (nodeType === 11 /* Namespace */) {
    return "@namespace " + node.namespace + ";";
  }
  return "";
};
var serializeCssRule = (opts, node) => {
  var _a2, _b;
  const decls = node.declarations;
  const usedSelectors = opts.usedSelectors;
  const selectors = (_b = (_a2 = node.selectors) == null ? void 0 : _a2.slice()) != null ? _b : [];
  if (decls == null || decls.length === 0) {
    return "";
  }
  if (usedSelectors) {
    let i;
    let j;
    let include = true;
    for (i = selectors.length - 1; i >= 0; i--) {
      const sel = getCssSelectors(selectors[i]);
      include = true;
      let jlen = sel.classNames.length;
      if (jlen > 0 && opts.hasUsedClassNames) {
        for (j = 0; j < jlen; j++) {
          if (!usedSelectors.classNames.has(sel.classNames[j])) {
            include = false;
            break;
          }
        }
      }
      if (include && opts.hasUsedTags) {
        jlen = sel.tags.length;
        if (jlen > 0) {
          for (j = 0; j < jlen; j++) {
            if (!usedSelectors.tags.has(sel.tags[j])) {
              include = false;
              break;
            }
          }
        }
      }
      if (include && opts.hasUsedAttrs) {
        jlen = sel.attrs.length;
        if (jlen > 0) {
          for (j = 0; j < jlen; j++) {
            if (!usedSelectors.attrs.has(sel.attrs[j])) {
              include = false;
              break;
            }
          }
        }
      }
      if (include && opts.hasUsedIds) {
        jlen = sel.ids.length;
        if (jlen > 0) {
          for (j = 0; j < jlen; j++) {
            if (!usedSelectors.ids.has(sel.ids[j])) {
              include = false;
              break;
            }
          }
        }
      }
      if (!include) {
        selectors.splice(i, 1);
      }
    }
  }
  if (selectors.length === 0) {
    return "";
  }
  const cleanedSelectors = [];
  let cleanedSelector = "";
  if (node.selectors) {
    for (const selector of node.selectors) {
      cleanedSelector = removeSelectorWhitespace(selector);
      if (!cleanedSelectors.includes(cleanedSelector)) {
        cleanedSelectors.push(cleanedSelector);
      }
    }
  }
  return `${cleanedSelectors}{${serializeCssMapVisit(opts, decls)}}`;
};
var serializeCssDeclaration = (node, index, len) => {
  if (node.value === "") {
    return "";
  }
  if (len - 1 === index) {
    return node.property + ":" + node.value;
  }
  return node.property + ":" + node.value + ";";
};
var serializeCssMedia = (opts, node) => {
  const mediaCss = serializeCssMapVisit(opts, node.rules);
  if (mediaCss === "") {
    return "";
  }
  return "@media " + removeMediaWhitespace(node.media) + "{" + mediaCss + "}";
};
var serializeCssKeyframes = (opts, node) => {
  const keyframesCss = serializeCssMapVisit(opts, node.keyframes);
  if (keyframesCss === "") {
    return "";
  }
  return "@" + (node.vendor || "") + "keyframes " + node.name + "{" + keyframesCss + "}";
};
var serializeCssKeyframe = (opts, node) => {
  var _a2, _b;
  return ((_b = (_a2 = node.values) == null ? void 0 : _a2.join(",")) != null ? _b : "") + "{" + serializeCssMapVisit(opts, node.declarations) + "}";
};
var serializeCssFontFace = (opts, node) => {
  const fontCss = serializeCssMapVisit(opts, node.declarations);
  if (fontCss === "") {
    return "";
  }
  return "@font-face{" + fontCss + "}";
};
var serializeCssSupports = (opts, node) => {
  const supportsCss = serializeCssMapVisit(opts, node.rules);
  if (supportsCss === "") {
    return "";
  }
  return "@supports " + node.supports + "{" + supportsCss + "}";
};
var serializeCssPage = (opts, node) => {
  var _a2, _b;
  const sel = (_b = (_a2 = node.selectors) == null ? void 0 : _a2.join(", ")) != null ? _b : "";
  return "@page " + sel + "{" + serializeCssMapVisit(opts, node.declarations) + "}";
};
var serializeCssDocument = (opts, node) => {
  const documentCss = serializeCssMapVisit(opts, node.rules);
  const doc = "@" + (node.vendor || "") + "document " + node.document;
  if (documentCss === "") {
    return "";
  }
  return doc + "{" + documentCss + "}";
};
var serializeCssMapVisit = (opts, nodes) => {
  let rtn = "";
  if (nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      rtn += serializeCssVisitNode(opts, nodes[i], i, len);
    }
  }
  return rtn;
};
var removeSelectorWhitespace = (selector) => {
  let rtn = "";
  let char = "";
  let inAttr = false;
  selector = selector.trim();
  for (let i = 0, l = selector.length; i < l; i++) {
    char = selector[i];
    if (char === "[" && rtn[rtn.length - 1] !== "\\") {
      inAttr = true;
    } else if (char === "]" && rtn[rtn.length - 1] !== "\\") {
      inAttr = false;
    }
    if (!inAttr && CSS_WS_REG.test(char)) {
      if (CSS_NEXT_CHAR_REG.test(selector[i + 1])) {
        continue;
      }
      if (CSS_PREV_CHAR_REG.test(rtn[rtn.length - 1])) {
        continue;
      }
      rtn += " ";
    } else {
      rtn += char;
    }
  }
  return rtn;
};
var removeMediaWhitespace = (media) => {
  var _a2;
  let rtn = "";
  let char = "";
  media = (_a2 = media == null ? void 0 : media.trim()) != null ? _a2 : "";
  for (let i = 0, l = media.length; i < l; i++) {
    char = media[i];
    if (CSS_WS_REG.test(char)) {
      if (CSS_WS_REG.test(rtn[rtn.length - 1])) {
        continue;
      }
      rtn += " ";
    } else {
      rtn += char;
    }
  }
  return rtn;
};
var CSS_WS_REG = /\s/;
var CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/;
var CSS_PREV_CHAR_REG = /[>\(\~\,\+]/;

// src/compiler/style/css-parser/used-selectors.ts
var getUsedSelectors = (elm) => {
  const usedSelectors = {
    attrs: /* @__PURE__ */ new Set(),
    classNames: /* @__PURE__ */ new Set(),
    ids: /* @__PURE__ */ new Set(),
    tags: /* @__PURE__ */ new Set()
  };
  collectUsedSelectors(usedSelectors, elm);
  return usedSelectors;
};
var collectUsedSelectors = (usedSelectors, elm) => {
  if (elm != null && elm.nodeType === 1) {
    const children = elm.children;
    const tagName = elm.nodeName.toLowerCase();
    usedSelectors.tags.add(tagName);
    const attributes = elm.attributes;
    for (let i = 0, l = attributes.length; i < l; i++) {
      const attr = attributes.item(i);
      const attrName = attr.name.toLowerCase();
      usedSelectors.attrs.add(attrName);
      if (attrName === "class") {
        const classList = elm.classList;
        for (let i2 = 0, l2 = classList.length; i2 < l2; i2++) {
          usedSelectors.classNames.add(classList.item(i2));
        }
      } else if (attrName === "id") {
        usedSelectors.ids.add(attr.value);
      }
    }
    if (children) {
      for (let i = 0, l = children.length; i < l; i++) {
        collectUsedSelectors(usedSelectors, children[i]);
      }
    }
  }
};

// src/compiler/html/remove-unused-styles.ts
var removeUnusedStyles = (doc, diagnostics) => {
  try {
    const styleElms = doc.head.querySelectorAll(`style[data-styles]`);
    const styleLen = styleElms.length;
    if (styleLen > 0) {
      const usedSelectors = getUsedSelectors(doc.documentElement);
      for (let i = 0; i < styleLen; i++) {
        removeUnusedStyleText(usedSelectors, diagnostics, styleElms[i]);
      }
    }
  } catch (e) {
    catchError(diagnostics, e);
  }
};
var removeUnusedStyleText = (usedSelectors, diagnostics, styleElm) => {
  try {
    const parseResults = parseCss(styleElm.innerHTML);
    diagnostics.push(...parseResults.diagnostics);
    if (hasError(diagnostics)) {
      return;
    }
    try {
      styleElm.innerHTML = serializeCss(parseResults.stylesheet, {
        usedSelectors
      });
    } catch (e) {
      diagnostics.push({
        level: "warn",
        type: "css",
        header: "CSS Stringify",
        messageText: e,
        lines: []
      });
    }
  } catch (e) {
    diagnostics.push({
      level: "warn",
      type: "css",
      header: "CSS Parse",
      messageText: e,
      lines: []
    });
  }
};

// src/hydrate/runner/inspect-element.ts
function inspectElement(results, elm, depth) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    const tagName = childElm.nodeName.toLowerCase();
    if (tagName.includes("-")) {
      const cmp = results.components.find((c) => c.tag === tagName);
      if (cmp != null) {
        cmp.count++;
        if (depth > cmp.depth) {
          cmp.depth = depth;
        }
      }
    } else {
      switch (tagName) {
        case "a":
          const anchor = collectAttributes(childElm);
          anchor.href = childElm.href;
          if (typeof anchor.href === "string") {
            if (!results.anchors.some((a) => a.href === anchor.href)) {
              results.anchors.push(anchor);
            }
          }
          break;
        case "img":
          const img = collectAttributes(childElm);
          img.src = childElm.src;
          if (typeof img.src === "string") {
            if (!results.imgs.some((a) => a.src === img.src)) {
              results.imgs.push(img);
            }
          }
          break;
        case "link":
          const link = collectAttributes(childElm);
          link.href = childElm.href;
          if (typeof link.rel === "string" && link.rel.toLowerCase() === "stylesheet") {
            if (typeof link.href === "string") {
              if (!results.styles.some((s) => s.link === link.href)) {
                delete link.rel;
                delete link.type;
                results.styles.push(link);
              }
            }
          }
          break;
        case "script":
          const script = collectAttributes(childElm);
          if (childElm.hasAttribute("src")) {
            script.src = childElm.src;
            if (typeof script.src === "string") {
              if (!results.scripts.some((s) => s.src === script.src)) {
                results.scripts.push(script);
              }
            }
          } else {
            const staticDataKey = childElm.getAttribute("data-stencil-static");
            if (staticDataKey) {
              results.staticData.push({
                id: staticDataKey,
                type: childElm.getAttribute("type"),
                content: childElm.textContent
              });
            }
          }
          break;
      }
    }
    depth++;
    inspectElement(results, childElm, depth);
  }
}
function collectAttributes(node) {
  const parsedElm = {};
  const attrs = node.attributes;
  for (let i = 0, ii = attrs.length; i < ii; i++) {
    const attr = attrs.item(i);
    const attrName = attr.nodeName.toLowerCase();
    if (SKIP_ATTRS.has(attrName)) {
      continue;
    }
    const attrValue = attr.nodeValue;
    if (attrName === "class" && attrValue === "") {
      continue;
    }
    parsedElm[attrName] = attrValue;
  }
  return parsedElm;
}
var SKIP_ATTRS = /* @__PURE__ */ new Set(["s-id", "c-id"]);

// src/hydrate/runner/patch-dom-implementation.ts
function patchDomImplementation(doc, opts) {
  let win;
  if (doc.defaultView != null) {
    opts.destroyWindow = true;
    patchWindow(doc.defaultView);
    win = doc.defaultView;
  } else {
    opts.destroyWindow = true;
    opts.destroyDocument = false;
    win = new MockWindow(false);
  }
  if (win.document !== doc) {
    win.document = doc;
  }
  if (doc.defaultView !== win) {
    doc.defaultView = win;
  }
  const HTMLElement = doc.documentElement.constructor.prototype;
  if (typeof HTMLElement.getRootNode !== "function") {
    const elm = doc.createElement("unknown-element");
    const HTMLUnknownElement = elm.constructor.prototype;
    HTMLUnknownElement.getRootNode = getRootNode;
  }
  if (typeof doc.createEvent === "function") {
    const CustomEvent = doc.createEvent("CustomEvent").constructor;
    if (win.CustomEvent !== CustomEvent) {
      win.CustomEvent = CustomEvent;
    }
  }
  try {
    win.__stencil_baseURI = doc.baseURI;
  } catch (e) {
    Object.defineProperty(doc, "baseURI", {
      get() {
        const baseElm = doc.querySelector("base[href]");
        if (baseElm) {
          return new URL(baseElm.getAttribute("href"), win.location.href).href;
        }
        return win.location.href;
      }
    });
  }
  return win;
}
function getRootNode(opts) {
  const isComposed = opts != null && opts.composed === true;
  let node = this;
  while (node.parentNode != null) {
    node = node.parentNode;
    if (isComposed === true && node.parentNode == null && node.host != null) {
      node = node.host;
    }
  }
  return node;
}

// src/hydrate/runner/render-utils.ts
function normalizeHydrateOptions(inputOpts) {
  const outputOpts = Object.assign(
    {
      serializeToHtml: false,
      destroyWindow: false,
      destroyDocument: false
    },
    inputOpts || {}
  );
  if (typeof outputOpts.clientHydrateAnnotations !== "boolean") {
    outputOpts.clientHydrateAnnotations = true;
  }
  if (typeof outputOpts.constrainTimeouts !== "boolean") {
    outputOpts.constrainTimeouts = true;
  }
  if (typeof outputOpts.maxHydrateCount !== "number") {
    outputOpts.maxHydrateCount = 300;
  }
  if (typeof outputOpts.runtimeLogging !== "boolean") {
    outputOpts.runtimeLogging = false;
  }
  if (typeof outputOpts.timeout !== "number") {
    outputOpts.timeout = 15e3;
  }
  if (Array.isArray(outputOpts.excludeComponents)) {
    outputOpts.excludeComponents = outputOpts.excludeComponents.filter(filterValidTags).map(mapValidTags);
  } else {
    outputOpts.excludeComponents = [];
  }
  if (Array.isArray(outputOpts.staticComponents)) {
    outputOpts.staticComponents = outputOpts.staticComponents.filter(filterValidTags).map(mapValidTags);
  } else {
    outputOpts.staticComponents = [];
  }
  return outputOpts;
}
function filterValidTags(tag) {
  return typeof tag === "string" && tag.includes("-");
}
function mapValidTags(tag) {
  return tag.trim().toLowerCase();
}
function generateHydrateResults(opts) {
  if (typeof opts.url !== "string") {
    opts.url = `https://hydrate.stenciljs.com/`;
  }
  if (typeof opts.buildId !== "string") {
    opts.buildId = createHydrateBuildId();
  }
  const results = {
    buildId: opts.buildId,
    diagnostics: [],
    url: opts.url,
    host: null,
    hostname: null,
    href: null,
    pathname: null,
    port: null,
    search: null,
    hash: null,
    html: null,
    httpStatus: null,
    hydratedCount: 0,
    anchors: [],
    components: [],
    imgs: [],
    scripts: [],
    staticData: [],
    styles: [],
    title: null
  };
  try {
    const url = new URL(opts.url, `https://hydrate.stenciljs.com/`);
    results.url = url.href;
    results.host = url.host;
    results.hostname = url.hostname;
    results.href = url.href;
    results.port = url.port;
    results.pathname = url.pathname;
    results.search = url.search;
    results.hash = url.hash;
  } catch (e) {
    renderCatchError(results, e);
  }
  return results;
}
var createHydrateBuildId = () => {
  let chars = "abcdefghijklmnopqrstuvwxyz";
  let buildId = "";
  while (buildId.length < 8) {
    const char = chars[Math.floor(Math.random() * chars.length)];
    buildId += char;
    if (buildId.length === 1) {
      chars += "0123456789";
    }
  }
  return buildId;
};
function renderBuildDiagnostic(results, level, header, msg) {
  const diagnostic = {
    level,
    type: "build",
    header,
    messageText: msg,
    relFilePath: void 0,
    absFilePath: void 0,
    lines: []
  };
  if (results.pathname) {
    if (results.pathname !== "/") {
      diagnostic.header += ": " + results.pathname;
    }
  } else if (results.url) {
    diagnostic.header += ": " + results.url;
  }
  results.diagnostics.push(diagnostic);
  return diagnostic;
}
function renderBuildError(results, msg) {
  return renderBuildDiagnostic(results, "error", "Hydrate Error", msg);
}
function renderCatchError(results, err2) {
  const diagnostic = renderBuildError(results, null);
  if (err2 != null) {
    if (err2.stack != null) {
      diagnostic.messageText = err2.stack.toString();
    } else {
      if (err2.message != null) {
        diagnostic.messageText = err2.message.toString();
      } else {
        diagnostic.messageText = err2.toString();
      }
    }
  }
  return diagnostic;
}

// src/hydrate/runner/runtime-log.ts
function runtimeLogging(win, opts, results) {
  try {
    const pathname = win.location.pathname;
    win.console.error = (...msgs) => {
      const errMsg = msgs.reduce((errMsg2, m) => {
        if (m) {
          if (m.stack != null) {
            return errMsg2 + " " + String(m.stack);
          } else {
            if (m.message != null) {
              return errMsg2 + " " + String(m.message);
            }
          }
        }
        return String(m);
      }, "").trim();
      if (errMsg !== "") {
        renderCatchError(results, errMsg);
        if (opts.runtimeLogging) {
          runtimeLog(pathname, "error", [errMsg]);
        }
      }
    };
    win.console.debug = (...msgs) => {
      renderBuildDiagnostic(results, "debug", "Hydrate Debug", [...msgs].join(", "));
      if (opts.runtimeLogging) {
        runtimeLog(pathname, "debug", msgs);
      }
    };
    if (opts.runtimeLogging) {
      ["log", "warn", "assert", "info", "trace"].forEach((type) => {
        win.console[type] = (...msgs) => {
          runtimeLog(pathname, type, msgs);
        };
      });
    }
  } catch (e) {
    renderCatchError(results, e);
  }
}
function runtimeLog(pathname, type, msgs) {
  global.console[type].apply(global.console, [`[ ${pathname}  ${type} ] `, ...msgs]);
}

// src/hydrate/runner/window-initialize.ts
function initializeWindow(win, doc, opts, results) {
  try {
    win.location.href = opts.url;
  } catch (e) {
    renderCatchError(results, e);
  }
  if (typeof opts.userAgent === "string") {
    try {
      win.navigator.userAgent = opts.userAgent;
    } catch (e) {
    }
  }
  if (typeof opts.cookie === "string") {
    try {
      doc.cookie = opts.cookie;
    } catch (e) {
    }
  }
  if (typeof opts.referrer === "string") {
    try {
      doc.referrer = opts.referrer;
    } catch (e) {
    }
  }
  if (typeof opts.direction === "string") {
    try {
      doc.documentElement.setAttribute("dir", opts.direction);
    } catch (e) {
    }
  }
  if (typeof opts.language === "string") {
    try {
      doc.documentElement.setAttribute("lang", opts.language);
    } catch (e) {
    }
  }
  if (typeof opts.buildId === "string") {
    try {
      doc.documentElement.setAttribute("data-stencil-build", opts.buildId);
    } catch (e) {
    }
  }
  try {
    win.customElements = null;
  } catch (e) {
  }
  if (opts.constrainTimeouts) {
    constrainTimeouts(win);
  }
  runtimeLogging(win, opts, results);
  return win;
}

// src/hydrate/runner/render.ts
function renderToString(html, options) {
  const opts = normalizeHydrateOptions(options);
  opts.serializeToHtml = true;
  return new Promise((resolve) => {
    let win;
    const results = generateHydrateResults(opts);
    if (hasError(results.diagnostics)) {
      resolve(results);
    } else if (typeof html === "string") {
      try {
        opts.destroyWindow = true;
        opts.destroyDocument = true;
        win = new MockWindow(html);
        render(win, opts, results, resolve);
      } catch (e) {
        if (win && win.close) {
          win.close();
        }
        win = null;
        renderCatchError(results, e);
        resolve(results);
      }
    } else if (isValidDocument(html)) {
      try {
        opts.destroyDocument = false;
        win = patchDomImplementation(html, opts);
        render(win, opts, results, resolve);
      } catch (e) {
        if (win && win.close) {
          win.close();
        }
        win = null;
        renderCatchError(results, e);
        resolve(results);
      }
    } else {
      renderBuildError(results, `Invalid html or document. Must be either a valid "html" string, or DOM "document".`);
      resolve(results);
    }
  });
}
function hydrateDocument(doc, options) {
  const opts = normalizeHydrateOptions(options);
  opts.serializeToHtml = false;
  return new Promise((resolve) => {
    let win;
    const results = generateHydrateResults(opts);
    if (hasError(results.diagnostics)) {
      resolve(results);
    } else if (typeof doc === "string") {
      try {
        opts.destroyWindow = true;
        opts.destroyDocument = true;
        win = new MockWindow(doc);
        render(win, opts, results, resolve);
      } catch (e) {
        if (win && win.close) {
          win.close();
        }
        win = null;
        renderCatchError(results, e);
        resolve(results);
      }
    } else if (isValidDocument(doc)) {
      try {
        opts.destroyDocument = false;
        win = patchDomImplementation(doc, opts);
        render(win, opts, results, resolve);
      } catch (e) {
        if (win && win.close) {
          win.close();
        }
        win = null;
        renderCatchError(results, e);
        resolve(results);
      }
    } else {
      renderBuildError(results, `Invalid html or document. Must be either a valid "html" string, or DOM "document".`);
      resolve(results);
    }
  });
}
function render(win, opts, results, resolve) {
  if (!process.__stencilErrors) {
    process.__stencilErrors = true;
    process.on("unhandledRejection", (e) => {
      console.log("unhandledRejection", e);
    });
  }
  initializeWindow(win, win.document, opts, results);
  if (typeof opts.beforeHydrate === "function") {
    try {
      const rtn = opts.beforeHydrate(win.document);
      if (isPromise(rtn)) {
        rtn.then(() => {
          hydrateFactory(win, opts, results, afterHydrate, resolve);
        });
      } else {
        hydrateFactory(win, opts, results, afterHydrate, resolve);
      }
    } catch (e) {
      renderCatchError(results, e);
      finalizeHydrate(win, win.document, opts, results, resolve);
    }
  } else {
    hydrateFactory(win, opts, results, afterHydrate, resolve);
  }
}
function afterHydrate(win, opts, results, resolve) {
  if (typeof opts.afterHydrate === "function") {
    try {
      const rtn = opts.afterHydrate(win.document);
      if (isPromise(rtn)) {
        rtn.then(() => {
          finalizeHydrate(win, win.document, opts, results, resolve);
        });
      } else {
        finalizeHydrate(win, win.document, opts, results, resolve);
      }
    } catch (e) {
      renderCatchError(results, e);
      finalizeHydrate(win, win.document, opts, results, resolve);
    }
  } else {
    finalizeHydrate(win, win.document, opts, results, resolve);
  }
}
function finalizeHydrate(win, doc, opts, results, resolve) {
  try {
    inspectElement(results, doc.documentElement, 0);
    if (opts.removeUnusedStyles !== false) {
      try {
        removeUnusedStyles(doc, results.diagnostics);
      } catch (e) {
        renderCatchError(results, e);
      }
    }
    if (typeof opts.title === "string") {
      try {
        doc.title = opts.title;
      } catch (e) {
        renderCatchError(results, e);
      }
    }
    results.title = doc.title;
    if (opts.removeScripts) {
      removeScripts(doc.documentElement);
    }
    try {
      updateCanonicalLink(doc, opts.canonicalUrl);
    } catch (e) {
      renderCatchError(results, e);
    }
    try {
      relocateMetaCharset(doc);
    } catch (e) {
    }
    if (!hasError(results.diagnostics)) {
      results.httpStatus = 200;
    }
    try {
      const metaStatus = doc.head.querySelector('meta[http-equiv="status"]');
      if (metaStatus != null) {
        const metaStatusContent = metaStatus.getAttribute("content");
        if (metaStatusContent && metaStatusContent.length > 0) {
          results.httpStatus = parseInt(metaStatusContent, 10);
        }
      }
    } catch (e) {
    }
    if (opts.clientHydrateAnnotations) {
      doc.documentElement.classList.add("hydrated");
    }
    if (opts.serializeToHtml) {
      results.html = serializeDocumentToString(doc, opts);
    }
  } catch (e) {
    renderCatchError(results, e);
  }
  if (opts.destroyWindow) {
    try {
      if (!opts.destroyDocument) {
        win.document = null;
        doc.defaultView = null;
      }
      if (win.close) {
        win.close();
      }
    } catch (e) {
      renderCatchError(results, e);
    }
  }
  resolve(results);
}
function serializeDocumentToString(doc, opts) {
  return serializeNodeToHtml(doc, {
    approximateLineWidth: opts.approximateLineWidth,
    outerHtml: false,
    prettyHtml: opts.prettyHtml,
    removeAttributeQuotes: opts.removeAttributeQuotes,
    removeBooleanAttributeQuotes: opts.removeBooleanAttributeQuotes,
    removeEmptyAttributes: opts.removeEmptyAttributes,
    removeHtmlComments: opts.removeHtmlComments,
    serializeShadowRoot: false
  });
}
function isValidDocument(doc) {
  return doc != null && doc.nodeType === 9 && doc.documentElement != null && doc.documentElement.nodeType === 1 && doc.body != null && doc.body.nodeType === 1;
}
function removeScripts(elm) {
  const children = elm.children;
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    removeScripts(child);
    if (child.nodeName === "SCRIPT" || child.nodeName === "LINK" && child.getAttribute("rel") === "modulepreload") {
      child.remove();
    }
  }
}

exports.createWindowFromHtml = createWindowFromHtml;
exports.hydrateDocument = hydrateDocument;
exports.renderToString = renderToString;
exports.serializeDocumentToString = serializeDocumentToString;
