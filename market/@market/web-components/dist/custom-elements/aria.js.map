{"file":"aria.js","mappings":"AAEA,MAAM,iBAAiB,GAAG,CAAC,EAAe;;IAExC,OAAO,EAAE;SACN,iBAAiB,EAAE;SACnB,MAAM,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;SAC1C,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI;QAChB,MAAM,KAAK,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,KAAK,KAAK,IAAI;YAAE,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;QACtC,OAAO,GAAG,CAAC;KACZ,EAAE,EAAE,CAAC,CAAC;AACX,CAAC,CAAC;AAEF;;;MAGa,qBAAqB,GAAG,CACnC,EAAe,EACf,kBAA4D;IAE5D,MAAM,gBAAgB,GAAG,IAAI,gBAAgB,CAAC;QAC5C,MAAM,cAAc,GAAG,iBAAiB,CAAC,EAAE,CAAC,CAAC;QAC7C,OAAO,kBAAkB,CAAC,cAAc,CAAC,CAAC;KAC3C,CAAC,CAAC;IAEH,gBAAgB,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;IAEnD,OAAO,gBAAgB,CAAC;AAC1B,EAAE;AAEF;;;;;;;;;;;;AAaA;;;;;;;;;;;;;MAaa,qBAAqB,GAAG,CAAC,OAAoB;;IACxD,MAAM,YAAY;;IAEhB,OAAO,CAAC,aAAa,CAAC,mBAAmB,CAAC;;;QAE1C,MAAC,OAAO,CAAC,WAAW,EAAiB,CAAC,IAAI,0CAAE,aAAa,CAAC,mBAAmB,CAAC,CAAA,CAAC;IACjF,OAAO,CAAA,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,SAAS,KAAI,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC;AAC9E,EAAE;AAEF;;;;;;;;;;;;;;;;MAiBa,wBAAwB,GAAG,CAAC,SAAsB;;IAC7D,MAAM,WAAW,GAAG,CAAC,IAAY,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC;IAC1E,IAAI,gBAAwB,CAAC;;IAG7B,MAAM,cAAc,GAAG,SAAS,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC;IACjE,IAAI,WAAW,CAAC,cAAc,CAAC,EAAE;QAC/B,MAAM,cAAc,GAAG,MAAA,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,0CAAE,WAAW,CAAC;QAC5E,gBAAgB,GAAG,gBAAgB,IAAI,cAAc,CAAC;KACvD;;IAGD,MAAM,SAAS,GAAG,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;IACvD,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;QAC1B,gBAAgB,GAAG,gBAAgB,IAAI,SAAS,CAAC;KAClD;IAED,OAAO,gBAAgB,IAAI,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC;AACzE,EAAE;MAEW,2BAA2B,GAAG,CACzC,SAAsB,EACtB,EAAE,QAAQ,EAAE,SAAS,EAA2C;;IAGhE,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;;IAElD,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,SAAS,CAAC,CAAC;AACrD;;;;","names":[],"sources":["src/utils/aria.ts"],"sourcesContent":["export type AriaAttributes = { [key: string]: string };\n\nconst getAriaAttributes = (el: HTMLElement): AriaAttributes => {\n  // create an object with all aria-* attributes on host element\n  return el\n    .getAttributeNames()\n    .filter((attr) => attr.startsWith('aria-'))\n    .reduce((acc, attr) => {\n      const value = el.getAttribute(attr);\n      if (value !== null) acc[attr] = value;\n      return acc;\n    }, {});\n};\n\n/**\n * Watch for aria attribute changes on host element.\n */\nexport const observeAriaAttributes = (\n  el: HTMLElement,\n  onMutationObserved: (ariaAttributes: AriaAttributes) => void,\n): MutationObserver => {\n  const mutationObserver = new MutationObserver(() => {\n    const ariaAttributes = getAriaAttributes(el);\n    return onMutationObserved(ariaAttributes);\n  });\n\n  mutationObserver.observe(el, { attributes: true });\n\n  return mutationObserver;\n};\n\n/**\n * ARIA LABELS\n *\n * It's currently not possible to make label/input associations across the\n * shadow DOM boundary. These helpers are intended to act as a lightweight a11y\n * solution by allowing our input and control components to set their own\n * aria-label attributes based on what is being used to label them.\n *\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n * https://nolanlawson.com/2022/11/28/shadow-dom-and-accessibility-the-trouble-with-aria\n * https://github.com/whatwg/html/issues/3219\n */\n\n/**\n * Returns the the aria-label attribute to set on text input components:\n *   <market-input-text>\n *   <market-select>\n *   <market-textarea>\n *   <market-input-password> (via its internal market-input-text)\n *\n * These components expect a <label> element in the default slot to use as the\n * floating input label. Falls back to the component's `name` attribute if no\n * label can be found.\n *\n * @param inputEl The input element that needs an aria-label\n */\nexport const getTextInputAriaLabel = (inputEl: HTMLElement): string => {\n  const slottedLabel =\n    // label slotted directly into input component\n    inputEl.querySelector('label:not([slot])') ||\n    // label slotted into a higher-level component (market-input-password)\n    (inputEl.getRootNode() as ShadowRoot).host?.querySelector('label:not([slot])');\n  return slottedLabel?.innerHTML || inputEl.getAttribute('name') || undefined;\n};\n\n/**\n * Returns the aria-label attribute to set on control components:\n *   <market-checkbox>\n *   <market-radio>\n *   <market-toggle>\n *\n * When used as a slotted control in <market-row>, the row handles setting the\n * aria-label of the control to match its own slotted label element. Otherwise,\n * if a consumer sets the aria-labelledby or aria-label attribute on the Market\n * component, the correct label text will be reflected in the shadow DOM.\n *\n * Adapted from Ionic Framework's getAriaLabel() helper:\n * https://github.com/ionic-team/ionic-framework/blob/main/core/src/utils/helpers.ts#L275-L332\n *\n * @param controlEl The control element that needs an aria-label\n */\n\nexport const getControlInputAriaLabel = (controlEl: HTMLElement): string => {\n  const attrIsValid = (attr: string) => attr !== null && attr.trim() !== '';\n  let controlAriaLabel: string;\n\n  // aria-labelledby takes precedence\n  const ariaLabelledBy = controlEl.getAttribute('aria-labelledby');\n  if (attrIsValid(ariaLabelledBy)) {\n    const labelledByText = document.getElementById(ariaLabelledBy)?.textContent;\n    controlAriaLabel = controlAriaLabel || labelledByText;\n  }\n\n  // aria-label\n  const ariaLabel = controlEl.getAttribute('aria-label');\n  if (attrIsValid(ariaLabel)) {\n    controlAriaLabel = controlAriaLabel || ariaLabel;\n  }\n\n  return controlAriaLabel || controlEl.getAttribute('name') || undefined;\n};\n\nexport const applyExpandableAriaControls = (\n  controlEl: HTMLElement,\n  { expanded, popoverId }: { expanded: string; popoverId: string },\n): void => {\n  // Screen reader announces the expanded state of the control on focus\n  controlEl.setAttribute('aria-expanded', expanded);\n  // Connect control to the popover content\n  controlEl.setAttribute('aria-controls', popoverId);\n};\n"],"version":3}